#include "luaot-generated-header.c"





static int zz_magic_function_0 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000002c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x0000004b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x2f000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_3: {
    Instruction i = 0x0000586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x30800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x0000986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_6: {
    Instruction i = 0x308000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x0000d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x30800340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x0001186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_10: {
    Instruction i = 0x30800380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x0001586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x308003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0001986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x30800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x0001d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_16: {
    Instruction i = 0x30800440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x0002186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_18: {
    Instruction i = 0x30800480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x0002586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_20: {
    Instruction i = 0x30800500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x0002986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_22: {
    Instruction i = 0x30800540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x0002d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x30800580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x0003186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_26: {
    Instruction i = 0x308005c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x0003586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_28: {
    Instruction i = 0x30800600;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x0003986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_30: {
    Instruction i = 0x30800640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x0003d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_32: {
    Instruction i = 0x30800680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x0004186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_34: {
    Instruction i = 0x308006c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x0004586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_36: {
    Instruction i = 0x30800700;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x0004986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_38: {
    Instruction i = 0x30800740;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_39: {
    Instruction i = 0x0004d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_40: {
    Instruction i = 0x30800780;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_41: {
    Instruction i = 0x0005186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_42: {
    Instruction i = 0x308007c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x0005586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_44: {
    Instruction i = 0x30800800;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_45: {
    Instruction i = 0x0005986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_46: {
    Instruction i = 0x30800840;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_47: {
    Instruction i = 0x0005d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_48: {
    Instruction i = 0x30800880;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x0006186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_50: {
    Instruction i = 0x308008c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x0006586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_52: {
    Instruction i = 0x30800900;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x0006986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_54: {
    Instruction i = 0x30800940;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x0006d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_56: {
    Instruction i = 0x30800980;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x0007186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_58: {
    Instruction i = 0x308009c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_59: {
    Instruction i = 0x0007586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_60: {
    Instruction i = 0x30800a00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_61: {
    Instruction i = 0x0007986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_62: {
    Instruction i = 0x30800a40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x0007d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_64: {
    Instruction i = 0x30800a80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_65: {
    Instruction i = 0x0008186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_66: {
    Instruction i = 0x30800ac0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_67: {
    Instruction i = 0x0008586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_68: {
    Instruction i = 0x30800b00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x0008986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_70: {
    Instruction i = 0x30800b40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_71: {
    Instruction i = 0x0008d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_72: {
    Instruction i = 0x30800b80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_73: {
    Instruction i = 0x0009186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_74: {
    Instruction i = 0x30800bc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_75: {
    Instruction i = 0x0009586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_76: {
    Instruction i = 0x30800c00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_77: {
    Instruction i = 0x0009986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_78: {
    Instruction i = 0x30800c40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_79: {
    Instruction i = 0x0009d86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_80: {
    Instruction i = 0x308012c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_81: {
    Instruction i = 0x000a186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_82: {
    Instruction i = 0x30801300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_83: {
    Instruction i = 0x000a586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_84: {
    Instruction i = 0x30801340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_85: {
    Instruction i = 0x000a986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_86: {
    Instruction i = 0x30801380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_87: {
    Instruction i = 0x000ad86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_88: {
    Instruction i = 0x308013c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_89: {
    Instruction i = 0x000b186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_90: {
    Instruction i = 0x30801400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_91: {
    Instruction i = 0x000b586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_92: {
    Instruction i = 0x30801440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x000b986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_94: {
    Instruction i = 0x308014c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x000bd86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_96: {
    Instruction i = 0x30801500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_97: {
    Instruction i = 0x000c186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_98: {
    Instruction i = 0x30801540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_99: {
    Instruction i = 0x000c586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_100: {
    Instruction i = 0x30801580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_101: {
    Instruction i = 0x000c986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_102: {
    Instruction i = 0x308015c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_103: {
    Instruction i = 0x000cd86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_104: {
    Instruction i = 0x30801600;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_105: {
    Instruction i = 0x000d186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_106: {
    Instruction i = 0x30801640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_107: {
    Instruction i = 0x000d586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_108: {
    Instruction i = 0x308016c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_109: {
    Instruction i = 0x000d986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_110: {
    Instruction i = 0x30801700;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_111: {
    Instruction i = 0x000dd86c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_112: {
    Instruction i = 0x30801740;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_113: {
    Instruction i = 0x000e186c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_114: {
    Instruction i = 0x30801780;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x000e586c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_116: {
    Instruction i = 0x308017c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_117: {
    Instruction i = 0x000e986c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_118: {
    Instruction i = 0x30801800;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x00001841;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_120: {
    Instruction i = 0x00004101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_121: {
    Instruction i = 0x00008141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_122: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_123: {
    Instruction i = 0x000101c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_124: {
    Instruction i = 0x00014201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_125: {
    Instruction i = 0x00018241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_126: {
    Instruction i = 0x0001c281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_127: {
    Instruction i = 0x000202c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_128: {
    Instruction i = 0x00024301;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_129: {
    Instruction i = 0x00001884;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_130: {
    Instruction i = 0x000ed8ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_131: {
    Instruction i = 0x31801880;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_132: {
    Instruction i = 0x8518804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_133: {
    Instruction i = 0x8583404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_134: {
    Instruction i = 0x8603804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_135: {
    Instruction i = 0x8683c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_136: {
    Instruction i = 0x8704004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_137: {
    Instruction i = 0x8784404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_138: {
    Instruction i = 0x8804804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_139: {
    Instruction i = 0x008018cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_140: {
    Instruction i = 0x02801900;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_141: {
    Instruction i = 0x008058eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_142: {
    Instruction i = 0x318004c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_143: {
    Instruction i = 0x8884c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_144: {
    Instruction i = 0x8905004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_145: {
    Instruction i = 0x8985404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_146: {
    Instruction i = 0x8a05804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_147: {
    Instruction i = 0x8a85c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_148: {
    Instruction i = 0x8b06004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_149: {
    Instruction i = 0x8b86404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_150: {
    Instruction i = 0x8c06804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_151: {
    Instruction i = 0x8c86c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_152: {
    Instruction i = 0x8d07004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_153: {
    Instruction i = 0x8d88004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_154: {
    Instruction i = 0x8e0b404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_155: {
    Instruction i = 0x8e8c404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_156: {
    Instruction i = 0x310018c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_157: {
    Instruction i = 0x00079901;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_158: {
    Instruction i = 0x010098e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_159: {
    Instruction i = 0x31800c80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_160: {
    Instruction i = 0x310018c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_161: {
    Instruction i = 0x0007d901;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_162: {
    Instruction i = 0x010098e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_163: {
    Instruction i = 0x31001900;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_164: {
    Instruction i = 0x00081941;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_165: {
    Instruction i = 0x01009924;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_166: {
    Instruction i = 0x32000cc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_167: {
    Instruction i = 0x31001900;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_168: {
    Instruction i = 0x00085941;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_169: {
    Instruction i = 0x01009924;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_170: {
    Instruction i = 0x32000d00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_171: {
    Instruction i = 0x31001900;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_172: {
    Instruction i = 0x00089941;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_173: {
    Instruction i = 0x01009924;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_174: {
    Instruction i = 0x31001940;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_175: {
    Instruction i = 0x0008d981;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_176: {
    Instruction i = 0x01009964;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_177: {
    Instruction i = 0x31001980;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_178: {
    Instruction i = 0x000919c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_179: {
    Instruction i = 0x010099a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_180: {
    Instruction i = 0x310019c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_181: {
    Instruction i = 0x00095a01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_182: {
    Instruction i = 0x010099e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_183: {
    Instruction i = 0x31001a00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_184: {
    Instruction i = 0x00099a41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_185: {
    Instruction i = 0x01009a24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_186: {
    Instruction i = 0x34000d40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_187: {
    Instruction i = 0x31001a00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_188: {
    Instruction i = 0x0009da41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_189: {
    Instruction i = 0x01009a24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_190: {
    Instruction i = 0x31001a40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_191: {
    Instruction i = 0x000a1a81;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_192: {
    Instruction i = 0x01009a64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_193: {
    Instruction i = 0x31001a80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_194: {
    Instruction i = 0x000a5ac1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_195: {
    Instruction i = 0x01009aa4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_196: {
    Instruction i = 0x31001ac0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_197: {
    Instruction i = 0x000a9b01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_198: {
    Instruction i = 0x01009ae4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_199: {
    Instruction i = 0x31001b00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_200: {
    Instruction i = 0x000adb41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_201: {
    Instruction i = 0x01009b24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_202: {
    Instruction i = 0x31001b40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_203: {
    Instruction i = 0x000b1b81;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_204: {
    Instruction i = 0x01009b64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_205: {
    Instruction i = 0x31001b80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_206: {
    Instruction i = 0x000b5bc1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_207: {
    Instruction i = 0x01009ba4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_208: {
    Instruction i = 0x31001bc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_209: {
    Instruction i = 0x000b9c01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_210: {
    Instruction i = 0x01009be4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_211: {
    Instruction i = 0x31001c00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_212: {
    Instruction i = 0x000bdc41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_213: {
    Instruction i = 0x01009c24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_214: {
    Instruction i = 0x31001c40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_215: {
    Instruction i = 0x000c1c81;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_216: {
    Instruction i = 0x01009c64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_217: {
    Instruction i = 0x31001c80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_218: {
    Instruction i = 0x000c5cc1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_219: {
    Instruction i = 0x01009ca4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_220: {
    Instruction i = 0x31001cc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_221: {
    Instruction i = 0x000c9d01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_222: {
    Instruction i = 0x01009ce4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_223: {
    Instruction i = 0x31001d00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_224: {
    Instruction i = 0x000cdd41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_225: {
    Instruction i = 0x01009d24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_226: {
    Instruction i = 0x31001d40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_227: {
    Instruction i = 0x000d1d81;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_228: {
    Instruction i = 0x01009d64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_229: {
    Instruction i = 0x31001d80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_230: {
    Instruction i = 0x000d5dc1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_231: {
    Instruction i = 0x01009da4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_232: {
    Instruction i = 0x31001dc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_233: {
    Instruction i = 0x000d9e01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_234: {
    Instruction i = 0x01009de4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_235: {
    Instruction i = 0x31001e00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_236: {
    Instruction i = 0x000dde41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_237: {
    Instruction i = 0x01009e24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_238: {
    Instruction i = 0x31001e40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_239: {
    Instruction i = 0x000e1e81;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_240: {
    Instruction i = 0x01009e64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_241: {
    Instruction i = 0x31001e80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_242: {
    Instruction i = 0x000e5ec1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_243: {
    Instruction i = 0x01009ea4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_244: {
    Instruction i = 0x31001ec0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_245: {
    Instruction i = 0x000e9f01;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_246: {
    Instruction i = 0x01009ee4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_247: {
    Instruction i = 0x31001f00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_248: {
    Instruction i = 0x000edf41;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_249: {
    Instruction i = 0x01009f24;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_250: {
    Instruction i = 0x9e0c804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_251: {
    Instruction i = 0x9e98c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_252: {
    Instruction i = 0x9f0cc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_253: {
    Instruction i = 0x9f8d004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_254: {
    Instruction i = 0xa019004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_255: {
    Instruction i = 0xa099404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_256: {
    Instruction i = 0xa119804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_257: {
    Instruction i = 0xa199c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_258: {
    Instruction i = 0xa20d404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_259: {
    Instruction i = 0xa29a004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_260: {
    Instruction i = 0xa31a404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_261: {
    Instruction i = 0xa39a804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_262: {
    Instruction i = 0xa41ac04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_263: {
    Instruction i = 0xa49b004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_264: {
    Instruction i = 0xa51b404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_265: {
    Instruction i = 0xa59b804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_266: {
    Instruction i = 0xa61bc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_267: {
    Instruction i = 0xa69c004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_268: {
    Instruction i = 0xa71c404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_269: {
    Instruction i = 0xa79c804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_270: {
    Instruction i = 0xa81cc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_271: {
    Instruction i = 0xa89d004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_272: {
    Instruction i = 0xa91d404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_273: {
    Instruction i = 0xa99d804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_274: {
    Instruction i = 0xaa1dc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_275: {
    Instruction i = 0xaa9e004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_276: {
    Instruction i = 0xab1e404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_277: {
    Instruction i = 0xab9e804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_278: {
    Instruction i = 0xac1ec04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_279: {
    Instruction i = 0xac9f004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_280: {
    Instruction i = 0x0c801f40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_281: {
    Instruction i = 0x19001f80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_282: {
    Instruction i = 0x26801fc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_283: {
    Instruction i = 0x3c802000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_284: {
    Instruction i = 0x33802040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_285: {
    Instruction i = 0x01801fe4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_286: {
    Instruction i = 0x00009f64;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_287: {
    Instruction i = 0x3e800d80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_288: {
    Instruction i = 0x00001f44;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_289: {
    Instruction i = 0x000f1fac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_290: {
    Instruction i = 0x3f001f40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_291: {
    Instruction i = 0x00001f84;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_292: {
    Instruction i = 0x000f5fec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_293: {
    Instruction i = 0x3f801f80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_294: {
    Instruction i = 0x00001fc4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_295: {
    Instruction i = 0x000fa02c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_296: {
    Instruction i = 0x40001fc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_297: {
    Instruction i = 0x00002004;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_298: {
    Instruction i = 0x000fe06c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_299: {
    Instruction i = 0x40802000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_300: {
    Instruction i = 0x3f002040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_301: {
    Instruction i = 0x39002080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_302: {
    Instruction i = 0x0100a064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_303: {
    Instruction i = 0x3f802080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_304: {
    Instruction i = 0x390020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_305: {
    Instruction i = 0x31802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_306: {
    Instruction i = 0x0180a0a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_307: {
    Instruction i = 0x41000dc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_308: {
    Instruction i = 0x3f802080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_309: {
    Instruction i = 0x390020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_310: {
    Instruction i = 0x3a802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_311: {
    Instruction i = 0x0180a0a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_312: {
    Instruction i = 0x41000e00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_313: {
    Instruction i = 0x40002080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_314: {
    Instruction i = 0x390020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_315: {
    Instruction i = 0x0100a0a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_316: {
    Instruction i = 0x41000e40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_317: {
    Instruction i = 0x3f002080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_318: {
    Instruction i = 0x398020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_319: {
    Instruction i = 0x0100a0a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_320: {
    Instruction i = 0x3f8020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_321: {
    Instruction i = 0x39802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_322: {
    Instruction i = 0x31802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_323: {
    Instruction i = 0x0180a0e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_324: {
    Instruction i = 0x41800e80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_325: {
    Instruction i = 0x3f8020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_326: {
    Instruction i = 0x39802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_327: {
    Instruction i = 0x3a802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_328: {
    Instruction i = 0x0180a0e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_329: {
    Instruction i = 0x41800ec0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_330: {
    Instruction i = 0x400020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_331: {
    Instruction i = 0x39802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_332: {
    Instruction i = 0x0100a0e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_333: {
    Instruction i = 0x41800f00;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_334: {
    Instruction i = 0x3f0020c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_335: {
    Instruction i = 0x38802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_336: {
    Instruction i = 0x0100a0e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_337: {
    Instruction i = 0x40002100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_338: {
    Instruction i = 0x38802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_339: {
    Instruction i = 0x0100a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_340: {
    Instruction i = 0x42000f40;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_341: {
    Instruction i = 0x3f802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_342: {
    Instruction i = 0x38802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_343: {
    Instruction i = 0x3b002180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_344: {
    Instruction i = 0x0180a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_345: {
    Instruction i = 0x42000f80;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_346: {
    Instruction i = 0x3f802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_347: {
    Instruction i = 0x38802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_348: {
    Instruction i = 0x3b802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_349: {
    Instruction i = 0x0180a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_350: {
    Instruction i = 0x42000fc0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_351: {
    Instruction i = 0x40002100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_352: {
    Instruction i = 0x3a002140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_353: {
    Instruction i = 0x0100a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_354: {
    Instruction i = 0x42001000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_355: {
    Instruction i = 0x40002100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_356: {
    Instruction i = 0x38002140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_357: {
    Instruction i = 0x0100a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_358: {
    Instruction i = 0x42001040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_359: {
    Instruction i = 0x3e802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_360: {
    Instruction i = 0x26802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_361: {
    Instruction i = 0x34802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_362: {
    Instruction i = 0x198021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_363: {
    Instruction i = 0x26802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_364: {
    Instruction i = 0x35002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_365: {
    Instruction i = 0x32002280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_366: {
    Instruction i = 0x01802224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_367: {
    Instruction i = 0x00002164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_368: {
    Instruction i = 0x0000a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_369: {
    Instruction i = 0x42001080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_370: {
    Instruction i = 0x3e802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_371: {
    Instruction i = 0x26802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_372: {
    Instruction i = 0x34802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_373: {
    Instruction i = 0x268021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_374: {
    Instruction i = 0x19802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_375: {
    Instruction i = 0x07802240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_376: {
    Instruction i = 0x19802280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_377: {
    Instruction i = 0x338022c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_378: {
    Instruction i = 0x0180a264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_379: {
    Instruction i = 0x33802280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_380: {
    Instruction i = 0x0200a1e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_381: {
    Instruction i = 0x37802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_382: {
    Instruction i = 0x02002164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_383: {
    Instruction i = 0x0000a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_384: {
    Instruction i = 0x420010c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_385: {
    Instruction i = 0x3e802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_386: {
    Instruction i = 0x26802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_387: {
    Instruction i = 0x34802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_388: {
    Instruction i = 0x198021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_389: {
    Instruction i = 0x32802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_390: {
    Instruction i = 0x02002164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_391: {
    Instruction i = 0x0000a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_392: {
    Instruction i = 0x42001100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_393: {
    Instruction i = 0x3f802100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_394: {
    Instruction i = 0x3a802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_395: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_396: {
    Instruction i = 0x348021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_397: {
    Instruction i = 0x3c002200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_398: {
    Instruction i = 0x33802240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_399: {
    Instruction i = 0x020021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_400: {
    Instruction i = 0x0000a124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_401: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_402: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_403: {
    Instruction i = 0x348021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_404: {
    Instruction i = 0x19802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_405: {
    Instruction i = 0x34002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_406: {
    Instruction i = 0x020021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_407: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_408: {
    Instruction i = 0x42801140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_409: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_410: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_411: {
    Instruction i = 0x348021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_412: {
    Instruction i = 0x1a002200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_413: {
    Instruction i = 0x37002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_414: {
    Instruction i = 0x020021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_415: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_416: {
    Instruction i = 0x42801180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_417: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_418: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_419: {
    Instruction i = 0x348021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_420: {
    Instruction i = 0x26802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_421: {
    Instruction i = 0x1a002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_422: {
    Instruction i = 0x26802280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_423: {
    Instruction i = 0x198022c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_424: {
    Instruction i = 0x33802300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_425: {
    Instruction i = 0x19802340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_426: {
    Instruction i = 0x020022a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_427: {
    Instruction i = 0x0000a224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_428: {
    Instruction i = 0x33002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_429: {
    Instruction i = 0x020021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_430: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_431: {
    Instruction i = 0x428011c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_432: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_433: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_434: {
    Instruction i = 0x1a0021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_435: {
    Instruction i = 0x26802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_436: {
    Instruction i = 0x19002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_437: {
    Instruction i = 0x19802280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_438: {
    Instruction i = 0x01802224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_439: {
    Instruction i = 0x000021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_440: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_441: {
    Instruction i = 0x42801200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_442: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_443: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_444: {
    Instruction i = 0x1a0021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_445: {
    Instruction i = 0x26802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_446: {
    Instruction i = 0x19002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_447: {
    Instruction i = 0x1a002280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_448: {
    Instruction i = 0x01802224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_449: {
    Instruction i = 0x000021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_450: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_451: {
    Instruction i = 0x42801240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_452: {
    Instruction i = 0x3e802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_453: {
    Instruction i = 0x26802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_454: {
    Instruction i = 0x1a0021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_455: {
    Instruction i = 0x1a002200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_456: {
    Instruction i = 0x018021a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_457: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_458: {
    Instruction i = 0x42801280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_459: {
    Instruction i = 0xad20404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_460: {
    Instruction i = 0xad8dc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_461: {
    Instruction i = 0xae0e004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_462: {
    Instruction i = 0xae8e404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_463: {
    Instruction i = 0xaf20804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_464: {
    Instruction i = 0xaf8e804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_465: {
    Instruction i = 0xb00ec04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_466: {
    Instruction i = 0xb08f004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_467: {
    Instruction i = 0xb120c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_468: {
    Instruction i = 0xb18f404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_469: {
    Instruction i = 0xb20f804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_470: {
    Instruction i = 0xb28fc04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_471: {
    Instruction i = 0xb310004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_472: {
    Instruction i = 0xb390404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_473: {
    Instruction i = 0xb410804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_474: {
    Instruction i = 0xb490c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_475: {
    Instruction i = 0xb511004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_476: {
    Instruction i = 0xb5a1004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_477: {
    Instruction i = 0xb611404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_478: {
    Instruction i = 0xb691804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_479: {
    Instruction i = 0xb711c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_480: {
    Instruction i = 0xb792004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_481: {
    Instruction i = 0xb812404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_482: {
    Instruction i = 0xb892804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_483: {
    Instruction i = 0x0a802140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_484: {
    Instruction i = 0x36802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_485: {
    Instruction i = 0x268021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_486: {
    Instruction i = 0x008021e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_487: {
    Instruction i = 0x0000a164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_488: {
    Instruction i = 0x0a802180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_489: {
    Instruction i = 0x360021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_490: {
    Instruction i = 0x26802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_491: {
    Instruction i = 0x00802224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_492: {
    Instruction i = 0x0000a1a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_493: {
    Instruction i = 0x000021c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_494: {
    Instruction i = 0x0010222c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_495: {
    Instruction i = 0x440021c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_496: {
    Instruction i = 0x00002204;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_497: {
    Instruction i = 0x0010626c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_498: {
    Instruction i = 0x44802200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_499: {
    Instruction i = 0xb913004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_500: {
    Instruction i = 0xb9a2004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_501: {
    Instruction i = 0xba13404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_502: {
    Instruction i = 0xba93c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_503: {
    Instruction i = 0xbb14004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_504: {
    Instruction i = 0xbb94404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_505: {
    Instruction i = 0x0000224b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_506: {
    Instruction i = 0x44801480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_507: {
    Instruction i = 0x00002244;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_508: {
    Instruction i = 0x0010a2ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_509: {
    Instruction i = 0x45002240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_510: {
    Instruction i = 0xbc14804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_511: {
    Instruction i = 0xbc94c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_512: {
    Instruction i = 0xbd15004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_513: {
    Instruction i = 0xbd95804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_514: {
    Instruction i = 0xbe15c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_515: {
    Instruction i = 0xbea2404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_516: {
    Instruction i = 0x00002284;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_517: {
    Instruction i = 0x0010e2ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_518: {
    Instruction i = 0x45802280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_519: {
    Instruction i = 0x000022c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_520: {
    Instruction i = 0x0011232c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_521: {
    Instruction i = 0x460022c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_522: {
    Instruction i = 0x0900230b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_523: {
    Instruction i = 0x45002340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_524: {
    Instruction i = 0x1c802380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_525: {
    Instruction i = 0x0b0023c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_526: {
    Instruction i = 0x0180a364;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_527: {
    Instruction i = 0x0180238b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_528: {
    Instruction i = 0x408023c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_529: {
    Instruction i = 0x0000a401;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_530: {
    Instruction i = 0x0a802440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_531: {
    Instruction i = 0x018063ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_532: {
    Instruction i = 0x458023c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_533: {
    Instruction i = 0x1b802400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_534: {
    Instruction i = 0x0b002440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_535: {
    Instruction i = 0x0b802480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_536: {
    Instruction i = 0x0200a3e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_537: {
    Instruction i = 0x45802400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_538: {
    Instruction i = 0x1c002440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_539: {
    Instruction i = 0x0b002480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_540: {
    Instruction i = 0x0c0024c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_541: {
    Instruction i = 0x0200a424;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_542: {
    Instruction i = 0x45002440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_543: {
    Instruction i = 0x1e002480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_544: {
    Instruction i = 0x0d0024c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_545: {
    Instruction i = 0x0180a464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_546: {
    Instruction i = 0x0180248b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_547: {
    Instruction i = 0x410024c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_548: {
    Instruction i = 0x0000a501;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_549: {
    Instruction i = 0x0c802540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_550: {
    Instruction i = 0x018064ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_551: {
    Instruction i = 0x458024c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_552: {
    Instruction i = 0x1d002500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_553: {
    Instruction i = 0x0d002540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_554: {
    Instruction i = 0x0d802580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_555: {
    Instruction i = 0x0200a4e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_556: {
    Instruction i = 0x45802500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_557: {
    Instruction i = 0x1d802540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_558: {
    Instruction i = 0x0d002580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_559: {
    Instruction i = 0x0e0025c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_560: {
    Instruction i = 0x0200a524;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_561: {
    Instruction i = 0x45002540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_562: {
    Instruction i = 0x20802580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_563: {
    Instruction i = 0x0a0025c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_564: {
    Instruction i = 0x0180a564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_565: {
    Instruction i = 0x0180258b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_566: {
    Instruction i = 0x418025c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_567: {
    Instruction i = 0x0000a601;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_568: {
    Instruction i = 0x07802640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_569: {
    Instruction i = 0x018065ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_570: {
    Instruction i = 0x450025c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_571: {
    Instruction i = 0x1e802600;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_572: {
    Instruction i = 0x08002640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_573: {
    Instruction i = 0x0180a5e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_574: {
    Instruction i = 0x45802600;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_575: {
    Instruction i = 0x1f002640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_576: {
    Instruction i = 0x08002680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_577: {
    Instruction i = 0x088026c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_578: {
    Instruction i = 0x0200a624;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_579: {
    Instruction i = 0x45802640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_580: {
    Instruction i = 0x1f802680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_581: {
    Instruction i = 0x080026c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_582: {
    Instruction i = 0x09002700;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_583: {
    Instruction i = 0x0200a664;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_584: {
    Instruction i = 0x0180268b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_585: {
    Instruction i = 0x210026c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_586: {
    Instruction i = 0x0000a701;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_587: {
    Instruction i = 0x0011676c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_588: {
    Instruction i = 0x018066ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_589: {
    Instruction i = 0x018026cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_590: {
    Instruction i = 0x21802700;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_591: {
    Instruction i = 0x0000a741;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_592: {
    Instruction i = 0x0011a7ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_593: {
    Instruction i = 0x018066eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_594: {
    Instruction i = 0x0180270b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_595: {
    Instruction i = 0x22002740;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_596: {
    Instruction i = 0x0000a781;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_597: {
    Instruction i = 0x0011e7ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_598: {
    Instruction i = 0x0180672b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_599: {
    Instruction i = 0x45002740;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_600: {
    Instruction i = 0x20002780;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_601: {
    Instruction i = 0x068027c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_602: {
    Instruction i = 0x0180a764;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_603: {
    Instruction i = 0x0180278b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_604: {
    Instruction i = 0x420027c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_605: {
    Instruction i = 0x001fa801;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_606: {
    Instruction i = 0x0012286c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_607: {
    Instruction i = 0x018067ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_608: {
    Instruction i = 0x018027cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_609: {
    Instruction i = 0x22802800;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_610: {
    Instruction i = 0x0000e841;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_611: {
    Instruction i = 0x001268ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_612: {
    Instruction i = 0x018067eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_613: {
    Instruction i = 0x0980632b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_614: {
    Instruction i = 0x46001680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_615: {
    Instruction i = 0xbf97c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_616: {
    Instruction i = 0x00002304;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_617: {
    Instruction i = 0x0012a36c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_618: {
    Instruction i = 0x46802300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_619: {
    Instruction i = 0x00002344;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_620: {
    Instruction i = 0x0012e3ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_621: {
    Instruction i = 0x47002340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_622: {
    Instruction i = 0xc018004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_623: {
    Instruction i = 0xc0a3404a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_624: {
    Instruction i = 0x00002384;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_625: {
    Instruction i = 0x001323ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_626: {
    Instruction i = 0x47802380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_627: {
    Instruction i = 0xc123804a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_628: {
    Instruction i = 0x000023c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_629: {
    Instruction i = 0x0013642c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_630: {
    Instruction i = 0x480023c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_631: {
    Instruction i = 0xc1a3c04a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_632: {
    Instruction i = 0x00002404;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_633: {
    Instruction i = 0x0013a46c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_634: {
    Instruction i = 0x48802400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_635: {
    Instruction i = 0xc224004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_636: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_637: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_1 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_1: {
    Instruction i = 0x0140008d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_2: {
    Instruction i = 0x0100400a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_3: {
    Instruction i = 0x0000009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_4: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_2 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400006;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00004041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_3 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00004022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_2: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_4 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00c0405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_3;
    }
  }
  
  
  label_2: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_3: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_5 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_6 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_7 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_8 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_9 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_10 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_11 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_12 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_13 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_14 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_15 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_16 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_17 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_18 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_19 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_3;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x8000800a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_5: {
    Instruction i = 0x8080400a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_6: {
    Instruction i = 0x8140c00a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_7: {
    Instruction i = 0x8240c00a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_8: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_20 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_21 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_22 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_23 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_24 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_25 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_26 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x020000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x020040eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_6: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_27 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_28 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_29 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_30 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_31 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_32 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_33 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_34 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_35 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_36 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_37 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_38 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400047;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_39 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8002c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_20;
  }
  
  
  label_8: {
    Instruction i = 0x00c00087;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_9: {
    Instruction i = 0x00c040c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_10: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x8001004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_14: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x8081004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_18: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x8008001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_20: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_25;
    }
  }
  
  
  label_24: {
    Instruction i = 0x8002c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_37;
  }
  
  
  label_25: {
    Instruction i = 0x00c00087;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_26: {
    Instruction i = 0x00c040c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_27: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x8001004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_31: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x8081004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_35: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_36: {
    Instruction i = 0x8003c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_37: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_39: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_40: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_42;
    }
  }
  
  
  label_41: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_42: {
    Instruction i = 0x00c00087;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_43: {
    Instruction i = 0x00c040c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_44: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x8001004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_48: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_49: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_50: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_51: {
    Instruction i = 0x8081004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_52: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_53: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_54: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_40 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_2: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_4: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x0100c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_12: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x018040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_18;
    }
  }
  
  
  label_17: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_18: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_21;
  }
  
  
  label_19: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_21: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_41 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x0000009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x0140008e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_3: {
    Instruction i = 0x80808021;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessequal(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_5: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0140010d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x00010107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_8: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x018080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x0140008e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_12: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_3;
  }
  
  
  label_13: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_14: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_42 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000000b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x0000006d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i) - 1;  /* required results */
    int j;
    int n = cast_int(base - ci->func) - cl->p->numparams - 1;
    if (n < 0)  /* less arguments than parameters? */
      n = 0;  /* no vararg arguments */
    if (b < 0) {  /* B == 0? */
      b = n;  /* get all var. arguments */
      Protect(luaD_checkstack(L, n));
      ra = RA(i);  /* previous call may change the stack */
      L->top = ra + n;
    }
    for (j = 0; j < b && j < n; j++)
      setobjs2s(L, ra + j, base - n + j);
    for (; j < b; j++)  /* complete required results with nil */
      setnilvalue(ra + j);
  }
  
  
  label_2: {
    Instruction i = 0x0000402b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_3: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x01000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_43 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_1: {
    Instruction i = 0x0000008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_7: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x7ffc401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_2;
  }
  
  
  label_16: {
    Instruction i = 0x000000c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_17: {
    Instruction i = 0x0100011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_18: {
    Instruction i = 0x01810020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_27;
  }
  
  
  label_20: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x01c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_22: {
    Instruction i = 0x01014147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_23: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x01804124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x01c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_26: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_17;
  }
  
  
  label_27: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_28: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_44 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_5: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_20: {
    Instruction i = 0x02000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_24: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_45 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_2: {
    Instruction i = 0x0000010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x02000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x0140001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_11;
  }
  
  
  label_6: {
    Instruction i = 0x0100010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_7: {
    Instruction i = 0x00000143;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x00000183;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x0100412b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_10: {
    Instruction i = 0x02000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x01c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_13;
    }
  }
  
  
  label_12: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_13: {
    Instruction i = 0x0000010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x020000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x01000104;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_16: {
    Instruction i = 0x000001ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_17: {
    Instruction i = 0x03800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x000041ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_19: {
    Instruction i = 0x03800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x000001cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_21: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x00000204;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_23: {
    Instruction i = 0x0000826c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x04800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x00000244;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_26: {
    Instruction i = 0x0000c2ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_27: {
    Instruction i = 0x05000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x00800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x020002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_31: {
    Instruction i = 0x000002a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_33;
    }
  }
  
  
  label_32: {
    Instruction i = 0x8033801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_240;
  }
  
  
  label_33: {
    Instruction i = 0x03000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_34: {
    Instruction i = 0x020002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x008282c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_37: {
    Instruction i = 0x05c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_39: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x008002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x038282c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_43: {
    Instruction i = 0x05c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x802e001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_230;
  }
  
  
  label_45: {
    Instruction i = 0x8140408a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_46: {
    Instruction i = 0x038002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_47: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x000002e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_51;
    }
  }
  
  
  label_50: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_55;
  }
  
  
  label_51: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_52: {
    Instruction i = 0x008002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_53: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_54: {
    Instruction i = 0x802ac01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_227;
  }
  
  
  label_55: {
    Instruction i = 0x040002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_56: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_58: {
    Instruction i = 0x000002e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_60;
    }
  }
  
  
  label_59: {
    Instruction i = 0x8025401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_210;
  }
  
  
  label_60: {
    Instruction i = 0x048002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_62: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x05000305;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x02000340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_65: {
    Instruction i = 0x01008324;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_66: {
    Instruction i = 0x0580034b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_67: {
    Instruction i = 0x05800385;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x060003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_69: {
    Instruction i = 0x06800405;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_70: {
    Instruction i = 0x07000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x07800485;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_72: {
    Instruction i = 0x080004c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_73: {
    Instruction i = 0x08800505;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x09000545;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x09800585;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_76: {
    Instruction i = 0x0a0005c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_77: {
    Instruction i = 0x0a800605;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_78: {
    Instruction i = 0x0580436b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_79: {
    Instruction i = 0x00000383;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_81;
    }
  }
  
  
  label_80: {
    Instruction i = 0x0000c3c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_81: {
    Instruction i = 0x0680041c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_82: {
    Instruction i = 0x07840020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_84;
    }
  }
  
  
  label_83: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_94;
  }
  
  
  label_84: {
    Instruction i = 0x0b000405;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_85: {
    Instruction i = 0x07c0844d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_86: {
    Instruction i = 0x06844447;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_87: {
    Instruction i = 0x05800480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_88: {
    Instruction i = 0x01808424;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_89: {
    Instruction i = 0x00000422;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_91;
    }
  }
  
  
  label_90: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_92;
  }
  
  
  label_91: {
    Instruction i = 0x00800383;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_93;
    }
  }
  
  
  label_92: {
    Instruction i = 0x07c083cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_93: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_81;
  }
  
  
  label_94: {
    Instruction i = 0x000003a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_96;
    }
  }
  
  
  label_95: {
    Instruction i = 0x8008c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_132;
  }
  
  
  label_96: {
    Instruction i = 0x0b8003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_97: {
    Instruction i = 0x0600041c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_98: {
    Instruction i = 0x0840805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_100;
    }
  }
  
  
  label_99: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_101;
  }
  
  
  label_100: {
    Instruction i = 0x00004403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_102;
    }
  }
  
  
  label_101: {
    Instruction i = 0x00800403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_103;
    }
  }
  
  
  label_102: {
    Instruction i = 0x010043e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_103: {
    Instruction i = 0x0b8003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_104: {
    Instruction i = 0x01410407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_105: {
    Instruction i = 0x0841405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_107;
    }
  }
  
  
  label_106: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_108;
  }
  
  
  label_107: {
    Instruction i = 0x00004403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_109;
    }
  }
  
  
  label_108: {
    Instruction i = 0x00800403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_110;
    }
  }
  
  
  label_109: {
    Instruction i = 0x010043e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_110: {
    Instruction i = 0x018003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_111: {
    Instruction i = 0x06408407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_112: {
    Instruction i = 0x04800440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_113: {
    Instruction i = 0x00808464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_114: {
    Instruction i = 0x01000480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x020083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_116: {
    Instruction i = 0x01410407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_117: {
    Instruction i = 0x00000422;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_119;
    }
  }
  
  
  label_118: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_129;
  }
  
  
  label_119: {
    Instruction i = 0x03000400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_120: {
    Instruction i = 0x0c000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_121: {
    Instruction i = 0x05800480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_122: {
    Instruction i = 0x008004cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_123: {
    Instruction i = 0x07800500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_124: {
    Instruction i = 0x008044eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_125: {
    Instruction i = 0x01800464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_126: {
    Instruction i = 0x00000425;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_127: {
    Instruction i = 0x00000426;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_128: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_132;
  }
  
  
  label_129: {
    Instruction i = 0x0c800405;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_130: {
    Instruction i = 0x00800425;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_131: {
    Instruction i = 0x00000426;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_132: {
    Instruction i = 0x0b0003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_133: {
    Instruction i = 0x05800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_134: {
    Instruction i = 0x0d000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_135: {
    Instruction i = 0x018083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_136: {
    Instruction i = 0x000003e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_138;
    }
  }
  
  
  label_137: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_142;
  }
  
  
  label_138: {
    Instruction i = 0x040003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_139: {
    Instruction i = 0x008003e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_140: {
    Instruction i = 0x000003e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_141: {
    Instruction i = 0x800fc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_206;
  }
  
  
  label_142: {
    Instruction i = 0x0b0003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_143: {
    Instruction i = 0x05800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_144: {
    Instruction i = 0x0d800445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_145: {
    Instruction i = 0x018083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_146: {
    Instruction i = 0x000003e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_148;
    }
  }
  
  
  label_147: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_152;
  }
  
  
  label_148: {
    Instruction i = 0x040003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_149: {
    Instruction i = 0x008003e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_150: {
    Instruction i = 0x000003e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_151: {
    Instruction i = 0x800d401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_206;
  }
  
  
  label_152: {
    Instruction i = 0x0b0003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_153: {
    Instruction i = 0x05800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_154: {
    Instruction i = 0x0e000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_155: {
    Instruction i = 0x018083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_156: {
    Instruction i = 0x000003e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_158;
    }
  }
  
  
  label_157: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_162;
  }
  
  
  label_158: {
    Instruction i = 0x040003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_159: {
    Instruction i = 0x008003e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_160: {
    Instruction i = 0x000003e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_161: {
    Instruction i = 0x800ac01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_206;
  }
  
  
  label_162: {
    Instruction i = 0x0b0003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_163: {
    Instruction i = 0x05800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_164: {
    Instruction i = 0x0e800445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_165: {
    Instruction i = 0x018083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_166: {
    Instruction i = 0x000003e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_168;
    }
  }
  
  
  label_167: {
    Instruction i = 0x8009401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_206;
  }
  
  
  label_168: {
    Instruction i = 0x0b8003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_169: {
    Instruction i = 0x0600041c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_170: {
    Instruction i = 0x0841805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_172;
    }
  }
  
  
  label_171: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_173;
  }
  
  
  label_172: {
    Instruction i = 0x00004403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_174;
    }
  }
  
  
  label_173: {
    Instruction i = 0x00800403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_175;
    }
  }
  
  
  label_174: {
    Instruction i = 0x010043e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_175: {
    Instruction i = 0x0b8003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_176: {
    Instruction i = 0x01410407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_177: {
    Instruction i = 0x0841405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_179;
    }
  }
  
  
  label_178: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_180;
  }
  
  
  label_179: {
    Instruction i = 0x00004403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_181;
    }
  }
  
  
  label_180: {
    Instruction i = 0x00800403;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_182;
    }
  }
  
  
  label_181: {
    Instruction i = 0x010043e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_182: {
    Instruction i = 0x018003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_183: {
    Instruction i = 0x06408407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_184: {
    Instruction i = 0x04800440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_185: {
    Instruction i = 0x00808464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_186: {
    Instruction i = 0x01000480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_187: {
    Instruction i = 0x020083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_188: {
    Instruction i = 0x01410407;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_189: {
    Instruction i = 0x00000422;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_191;
    }
  }
  
  
  label_190: {
    Instruction i = 0x8002c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_203;
  }
  
  
  label_191: {
    Instruction i = 0x03000400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_192: {
    Instruction i = 0x0c000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_193: {
    Instruction i = 0x0e800485;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_194: {
    Instruction i = 0x018004cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_195: {
    Instruction i = 0x07800500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_196: {
    Instruction i = 0x06410547;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_197: {
    Instruction i = 0x06418587;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_198: {
    Instruction i = 0x018044eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_199: {
    Instruction i = 0x01800464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_200: {
    Instruction i = 0x00000425;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_201: {
    Instruction i = 0x00000426;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_202: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_206;
  }
  
  
  label_203: {
    Instruction i = 0x0c800405;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_204: {
    Instruction i = 0x00800425;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_205: {
    Instruction i = 0x00000426;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_206: {
    Instruction i = 0x0c8003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_207: {
    Instruction i = 0x008003e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_208: {
    Instruction i = 0x000003e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_209: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_227;
  }
  
  
  label_210: {
    Instruction i = 0x0f0002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_211: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_212: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_213: {
    Instruction i = 0x000002e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_215;
    }
  }
  
  
  label_214: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_219;
  }
  
  
  label_215: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_216: {
    Instruction i = 0x008002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_217: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_218: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_227;
  }
  
  
  label_219: {
    Instruction i = 0x0f8002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_220: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_221: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_222: {
    Instruction i = 0x000002e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_224;
    }
  }
  
  
  label_223: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_227;
  }
  
  
  label_224: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_225: {
    Instruction i = 0x008002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_226: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_227: {
    Instruction i = 0x0c8002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_228: {
    Instruction i = 0x008002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_229: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_230: {
    Instruction i = 0x054041ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_231: {
    Instruction i = 0x010002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_232: {
    Instruction i = 0x01800300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_233: {
    Instruction i = 0x02000340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_234: {
    Instruction i = 0x018042e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_235: {
    Instruction i = 0x100002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_236: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_237: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_238: {
    Instruction i = 0x05800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_239: {
    Instruction i = 0x7fcac01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_28;
  }
  
  
  label_240: {
    Instruction i = 0x02800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_241: {
    Instruction i = 0x020002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_242: {
    Instruction i = 0x010002a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_243: {
    Instruction i = 0x000002a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_244: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_46 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01804064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_5: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0100009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_7: {
    Instruction i = 0x00808020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_9: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x00c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_11: {
    Instruction i = 0x0100c0c6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_12: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x018040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00c0404d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_15: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_16: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_17: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_47 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x01804064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x02800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x000000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_15: {
    Instruction i = 0x0100010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_16: {
    Instruction i = 0x00000143;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_18;
    }
  }
  
  
  label_17: {
    Instruction i = 0x00000183;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x0100412b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_19: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x02800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_48 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x80404008;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *upval = cl->upvals[GETARG_A(i)]->v;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, upval, rb, rc);
  }
  
  
  label_1: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01000025;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_49 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000000b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00400046;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_2: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01010064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_5: {
    Instruction i = 0x0240400a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_6: {
    Instruction i = 0x00004069;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId cb = ra + 3;  /* call base */
    setobjs2s(L, cb+2, ra+2);
    setobjs2s(L, cb+1, ra+1);
    setobjs2s(L, cb, ra);
    L->top = cb + 3;  /* func. + 2 args (state and index) */
    Protect(luaD_call(L, cb, GETARG_C(i)));
    L->top = ci->top;
  }
  
  
  label_7: {
    Instruction i = 0x7fff00ea;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (!ttisnil(ra + 1)) {  /* continue loop? */
      setobjs2s(L, ra, ra + 1);  /* save control variable */
      ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
      goto label_5; /* jump back */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00400046;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01010064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_12: {
    Instruction i = 0x0240400a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_13: {
    Instruction i = 0x00004069;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId cb = ra + 3;  /* call base */
    setobjs2s(L, cb+2, ra+2);
    setobjs2s(L, cb+1, ra+1);
    setobjs2s(L, cb, ra);
    L->top = cb + 3;  /* func. + 2 args (state and index) */
    Protect(luaD_call(L, cb, GETARG_C(i)));
    L->top = ci->top;
  }
  
  
  label_14: {
    Instruction i = 0x7fff00ea;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (!ttisnil(ra + 1)) {  /* continue loop? */
      setobjs2s(L, ra, ra + 1);  /* save control variable */
      ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
      goto label_12; /* jump back */
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_50 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_4: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0200011b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RB(i);
    int res = l_isfalse(rb);  /* next assignment may change this value */
    setbvalue(ra, res);
  }
  
  
  label_9: {
    Instruction i = 0x010040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_15: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x03000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x800c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_74;
  }
  
  
  label_25: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_28: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_30;
    }
  }
  
  
  label_29: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_30: {
    Instruction i = 0x040000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_39: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_40: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_74;
  }
  
  
  label_43: {
    Instruction i = 0x060000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_44: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_45: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_46: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_48;
    }
  }
  
  
  label_47: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_58;
  }
  
  
  label_48: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_49: {
    Instruction i = 0x07000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x07800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_53: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_54: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_55: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x8003c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_74;
  }
  
  
  label_58: {
    Instruction i = 0x080000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_59: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_60: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_61: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_63;
    }
  }
  
  
  label_62: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_73;
  }
  
  
  label_63: {
    Instruction i = 0x088000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x09000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_66: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x09800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_71: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_72: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_74;
  }
  
  
  label_73: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_74: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_77: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_78: {
    Instruction i = 0x0a0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_79: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_80: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_81: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_82: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_83: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_51 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x0000015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_3: {
    Instruction i = 0x02014020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x800bc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_5: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0240018d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_8: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_9: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_13;
    }
  }
  
  
  label_12: {
    Instruction i = 0x8006401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_39;
  }
  
  
  label_13: {
    Instruction i = 0x0240014d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_15: {
    Instruction i = 0x028040ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_16: {
    Instruction i = 0x0240414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_17: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_18: {
    Instruction i = 0x028080ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_19: {
    Instruction i = 0x0240810d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_20: {
    Instruction i = 0x0000015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_21: {
    Instruction i = 0x02014020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_37;
  }
  
  
  label_23: {
    Instruction i = 0x0240014d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_24: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_25: {
    Instruction i = 0x0240018d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_26: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_27: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_28: {
    Instruction i = 0x028180ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_29: {
    Instruction i = 0x0240414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_30: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_31: {
    Instruction i = 0x0240418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_32: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_33: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_34: {
    Instruction i = 0x028180ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_35: {
    Instruction i = 0x0240810d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_36: {
    Instruction i = 0x7ffb801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_20;
  }
  
  
  label_37: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_38: {
    Instruction i = 0x8002c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_51;
  }
  
  
  label_39: {
    Instruction i = 0x0240014d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_40: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_41: {
    Instruction i = 0x0240018d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_42: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_43: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_44: {
    Instruction i = 0x028180ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_45: {
    Instruction i = 0x0240414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_46: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_47: {
    Instruction i = 0x0240418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_48: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_49: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_50: {
    Instruction i = 0x028180ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_51: {
    Instruction i = 0x0240810d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_52: {
    Instruction i = 0x7ff3001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_2;
  }
  
  
  label_53: {
    Instruction i = 0x0000011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_54: {
    Instruction i = 0x0240010d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_55: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_56: {
    Instruction i = 0x020040ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_57: {
    Instruction i = 0x0000011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_58: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_59: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_60: {
    Instruction i = 0x020080ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_61: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_62: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_52 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_1: {
    Instruction i = 0x0000011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x01810020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_4: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x01c0014d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_6: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x00014147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_8: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_12: {
    Instruction i = 0x01c0410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_13: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x00010107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_15: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x01c080cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_17: {
    Instruction i = 0x7ffb801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_1;
  }
  
  
  label_18: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_53 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_1: {
    Instruction i = 0x000000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_4: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x0140010d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_6: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x00010107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_8: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x018080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_12: {
    Instruction i = 0x014040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_13: {
    Instruction i = 0x01c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x0000c0c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_15: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x0140808d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_17: {
    Instruction i = 0x7ffb801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_1;
  }
  
  
  label_18: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_21: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_54 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x000000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_3: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_5: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x0140014d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_8: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x00014147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_10: {
    Instruction i = 0x0140418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_11: {
    Instruction i = 0x0340418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_12: {
    Instruction i = 0x00018187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_13: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x018080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x0140808d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_18: {
    Instruction i = 0x7ffb801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_2;
  }
  
  
  label_19: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_55 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_1: {
    Instruction i = 0x000000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_14;
  }
  
  
  label_4: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x0140010d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_6: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x00010107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_8: {
    Instruction i = 0x0140414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_10: {
    Instruction i = 0x00014147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_11: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x0140808d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_13: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_1;
  }
  
  
  label_14: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_56 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_8: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x028001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x03800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x02800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x04000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x000002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x010002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x01800264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_28: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_31: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_33;
    }
  }
  
  
  label_32: {
    Instruction i = 0x803c401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_275;
  }
  
  
  label_33: {
    Instruction i = 0x0000010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_34: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_71;
  }
  
  
  label_40: {
    Instruction i = 0x00800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_51;
  }
  
  
  label_45: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_47: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x018001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_50: {
    Instruction i = 0x7ffbc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_51: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_54: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_56;
    }
  }
  
  
  label_55: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_69;
  }
  
  
  label_56: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_57: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_58: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_59: {
    Instruction i = 0x02800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_60: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_61: {
    Instruction i = 0x000041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_62: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_63: {
    Instruction i = 0x068001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x02800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_65: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_66: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x03000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_68: {
    Instruction i = 0x7ff7401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_69: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_70: {
    Instruction i = 0x7ff6c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_71: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_72: {
    Instruction i = 0x024001c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_73: {
    Instruction i = 0x07800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_75: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_77;
    }
  }
  
  
  label_76: {
    Instruction i = 0x8005c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_101;
  }
  
  
  label_77: {
    Instruction i = 0x0200019c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_78: {
    Instruction i = 0x0340001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_80;
    }
  }
  
  
  label_79: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_81;
  }
  
  
  label_80: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_81: {
    Instruction i = 0x02404187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_82: {
    Instruction i = 0x000001cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_83: {
    Instruction i = 0x00004201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_84: {
    Instruction i = 0x0200025c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_85: {
    Instruction i = 0x04024020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_87;
    }
  }
  
  
  label_86: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_94;
  }
  
  
  label_87: {
    Instruction i = 0x0440424e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_88: {
    Instruction i = 0x04c0024d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_89: {
    Instruction i = 0x0440028d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_90: {
    Instruction i = 0x02028287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_91: {
    Instruction i = 0x048281ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_92: {
    Instruction i = 0x0440020d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_93: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_84;
  }
  
  
  label_94: {
    Instruction i = 0x08000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_95: {
    Instruction i = 0x00000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_96: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_97: {
    Instruction i = 0x038002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_98: {
    Instruction i = 0x02000225;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_99: {
    Instruction i = 0x00000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_100: {
    Instruction i = 0x8031801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_101: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_102: {
    Instruction i = 0x024001c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_103: {
    Instruction i = 0x08800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_104: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_105: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_107;
    }
  }
  
  
  label_106: {
    Instruction i = 0x801b801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_218;
  }
  
  
  label_107: {
    Instruction i = 0x0200019c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_108: {
    Instruction i = 0x0340001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_110;
    }
  }
  
  
  label_109: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_111;
  }
  
  
  label_110: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_111: {
    Instruction i = 0x09000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_112: {
    Instruction i = 0x010001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_113: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x02404247;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_115: {
    Instruction i = 0x018001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_116: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_117: {
    Instruction i = 0x098001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_118: {
    Instruction i = 0x03000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_120: {
    Instruction i = 0x000041e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_122;
    }
  }
  
  
  label_121: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_123;
  }
  
  
  label_122: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_123: {
    Instruction i = 0x000001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_124: {
    Instruction i = 0x0a000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_125: {
    Instruction i = 0x03000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_126: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_127: {
    Instruction i = 0x000081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_128: {
    Instruction i = 0x00800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_129: {
    Instruction i = 0x03800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_130: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_131: {
    Instruction i = 0x00000222;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_133;
    }
  }
  
  
  label_132: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_138;
  }
  
  
  label_133: {
    Instruction i = 0x01000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_134: {
    Instruction i = 0x00000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_135: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_136: {
    Instruction i = 0x01800225;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_137: {
    Instruction i = 0x00000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_138: {
    Instruction i = 0x0a800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_139: {
    Instruction i = 0x03800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_140: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_141: {
    Instruction i = 0x00004222;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_143;
    }
  }
  
  
  label_142: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_144;
  }
  
  
  label_143: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_144: {
    Instruction i = 0x0b000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_145: {
    Instruction i = 0x03800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_146: {
    Instruction i = 0x0b800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_147: {
    Instruction i = 0x01808224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_148: {
    Instruction i = 0x00004222;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_150;
    }
  }
  
  
  label_149: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_150: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_151: {
    Instruction i = 0x00000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_152: {
    Instruction i = 0x0c000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_153: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_154: {
    Instruction i = 0x01000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_155: {
    Instruction i = 0x00008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_156: {
    Instruction i = 0x00800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_157: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_158: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_159: {
    Instruction i = 0x00000262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_161;
    }
  }
  
  
  label_160: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_166;
  }
  
  
  label_161: {
    Instruction i = 0x01000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_162: {
    Instruction i = 0x00000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_163: {
    Instruction i = 0x010002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_164: {
    Instruction i = 0x01800265;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_165: {
    Instruction i = 0x00000266;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_166: {
    Instruction i = 0x04800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_167: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_168: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_169: {
    Instruction i = 0x00004262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_171;
    }
  }
  
  
  label_170: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_172;
  }
  
  
  label_171: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_172: {
    Instruction i = 0x06000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_173: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_174: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_175: {
    Instruction i = 0x00000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_176: {
    Instruction i = 0x068002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_177: {
    Instruction i = 0x04000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_178: {
    Instruction i = 0x010002e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_179: {
    Instruction i = 0x000082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_180: {
    Instruction i = 0x008002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_181: {
    Instruction i = 0x05000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_182: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_183: {
    Instruction i = 0x000002e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_185;
    }
  }
  
  
  label_184: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_190;
  }
  
  
  label_185: {
    Instruction i = 0x010002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_186: {
    Instruction i = 0x00000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_187: {
    Instruction i = 0x01000340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_188: {
    Instruction i = 0x018002e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_189: {
    Instruction i = 0x000002e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_190: {
    Instruction i = 0x050002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_191: {
    Instruction i = 0x05000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_192: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_193: {
    Instruction i = 0x000042e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_195;
    }
  }
  
  
  label_194: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_196;
  }
  
  
  label_195: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_196: {
    Instruction i = 0x000002cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_197: {
    Instruction i = 0x04000305;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_198: {
    Instruction i = 0x00000340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_199: {
    Instruction i = 0x01000324;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_200: {
    Instruction i = 0x000042eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_201: {
    Instruction i = 0x00004301;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_202: {
    Instruction i = 0x0200035c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_203: {
    Instruction i = 0x06034020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_205;
    }
  }
  
  
  label_204: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_212;
  }
  
  
  label_205: {
    Instruction i = 0x0640034e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_206: {
    Instruction i = 0x06c0034d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_207: {
    Instruction i = 0x0640038d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_208: {
    Instruction i = 0x02038387;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_209: {
    Instruction i = 0x068382ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_210: {
    Instruction i = 0x0640030d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_211: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_212: {
    Instruction i = 0x0c800305;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_213: {
    Instruction i = 0x04800340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_214: {
    Instruction i = 0x05800380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_215: {
    Instruction i = 0x01800325;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_216: {
    Instruction i = 0x00000326;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_217: {
    Instruction i = 0x8014401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_218: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_219: {
    Instruction i = 0x024001c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_220: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_221: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_222: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_224;
    }
  }
  
  
  label_223: {
    Instruction i = 0x8006401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_250;
  }
  
  
  label_224: {
    Instruction i = 0x0200019c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_225: {
    Instruction i = 0x0340001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_227;
    }
  }
  
  
  label_226: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_228;
  }
  
  
  label_227: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_228: {
    Instruction i = 0x02404187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_229: {
    Instruction i = 0x000001cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_230: {
    Instruction i = 0x00004201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_231: {
    Instruction i = 0x0200025c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_232: {
    Instruction i = 0x04024020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_234;
    }
  }
  
  
  label_233: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_244;
  }
  
  
  label_234: {
    Instruction i = 0x0440424e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_235: {
    Instruction i = 0x04c0024d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_236: {
    Instruction i = 0x01000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_237: {
    Instruction i = 0x000002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_238: {
    Instruction i = 0x0440030d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_239: {
    Instruction i = 0x02030307;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_240: {
    Instruction i = 0x018082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_241: {
    Instruction i = 0x048281ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_242: {
    Instruction i = 0x0440020d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_243: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_231;
  }
  
  
  label_244: {
    Instruction i = 0x0d000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_245: {
    Instruction i = 0x03000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_246: {
    Instruction i = 0x03800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_247: {
    Instruction i = 0x01800225;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_248: {
    Instruction i = 0x00000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_249: {
    Instruction i = 0x800c401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_250: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_251: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_252: {
    Instruction i = 0x02400207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_253: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_254: {
    Instruction i = 0x000001cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_255: {
    Instruction i = 0x00000201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_256: {
    Instruction i = 0x0200025c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_257: {
    Instruction i = 0x04024020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_259;
    }
  }
  
  
  label_258: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_269;
  }
  
  
  label_259: {
    Instruction i = 0x0440024e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_260: {
    Instruction i = 0x04c0024d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_261: {
    Instruction i = 0x01000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_262: {
    Instruction i = 0x000002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_263: {
    Instruction i = 0x0440030d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_264: {
    Instruction i = 0x02030307;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_265: {
    Instruction i = 0x018082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_266: {
    Instruction i = 0x048281ca;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_267: {
    Instruction i = 0x0440020d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_268: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_256;
  }
  
  
  label_269: {
    Instruction i = 0x0c800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_270: {
    Instruction i = 0x03000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_271: {
    Instruction i = 0x03800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_272: {
    Instruction i = 0x01800225;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_273: {
    Instruction i = 0x00000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_274: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_275: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_276: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_277: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_278: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_280;
    }
  }
  
  
  label_279: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_282;
  }
  
  
  label_280: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_281: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_282: {
    Instruction i = 0x0d800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_283: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_284: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_285: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_287;
    }
  }
  
  
  label_286: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_294;
  }
  
  
  label_287: {
    Instruction i = 0x0e000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_288: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_289: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_290: {
    Instruction i = 0x018001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_291: {
    Instruction i = 0x02000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_292: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_293: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_294: {
    Instruction i = 0x0e800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_295: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_296: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_297: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_299;
    }
  }
  
  
  label_298: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_300;
  }
  
  
  label_299: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_300: {
    Instruction i = 0x0f000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_301: {
    Instruction i = 0x00800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_302: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_303: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_57 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_8;
  }
  
  
  label_5: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_9: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_58 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_1: {
    Instruction i = 0x000000ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x01800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_17;
  }
  
  
  label_12: {
    Instruction i = 0x040000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_17: {
    Instruction i = 0x048000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_22;
    }
  }
  
  
  label_21: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_22: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x05800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x06000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_32: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_35;
    }
  }
  
  
  label_34: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_41;
  }
  
  
  label_35: {
    Instruction i = 0x06800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_44;
  }
  
  
  label_41: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x00800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_44: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x07800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_47: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_48: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x08000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x00004162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_54;
    }
  }
  
  
  label_53: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_57;
  }
  
  
  label_54: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_57: {
    Instruction i = 0x08800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_58: {
    Instruction i = 0x09000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_59: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_60: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_61: {
    Instruction i = 0x00008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_62: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_63: {
    Instruction i = 0x098001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x02000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_65: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_66: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x080001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x03000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_72;
    }
  }
  
  
  label_71: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_81;
  }
  
  
  label_72: {
    Instruction i = 0x0a0001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_73: {
    Instruction i = 0x05000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x09800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x01000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_77: {
    Instruction i = 0x00000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x000081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_79: {
    Instruction i = 0x000041e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_81;
    }
  }
  
  
  label_80: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_84;
  }
  
  
  label_81: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_82: {
    Instruction i = 0x008001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_83: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_84: {
    Instruction i = 0x090001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_85: {
    Instruction i = 0x03000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_86: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_87: {
    Instruction i = 0x0a800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_88: {
    Instruction i = 0x00000241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_89: {
    Instruction i = 0x0a000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_90: {
    Instruction i = 0x028002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_91: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_92: {
    Instruction i = 0x000042a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_94;
    }
  }
  
  
  label_93: {
    Instruction i = 0x800e801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_153;
  }
  
  
  label_94: {
    Instruction i = 0x0b000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_95: {
    Instruction i = 0x028002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_96: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_97: {
    Instruction i = 0x000002a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_99;
    }
  }
  
  
  label_98: {
    Instruction i = 0x8005401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_121;
  }
  
  
  label_99: {
    Instruction i = 0x0b800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_100: {
    Instruction i = 0x008002dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_101: {
    Instruction i = 0x05c042ce;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_102: {
    Instruction i = 0x0482c021;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessequal(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_104;
    }
  }
  
  
  label_103: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_112;
  }
  
  
  label_104: {
    Instruction i = 0x0c000305;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_105: {
    Instruction i = 0x05c0434d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_106: {
    Instruction i = 0x00834347;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_107: {
    Instruction i = 0x05000380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_108: {
    Instruction i = 0x01808324;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_109: {
    Instruction i = 0x06000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_110: {
    Instruction i = 0x05c042ce;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_111: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_102;
  }
  
  
  label_112: {
    Instruction i = 0x0c8002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_113: {
    Instruction i = 0x04000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x02800340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x05000380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_116: {
    Instruction i = 0x020082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_117: {
    Instruction i = 0x05800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_118: {
    Instruction i = 0x0080025c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_119: {
    Instruction i = 0x0b800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_120: {
    Instruction i = 0x7ff7c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_89;
  }
  
  
  label_121: {
    Instruction i = 0x08000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_122: {
    Instruction i = 0x028002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_123: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_124: {
    Instruction i = 0x000002a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_126;
    }
  }
  
  
  label_125: {
    Instruction i = 0x8005801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_149;
  }
  
  
  label_126: {
    Instruction i = 0x0080029c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_127: {
    Instruction i = 0x04828020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_129;
    }
  }
  
  
  label_128: {
    Instruction i = 0x8003c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_145;
  }
  
  
  label_129: {
    Instruction i = 0x04c0428d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_130: {
    Instruction i = 0x00828287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_131: {
    Instruction i = 0x04c0424d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_132: {
    Instruction i = 0x0c8002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_133: {
    Instruction i = 0x04000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_134: {
    Instruction i = 0x09000345;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_135: {
    Instruction i = 0x02800380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_136: {
    Instruction i = 0x01008364;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_137: {
    Instruction i = 0x05000380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_138: {
    Instruction i = 0x020082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_139: {
    Instruction i = 0x05800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_140: {
    Instruction i = 0x098002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_141: {
    Instruction i = 0x02800300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_142: {
    Instruction i = 0x010082e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_143: {
    Instruction i = 0x05800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_144: {
    Instruction i = 0x7ff1c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_89;
  }
  
  
  label_145: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_146: {
    Instruction i = 0x008002a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_147: {
    Instruction i = 0x000002a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_148: {
    Instruction i = 0x7ff0c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_89;
  }
  
  
  label_149: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_150: {
    Instruction i = 0x008002a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_151: {
    Instruction i = 0x000002a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_152: {
    Instruction i = 0x7fefc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_89;
  }
  
  
  label_153: {
    Instruction i = 0x0080029c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_154: {
    Instruction i = 0x0502405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_156;
    }
  }
  
  
  label_155: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_159;
  }
  
  
  label_156: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_157: {
    Instruction i = 0x008002a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_158: {
    Instruction i = 0x000002a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_159: {
    Instruction i = 0x0d000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_160: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_161: {
    Instruction i = 0x03800300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_162: {
    Instruction i = 0x018002a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_163: {
    Instruction i = 0x000002a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_164: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_59 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x028001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x000001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x00000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x000000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000025;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x00000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_60 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x02000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x00000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x000080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_13: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x0200011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_15: {
    Instruction i = 0x01810020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_17;
    }
  }
  
  
  label_16: {
    Instruction i = 0x800c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_66;
  }
  
  
  label_17: {
    Instruction i = 0x03000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x01c0418d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_20: {
    Instruction i = 0x02818186;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_21: {
    Instruction i = 0x03404187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_22: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_25;
    }
  }
  
  
  label_24: {
    Instruction i = 0x8009801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_64;
  }
  
  
  label_25: {
    Instruction i = 0x01c0410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_26: {
    Instruction i = 0x02810106;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_27: {
    Instruction i = 0x02408107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_28: {
    Instruction i = 0x0080015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_29: {
    Instruction i = 0x0281005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_32;
  }
  
  
  label_31: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_32: {
    Instruction i = 0x01c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_33: {
    Instruction i = 0x02814146;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_34: {
    Instruction i = 0x02c0c147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_35: {
    Instruction i = 0x0240401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_37;
    }
  }
  
  
  label_36: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_37: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x00c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_39: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x018001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_43: {
    Instruction i = 0x0240801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_52;
  }
  
  
  label_45: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x00c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_47: {
    Instruction i = 0x00c08207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_48: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x020001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_51: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_52: {
    Instruction i = 0x0240c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_54;
    }
  }
  
  
  label_53: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_54: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x00c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_56: {
    Instruction i = 0x00c08207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_57: {
    Instruction i = 0x00c0c247;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_58: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_59: {
    Instruction i = 0x028001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_61: {
    Instruction i = 0x03800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_64: {
    Instruction i = 0x01c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_65: {
    Instruction i = 0x7ff2801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_66: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_67: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_61 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x010001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x02000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x02800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x010002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x010002a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x03000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x03800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_28;
  }
  
  
  label_21: {
    Instruction i = 0x0100011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_22: {
    Instruction i = 0x0240005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_24;
    }
  }
  
  
  label_23: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_24: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x01400107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_26: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_27: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_45;
  }
  
  
  label_28: {
    Instruction i = 0x03000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_32: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_34;
    }
  }
  
  
  label_33: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_45;
  }
  
  
  label_34: {
    Instruction i = 0x0100011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_35: {
    Instruction i = 0x0240405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_37;
    }
  }
  
  
  label_36: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_38;
  }
  
  
  label_37: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_38: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_39: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x01400187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_41: {
    Instruction i = 0x014041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_42: {
    Instruction i = 0x01800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x02800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_45: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_46: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_62 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_3;
  }
  
  
  label_2: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x00000104;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_4: {
    Instruction i = 0x0000016c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_5: {
    Instruction i = 0x02800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x00000144;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_7: {
    Instruction i = 0x000041ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x03000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x03000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0000018b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x000001c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x04800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x00004262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8007c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_21: {
    Instruction i = 0x05000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x00000262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_33;
  }
  
  
  label_26: {
    Instruction i = 0x05800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x040002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x01804264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x008001c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_32;
    }
  }
  
  
  label_31: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x7ffb801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_33: {
    Instruction i = 0x06800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_34: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x00000262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_38;
    }
  }
  
  
  label_37: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_49;
  }
  
  
  label_38: {
    Instruction i = 0x05800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_39: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x070002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x04000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x010002e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x00004264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x07800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x04000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x04800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x7ff7801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_49: {
    Instruction i = 0x02000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_50: {
    Instruction i = 0x00800265;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_51: {
    Instruction i = 0x00000266;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_52: {
    Instruction i = 0x7ff6801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_53: {
    Instruction i = 0x00800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_54: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_56;
    }
  }
  
  
  label_55: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_60;
  }
  
  
  label_56: {
    Instruction i = 0x03000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_57: {
    Instruction i = 0x030002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_58: {
    Instruction i = 0x010082a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_59: {
    Instruction i = 0x05000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_60: {
    Instruction i = 0x0000028b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_61: {
    Instruction i = 0x080002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x00000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x0000836c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_64: {
    Instruction i = 0x018042e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_65: {
    Instruction i = 0x048002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_66: {
    Instruction i = 0x0500031c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_67: {
    Instruction i = 0x0640430e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_68: {
    Instruction i = 0x81030021;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessequal(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_70;
    }
  }
  
  
  label_69: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_78;
  }
  
  
  label_70: {
    Instruction i = 0x09000345;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x0640438d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_72: {
    Instruction i = 0x05038387;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_73: {
    Instruction i = 0x058003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_74: {
    Instruction i = 0x01808364;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_75: {
    Instruction i = 0x068002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x0640430e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_77: {
    Instruction i = 0x7ffd401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_68;
  }
  
  
  label_78: {
    Instruction i = 0x04800300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_79: {
    Instruction i = 0x0500035c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_80: {
    Instruction i = 0x06c0434e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_81: {
    Instruction i = 0x81034021;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessequal(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_83;
    }
  }
  
  
  label_82: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_96;
  }
  
  
  label_83: {
    Instruction i = 0x09000385;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_84: {
    Instruction i = 0x028003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_85: {
    Instruction i = 0x09800405;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x00000440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_87: {
    Instruction i = 0x06c0448d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_88: {
    Instruction i = 0x05048487;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_89: {
    Instruction i = 0x01800424;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_90: {
    Instruction i = 0x000083e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_91: {
    Instruction i = 0x06000400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_92: {
    Instruction i = 0x018083a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_93: {
    Instruction i = 0x07000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_94: {
    Instruction i = 0x06c0434e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_95: {
    Instruction i = 0x7ffc001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_81;
  }
  
  
  label_96: {
    Instruction i = 0x0a000345;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_97: {
    Instruction i = 0x0a800385;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_98: {
    Instruction i = 0x010003c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_99: {
    Instruction i = 0x00800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_100: {
    Instruction i = 0x09000445;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x02800480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x0a0004c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_103: {
    Instruction i = 0x0a800505;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_104: {
    Instruction i = 0x01000545;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_105: {
    Instruction i = 0x05800580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_106: {
    Instruction i = 0x010005c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_107: {
    Instruction i = 0x01800564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_108: {
    Instruction i = 0x000004e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_109: {
    Instruction i = 0x000084a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_110: {
    Instruction i = 0x060004c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_111: {
    Instruction i = 0x01800464;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_112: {
    Instruction i = 0x000003e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_113: {
    Instruction i = 0x00000365;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_114: {
    Instruction i = 0x00000366;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_115: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_63 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x0040001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_3;
    }
  }
  
  
  label_2: {
    Instruction i = 0x8004c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_3: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x03800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x0100020b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x04800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x05000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x0100422b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_17: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x000000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x00000025;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_23: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_64 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x02000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_65 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_1: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x018000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_3: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_5: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0140410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_7: {
    Instruction i = 0x00010106;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_8: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x018080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_12: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x0140408d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x7ffc401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_1;
  }
  
  
  label_15: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x018040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_66 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_2: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_4: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_14: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_17: {
    Instruction i = 0x000000ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_18: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_24;
    }
  }
  
  
  label_23: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_24: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_26: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_29;
    }
  }
  
  
  label_28: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_29: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_34: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_35: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x008000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_41: {
    Instruction i = 0x8013001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_119;
  }
  
  
  label_42: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_47;
    }
  }
  
  
  label_46: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_60;
  }
  
  
  label_47: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_52;
    }
  }
  
  
  label_51: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_54;
  }
  
  
  label_52: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_54;
    }
  }
  
  
  label_53: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_54: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_55: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_56: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_58: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_59: {
    Instruction i = 0x800e801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_119;
  }
  
  
  label_60: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_62: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_65;
    }
  }
  
  
  label_64: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_80;
  }
  
  
  label_65: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_66: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_67: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_68: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_70;
    }
  }
  
  
  label_69: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_72;
  }
  
  
  label_70: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_72;
    }
  }
  
  
  label_71: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_72: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_73: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_74: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_75: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_76: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_77: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_79: {
    Instruction i = 0x8009801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_119;
  }
  
  
  label_80: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_81: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_82: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_83: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_85;
    }
  }
  
  
  label_84: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_100;
  }
  
  
  label_85: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_87: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_88: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_90;
    }
  }
  
  
  label_89: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_92;
  }
  
  
  label_90: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_92;
    }
  }
  
  
  label_91: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_92: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_94: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_96: {
    Instruction i = 0x060001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_97: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_98: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_99: {
    Instruction i = 0x8004801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_119;
  }
  
  
  label_100: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_103: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_105;
    }
  }
  
  
  label_104: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_119;
  }
  
  
  label_105: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_106: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_107: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_108: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_110;
    }
  }
  
  
  label_109: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_112;
  }
  
  
  label_110: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_112;
    }
  }
  
  
  label_111: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_112: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_113: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_116: {
    Instruction i = 0x078001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_117: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_118: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_119: {
    Instruction i = 0x080000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_120: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_121: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_122: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_67 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_27;
  }
  
  
  label_10: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_27;
  }
  
  
  label_20: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x01804124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x00800103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_29;
  }
  
  
  label_27: {
    Instruction i = 0x00000103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_29;
    }
  }
  
  
  label_28: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_29: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_68 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_5: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_6: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_14;
  }
  
  
  label_11: {
    Instruction i = 0x000040c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_12: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x8033c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_14: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x800a401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_19: {
    Instruction i = 0x00008041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_20: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_21: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x8003c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_26: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_30: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_32: {
    Instruction i = 0x00008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x0181405d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_34: {
    Instruction i = 0x0000c081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_35: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_37: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_40: {
    Instruction i = 0x01800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_41: {
    Instruction i = 0x7ffa801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_21;
  }
  
  
  label_42: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_47;
    }
  }
  
  
  label_46: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_51;
  }
  
  
  label_47: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x00010101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_49: {
    Instruction i = 0x0181005d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_50: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_59;
  }
  
  
  label_51: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_52: {
    Instruction i = 0x00014101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_53: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_54: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x0201411d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_57: {
    Instruction i = 0x00010141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_58: {
    Instruction i = 0x0181405d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_59: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_60: {
    Instruction i = 0x8028001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_61: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_64: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_66;
    }
  }
  
  
  label_65: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_80;
  }
  
  
  label_66: {
    Instruction i = 0x000180c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_67: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_69: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_70: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_71: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_72: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_73: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_74: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_75: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_76: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_77: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_78: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_79: {
    Instruction i = 0x8023401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_80: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_81: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_82: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_83: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_85;
    }
  }
  
  
  label_84: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_99;
  }
  
  
  label_85: {
    Instruction i = 0x0001c0c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_86: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_87: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_88: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_89: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_90: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_91: {
    Instruction i = 0x060001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_92: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_94: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_95: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_96: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_97: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_98: {
    Instruction i = 0x801e801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_99: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_100: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_101: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_102: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_104;
    }
  }
  
  
  label_103: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_109;
  }
  
  
  label_104: {
    Instruction i = 0x070000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_105: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_106: {
    Instruction i = 0x010000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_107: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_108: {
    Instruction i = 0x801c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_109: {
    Instruction i = 0x078000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_110: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_111: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_112: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_114;
    }
  }
  
  
  label_113: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_135;
  }
  
  
  label_114: {
    Instruction i = 0x000200c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_115: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_116: {
    Instruction i = 0x08000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_117: {
    Instruction i = 0x08800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_118: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_120: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_121: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_122: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_123: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_124: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_125: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_126: {
    Instruction i = 0x09000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_127: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_128: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_129: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_130: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_131: {
    Instruction i = 0x00010101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_132: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_133: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_134: {
    Instruction i = 0x8015801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_135: {
    Instruction i = 0x098000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_136: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_137: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_138: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_140;
    }
  }
  
  
  label_139: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_161;
  }
  
  
  label_140: {
    Instruction i = 0x000240c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_141: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_142: {
    Instruction i = 0x0a000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_143: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_144: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_145: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_146: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_147: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_148: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_149: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_150: {
    Instruction i = 0x0a800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_151: {
    Instruction i = 0x0b000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_152: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_153: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_154: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_155: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_156: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_157: {
    Instruction i = 0x00010101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_158: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_159: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_160: {
    Instruction i = 0x800f001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_161: {
    Instruction i = 0x0b8000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_162: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_163: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_164: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_166;
    }
  }
  
  
  label_165: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_197;
  }
  
  
  label_166: {
    Instruction i = 0x000280c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_167: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_168: {
    Instruction i = 0x08000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_169: {
    Instruction i = 0x0c000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_170: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_171: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_172: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_173: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_174: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_175: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_176: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_177: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_178: {
    Instruction i = 0x0c800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_179: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_180: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_181: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_182: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_183: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_184: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_185: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_186: {
    Instruction i = 0x0a800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_187: {
    Instruction i = 0x0d000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_188: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_189: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_190: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_191: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_192: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_193: {
    Instruction i = 0x00010101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_194: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_195: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_196: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_197: {
    Instruction i = 0x0d8000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_198: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_199: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_200: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_202;
    }
  }
  
  
  label_201: {
    Instruction i = 0x8004c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_222;
  }
  
  
  label_202: {
    Instruction i = 0x0002c0c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_203: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_204: {
    Instruction i = 0x0e000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_205: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_206: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_207: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_208: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_209: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_210: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_211: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_212: {
    Instruction i = 0x0a800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_213: {
    Instruction i = 0x0e800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_214: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_215: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_216: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_217: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_218: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_219: {
    Instruction i = 0x00010101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_220: {
    Instruction i = 0x018100dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_221: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_222: {
    Instruction i = 0x0f0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_223: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_224: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_225: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_69 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0100004b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x0100406b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_4: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_70 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x018000e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x00000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_8: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_71 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x02008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x020000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x00000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_12: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_72 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x008001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x02000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x02008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x020000e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_14: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_73 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x008001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x00000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x02800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x020001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_74 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_17;
  }
  
  
  label_6: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00004124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x02000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x7ffbc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_1;
  }
  
  
  label_17: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_22;
    }
  }
  
  
  label_21: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_26;
  }
  
  
  label_22: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x01800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_75 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x000000ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x0000412c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x02000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_76 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_77 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_78 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_11;
  }
  
  
  label_9: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_11: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x010000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x00008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_21: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x018080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_29;
    }
  }
  
  
  label_28: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_29: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_33: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_34: {
    Instruction i = 0x010000e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_35: {
    Instruction i = 0x000080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x03800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_39: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_40: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_42;
    }
  }
  
  
  label_41: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_44;
  }
  
  
  label_42: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_44;
    }
  }
  
  
  label_43: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_44: {
    Instruction i = 0x04000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_47: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x000000e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_51: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_53;
    }
  }
  
  
  label_52: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_55;
  }
  
  
  label_53: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_55;
    }
  }
  
  
  label_54: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_55: {
    Instruction i = 0x0000008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_56: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_57: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_58: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_59: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_61: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_64: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_66;
    }
  }
  
  
  label_65: {
    Instruction i = 0x8015401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_152;
  }
  
  
  label_66: {
    Instruction i = 0x03800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_67: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_68: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_69: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_71;
    }
  }
  
  
  label_70: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_73;
  }
  
  
  label_71: {
    Instruction i = 0x00000103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_73;
    }
  }
  
  
  label_72: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_73: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_77: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_79: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_80: {
    Instruction i = 0x018001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_81: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_82: {
    Instruction i = 0x00008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_83: {
    Instruction i = 0x028000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_84: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_85: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_86: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_87: {
    Instruction i = 0x00004162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_89;
    }
  }
  
  
  label_88: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_91;
  }
  
  
  label_89: {
    Instruction i = 0x00000143;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_91;
    }
  }
  
  
  label_90: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_91: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_92: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_94: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_95: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_96: {
    Instruction i = 0x02000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_97: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_98: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_99: {
    Instruction i = 0x03000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_100: {
    Instruction i = 0x03800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_103: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_105;
    }
  }
  
  
  label_104: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_107;
  }
  
  
  label_105: {
    Instruction i = 0x00000183;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_107;
    }
  }
  
  
  label_106: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_107: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_108: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_109: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_110: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_111: {
    Instruction i = 0x00000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_112: {
    Instruction i = 0x04800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_113: {
    Instruction i = 0x02000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x01000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_115: {
    Instruction i = 0x00000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_116: {
    Instruction i = 0x000081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_117: {
    Instruction i = 0x000041e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_119;
    }
  }
  
  
  label_118: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_121;
  }
  
  
  label_119: {
    Instruction i = 0x000001c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_121;
    }
  }
  
  
  label_120: {
    Instruction i = 0x010001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_121: {
    Instruction i = 0x008001c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_123;
    }
  }
  
  
  label_122: {
    Instruction i = 0x00000201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_123: {
    Instruction i = 0x0100025c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_124: {
    Instruction i = 0x04024020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_126;
    }
  }
  
  
  label_125: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_141;
  }
  
  
  label_126: {
    Instruction i = 0x05800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_127: {
    Instruction i = 0x0440028d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_128: {
    Instruction i = 0x0540428d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_129: {
    Instruction i = 0x01028287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_130: {
    Instruction i = 0x028002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_131: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_132: {
    Instruction i = 0x00000262;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_134;
    }
  }
  
  
  label_133: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_139;
  }
  
  
  label_134: {
    Instruction i = 0x0440424d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_135: {
    Instruction i = 0x04c0424d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_136: {
    Instruction i = 0x0481808a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_137: {
    Instruction i = 0x000001c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_139;
    }
  }
  
  
  label_138: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_141;
  }
  
  
  label_139: {
    Instruction i = 0x0440820d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_140: {
    Instruction i = 0x7ffb401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_123;
  }
  
  
  label_141: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_143;
    }
  }
  
  
  label_142: {
    Instruction i = 0x7feb401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_143: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_144: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_145: {
    Instruction i = 0x02800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_146: {
    Instruction i = 0x01804224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_147: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_148: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_149: {
    Instruction i = 0x03000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_150: {
    Instruction i = 0x01804224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_151: {
    Instruction i = 0x7fe9001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_152: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_153: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_79 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0180008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x00000101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_3: {
    Instruction i = 0x0000016c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x018040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_80 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0080010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0080412b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_14: {
    Instruction i = 0x018000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_21: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_81 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x018000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x00000141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_3: {
    Instruction i = 0x000001ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x018040eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_5: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_82 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0080010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0080412b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_14: {
    Instruction i = 0x018000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_21: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x010000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_83 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_2: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_4: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x01800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_17;
    }
  }
  
  
  label_16: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_17: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_22;
    }
  }
  
  
  label_21: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_30;
  }
  
  
  label_22: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x0100014b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_25: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_26: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x0100416b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_28: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_30: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_32;
    }
  }
  
  
  label_31: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_32: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_33: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x000000c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_35: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_36: {
    Instruction i = 0x020000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x00000104;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_38: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_39: {
    Instruction i = 0x02800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_42: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x0300019b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RB(i);
    int res = l_isfalse(rb);  /* next assignment may change this value */
    setbvalue(ra, res);
  }
  
  
  label_45: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_46: {
    Instruction i = 0x00000144;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_47: {
    Instruction i = 0x000081ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_48: {
    Instruction i = 0x03000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_54;
    }
  }
  
  
  label_53: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_64;
  }
  
  
  label_54: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_55: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_56: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_57: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_59;
    }
  }
  
  
  label_58: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_59: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_60: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_61: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_63: {
    Instruction i = 0x8014801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_147;
  }
  
  
  label_64: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_66: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_69;
    }
  }
  
  
  label_68: {
    Instruction i = 0x8004801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_88;
  }
  
  
  label_69: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_70: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_71: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_72: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_74;
    }
  }
  
  
  label_73: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_76;
  }
  
  
  label_74: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_76: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_77: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_78: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_79: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_80: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_82;
    }
  }
  
  
  label_81: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_85;
  }
  
  
  label_82: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_83: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_85;
    }
  }
  
  
  label_84: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_86;
  }
  
  
  label_85: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_87: {
    Instruction i = 0x800e801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_147;
  }
  
  
  label_88: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_89: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_90: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_91: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_93;
    }
  }
  
  
  label_92: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_108;
  }
  
  
  label_93: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_94: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_96: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_98;
    }
  }
  
  
  label_97: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_100;
  }
  
  
  label_98: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_99: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_100: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_101: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_103: {
    Instruction i = 0x06000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_104: {
    Instruction i = 0x06800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_105: {
    Instruction i = 0x028001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_106: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_107: {
    Instruction i = 0x8009801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_147;
  }
  
  
  label_108: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_109: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_110: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_111: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_113;
    }
  }
  
  
  label_112: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_128;
  }
  
  
  label_113: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_114: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_116: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_118;
    }
  }
  
  
  label_117: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_120;
  }
  
  
  label_118: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_119: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_120: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_121: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_122: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_123: {
    Instruction i = 0x07800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_124: {
    Instruction i = 0x08000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_125: {
    Instruction i = 0x028001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_126: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_127: {
    Instruction i = 0x8004801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_147;
  }
  
  
  label_128: {
    Instruction i = 0x08800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_129: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_130: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_131: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_133;
    }
  }
  
  
  label_132: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_147;
  }
  
  
  label_133: {
    Instruction i = 0x08800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_134: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_135: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_136: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_138;
    }
  }
  
  
  label_137: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_140;
  }
  
  
  label_138: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_139: {
    Instruction i = 0x010001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_140: {
    Instruction i = 0x02800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_141: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_142: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_143: {
    Instruction i = 0x09000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_144: {
    Instruction i = 0x09800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_145: {
    Instruction i = 0x028001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_146: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_147: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_148: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_149: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_150: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_84 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0180014b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x0180416b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_7: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_9: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_85 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x020000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_86 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x01000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x008001cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x00000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x00800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x01000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000041eb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_11: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x00800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x010001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x0080020b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_15: {
    Instruction i = 0x01800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x00000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x01800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x008002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x010002a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x0000422b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_22: {
    Instruction i = 0x018001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_23: {
    Instruction i = 0x00000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_25: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_87 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000cb;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_9: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x018001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x02000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x00008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x02800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x7ffb401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_22: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x00004162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_28;
  }
  
  
  label_27: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_28: {
    Instruction i = 0x03000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x018001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x01800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_32: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_33: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_88 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x01c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_5: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x01800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_11: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_89 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0080010b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0080412b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_14: {
    Instruction i = 0x018000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_18: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_21: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x010000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_90 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x02000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_4: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_9: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0180018b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x018041ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_16: {
    Instruction i = 0x01800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_18: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_24;
  }
  
  
  label_23: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_24: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x03000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_28: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_30: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_32: {
    Instruction i = 0x00004162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_34;
    }
  }
  
  
  label_33: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_34: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_35: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_41: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x050001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_46: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_48;
    }
  }
  
  
  label_47: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_49;
  }
  
  
  label_48: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_49: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_50: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_91 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_4;
  }
  
  
  label_2: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_4: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x0000401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_14: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_17: {
    Instruction i = 0x000000ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_18: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_24;
    }
  }
  
  
  label_23: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_24: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_26: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_29;
    }
  }
  
  
  label_28: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_29: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_34: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_35: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x018040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x008000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_41: {
    Instruction i = 0x801b001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_42: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_47;
    }
  }
  
  
  label_46: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_60;
  }
  
  
  label_47: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_52;
    }
  }
  
  
  label_51: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_54;
  }
  
  
  label_52: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_54;
    }
  }
  
  
  label_53: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_54: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_55: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_56: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_58: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_59: {
    Instruction i = 0x8016801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_60: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_62: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_65;
    }
  }
  
  
  label_64: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_80;
  }
  
  
  label_65: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_66: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_67: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_68: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_70;
    }
  }
  
  
  label_69: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_72;
  }
  
  
  label_70: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_72;
    }
  }
  
  
  label_71: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_72: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_73: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_74: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_75: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_76: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_77: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_79: {
    Instruction i = 0x8011801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_80: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_81: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_82: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_83: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_85;
    }
  }
  
  
  label_84: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_100;
  }
  
  
  label_85: {
    Instruction i = 0x050000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_87: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_88: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_90;
    }
  }
  
  
  label_89: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_92;
  }
  
  
  label_90: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_92;
    }
  }
  
  
  label_91: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_92: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_94: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x05800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_96: {
    Instruction i = 0x060001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_97: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_98: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_99: {
    Instruction i = 0x800c801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_100: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_103: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_105;
    }
  }
  
  
  label_104: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_120;
  }
  
  
  label_105: {
    Instruction i = 0x068000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_106: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_107: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_108: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_110;
    }
  }
  
  
  label_109: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_112;
  }
  
  
  label_110: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_112;
    }
  }
  
  
  label_111: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_112: {
    Instruction i = 0x010000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_113: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_115: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_116: {
    Instruction i = 0x078001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_117: {
    Instruction i = 0x028000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_118: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_119: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_120: {
    Instruction i = 0x080000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_121: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_122: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_123: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_125;
    }
  }
  
  
  label_124: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_128;
  }
  
  
  label_125: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_127;
    }
  }
  
  
  label_126: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_127: {
    Instruction i = 0x8005801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_128: {
    Instruction i = 0x088000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_129: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_130: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_131: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_133;
    }
  }
  
  
  label_132: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_136;
  }
  
  
  label_133: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_135;
    }
  }
  
  
  label_134: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_135: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_136: {
    Instruction i = 0x090000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_137: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_138: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_139: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_141;
    }
  }
  
  
  label_140: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_144;
  }
  
  
  label_141: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_143;
    }
  }
  
  
  label_142: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_143: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_144: {
    Instruction i = 0x098000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_145: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_146: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_147: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_149;
    }
  }
  
  
  label_148: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_151;
  }
  
  
  label_149: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_151;
    }
  }
  
  
  label_150: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_151: {
    Instruction i = 0x0a0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_152: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_153: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_154: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_92 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_27;
  }
  
  
  label_10: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x010001a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_27;
  }
  
  
  label_20: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x01804124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x00800103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_26: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_29;
  }
  
  
  label_27: {
    Instruction i = 0x00000103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_29;
    }
  }
  
  
  label_28: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_29: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_93 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x010000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_94 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x08800044;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_1: {
    Instruction i = 0x000004ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x098000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x000044ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x09800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x000084ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_6: {
    Instruction i = 0x09800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x0000c4ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x09800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x000104ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_10: {
    Instruction i = 0x098001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x000144ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x09800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x000184ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x09800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x0001c4ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_16: {
    Instruction i = 0x09800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x000204ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_18: {
    Instruction i = 0x098002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x000244ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_20: {
    Instruction i = 0x09800300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x000284ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_22: {
    Instruction i = 0x09800440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x0002c4ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x09800480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x00000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_26: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_27: {
    Instruction i = 0x000004c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_28: {
    Instruction i = 0x0003052c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_29: {
    Instruction i = 0x0a0004c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x00000504;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_31: {
    Instruction i = 0x0003456c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_32: {
    Instruction i = 0x0a800500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x09800540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_34: {
    Instruction i = 0x00004581;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_35: {
    Instruction i = 0x000385ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_36: {
    Instruction i = 0x01808564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x0a800340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x09800540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_39: {
    Instruction i = 0x00008581;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_40: {
    Instruction i = 0x0003c5ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_41: {
    Instruction i = 0x01808564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x0a800380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x0a000540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x0000c581;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_45: {
    Instruction i = 0x000405ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_46: {
    Instruction i = 0x01808564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x0a8003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x09800540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x00010581;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_50: {
    Instruction i = 0x000445ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_51: {
    Instruction i = 0x01808564;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x0a800400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x09000540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_54: {
    Instruction i = 0x00800565;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_55: {
    Instruction i = 0x00000566;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_56: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_95 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x0000001c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_5: {
    Instruction i = 0x00004003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x00800003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_8: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_96 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x0080005b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RB(i);
    int res = l_isfalse(rb);  /* next assignment may change this value */
    setbvalue(ra, res);
  }
  
  
  label_4: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0040000c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    const TValue *aux;
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobjs2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, aux, luaH_getstr)) {
      setobj2s(L, ra, aux);
    }
    else Protect(luaV_finishget(L, rb, rc, ra, aux));
  }
  
  
  label_7: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x0140408d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_11: {
    Instruction i = 0x02008024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00c0404d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x01800049;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_15: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_97 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0140008c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    const TValue *aux;
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobjs2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, aux, luaH_getstr)) {
      setobj2s(L, ra, aux);
    }
    else Protect(luaV_finishget(L, rb, rc, ra, aux));
  }
  
  
  label_3: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x0240410e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_5: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_6: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x02c0414e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_8: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x0100005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_12: {
    Instruction i = 0x00004083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00c0404e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_17: {
    Instruction i = 0x01000049;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_18: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_98 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400006;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00004041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_99 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_2: {
    Instruction i = 0x0040405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_4: {
    Instruction i = 0x0040805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_6: {
    Instruction i = 0x0040c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_8: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_11: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_100 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_13;
    }
  }
  
  
  label_12: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_13: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_18;
    }
  }
  
  
  label_17: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_18: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_23: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_27: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x00800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_31: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_36;
    }
  }
  
  
  label_35: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_39;
  }
  
  
  label_36: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_37: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_41: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_101 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_14: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x010040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_24;
    }
  }
  
  
  label_23: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_24: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_28: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x0100c05d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_31: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_34: {
    Instruction i = 0x7ffbc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_35: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_44;
  }
  
  
  label_40: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_41: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x0100c05d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_43: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_47;
  }
  
  
  label_44: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x010040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x010000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_51: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_102 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00004081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_17: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x000000c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_20: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_21: {
    Instruction i = 0x020000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x00000104;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_23: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x02800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x00804164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_31: {
    Instruction i = 0x04800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x02800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x0040801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_39: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_43: {
    Instruction i = 0x0040c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_70;
  }
  
  
  label_45: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x00804164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x05800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_50: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x010041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_53: {
    Instruction i = 0x008041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_54: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_55: {
    Instruction i = 0x008081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_58;
    }
  }
  
  
  label_57: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_58: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_59: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_61: {
    Instruction i = 0x00800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x008081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x03000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_64: {
    Instruction i = 0x0040805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_66;
    }
  }
  
  
  label_65: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_69;
  }
  
  
  label_66: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_67: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_68: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_69: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_70: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_72: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_73: {
    Instruction i = 0x05800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_75: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_77: {
    Instruction i = 0x010041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x7ff2401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_79: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_103 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000009;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_12: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x0100c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_26;
  }
  
  
  label_21: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x7ffb001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_7;
  }
  
  
  label_26: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_31: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x0100c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_40: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_43: {
    Instruction i = 0x8000004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_44: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_104 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x018000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_105 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_19: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_30;
  }
  
  
  label_27: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_30: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_39: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_106 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_19: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_30;
  }
  
  
  label_27: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_30: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_39: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_107 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_7;
  }
  
  
  label_5: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x0900004b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_9: {
    Instruction i = 0x000040c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_10: {
    Instruction i = 0x00008101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_11: {
    Instruction i = 0x0000c141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_12: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_13: {
    Instruction i = 0x000141c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_14: {
    Instruction i = 0x00018201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_15: {
    Instruction i = 0x0001c241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_16: {
    Instruction i = 0x00020281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_17: {
    Instruction i = 0x000242c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_18: {
    Instruction i = 0x00028301;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_19: {
    Instruction i = 0x0002c341;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_20: {
    Instruction i = 0x00030381;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_21: {
    Instruction i = 0x000343c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_22: {
    Instruction i = 0x00038401;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_23: {
    Instruction i = 0x0003c441;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_24: {
    Instruction i = 0x00040481;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_25: {
    Instruction i = 0x000444c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_26: {
    Instruction i = 0x00048501;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_27: {
    Instruction i = 0x0980406b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_28: {
    Instruction i = 0x0004c081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_29: {
    Instruction i = 0x008000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_30: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_32;
    }
  }
  
  
  label_31: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_40;
  }
  
  
  label_32: {
    Instruction i = 0x014500cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_33: {
    Instruction i = 0x0080c0c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_34: {
    Instruction i = 0x0000c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_36;
    }
  }
  
  
  label_35: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_38;
  }
  
  
  label_36: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_38;
    }
  }
  
  
  label_37: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_38: {
    Instruction i = 0x0145008d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_39: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_29;
  }
  
  
  label_40: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_42;
    }
  }
  
  
  label_41: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_108 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00804024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x0400000b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x038001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x04000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0400402b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_12: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_13: {
    Instruction i = 0x0000009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_14: {
    Instruction i = 0x00808020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_24;
  }
  
  
  label_16: {
    Instruction i = 0x00c0408d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_17: {
    Instruction i = 0x00008087;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_18: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x0140805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_21: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x00c0404d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_23: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_24: {
    Instruction i = 0x04800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x00800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_27: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_109 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_110 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_11: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_20: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_28: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x03800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_46;
  }
  
  
  label_39: {
    Instruction i = 0x040000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x03800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_46;
    }
  }
  
  
  label_45: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_49;
  }
  
  
  label_46: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_47: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_48: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_49: {
    Instruction i = 0x048000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_51: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_52: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_53: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_54: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x000000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_57: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_58: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_111 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_112 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_11: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_20: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_28: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x03800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_39: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x03000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_47: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_48: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_50;
    }
  }
  
  
  label_49: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_57;
  }
  
  
  label_50: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_51: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_54: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_55: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_57;
    }
  }
  
  
  label_56: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_60;
  }
  
  
  label_57: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_58: {
    Instruction i = 0x00800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_59: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_60: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_64: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_66: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x050001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x01800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x00000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_71: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_72: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_113 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x0140001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_8;
  }
  
  
  label_5: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_8: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_114 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_10: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_115 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_116 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_117 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000016c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x000041ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0240001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_10: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x01800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x02000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_118 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_119 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_120 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_10: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_121 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_122 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_123 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0b000044;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_1: {
    Instruction i = 0x0000062c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x0c0000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x0000462c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x0c000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x0000862c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_6: {
    Instruction i = 0x0c000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x0000c62c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x0c000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x0001062c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_10: {
    Instruction i = 0x0c0001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x0001462c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_12: {
    Instruction i = 0x0c000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x0001862c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_14: {
    Instruction i = 0x0c000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x0001c62c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_16: {
    Instruction i = 0x0c000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x0002062c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_18: {
    Instruction i = 0x0c0002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x0002462c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_20: {
    Instruction i = 0x0c000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x0002862c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_22: {
    Instruction i = 0x0c000440;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x0002c62c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x0c000480;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x0003062c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_26: {
    Instruction i = 0x0c0004c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x0003462c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_28: {
    Instruction i = 0x0c000500;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x0003862c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_30: {
    Instruction i = 0x0c000540;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x0003c62c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_32: {
    Instruction i = 0x0c000580;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x0004062c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_34: {
    Instruction i = 0x0c0005c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x00000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_37: {
    Instruction i = 0x00000604;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_38: {
    Instruction i = 0x0004466c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_39: {
    Instruction i = 0x0c800600;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x00000644;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_41: {
    Instruction i = 0x000486ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_42: {
    Instruction i = 0x0d000640;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x0c000680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x000046c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_45: {
    Instruction i = 0x0004c72c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_46: {
    Instruction i = 0x018086a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x0d000340;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_48: {
    Instruction i = 0x0c000680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x000086c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_50: {
    Instruction i = 0x0005072c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_51: {
    Instruction i = 0x018086a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x0d000380;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x0c800680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_54: {
    Instruction i = 0x0000c6c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_55: {
    Instruction i = 0x0005472c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_56: {
    Instruction i = 0x018086a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_57: {
    Instruction i = 0x0d0003c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_58: {
    Instruction i = 0x0c000680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_59: {
    Instruction i = 0x000106c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_60: {
    Instruction i = 0x0005872c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_61: {
    Instruction i = 0x018086a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_62: {
    Instruction i = 0x0d000400;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x09000680;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_64: {
    Instruction i = 0x008006a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_65: {
    Instruction i = 0x000006a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_66: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_124 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x0000001c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_2: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_5: {
    Instruction i = 0x00004003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x00800003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_8: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_125 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x0080005b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RB(i);
    int res = l_isfalse(rb);  /* next assignment may change this value */
    setbvalue(ra, res);
  }
  
  
  label_4: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x0040000c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    const TValue *aux;
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobjs2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, aux, luaH_getstr)) {
      setobj2s(L, ra, aux);
    }
    else Protect(luaV_finishget(L, rb, rc, ra, aux));
  }
  
  
  label_7: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x0140408d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01c040cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_11: {
    Instruction i = 0x02008024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00c0404d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_14: {
    Instruction i = 0x01800049;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_15: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_126 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0140008c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    const TValue *aux;
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    TString *key = tsvalue(rc);  /* key must be a string */
    setobjs2s(L, ra + 1, rb);
    if (luaV_fastget(L, rb, key, aux, luaH_getstr)) {
      setobj2s(L, ra, aux);
    }
    else Protect(luaV_finishget(L, rb, rc, ra, aux));
  }
  
  
  label_3: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x0240410e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_5: {
    Instruction i = 0x0240410d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_6: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x02c0414e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_8: {
    Instruction i = 0x02c0414d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_9: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x0100005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_12: {
    Instruction i = 0x00004083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00c0404e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(-, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numsub(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
  }
  
  
  label_17: {
    Instruction i = 0x01000049;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_18: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_127 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00400006;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *upval = cl->upvals[GETARG_B(i)]->v;
    TValue *rc = RKC(i);
    gettableProtected(L, upval, rc, ra);
  }
  
  
  label_1: {
    Instruction i = 0x00004041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_128 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_2: {
    Instruction i = 0x0040405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_4: {
    Instruction i = 0x0040805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_6: {
    Instruction i = 0x0040c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_8: {
    Instruction i = 0x00004043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_11: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_129 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_13;
    }
  }
  
  
  label_12: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_13: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_18;
    }
  }
  
  
  label_17: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_18: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_23: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_27: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x00800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_31: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x00004062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_36;
    }
  }
  
  
  label_35: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_39;
  }
  
  
  label_36: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_37: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x00800043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_41;
    }
  }
  
  
  label_40: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_41: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_130 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_14;
    }
  }
  
  
  label_13: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_14: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x010040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_24;
    }
  }
  
  
  label_23: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_24: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_28: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_29: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x0100c05d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_31: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_34: {
    Instruction i = 0x7ffbc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_19;
  }
  
  
  label_35: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_36: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_44;
  }
  
  
  label_40: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_41: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x0100c05d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_43: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_47;
  }
  
  
  label_44: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x010040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_49: {
    Instruction i = 0x010000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_51: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_131 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00004081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_17: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_19: {
    Instruction i = 0x000000c4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_20: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_21: {
    Instruction i = 0x020000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_22: {
    Instruction i = 0x00000104;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_23: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_24: {
    Instruction i = 0x02800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x00804164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_27: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_31: {
    Instruction i = 0x04800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x02800000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_37: {
    Instruction i = 0x0040801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_39: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_43: {
    Instruction i = 0x0040c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_70;
  }
  
  
  label_45: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x00804164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x05800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_49: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_50: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_51: {
    Instruction i = 0x010041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_52: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_53: {
    Instruction i = 0x008041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_54: {
    Instruction i = 0x00000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_55: {
    Instruction i = 0x008081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_58;
    }
  }
  
  
  label_57: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_58: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_59: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_61: {
    Instruction i = 0x00800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x008081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_63: {
    Instruction i = 0x03000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_64: {
    Instruction i = 0x0040805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_66;
    }
  }
  
  
  label_65: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_69;
  }
  
  
  label_66: {
    Instruction i = 0x04800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_67: {
    Instruction i = 0x008001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_68: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_69: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_70: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_72: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_73: {
    Instruction i = 0x05800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_74: {
    Instruction i = 0x00808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_75: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_77: {
    Instruction i = 0x010041a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x7ff2401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_79: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_132 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x0080801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000009;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    UpVal *uv = cl->upvals[GETARG_B(i)];
    setobj(L, uv->v, ra);
    luaC_upvalbarrier(L, uv);
  }
  
  
  label_5: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_9: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_10: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_12: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x0100c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_26;
  }
  
  
  label_21: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_22: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_23: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x01800040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x7ffb001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_7;
  }
  
  
  label_26: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_28: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_31: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x0100c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_40: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_43: {
    Instruction i = 0x8000004a;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    settableProtected(L, ra, rb, rc);
  }
  
  
  label_44: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_133 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x018000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_134 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_19: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_30;
  }
  
  
  label_27: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_30: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_39: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_135 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0040005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_15;
  }
  
  
  label_10: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_15: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_17: {
    Instruction i = 0x00c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_19;
    }
  }
  
  
  label_18: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_19: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_27;
    }
  }
  
  
  label_26: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_30;
  }
  
  
  label_27: {
    Instruction i = 0x02000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_30: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_31: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_39: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_136 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_7;
  }
  
  
  label_5: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_7;
    }
  }
  
  
  label_6: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_7: {
    Instruction i = 0x0900004b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_8: {
    Instruction i = 0x00000081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_9: {
    Instruction i = 0x000040c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_10: {
    Instruction i = 0x00008101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_11: {
    Instruction i = 0x0000c141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_12: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_13: {
    Instruction i = 0x000141c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_14: {
    Instruction i = 0x00018201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_15: {
    Instruction i = 0x0001c241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_16: {
    Instruction i = 0x00020281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_17: {
    Instruction i = 0x000242c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_18: {
    Instruction i = 0x00028301;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_19: {
    Instruction i = 0x0002c341;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_20: {
    Instruction i = 0x00030381;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_21: {
    Instruction i = 0x000343c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_22: {
    Instruction i = 0x00038401;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_23: {
    Instruction i = 0x0003c441;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_24: {
    Instruction i = 0x00040481;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_25: {
    Instruction i = 0x000444c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_26: {
    Instruction i = 0x00048501;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_27: {
    Instruction i = 0x0980406b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_28: {
    Instruction i = 0x0004c081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_29: {
    Instruction i = 0x008000dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_30: {
    Instruction i = 0x0100c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_32;
    }
  }
  
  
  label_31: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_40;
  }
  
  
  label_32: {
    Instruction i = 0x014500cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_33: {
    Instruction i = 0x0080c0c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_34: {
    Instruction i = 0x0000c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_36;
    }
  }
  
  
  label_35: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_38;
  }
  
  
  label_36: {
    Instruction i = 0x000000c3;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_38;
    }
  }
  
  
  label_37: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_38: {
    Instruction i = 0x0145008d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_39: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_29;
  }
  
  
  label_40: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_42;
    }
  }
  
  
  label_41: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_137 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00804024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x0400000b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x02800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_8: {
    Instruction i = 0x03000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x038001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x04000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x0400402b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_12: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_13: {
    Instruction i = 0x0000009c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_14: {
    Instruction i = 0x00808020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_24;
  }
  
  
  label_16: {
    Instruction i = 0x00c0408d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_17: {
    Instruction i = 0x00008087;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_18: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x0140805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_22;
  }
  
  
  label_21: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_22: {
    Instruction i = 0x00c0404d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_23: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_24: {
    Instruction i = 0x04800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x00800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_27: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_138 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0040001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_2: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_3: {
    Instruction i = 0x00800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_139 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x0000001b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RB(i);
    int res = l_isfalse(rb);  /* next assignment may change this value */
    setbvalue(ra, res);
  }
  
  
  label_3: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_4: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_140 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_2: {
    Instruction i = 0x008000a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_4: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x0100005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_10;
  }
  
  
  label_9: {
    Instruction i = 0x00004083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x00800083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_12;
    }
  }
  
  
  label_11: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_141 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00800004;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_1: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x01000000;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x000040ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x05800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_11;
  }
  
  
  label_9: {
    Instruction i = 0x00000083;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_11: {
    Instruction i = 0x06000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x0140001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x8007401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_45;
  }
  
  
  label_15: {
    Instruction i = 0x0c0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x0c800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00800124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x000040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_19: {
    Instruction i = 0x060000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_20: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x01c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_34;
  }
  
  
  label_23: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_24: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_25: {
    Instruction i = 0x06800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x0d000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x068001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x0d800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x02000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_30: {
    Instruction i = 0x018001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_31: {
    Instruction i = 0x00000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_32: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_33: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_37;
  }
  
  
  label_34: {
    Instruction i = 0x0a000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x01004124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_38: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_39: {
    Instruction i = 0x06800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x0d000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x01800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_44: {
    Instruction i = 0x801a001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_150;
  }
  
  
  label_45: {
    Instruction i = 0x0140801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_47;
    }
  }
  
  
  label_46: {
    Instruction i = 0x800d401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_101;
  }
  
  
  label_47: {
    Instruction i = 0x0c0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x0c800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_49: {
    Instruction i = 0x00800124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_50: {
    Instruction i = 0x000040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_51: {
    Instruction i = 0x060000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_53: {
    Instruction i = 0x01c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_55;
    }
  }
  
  
  label_54: {
    Instruction i = 0x8004801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_74;
  }
  
  
  label_55: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_56: {
    Instruction i = 0x0000c141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_57: {
    Instruction i = 0x01004124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_58: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_59: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x06800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x068001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_63: {
    Instruction i = 0x0d000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x06800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x07800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_66: {
    Instruction i = 0x080002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_67: {
    Instruction i = 0x02000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_68: {
    Instruction i = 0x02000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_69: {
    Instruction i = 0x000081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x0e000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x02000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_72: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_73: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_92;
  }
  
  
  label_74: {
    Instruction i = 0x01c0c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_76;
    }
  }
  
  
  label_75: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_89;
  }
  
  
  label_76: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_77: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_78: {
    Instruction i = 0x06800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_79: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_80: {
    Instruction i = 0x068001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_81: {
    Instruction i = 0x07800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_82: {
    Instruction i = 0x08000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_83: {
    Instruction i = 0x02000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_84: {
    Instruction i = 0x020081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_85: {
    Instruction i = 0x0e000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x02000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_87: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_88: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_92;
  }
  
  
  label_89: {
    Instruction i = 0x0a000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_90: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_91: {
    Instruction i = 0x01004124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_92: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_94: {
    Instruction i = 0x06800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_95: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_96: {
    Instruction i = 0x020001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_97: {
    Instruction i = 0x0e000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_98: {
    Instruction i = 0x02000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_99: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_100: {
    Instruction i = 0x800c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_150;
  }
  
  
  label_101: {
    Instruction i = 0x0140401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_103;
    }
  }
  
  
  label_102: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_111;
  }
  
  
  label_103: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_104: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_105: {
    Instruction i = 0x06800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_106: {
    Instruction i = 0x0d800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_107: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_108: {
    Instruction i = 0x01800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_109: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_110: {
    Instruction i = 0x8009801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_150;
  }
  
  
  label_111: {
    Instruction i = 0x0141001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_113;
    }
  }
  
  
  label_112: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_123;
  }
  
  
  label_113: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_114: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_115: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_116: {
    Instruction i = 0x00014141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_117: {
    Instruction i = 0x01004124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_118: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_120: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_121: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_122: {
    Instruction i = 0x8006801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_150;
  }
  
  
  label_123: {
    Instruction i = 0x0141801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_125;
    }
  }
  
  
  label_124: {
    Instruction i = 0x8002c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_137;
  }
  
  
  label_125: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_126: {
    Instruction i = 0x00008101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_127: {
    Instruction i = 0x010040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_128: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_129: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_130: {
    Instruction i = 0x06800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_131: {
    Instruction i = 0x07000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_132: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_133: {
    Instruction i = 0x080001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_134: {
    Instruction i = 0x02000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_135: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_136: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_150;
  }
  
  
  label_137: {
    Instruction i = 0x0a0000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_138: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_139: {
    Instruction i = 0x010040e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_140: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_141: {
    Instruction i = 0x008080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_142: {
    Instruction i = 0x01c1c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_144;
    }
  }
  
  
  label_143: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_146;
  }
  
  
  label_144: {
    Instruction i = 0x00000103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_146;
    }
  }
  
  
  label_145: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_146: {
    Instruction i = 0x00800100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_147: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_148: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_149: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_150: {
    Instruction i = 0x0b8000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_151: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_152: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_153: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_142 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x0040001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_2;
    }
  }
  
  
  label_1: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_3;
  }
  
  
  label_2: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x00000044;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_4: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_5: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_8;
    }
  }
  
  
  label_7: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_21;
  }
  
  
  label_8: {
    Instruction i = 0x0480008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_9: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x028001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x04000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x048002c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_18: {
    Instruction i = 0x048040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_19: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_21;
    }
  }
  
  
  label_20: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_21: {
    Instruction i = 0x0400008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_22: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_25: {
    Instruction i = 0x02800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x030001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x03800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_28: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x04800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_30: {
    Instruction i = 0x040040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_31: {
    Instruction i = 0x000040c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_32: {
    Instruction i = 0x0100011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_33: {
    Instruction i = 0x01810020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_35;
    }
  }
  
  
  label_34: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_35: {
    Instruction i = 0x01c0810d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_36: {
    Instruction i = 0x01010107;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_37: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x0240c05f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_41;
  }
  
  
  label_40: {
    Instruction i = 0x01000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_41: {
    Instruction i = 0x01c080cd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_42: {
    Instruction i = 0x7ffd001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_32;
  }
  
  
  label_43: {
    Instruction i = 0x058000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_44: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_46: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_143 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00000041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_2: {
    Instruction i = 0x01004024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00004081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_7: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_9: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_144 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_5;
  }
  
  
  label_4: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_5: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_9;
    }
  }
  
  
  label_8: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_24;
  }
  
  
  label_9: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_10: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_11: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x02800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x018001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_16: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x02008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_20: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_21: {
    Instruction i = 0x020000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x8015401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_24: {
    Instruction i = 0x00c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_35;
  }
  
  
  label_26: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_28: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_30: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_32: {
    Instruction i = 0x020000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_33: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_34: {
    Instruction i = 0x8012801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_35: {
    Instruction i = 0x00c0801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_37;
    }
  }
  
  
  label_36: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_43;
  }
  
  
  label_37: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_38: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_39: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_40: {
    Instruction i = 0x018000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x8010801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_43: {
    Instruction i = 0x00c0c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_45;
    }
  }
  
  
  label_44: {
    Instruction i = 0x8003c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_45: {
    Instruction i = 0x01000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x008080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_48: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_49: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x02800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_51: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x00000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x03000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_54: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_55: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_56: {
    Instruction i = 0x02008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_57: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_58: {
    Instruction i = 0x020000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_59: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_60: {
    Instruction i = 0x800c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_61: {
    Instruction i = 0x00c1001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_63;
    }
  }
  
  
  label_62: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_73;
  }
  
  
  label_63: {
    Instruction i = 0x01800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x020000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_66: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_67: {
    Instruction i = 0x03800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x000001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x01800164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x000000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_71: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_72: {
    Instruction i = 0x8009001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_73: {
    Instruction i = 0x00c1401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_75;
    }
  }
  
  
  label_74: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_106;
  }
  
  
  label_75: {
    Instruction i = 0x0080008b;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    Table *t = luaH_new(L);
    sethvalue(L, ra, t);
    if (b != 0 || c != 0)
      luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
    checkGC(L, ra + 1);
  }
  
  
  label_76: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_77: {
    Instruction i = 0x008040ab;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int n = GETARG_B(i);
    int c = GETARG_C(i);
    unsigned int last;
    Table *h;
    if (n == 0) n = cast_int(L->top - ra) - 1;
    if (c == 0) {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
      c = GETARG_Ax(*ci->u.l.savedpc++);
    }
    h = hvalue(ra);
    last = ((c-1)*LFIELDS_PER_FLUSH) + n;
    if (last > h->sizearray)  /* needs more space? */
      luaH_resizearray(L, h, last);  /* preallocate it at once */
    for (; n > 0; n--) {
      TValue *val = ra+n;
      luaH_setint(L, h, last--, val);
      luaC_barrierback(L, h, val);
    }
    L->top = ci->top;  /* correct top (in case of previous open call) */
  }
  
  
  label_78: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_79: {
    Instruction i = 0x00800103;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_81;
    }
  }
  
  
  label_80: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_81: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_82: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_83: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_84: {
    Instruction i = 0x01804124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_85: {
    Instruction i = 0x00000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_87: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_89;
    }
  }
  
  
  label_88: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_98;
  }
  
  
  label_89: {
    Instruction i = 0x00800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_90: {
    Instruction i = 0x00808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_91: {
    Instruction i = 0x0241405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_93;
    }
  }
  
  
  label_92: {
    Instruction i = 0x7ffc001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_78;
  }
  
  
  label_93: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_94: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x01004164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_96: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_98;
  }
  
  
  label_97: {
    Instruction i = 0x7ffac01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_78;
  }
  
  
  label_98: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_99: {
    Instruction i = 0x05800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_100: {
    Instruction i = 0x06000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_102: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_103: {
    Instruction i = 0x000000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_104: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_105: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_110;
  }
  
  
  label_106: {
    Instruction i = 0x05000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_107: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_108: {
    Instruction i = 0x010040a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_109: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_110: {
    Instruction i = 0x06800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_111: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_112: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_113: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_145 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x0040001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x01008064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x00000062;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_12;
  }
  
  
  label_11: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_12: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x01000065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_146 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_147 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_11: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_20: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_28: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x03800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000000e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_46;
  }
  
  
  label_39: {
    Instruction i = 0x040000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x03800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_41: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_42: {
    Instruction i = 0x01000124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_43: {
    Instruction i = 0x000080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_46;
    }
  }
  
  
  label_45: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_49;
  }
  
  
  label_46: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_47: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_48: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_49: {
    Instruction i = 0x048000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x05000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_51: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_52: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_53: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_54: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_55: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_56: {
    Instruction i = 0x000000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_57: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_58: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_148 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_1: {
    Instruction i = 0x010000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_2: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_149 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x00000022;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_4;
    }
  }
  
  
  label_3: {
    Instruction i = 0x8000401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_6;
  }
  
  
  label_4: {
    Instruction i = 0x00000003;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_6;
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_6: {
    Instruction i = 0x00800005;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_7: {
    Instruction i = 0x00808024;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x01000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x0000405f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_11;
    }
  }
  
  
  label_10: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_16;
  }
  
  
  label_11: {
    Instruction i = 0x01800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_12: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_13: {
    Instruction i = 0x01004064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_14: {
    Instruction i = 0x00000043;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setbvalue(ra, GETARG_B(i));
    if (GETARG_C(i)) { /* skip next instruction (if C) */
      ci->u.l.savedpc++;
      goto label_16;
    }
  }
  
  
  label_15: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_16: {
    Instruction i = 0x02000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_17: {
    Instruction i = 0x00808064;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_23;
  }
  
  
  label_20: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_22: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_23: {
    Instruction i = 0x03000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_24: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_25: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_26: {
    Instruction i = 0x000040a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_28;
    }
  }
  
  
  label_27: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_31;
  }
  
  
  label_28: {
    Instruction i = 0x02800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_29: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_30: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_31: {
    Instruction i = 0x03800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_32: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_33: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_34: {
    Instruction i = 0x030000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_36: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x000040e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_39;
    }
  }
  
  
  label_38: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_42;
  }
  
  
  label_39: {
    Instruction i = 0x028000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_41: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_42: {
    Instruction i = 0x038000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_43: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_44: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_45: {
    Instruction i = 0x03000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_46: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_47: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_48: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_50;
    }
  }
  
  
  label_49: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_57;
  }
  
  
  label_50: {
    Instruction i = 0x04000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_51: {
    Instruction i = 0x03800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x01800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_53: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_54: {
    Instruction i = 0x00008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_55: {
    Instruction i = 0x00004122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_57;
    }
  }
  
  
  label_56: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_60;
  }
  
  
  label_57: {
    Instruction i = 0x02800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_58: {
    Instruction i = 0x00800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_59: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_60: {
    Instruction i = 0x04800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_61: {
    Instruction i = 0x05000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_62: {
    Instruction i = 0x00800180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_63: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_64: {
    Instruction i = 0x05000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_65: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_66: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_67: {
    Instruction i = 0x050001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_68: {
    Instruction i = 0x01800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_69: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_70: {
    Instruction i = 0x00000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_71: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_72: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_150 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x0140001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_8;
  }
  
  
  label_5: {
    Instruction i = 0x008000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x008000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_8: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_9: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_10: {
    Instruction i = 0x00800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_11: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_151 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_10: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_152 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_153 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_154 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x000000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000016c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x000041ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x0240001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_10;
    }
  }
  
  
  label_9: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_13;
  }
  
  
  label_10: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_12: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_13: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_14: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_15: {
    Instruction i = 0x008001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_16: {
    Instruction i = 0x01800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_17: {
    Instruction i = 0x02000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_18: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_19: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_155 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_156 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_157 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x0000012c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_3: {
    Instruction i = 0x0000416c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_4: {
    Instruction i = 0x020080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_5: {
    Instruction i = 0x010000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_8: {
    Instruction i = 0x018000e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_9: {
    Instruction i = 0x000000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_10: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_158 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_1: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_159 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x008000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_2: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_3: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_160 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000044;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_1: {
    Instruction i = 0x000000ac;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_2: {
    Instruction i = 0x01000040;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_3: {
    Instruction i = 0x09000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_4: {
    Instruction i = 0x080000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_5: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_6: {
    Instruction i = 0x010000e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_7: {
    Instruction i = 0x000080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x000000c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_9: {
    Instruction i = 0x00000101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_10: {
    Instruction i = 0x09800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_13: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_15;
    }
  }
  
  
  label_14: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_18;
  }
  
  
  label_15: {
    Instruction i = 0x00004141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_16: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_17: {
    Instruction i = 0x803a001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_18: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_19: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_20: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_21: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_23;
    }
  }
  
  
  label_22: {
    Instruction i = 0x8009c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_63;
  }
  
  
  label_23: {
    Instruction i = 0x000080c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_24: {
    Instruction i = 0x00000101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_25: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_26: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_27: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_28: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_30;
    }
  }
  
  
  label_29: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_44;
  }
  
  
  label_30: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_31: {
    Instruction i = 0x02000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_32: {
    Instruction i = 0x0a0001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_33: {
    Instruction i = 0x05000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_34: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_35: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_36: {
    Instruction i = 0x000081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_37: {
    Instruction i = 0x0281c0dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_38: {
    Instruction i = 0x0000c101;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_39: {
    Instruction i = 0x04800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_40: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_41: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_42: {
    Instruction i = 0x02800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x7ffb001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_25;
  }
  
  
  label_44: {
    Instruction i = 0x09800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_45: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_46: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_47: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_49;
    }
  }
  
  
  label_48: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_53;
  }
  
  
  label_49: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_50: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_51: {
    Instruction i = 0x028180dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_52: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_61;
  }
  
  
  label_53: {
    Instruction i = 0x01800140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_54: {
    Instruction i = 0x00014181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_55: {
    Instruction i = 0x0a0001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_56: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_57: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_58: {
    Instruction i = 0x0301c19d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_59: {
    Instruction i = 0x000101c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_60: {
    Instruction i = 0x0281c0dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_61: {
    Instruction i = 0x010000e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_62: {
    Instruction i = 0x802ec01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_63: {
    Instruction i = 0x0a800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_64: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_65: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_66: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_68;
    }
  }
  
  
  label_67: {
    Instruction i = 0x800a001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_109;
  }
  
  
  label_68: {
    Instruction i = 0x0b000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_69: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_70: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_71: {
    Instruction i = 0x0b800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_72: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_73: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_74: {
    Instruction i = 0x018001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_75: {
    Instruction i = 0x03000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_76: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_77: {
    Instruction i = 0x03c1805f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_79;
    }
  }
  
  
  label_78: {
    Instruction i = 0x8004c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_99;
  }
  
  
  label_79: {
    Instruction i = 0x0380021c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_80: {
    Instruction i = 0x0441c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_82;
    }
  }
  
  
  label_81: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_99;
  }
  
  
  label_82: {
    Instruction i = 0x02000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_83: {
    Instruction i = 0x02800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_84: {
    Instruction i = 0x0c000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_85: {
    Instruction i = 0x01808224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_86: {
    Instruction i = 0x00000222;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_88;
    }
  }
  
  
  label_87: {
    Instruction i = 0x8002801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_99;
  }
  
  
  label_88: {
    Instruction i = 0x02000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_89: {
    Instruction i = 0x03c20247;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_90: {
    Instruction i = 0x07000285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_91: {
    Instruction i = 0x01808224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_92: {
    Instruction i = 0x00000222;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_94;
    }
  }
  
  
  label_93: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_99;
  }
  
  
  label_94: {
    Instruction i = 0x00800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_95: {
    Instruction i = 0x03c1c247;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_96: {
    Instruction i = 0x00024281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_97: {
    Instruction i = 0x01800225;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_98: {
    Instruction i = 0x00000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_99: {
    Instruction i = 0x00028201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_100: {
    Instruction i = 0x0a000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_101: {
    Instruction i = 0x0c800285;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_102: {
    Instruction i = 0x028002c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_103: {
    Instruction i = 0x03000300;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_104: {
    Instruction i = 0x018002a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_105: {
    Instruction i = 0x00008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_106: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_107: {
    Instruction i = 0x01000226;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_108: {
    Instruction i = 0x8023401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_109: {
    Instruction i = 0x0d000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_110: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_111: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_112: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_114;
    }
  }
  
  
  label_113: {
    Instruction i = 0x8003401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_128;
  }
  
  
  label_114: {
    Instruction i = 0x0002c141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_115: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_116: {
    Instruction i = 0x0c8001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_117: {
    Instruction i = 0x0d800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_118: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_120: {
    Instruction i = 0x0e000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_121: {
    Instruction i = 0x01000280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_122: {
    Instruction i = 0x01000264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_123: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_124: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_125: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_126: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_127: {
    Instruction i = 0x801e801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_128: {
    Instruction i = 0x00000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_129: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_130: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_131: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_133;
    }
  }
  
  
  label_132: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_138;
  }
  
  
  label_133: {
    Instruction i = 0x00800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_134: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_135: {
    Instruction i = 0x01000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_136: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_137: {
    Instruction i = 0x801c001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_138: {
    Instruction i = 0x0e800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_139: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_140: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_141: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_143;
    }
  }
  
  
  label_142: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_164;
  }
  
  
  label_143: {
    Instruction i = 0x00030141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_144: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_145: {
    Instruction i = 0x0f0001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_146: {
    Instruction i = 0x0f800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_147: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_148: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_149: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_150: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_151: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_152: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_153: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_154: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_155: {
    Instruction i = 0x100001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_156: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_157: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_158: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_159: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_160: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_161: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_162: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_163: {
    Instruction i = 0x8015801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_164: {
    Instruction i = 0x10800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_165: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_166: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_167: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_169;
    }
  }
  
  
  label_168: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_190;
  }
  
  
  label_169: {
    Instruction i = 0x00034141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_170: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_171: {
    Instruction i = 0x110001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_172: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_173: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_174: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_175: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_176: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_177: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_178: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_179: {
    Instruction i = 0x118001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_180: {
    Instruction i = 0x12000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_181: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_182: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_183: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_184: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_185: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_186: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_187: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_188: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_189: {
    Instruction i = 0x800f001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_190: {
    Instruction i = 0x12800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_191: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_192: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_193: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_195;
    }
  }
  
  
  label_194: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_226;
  }
  
  
  label_195: {
    Instruction i = 0x00038141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_196: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_197: {
    Instruction i = 0x0f0001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_198: {
    Instruction i = 0x13000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_199: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_200: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_201: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_202: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_203: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_204: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_205: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_206: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_207: {
    Instruction i = 0x138001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_208: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_209: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_210: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_211: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_212: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_213: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_214: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_215: {
    Instruction i = 0x118001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_216: {
    Instruction i = 0x14000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_217: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_218: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_219: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_220: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_221: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_222: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_223: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_224: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_225: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_226: {
    Instruction i = 0x14800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_227: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_228: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_229: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_231;
    }
  }
  
  
  label_230: {
    Instruction i = 0x8004c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_251;
  }
  
  
  label_231: {
    Instruction i = 0x0003c141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_232: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_233: {
    Instruction i = 0x150001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_234: {
    Instruction i = 0x01000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_235: {
    Instruction i = 0x010001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_236: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_237: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_238: {
    Instruction i = 0x0000c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_239: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_240: {
    Instruction i = 0x0a000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_241: {
    Instruction i = 0x118001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_242: {
    Instruction i = 0x15800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_243: {
    Instruction i = 0x01000240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_244: {
    Instruction i = 0x01000224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_245: {
    Instruction i = 0x000001e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_246: {
    Instruction i = 0x000081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_247: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_248: {
    Instruction i = 0x00010181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_249: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_250: {
    Instruction i = 0x01000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_251: {
    Instruction i = 0x01000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_252: {
    Instruction i = 0x00800165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_253: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_254: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_161 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_2: {
    Instruction i = 0x010080a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_3: {
    Instruction i = 0x000000a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_5;
    }
  }
  
  
  label_4: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_9;
  }
  
  
  label_5: {
    Instruction i = 0x00800085;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_6: {
    Instruction i = 0x000000c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_7: {
    Instruction i = 0x010000a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_8: {
    Instruction i = 0x000000a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_9: {
    Instruction i = 0x00000084;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    do {
      setnilvalue(ra++);
    } while (b--);
  }
  
  
  label_10: {
    Instruction i = 0x000000ec;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Proto *p = cl->p->p[GETARG_Bx(i)];
    LClosure *ncl = luaV_getcached(p, cl->upvals, base);  /* cached closure*/
    if (ncl == NULL)  /* no match? */
      luaV_pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
    else
      setclLvalue(L, ra, ncl);  /* push cashed closure */
    checkGC(L, ra + 1);
  }
  
  
  label_11: {
    Instruction i = 0x01800080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_12: {
    Instruction i = 0x018000c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_13: {
    Instruction i = 0x00000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_14: {
    Instruction i = 0x010080e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_15: {
    Instruction i = 0x01c0005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_17;
    }
  }
  
  
  label_16: {
    Instruction i = 0x8036801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_236;
  }
  
  
  label_17: {
    Instruction i = 0x0180011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_18: {
    Instruction i = 0x0240401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_20;
    }
  }
  
  
  label_19: {
    Instruction i = 0x8035c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_236;
  }
  
  
  label_20: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_21: {
    Instruction i = 0x01c08147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_22: {
    Instruction i = 0x02800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_23: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_24: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_26;
    }
  }
  
  
  label_25: {
    Instruction i = 0x8034401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_236;
  }
  
  
  label_26: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_27: {
    Instruction i = 0x01c0c147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_28: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_29: {
    Instruction i = 0x0240005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_31;
    }
  }
  
  
  label_30: {
    Instruction i = 0x8017c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_31: {
    Instruction i = 0x0200015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_32: {
    Instruction i = 0x02c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_34;
    }
  }
  
  
  label_33: {
    Instruction i = 0x8017001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_34: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_35: {
    Instruction i = 0x02408187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_36: {
    Instruction i = 0x030001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_37: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_38: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_40;
    }
  }
  
  
  label_39: {
    Instruction i = 0x8015801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_40: {
    Instruction i = 0x0240c147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_41: {
    Instruction i = 0x01800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_42: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_43: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_44: {
    Instruction i = 0x0340005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_46;
    }
  }
  
  
  label_45: {
    Instruction i = 0x8005c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_70;
  }
  
  
  label_46: {
    Instruction i = 0x030001dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_47: {
    Instruction i = 0x03c0801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_49;
    }
  }
  
  
  label_48: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_70;
  }
  
  
  label_49: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_50: {
    Instruction i = 0x02404207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_51: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_52: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_53: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_55;
    }
  }
  
  
  label_54: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_70;
  }
  
  
  label_55: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_56: {
    Instruction i = 0x04000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_57: {
    Instruction i = 0x03408247;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_58: {
    Instruction i = 0x00010281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_59: {
    Instruction i = 0x01808224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_60: {
    Instruction i = 0x00014241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_61: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_62: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_63: {
    Instruction i = 0x01c04287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_64: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_65: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_66: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_67: {
    Instruction i = 0x010001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_68: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_69: {
    Instruction i = 0x800e001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_70: {
    Instruction i = 0x048001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_71: {
    Instruction i = 0x02800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_72: {
    Instruction i = 0x010081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_73: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_75;
    }
  }
  
  
  label_74: {
    Instruction i = 0x8007801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_106;
  }
  
  
  label_75: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_76: {
    Instruction i = 0x05000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_77: {
    Instruction i = 0x02800240;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_78: {
    Instruction i = 0x01008224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_79: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_80: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_81: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_83;
    }
  }
  
  
  label_82: {
    Instruction i = 0x8005801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_106;
  }
  
  
  label_83: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_84: {
    Instruction i = 0x02404207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_85: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_86: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_87: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_89;
    }
  }
  
  
  label_88: {
    Instruction i = 0x8004001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_106;
  }
  
  
  label_89: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_90: {
    Instruction i = 0x04000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_91: {
    Instruction i = 0x05800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_92: {
    Instruction i = 0x02800280;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_93: {
    Instruction i = 0x01008264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_94: {
    Instruction i = 0x00010281;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_95: {
    Instruction i = 0x01808224;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_96: {
    Instruction i = 0x00018241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_97: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_98: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_99: {
    Instruction i = 0x01c04287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_100: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_101: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_102: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_103: {
    Instruction i = 0x010001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_104: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_105: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_106: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_107: {
    Instruction i = 0x02800200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_108: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_109: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_110: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_112;
    }
  }
  
  
  label_111: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_112: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_113: {
    Instruction i = 0x01c04207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_114: {
    Instruction i = 0x06000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_115: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_116: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_118;
    }
  }
  
  
  label_117: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_127;
  }
  
  
  label_118: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_119: {
    Instruction i = 0x0001c201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_120: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_121: {
    Instruction i = 0x02404287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_122: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_123: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_124: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_125: {
    Instruction i = 0x010001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_126: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_127: {
    Instruction i = 0x01800145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_128: {
    Instruction i = 0x01c04187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_129: {
    Instruction i = 0x01008164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_130: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_131: {
    Instruction i = 0x01c0c1c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_132: {
    Instruction i = 0x03000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_133: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_134: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_136;
    }
  }
  
  
  label_135: {
    Instruction i = 0x8004c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_156;
  }
  
  
  label_136: {
    Instruction i = 0x02c0005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_138;
    }
  }
  
  
  label_137: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_156;
  }
  
  
  label_138: {
    Instruction i = 0x0280019c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_139: {
    Instruction i = 0x0340c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_141;
    }
  }
  
  
  label_140: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_156;
  }
  
  
  label_141: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_142: {
    Instruction i = 0x02c081c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_143: {
    Instruction i = 0x06800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_144: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_145: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_147;
    }
  }
  
  
  label_146: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_156;
  }
  
  
  label_147: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_148: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_149: {
    Instruction i = 0x02c0c207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_150: {
    Instruction i = 0x00010241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_151: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_152: {
    Instruction i = 0x00020201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_153: {
    Instruction i = 0x038201dd;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_154: {
    Instruction i = 0x010001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_155: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_156: {
    Instruction i = 0x0240005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_158;
    }
  }
  
  
  label_157: {
    Instruction i = 0x800ac01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_158: {
    Instruction i = 0x0200019c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_159: {
    Instruction i = 0x0340c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_161;
    }
  }
  
  
  label_160: {
    Instruction i = 0x800a001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_161: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_162: {
    Instruction i = 0x01c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_163: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_164: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_165: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_167;
    }
  }
  
  
  label_166: {
    Instruction i = 0x8008801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_167: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_168: {
    Instruction i = 0x024081c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_169: {
    Instruction i = 0x07000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_170: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_171: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_173;
    }
  }
  
  
  label_172: {
    Instruction i = 0x8007001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_173: {
    Instruction i = 0x01800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_174: {
    Instruction i = 0x0240c1c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_175: {
    Instruction i = 0x010081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_176: {
    Instruction i = 0x0340005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_178;
    }
  }
  
  
  label_177: {
    Instruction i = 0x8005c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_178: {
    Instruction i = 0x030001dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_179: {
    Instruction i = 0x03c0401f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_181;
    }
  }
  
  
  label_180: {
    Instruction i = 0x8005001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_181: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_182: {
    Instruction i = 0x03408207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_183: {
    Instruction i = 0x03000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_184: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_185: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_187;
    }
  }
  
  
  label_186: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_187: {
    Instruction i = 0x020001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_188: {
    Instruction i = 0x0340c207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_189: {
    Instruction i = 0x03800245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_190: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_191: {
    Instruction i = 0x000001e2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_193;
    }
  }
  
  
  label_192: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_202;
  }
  
  
  label_193: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_194: {
    Instruction i = 0x00024201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_195: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_196: {
    Instruction i = 0x03404287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_197: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_198: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_199: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_200: {
    Instruction i = 0x010001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_201: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_202: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_203: {
    Instruction i = 0x01c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_204: {
    Instruction i = 0x03800205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_205: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_206: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_208;
    }
  }
  
  
  label_207: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_211;
  }
  
  
  label_208: {
    Instruction i = 0x00028181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_209: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_211;
    }
  }
  
  
  label_210: {
    Instruction i = 0x8003001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_224;
  }
  
  
  label_211: {
    Instruction i = 0x02000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_212: {
    Instruction i = 0x01c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_213: {
    Instruction i = 0x06000205;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_214: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_215: {
    Instruction i = 0x000001a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_217;
    }
  }
  
  
  label_216: {
    Instruction i = 0x8000801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_220;
  }
  
  
  label_217: {
    Instruction i = 0x0002c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_218: {
    Instruction i = 0x000041a2;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_220;
    }
  }
  
  
  label_219: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_224;
  }
  
  
  label_220: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_221: {
    Instruction i = 0x01c041c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_222: {
    Instruction i = 0x00010201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_223: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_224: {
    Instruction i = 0x010001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_225: {
    Instruction i = 0x03000200;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_226: {
    Instruction i = 0x00030241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_227: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_228: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_229: {
    Instruction i = 0x01c0c287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_230: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_231: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_232: {
    Instruction i = 0x0402421d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_233: {
    Instruction i = 0x010001e5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_234: {
    Instruction i = 0x000001e6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_235: {
    Instruction i = 0x801bc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_236: {
    Instruction i = 0x01c0005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_238;
    }
  }
  
  
  label_237: {
    Instruction i = 0x801b401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_238: {
    Instruction i = 0x0180011c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_239: {
    Instruction i = 0x0240c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_241;
    }
  }
  
  
  label_240: {
    Instruction i = 0x801a801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_241: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_242: {
    Instruction i = 0x01c08147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_243: {
    Instruction i = 0x07000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_244: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_245: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_247;
    }
  }
  
  
  label_246: {
    Instruction i = 0x8008001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_280;
  }
  
  
  label_247: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_248: {
    Instruction i = 0x01c0c147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_249: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_250: {
    Instruction i = 0x0240005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_252;
    }
  }
  
  
  label_251: {
    Instruction i = 0x8004401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_270;
  }
  
  
  label_252: {
    Instruction i = 0x0200015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_253: {
    Instruction i = 0x02c0c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_255;
    }
  }
  
  
  label_254: {
    Instruction i = 0x8003801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_270;
  }
  
  
  label_255: {
    Instruction i = 0x02000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_256: {
    Instruction i = 0x02408187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_257: {
    Instruction i = 0x078001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_258: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_259: {
    Instruction i = 0x00000162;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_261;
    }
  }
  
  
  label_260: {
    Instruction i = 0x8002001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_270;
  }
  
  
  label_261: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_262: {
    Instruction i = 0x00034181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_263: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_264: {
    Instruction i = 0x0240c207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_265: {
    Instruction i = 0x00010241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_266: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_267: {
    Instruction i = 0x0301c19d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_268: {
    Instruction i = 0x01000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_269: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_270: {
    Instruction i = 0x01000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_271: {
    Instruction i = 0x00038181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_272: {
    Instruction i = 0x040001c5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_273: {
    Instruction i = 0x01c0c207;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_274: {
    Instruction i = 0x00010241;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_275: {
    Instruction i = 0x018081e4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_276: {
    Instruction i = 0x0301c19d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_277: {
    Instruction i = 0x01000165;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_278: {
    Instruction i = 0x00000166;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_279: {
    Instruction i = 0x8010c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_280: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_281: {
    Instruction i = 0x01c08147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_282: {
    Instruction i = 0x06800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_283: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_284: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_286;
    }
  }
  
  
  label_285: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_296;
  }
  
  
  label_286: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_287: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_288: {
    Instruction i = 0x01c0c187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_289: {
    Instruction i = 0x000101c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_290: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_291: {
    Instruction i = 0x0003c181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_292: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_293: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_294: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_295: {
    Instruction i = 0x800cc01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_296: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_297: {
    Instruction i = 0x01c08147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_298: {
    Instruction i = 0x07800185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_299: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_300: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_302;
    }
  }
  
  
  label_301: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_312;
  }
  
  
  label_302: {
    Instruction i = 0x01000100;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_303: {
    Instruction i = 0x00040141;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_304: {
    Instruction i = 0x04000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_305: {
    Instruction i = 0x01c0c1c7;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_306: {
    Instruction i = 0x00010201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_307: {
    Instruction i = 0x018081a4;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_308: {
    Instruction i = 0x0281815d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_309: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_310: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_311: {
    Instruction i = 0x8008c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_312: {
    Instruction i = 0x02000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_313: {
    Instruction i = 0x01c08147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_314: {
    Instruction i = 0x08000185;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_315: {
    Instruction i = 0x01808124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_316: {
    Instruction i = 0x00000122;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra)) {
      ci->u.l.savedpc++;

      goto label_318;
    }
  }
  
  
  label_317: {
    Instruction i = 0x8007401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_318: {
    Instruction i = 0x01800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_319: {
    Instruction i = 0x01c0c147;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_320: {
    Instruction i = 0x01008124;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_321: {
    Instruction i = 0x0240005f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_323;
    }
  }
  
  
  label_322: {
    Instruction i = 0x8006001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_323: {
    Instruction i = 0x0200015c;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_324: {
    Instruction i = 0x81014020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_326;
    }
  }
  
  
  label_325: {
    Instruction i = 0x8005401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_348;
  }
  
  
  label_326: {
    Instruction i = 0x04000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_327: {
    Instruction i = 0x02408187;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_328: {
    Instruction i = 0x000101c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_329: {
    Instruction i = 0x01808164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_330: {
    Instruction i = 0x00008181;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_331: {
    Instruction i = 0x020001dc;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    Protect(luaV_objlen(L, ra, RB(i)));
  }
  
  
  label_332: {
    Instruction i = 0x0301c020;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int cmp;
    Protect(cmp = luaV_lessthan(L, RKB(i), RKC(i)));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_334;
    }
  }
  
  
  label_333: {
    Instruction i = 0x8002401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_344;
  }
  
  
  label_334: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_335: {
    Instruction i = 0x00044201;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_336: {
    Instruction i = 0x04000245;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_337: {
    Instruction i = 0x0340828d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_338: {
    Instruction i = 0x02028287;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    StkId rb = RB(i);
    TValue *rc = RKC(i);
    gettableProtected(L, rb, rc, ra);
  }
  
  
  label_339: {
    Instruction i = 0x000102c1;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_340: {
    Instruction i = 0x01808264;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_341: {
    Instruction i = 0x0382415d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_342: {
    Instruction i = 0x0340818d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    lua_Number nb; lua_Number nc;
    if (ttisinteger(rb) && ttisinteger(rc)) {
      lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
      setivalue(ra, intop(+, ib, ic));
    }
    else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
      setfltvalue(ra, luai_numadd(L, nb, nc));
    }
    else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
  }
  
  
  label_343: {
    Instruction i = 0x7ffc801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_331;
  }
  
  
  label_344: {
    Instruction i = 0x01000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_345: {
    Instruction i = 0x028001c0;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_346: {
    Instruction i = 0x010001a5;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_347: {
    Instruction i = 0x000001a6;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_348: {
    Instruction i = 0x00c1001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_350;
    }
  }
  
  
  label_349: {
    Instruction i = 0x8001001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_355;
  }
  
  
  label_350: {
    Instruction i = 0x08800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_351: {
    Instruction i = 0x00000140;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_352: {
    Instruction i = 0x01000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_353: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_354: {
    Instruction i = 0x8001c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_363;
  }
  
  
  label_355: {
    Instruction i = 0x00c4801f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_357;
    }
  }
  
  
  label_356: {
    Instruction i = 0x8001401e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_363;
  }
  
  
  label_357: {
    Instruction i = 0x08800105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_358: {
    Instruction i = 0x09000145;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_359: {
    Instruction i = 0x00000180;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_360: {
    Instruction i = 0x01000164;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int nresults = GETARG_C(i) - 1;
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    if (luaD_precall(L, ra, nresults)) {  /* C function? */
      if (nresults >= 0)
        L->top = ci->top;  /* adjust results */
      Protect((void)0);  /* update 'base' */
    } else {  /* Lua function */
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_361: {
    Instruction i = 0x00000125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_362: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_363: {
    Instruction i = 0x01000105;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_364: {
    Instruction i = 0x00800125;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_365: {
    Instruction i = 0x00000126;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_366: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}





static int zz_magic_function_162 (lua_State *L, LClosure *cl)
{
  CallInfo *ci = L->ci;
  TValue *k = cl->p->k;
  StkId base = ci->u.l.base;
  
  
  (void) ci;
  (void) k;
  (void) base;
  
  
  label_0: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_1: {
    Instruction i = 0x00c0001f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_3;
    }
  }
  
  
  label_2: {
    Instruction i = 0x8001801e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_10;
  }
  
  
  label_3: {
    Instruction i = 0x00004041;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_4: {
    Instruction i = 0x00000080;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    setobjs2s(L, ra, RB(i));
  }
  
  
  label_5: {
    Instruction i = 0x0080805d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_6: {
    Instruction i = 0x00008081;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    TValue *rb = k + GETARG_Bx(i);
    setobj2s(L, ra, rb);
  }
  
  
  label_7: {
    Instruction i = 0x0080805d;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    int c = GETARG_C(i);
    StkId rb;
    L->top = base + c + 1;  /* mark the end of concat operands */
    Protect(luaV_concat(L, c - b + 1));
    ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
    rb = base + b;
    setobjs2s(L, ra, rb);
    checkGC(L, (ra >= rb ? ra + 1 : rb));
    L->top = ci->top;  /* restore top */
  }
  
  
  label_8: {
    Instruction i = 0x01000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_9: {
    Instruction i = 0x8000c01e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_14;
  }
  
  
  label_10: {
    Instruction i = 0x00000045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_11: {
    Instruction i = 0x00c0c01f;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    TValue *rb = RKB(i);
    TValue *rc = RKC(i);
    int cmp;
    Protect(cmp = luaV_equalobj(L, rb, rc));
    if (cmp != GETARG_A(i)) {
      ci->u.l.savedpc++;

      goto label_13;
    }
  }
  
  
  label_12: {
    Instruction i = 0x8000001e;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    (void) ra;
    int a = GETARG_A(i);
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1);
    ci->u.l.savedpc += GETARG_sBx(i);
    goto label_14;
  }
  
  
  label_13: {
    Instruction i = 0x01000026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_14: {
    Instruction i = 0x00800045;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    setobj2s(L, ra, cl->upvals[b]->v);
  }
  
  
  label_15: {
    Instruction i = 0x00800065;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (b != 0) L->top = ra+b;  /* else previous instruction set top */
    lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
    if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
      Protect((void)0);  /* update 'base' */
    }
    else {
      luaV_execute(L);
      Protect((void)0);  /* update 'base' */
    }
  }
  
  
  label_16: {
    Instruction i = 0x00000066;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
  
  label_17: {
    Instruction i = 0x00800026;
    ci->u.l.savedpc++;
    if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT))
      Protect(luaG_traceexec(L));
    StkId ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    
    int b = GETARG_B(i);
    if (cl->p->sizep > 0) luaF_close(L, base);
    int ret = (b != 0 ? b - 1 : cast_int(L->top - ra));
    luaD_poscall(L, ci, ra, ret);
    return ret;
  }
  
}

ZZ_MAGIC_FUNC zz_magic_functions[163] = {
  zz_magic_function_0,
  zz_magic_function_1,
  zz_magic_function_2,
  zz_magic_function_3,
  zz_magic_function_4,
  zz_magic_function_5,
  zz_magic_function_6,
  zz_magic_function_7,
  zz_magic_function_8,
  zz_magic_function_9,
  zz_magic_function_10,
  zz_magic_function_11,
  zz_magic_function_12,
  zz_magic_function_13,
  zz_magic_function_14,
  zz_magic_function_15,
  zz_magic_function_16,
  zz_magic_function_17,
  zz_magic_function_18,
  zz_magic_function_19,
  zz_magic_function_20,
  zz_magic_function_21,
  zz_magic_function_22,
  zz_magic_function_23,
  zz_magic_function_24,
  zz_magic_function_25,
  zz_magic_function_26,
  zz_magic_function_27,
  zz_magic_function_28,
  zz_magic_function_29,
  zz_magic_function_30,
  zz_magic_function_31,
  zz_magic_function_32,
  zz_magic_function_33,
  zz_magic_function_34,
  zz_magic_function_35,
  zz_magic_function_36,
  zz_magic_function_37,
  zz_magic_function_38,
  zz_magic_function_39,
  zz_magic_function_40,
  zz_magic_function_41,
  zz_magic_function_42,
  zz_magic_function_43,
  zz_magic_function_44,
  zz_magic_function_45,
  zz_magic_function_46,
  zz_magic_function_47,
  zz_magic_function_48,
  zz_magic_function_49,
  zz_magic_function_50,
  zz_magic_function_51,
  zz_magic_function_52,
  zz_magic_function_53,
  zz_magic_function_54,
  zz_magic_function_55,
  zz_magic_function_56,
  zz_magic_function_57,
  zz_magic_function_58,
  zz_magic_function_59,
  zz_magic_function_60,
  zz_magic_function_61,
  zz_magic_function_62,
  zz_magic_function_63,
  zz_magic_function_64,
  zz_magic_function_65,
  zz_magic_function_66,
  zz_magic_function_67,
  zz_magic_function_68,
  zz_magic_function_69,
  zz_magic_function_70,
  zz_magic_function_71,
  zz_magic_function_72,
  zz_magic_function_73,
  zz_magic_function_74,
  zz_magic_function_75,
  zz_magic_function_76,
  zz_magic_function_77,
  zz_magic_function_78,
  zz_magic_function_79,
  zz_magic_function_80,
  zz_magic_function_81,
  zz_magic_function_82,
  zz_magic_function_83,
  zz_magic_function_84,
  zz_magic_function_85,
  zz_magic_function_86,
  zz_magic_function_87,
  zz_magic_function_88,
  zz_magic_function_89,
  zz_magic_function_90,
  zz_magic_function_91,
  zz_magic_function_92,
  zz_magic_function_93,
  zz_magic_function_94,
  zz_magic_function_95,
  zz_magic_function_96,
  zz_magic_function_97,
  zz_magic_function_98,
  zz_magic_function_99,
  zz_magic_function_100,
  zz_magic_function_101,
  zz_magic_function_102,
  zz_magic_function_103,
  zz_magic_function_104,
  zz_magic_function_105,
  zz_magic_function_106,
  zz_magic_function_107,
  zz_magic_function_108,
  zz_magic_function_109,
  zz_magic_function_110,
  zz_magic_function_111,
  zz_magic_function_112,
  zz_magic_function_113,
  zz_magic_function_114,
  zz_magic_function_115,
  zz_magic_function_116,
  zz_magic_function_117,
  zz_magic_function_118,
  zz_magic_function_119,
  zz_magic_function_120,
  zz_magic_function_121,
  zz_magic_function_122,
  zz_magic_function_123,
  zz_magic_function_124,
  zz_magic_function_125,
  zz_magic_function_126,
  zz_magic_function_127,
  zz_magic_function_128,
  zz_magic_function_129,
  zz_magic_function_130,
  zz_magic_function_131,
  zz_magic_function_132,
  zz_magic_function_133,
  zz_magic_function_134,
  zz_magic_function_135,
  zz_magic_function_136,
  zz_magic_function_137,
  zz_magic_function_138,
  zz_magic_function_139,
  zz_magic_function_140,
  zz_magic_function_141,
  zz_magic_function_142,
  zz_magic_function_143,
  zz_magic_function_144,
  zz_magic_function_145,
  zz_magic_function_146,
  zz_magic_function_147,
  zz_magic_function_148,
  zz_magic_function_149,
  zz_magic_function_150,
  zz_magic_function_151,
  zz_magic_function_152,
  zz_magic_function_153,
  zz_magic_function_154,
  zz_magic_function_155,
  zz_magic_function_156,
  zz_magic_function_157,
  zz_magic_function_158,
  zz_magic_function_159,
  zz_magic_function_160,
  zz_magic_function_161,
  zz_magic_function_162,
};

static const char ZZ_ORIGINAL_SOURCE_CODE[] = {
   45,  45,  32,  71, 101, 110, 101, 114,  97, 116, 101, 100,  32,  98, 121,  32, 
  109,  97, 107, 101,  46, 114, 107, 116,  10,  10,  45,  45,  32,  32,  32,  32, 
   84, 104, 101,  32,  76,  97, 110, 103, 117,  97, 103, 101,  10,  45,  45,  32, 
   32,  32,  32,  67, 111, 112, 121, 114, 105, 103, 104, 116,  32,  40,  67,  41, 
   32,  50,  48,  49,  56,  44,  32,  50,  48,  49,  57,  32,  32,  90,  97, 111, 
  113, 105,  32,  60, 122,  97, 111, 109, 105, 114,  64, 111, 117, 116, 108, 111, 
  111, 107,  46,  99, 111, 109,  62,  10,  10,  45,  45,  32,  32,  32,  32,  84, 
  104, 105, 115,  32, 112, 114, 111, 103, 114,  97, 109,  32, 105, 115,  32, 102, 
  114, 101, 101,  32, 115, 111, 102, 116, 119,  97, 114, 101,  58,  32, 121, 111, 
  117,  32,  99,  97, 110,  32, 114, 101, 100, 105, 115, 116, 114, 105,  98, 117, 
  116, 101,  32, 105, 116,  32,  97, 110, 100,  47, 111, 114,  32, 109, 111, 100, 
  105, 102, 121,  10,  45,  45,  32,  32,  32,  32, 105, 116,  32, 117, 110, 100, 
  101, 114,  32, 116, 104, 101,  32, 116, 101, 114, 109, 115,  32, 111, 102,  32, 
  116, 104, 101,  32,  71,  78,  85,  32,  65, 102, 102, 101, 114, 111,  32,  71, 
  101, 110, 101, 114,  97, 108,  32,  80, 117,  98, 108, 105,  99,  32,  76, 105, 
   99, 101, 110, 115, 101,  32,  97, 115,  32, 112, 117,  98, 108, 105, 115, 104, 
  101, 100,  10,  45,  45,  32,  32,  32,  32,  98, 121,  32, 116, 104, 101,  32, 
   70, 114, 101, 101,  32,  83, 111, 102, 116, 119,  97, 114, 101,  32,  70, 111, 
  117, 110, 100,  97, 116, 105, 111, 110,  44,  32, 101, 105, 116, 104, 101, 114, 
   32, 118, 101, 114, 115, 105, 111, 110,  32,  51,  32, 111, 102,  32, 116, 104, 
  101,  32,  76, 105,  99, 101, 110, 115, 101,  44,  32, 111, 114,  10,  45,  45, 
   32,  32,  32,  32,  40,  97, 116,  32, 121, 111, 117, 114,  32, 111, 112, 116, 
  105, 111, 110,  41,  32,  97, 110, 121,  32, 108,  97, 116, 101, 114,  32, 118, 
  101, 114, 115, 105, 111, 110,  46,  10,  10,  45,  45,  32,  32,  32,  32,  84, 
  104, 105, 115,  32, 112, 114, 111, 103, 114,  97, 109,  32, 105, 115,  32, 100, 
  105, 115, 116, 114, 105,  98, 117, 116, 101, 100,  32, 105, 110,  32, 116, 104, 
  101,  32, 104, 111, 112, 101,  32, 116, 104,  97, 116,  32, 105, 116,  32, 119, 
  105, 108, 108,  32,  98, 101,  32, 117, 115, 101, 102, 117, 108,  44,  10,  45, 
   45,  32,  32,  32,  32,  98, 117, 116,  32,  87,  73,  84,  72,  79,  85,  84, 
   32,  65,  78,  89,  32,  87,  65,  82,  82,  65,  78,  84,  89,  59,  32, 119, 
  105, 116, 104, 111, 117, 116,  32, 101, 118, 101, 110,  32, 116, 104, 101,  32, 
  105, 109, 112, 108, 105, 101, 100,  32, 119,  97, 114, 114,  97, 110, 116, 121, 
   32, 111, 102,  10,  45,  45,  32,  32,  32,  32,  77,  69,  82,  67,  72,  65, 
   78,  84,  65,  66,  73,  76,  73,  84,  89,  32, 111, 114,  32,  70,  73,  84, 
   78,  69,  83,  83,  32,  70,  79,  82,  32,  65,  32,  80,  65,  82,  84,  73, 
   67,  85,  76,  65,  82,  32,  80,  85,  82,  80,  79,  83,  69,  46,  32,  32, 
   83, 101, 101,  32, 116, 104, 101,  10,  45,  45,  32,  32,  32,  32,  71,  78, 
   85,  32,  65, 102, 102, 101, 114, 111,  32,  71, 101, 110, 101, 114,  97, 108, 
   32,  80, 117,  98, 108, 105,  99,  32,  76, 105,  99, 101, 110, 115, 101,  32, 
  102, 111, 114,  32, 109, 111, 114, 101,  32, 100, 101, 116,  97, 105, 108, 115, 
   46,  10,  10,  45,  45,  32,  32,  32,  32,  89, 111, 117,  32, 115, 104, 111, 
  117, 108, 100,  32, 104,  97, 118, 101,  32, 114, 101,  99, 101, 105, 118, 101, 
  100,  32,  97,  32,  99, 111, 112, 121,  32, 111, 102,  32, 116, 104, 101,  32, 
   71,  78,  85,  32,  65, 102, 102, 101, 114, 111,  32,  71, 101, 110, 101, 114, 
   97, 108,  32,  80, 117,  98, 108, 105,  99,  32,  76, 105,  99, 101, 110, 115, 
  101,  10,  45,  45,  32,  32,  32,  32,  97, 108, 111, 110, 103,  32, 119, 105, 
  116, 104,  32, 116, 104, 105, 115,  32, 112, 114, 111, 103, 114,  97, 109,  46, 
   32,  32,  73, 102,  32, 110, 111, 116,  44,  32, 115, 101, 101,  32,  60, 104, 
  116, 116, 112, 115,  58,  47,  47, 119, 119, 119,  46, 103, 110, 117,  46, 111, 
  114, 103,  47, 108, 105,  99, 101, 110, 115, 101, 115,  47,  62,  46,  10,  10, 
  108, 111,  99,  97, 108,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 
  121,  80, 117, 115, 104,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40,  97, 114, 114,  44,  32, 105, 116, 101, 109,  41,  10,  32,  32,  32,  32, 
   97, 114, 114,  91,  35,  97, 114, 114,  43,  49,  93,  32,  61,  32, 105, 116, 
  101, 109,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  35,  97, 
  114, 114,  10, 101, 110, 100,  10, 108, 111,  99,  97, 108,  32, 101, 120, 112, 
  111, 114, 116, 115,  32,  61,  32, 123, 125,  10, 108, 111,  99,  97, 108,  32, 
   69,  82,  82,  79,  82,  44,  32,  65,  83,  83,  69,  82,  84,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  44,  32, 110, 
  117, 108, 108,  95, 116,  44,  32, 100,  97, 116,  97,  95, 116,  44,  32, 101, 
  114, 114, 111, 114,  95, 116,  44,  32, 106, 117, 115, 116,  95, 116,  44,  32, 
  100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 116, 
   44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95, 116,  44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 116,  44,  32, 100, 101, 
  108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 116,  44,  32, 115, 121, 109, 
   98, 111, 108,  95, 112,  44,  32, 117, 110,  95, 115, 121, 109,  98, 111, 108, 
   44,  32, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 112,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 104, 101,  97, 100,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 116,  97, 105, 108,  44,  32, 110, 117, 108, 108,  95, 118, 
   44,  32, 110, 117, 108, 108,  95, 112,  44,  32, 110, 101, 119,  95, 100,  97, 
  116,  97,  44,  32, 100,  97, 116,  97,  95, 112,  44,  32, 100,  97, 116,  97, 
   95, 110,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 108, 105, 115, 116, 
   44,  32, 110, 101, 119,  95, 101, 114, 114, 111, 114,  44,  32, 101, 114, 114, 
  111, 114,  95, 112,  44,  32, 101, 114, 114, 111, 114,  95, 110,  97, 109, 101, 
   44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  44,  32, 108,  97, 
  110, 103,  95, 115, 101, 116,  95, 100, 111,  44,  32, 106, 117, 115, 116,  95, 
  112,  44,  32, 117, 110,  95, 106, 117, 115, 116,  44,  32, 101, 118,  97, 108, 
  117,  97, 116, 101,  44,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 
  117,  97, 116, 101,  95, 112,  44,  32, 100, 101, 108,  97, 121,  95, 101, 118, 
   97, 108, 117,  97, 116, 101,  95, 101, 110, 118,  44,  32, 100, 101, 108,  97, 
  121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 120,  44,  32,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95,  97, 112, 112, 108, 121, 
   44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 111, 114, 109,  95, 112,  44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 101, 110, 118,  44,  32, 
  100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 
  114, 109,  95, 102,  44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102, 111, 114, 109,  95, 120, 115,  44,  32,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  44, 
   32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95, 112,  44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 102,  44,  32, 100, 101, 108, 
   97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 
  120, 115,  44,  32,  97, 112, 112, 108, 121,  44,  32, 100, 101, 108,  97, 121, 
   95,  97, 112, 112, 108, 121,  95, 112,  44,  32, 100, 101, 108,  97, 121,  95, 
   97, 112, 112, 108, 121,  95, 102,  44,  32, 100, 101, 108,  97, 121,  95,  97, 
  112, 112, 108, 121,  95, 120, 115,  44,  32, 102, 111, 114,  99, 101,  95,  97, 
  108, 108,  95, 114, 101,  99,  44,  32, 115, 121, 115, 116, 101, 109,  95, 115, 
  121, 109,  98, 111, 108,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
  115, 121, 109,  98, 111, 108,  44,  32, 102, 111, 114, 109,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 109,  97, 112, 112, 105, 110, 103,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 116, 104, 101,  95, 119, 111, 114, 108, 100,  95, 115, 
  116, 111, 112, 112, 101, 100,  95, 118,  44,  32, 100,  97, 116,  97,  95, 110, 
   97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32, 100,  97, 116,  97,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 112,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 101, 114, 114, 111, 
  114,  95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 101, 114, 114, 111, 
  114,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  95, 102, 117, 
  110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 
  121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 115, 121, 109,  98, 111, 
  108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32, 110, 117, 108, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  44,  32, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  97, 112, 112, 108, 121,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 101, 118,  97, 
  108, 117,  97, 116, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 105, 102,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 113, 117, 111, 116, 101,  95, 102, 111, 114, 109,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   44,  32, 108,  97, 109,  98, 100,  97,  95, 102, 111, 114, 109,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 
  102, 111, 114, 109,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  44,  32, 115, 121, 109,  98, 111, 108,  95, 101, 113, 117,  97, 
  108,  95, 112,  44,  32, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 
  108, 105, 115, 116,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  44,  32, 
  117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108,  44,  32,  97, 110, 121, 
   95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 112,  44,  32, 102, 
  111, 114,  99, 101,  95,  97, 108, 108,  44,  32, 102, 111, 114,  99, 101,  49, 
   44,  32, 101, 110, 118,  95, 110, 117, 108, 108,  95, 118,  44,  32, 101, 110, 
  118,  95, 115, 101, 116,  44,  32, 101, 110, 118,  95, 103, 101, 116,  44,  32, 
  109, 117, 115, 116,  95, 101, 110, 118,  95, 103, 101, 116,  44,  32, 101, 110, 
  118,  50, 118,  97, 108,  44,  32, 101, 110, 118,  95, 102, 111, 114, 101,  97, 
   99, 104,  44,  32, 114, 101,  97, 108,  95, 101, 118,  97, 108, 117,  97, 116, 
  101,  44,  32, 110,  97, 109, 101,  95, 112,  44,  32, 114, 101,  97, 108,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 
  108, 121,  95, 115,  44,  32, 114, 101,  97, 108,  95,  97, 112, 112, 108, 121, 
   44,  32, 114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95,  97, 112, 112, 108, 121,  44,  32, 114, 101,  97, 108,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95,  97, 112, 112, 
  108, 121,  44,  32, 110, 101, 119,  95, 108,  97, 109,  98, 100,  97,  44,  32, 
  106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  44,  32, 
  115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  59,  10,  69,  82, 
   82,  79,  82,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 
   10,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  84, 104, 101,  76, 
   97, 110, 103, 117,  97, 103, 101,  32,  80,  65,  78,  73,  67,  34,  41,  59, 
   10, 101, 110, 100,  59,  10,  65,  83,  83,  69,  82,  84,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 105, 
  102,  32, 110, 111, 116,  32, 120,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79, 
   82,  40,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10, 101, 110, 100, 
   59,  10, 115, 121, 109,  98, 111, 108,  95, 112,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 
   48,  59,  10, 101, 110, 100,  59,  10, 117, 110,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43, 
   32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 110, 101, 119,  95,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  41,  10,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 123,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 116,  44,  32, 120,  44,  32, 121, 125,  59,  10, 101, 
  110, 100,  59,  10,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  48,  32, 
   43,  32,  49,  93,  32,  61,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 116,  59,  10, 101, 110, 100,  59,  10,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43,  32,  49,  93, 
   59,  10, 101, 110, 100,  59,  10,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 116,  97, 105, 108,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 120,  91,  50,  32,  43,  32,  49,  93,  59,  10, 101, 110, 100,  59, 
   10, 110, 117, 108, 108,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 110, 117, 108, 
  108,  95, 116,  59,  10, 101, 110, 100,  59,  10, 110, 101, 119,  95, 100,  97, 
  116,  97,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44, 
   32, 121,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 123, 
  100,  97, 116,  97,  95, 116,  44,  32, 120,  44,  32, 121, 125,  59,  10, 101, 
  110, 100,  59,  10, 100,  97, 116,  97,  95, 112,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 
  100,  97, 116,  97,  95, 116,  59,  10, 101, 110, 100,  59,  10, 100,  97, 116, 
   97,  95, 110,  97, 109, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  91,  49,  32,  43,  32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 100, 
   97, 116,  97,  95, 108, 105, 115, 116,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 120,  91,  50,  32,  43,  32,  49,  93,  59,  10, 101, 110, 100,  59, 
   10, 110, 101, 119,  95, 101, 114, 114, 111, 114,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  41,  10,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 123, 101, 114, 114, 111, 114,  95, 116,  44, 
   32, 120,  44,  32, 121, 125,  59,  10, 101, 110, 100,  59,  10, 101, 114, 114, 
  111, 114,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
  120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91, 
   48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 101, 114, 114, 111, 114,  95, 
  116,  59,  10, 101, 110, 100,  59,  10, 101, 114, 114, 111, 114,  95, 110,  97, 
  109, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32, 
   43,  32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 101, 114, 114, 111, 114, 
   95, 108, 105, 115, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 
   91,  50,  32,  43,  32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 108,  97, 
  110, 103,  95, 115, 101, 116,  95, 100, 111,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 120,  44,  32, 121,  41,  10,  32,  32,  32,  32, 105, 
  102,  32, 120,  32,  61,  61,  32, 121,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 120,  91,  48,  32,  43,  32, 
   49,  93,  32,  61,  32, 106, 117, 115, 116,  95, 116,  59,  10,  32,  32,  32, 
   32, 120,  91,  49,  32,  43,  32,  49,  93,  32,  61,  32, 121,  59,  10,  32, 
   32,  32,  32, 120,  91,  50,  32,  43,  32,  49,  93,  32,  61,  32, 102,  97, 
  108, 115, 101,  59,  10,  32,  32,  32,  32, 120,  91,  51,  32,  43,  32,  49, 
   93,  32,  61,  32, 102,  97, 108, 115, 101,  59,  10, 101, 110, 100,  59,  10, 
  106, 117, 115, 116,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 106, 117, 115, 116, 
   95, 116,  59,  10, 101, 110, 100,  59,  10, 117, 110,  95, 106, 117, 115, 116, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43,  32, 
   49,  93,  59,  10, 101, 110, 100,  59,  10, 101, 118,  97, 108, 117,  97, 116, 
  101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 
  121,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 123, 100, 
  101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 116,  44, 
   32, 120,  44,  32, 121, 125,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108, 
   97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 112,  32,  61,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 120,  91,  48,  32,  43,  32,  49,  93,  32, 
   61,  61,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 
  101,  95, 116,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95, 
  101, 118,  97, 108, 117,  97, 116, 101,  95, 101, 110, 118,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43,  32,  49,  93,  59,  10, 
  101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117, 
   97, 116, 101,  95, 120,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 
   91,  50,  32,  43,  32,  49,  93,  59,  10, 101, 110, 100,  59,  10,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95,  97, 112, 112, 108, 121, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 121, 
   44,  32, 122,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  123, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  111, 114, 109,  95, 116,  44,  32, 120,  44,  32, 121,  44,  32, 122, 125,  59, 
   10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102, 111, 114, 109,  95, 112,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 
  100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 
  114, 109,  95, 116,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 101, 110, 
  118,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43, 
   32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 102,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  50,  32,  43,  32,  49,  93, 
   59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 120, 115,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 120,  91,  51,  32,  43,  32,  49,  93,  59,  10, 
  101, 110, 100,  59,  10,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110, 
   99,  95,  97, 112, 112, 108, 121,  32,  61,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 120,  44,  32, 121,  41,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 123, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 102, 117, 110,  99,  95, 116,  44,  32, 120,  44,  32, 121, 125, 
   59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 112,  32,  61,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 120,  91,  48,  32,  43,  32,  49,  93,  32,  61,  61, 
   32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95, 116,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 
  121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 102, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  49,  32,  43,  32, 
   49,  93,  59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 120, 115,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  50,  32,  43,  32,  49,  93, 
   59,  10, 101, 110, 100,  59,  10,  97, 112, 112, 108, 121,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 102,  44,  32, 120, 115,  41,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 123, 100, 101, 108,  97, 121, 
   95,  97, 112, 112, 108, 121,  95, 116,  44,  32, 102,  44,  32, 120, 115, 125, 
   59,  10, 101, 110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  97, 112, 112, 
  108, 121,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
  120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91, 
   48,  32,  43,  32,  49,  93,  32,  61,  61,  32, 100, 101, 108,  97, 121,  95, 
   97, 112, 112, 108, 121,  95, 116,  59,  10, 101, 110, 100,  59,  10, 100, 101, 
  108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 102,  32,  61,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 120,  91,  49,  32,  43,  32,  49,  93,  59,  10, 101, 
  110, 100,  59,  10, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 
  120, 115,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  91,  50,  32, 
   43,  32,  49,  93,  59,  10, 101, 110, 100,  59,  10, 102, 111, 114,  99, 101, 
   95,  97, 108, 108,  95, 114, 101,  99,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 114,  97, 119,  41,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 120,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108, 
   40, 114,  97, 119,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 100,  97, 
  116,  97,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  97,  32,  61,  32, 120, 
   91,  49,  32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 100,  32,  61,  32, 120,  91,  50,  32,  43, 
   32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 120,  91,  49, 
   32,  43,  32,  49,  93,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 
  108,  95, 114, 101,  99,  40,  97,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 120,  91,  50,  32,  43,  32,  49,  93,  32,  61,  32, 102, 111, 114, 
   99, 101,  95,  97, 108, 108,  95, 114, 101,  99,  40, 100,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  59, 
   10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 101, 114, 114, 111, 
  114,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  97,  32,  61,  32, 120,  91, 
   49,  32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 100,  32,  61,  32, 120,  91,  50,  32,  43,  32, 
   49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 120,  91,  49,  32, 
   43,  32,  49,  93,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108, 
   95, 114, 101,  99,  40,  97,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 120,  91,  50,  32,  43,  32,  49,  93,  32,  61,  32, 102, 111, 114,  99, 
  101,  95,  97, 108, 108,  95, 114, 101,  99,  40, 100,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  59,  10, 
   32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
   97,  32,  61,  32, 120,  91,  49,  32,  43,  32,  49,  93,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 100,  32,  61,  32, 
  120,  91,  50,  32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 120,  91,  49,  32,  43,  32,  49,  93,  32,  61,  32, 102, 111, 114, 
   99, 101,  95,  97, 108, 108,  95, 114, 101,  99,  40,  97,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 120,  91,  50,  32,  43,  32,  49,  93,  32, 
   61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  95, 114, 101,  99,  40, 
  100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 120,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  59,  10, 101, 110, 100,  59, 
   10, 115, 121, 109,  98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  41, 
   10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 121,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 105, 102,  32, 117, 110,  95, 115, 121, 109,  98, 111, 
  108,  40, 120,  41,  32,  61,  61,  32, 117, 110,  95, 115, 121, 109,  98, 111, 
  108,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108,  97, 110, 103,  95, 115, 101, 116,  95, 100, 111,  40, 120,  44, 
   32, 121,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 101, 108, 
  115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10, 101, 110, 100,  59,  10, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111, 
   95, 108, 105, 115, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120, 115,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 
  101, 116,  32,  61,  32, 110, 117, 108, 108,  95, 118,  59,  10,  32,  32,  32, 
   32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 105,  32,  61,  32,  40,  35, 120, 115,  41,  32,  45,  32,  49,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105, 
   32,  62,  61,  32,  48,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 110, 101, 119,  95,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  40, 120, 115,  91, 105, 
   32,  43,  32,  49,  93,  44,  32, 114, 101, 116,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  45, 
   32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 114, 101, 116,  59,  10, 101, 110, 100,  59,  10, 110, 101, 119, 
   95, 108, 105, 115, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40,  46,  46,  46,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  120, 115,  32,  61,  32,  40, 123,  46,  46,  46, 125,  41,  59,  10,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 106, 115,  65, 114, 114,  97, 121, 
   95, 116, 111,  95, 108, 105, 115, 116,  40, 120, 115,  41,  59,  10, 101, 110, 
  100,  59,  10, 117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 114,  97, 119,  41,  10,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114,  97, 119, 
   59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61, 
   32, 123, 125,  59,  10,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 106, 
  117, 115, 116,  95, 112,  40, 120,  41,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121,  80, 
  117, 115, 104,  40, 120, 115,  44,  32, 120,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 120,  32,  61,  32, 117, 110,  95, 106, 117, 115, 116,  40, 
  120,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 120, 115,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
   97, 110, 103,  95, 115, 101, 116,  95, 100, 111,  40, 120, 115,  91, 105,  32, 
   43,  32,  49,  93,  44,  32, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  59,  10, 101, 110, 100,  59,  10,  97, 110, 121,  95, 100, 101, 108,  97, 
  121,  95, 106, 117, 115, 116,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32,  40,  40,  40, 106, 117, 115, 116,  95, 112,  40, 120,  41,  32, 111, 
  114,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101, 
   95, 112,  40, 120,  41,  41,  32, 111, 114,  32, 100, 101, 108,  97, 121,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 112,  40, 120, 
   41,  41,  32, 111, 114,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102, 117, 110,  99,  95, 112,  40, 120,  41,  41,  32, 111, 
  114,  32, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 112,  40, 
  120,  41,  59,  10, 101, 110, 100,  59,  10, 102, 111, 114,  99, 101,  95,  97, 
  108, 108,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 114,  97, 
  119,  44,  32, 112,  97, 114, 101, 110, 116, 115,  95, 104, 105, 115, 116, 111, 
  114, 121,  44,  32, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 101,  95, 
  114, 101, 112, 108,  97,  99, 101,  44,  32, 120, 115,  41,  10,  32,  32,  32, 
   32, 105, 102,  32, 112,  97, 114, 101, 110, 116, 115,  95, 104, 105, 115, 116, 
  111, 114, 121,  32,  61,  61,  32, 110, 105, 108,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 112,  97, 114, 101, 110, 116, 115,  95, 
  104, 105, 115, 116, 111, 114, 121,  32,  61,  32, 123, 125,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 114, 101, 102, 
   95, 110, 111, 118,  97, 108, 117, 101,  95, 114, 101, 112, 108,  97,  99, 101, 
   32,  61,  61,  32, 110, 105, 108,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 101, 
   95, 114, 101, 112, 108,  97,  99, 101,  32,  61,  32, 123, 102,  97, 108, 115, 
  101,  44,  32, 102,  97, 108, 115, 101, 125,  59,  10,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 120, 115,  32,  61,  61,  32, 
  110, 105, 108,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 120, 115,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  44,  32, 100, 
  111,  95, 114, 101, 119, 114, 105, 116, 101,  44,  32, 100, 111,  95, 114, 101, 
  119, 114, 105, 116, 101,  95, 102, 111, 114,  99, 101,  95,  97, 108, 108,  59, 
   10,  32,  32,  32,  32, 100, 111,  95, 114, 101, 119, 114, 105, 116, 101,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 110, 101, 119, 118,  97, 
  108,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 110, 103,  95, 
  115, 101, 116,  95, 100, 111,  40, 120,  44,  32, 110, 101, 119, 118,  97, 108, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 120, 
  115,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108,  97, 110, 103,  95, 115, 101, 116,  95, 100, 
  111,  40, 120, 115,  91, 105,  32,  43,  32,  49,  93,  44,  32, 110, 101, 119, 
  118,  97, 108,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119, 118, 
   97, 108,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32, 
   32, 100, 111,  95, 114, 101, 119, 114, 105, 116, 101,  95, 102, 111, 114,  99, 
  101,  95,  97, 108, 108,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 110, 101, 119, 118,  97, 108,  41,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 100, 111,  95, 114, 101, 119, 114, 105, 116, 101,  40, 110, 101, 119, 118, 
   97, 108,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
   97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 112, 
   40, 110, 101, 119, 118,  97, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95, 
   65, 114, 114,  97, 121,  80, 117, 115, 104,  40, 120, 115,  44,  32, 120,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 110, 
  101, 119, 118,  97, 108,  44,  32, 123, 125,  44,  32, 123, 102,  97, 108, 115, 
  101,  44,  32, 102,  97, 108, 115, 101, 125,  44,  32, 120, 115,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119, 118,  97, 
  108,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 104, 105, 115, 116, 111, 114, 121,  32,  61,  32, 
  123, 125,  59,  10,  32,  32,  32,  32, 120,  32,  61,  32, 114,  97, 119,  59, 
   10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 112, 108,  97, 
   99, 101,  95, 116, 104, 105, 115,  95, 119, 105, 116, 104,  95, 115, 116, 111, 
  112, 112, 101, 100,  59,  10,  32,  32,  32,  32, 114, 101, 112, 108,  97,  99, 
  101,  95, 116, 104, 105, 115,  95, 119, 105, 116, 104,  95, 115, 116, 111, 112, 
  112, 101, 100,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 102,  95, 110, 111, 118, 
   97, 108, 117, 101,  95, 114, 101, 112, 108,  97,  99, 101,  91,  49,  32,  43, 
   32,  49,  93,  32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 100, 111,  95, 114, 101, 
  119, 114, 105, 116, 101,  95, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 
  116, 104, 101,  95, 119, 111, 114, 108, 100,  95, 115, 116, 111, 112, 112, 101, 
  100,  95, 118,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 107, 101,  95, 104, 105, 
  115, 116, 111, 114, 121,  59,  10,  32,  32,  32,  32, 109,  97, 107, 101,  95, 
  104, 105, 115, 116, 111, 114, 121,  32,  61,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 114, 101, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 102, 111, 114,  32, 120,  95, 105, 100,  32, 105, 110, 
   32, 112,  97, 105, 114, 115,  40, 104, 105, 115, 116, 111, 114, 121,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116,  91, 120,  95, 105, 100,  93,  32,  61,  32, 116, 114, 117, 101,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 102, 111, 114,  32, 120,  95, 105, 100,  32, 105, 110, 
   32, 112,  97, 105, 114, 115,  40, 112,  97, 114, 101, 110, 116, 115,  95, 104, 
  105, 115, 116, 111, 114, 121,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  91, 120,  95, 105, 100,  93, 
   32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 114, 101, 116,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   59,  10,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32,  97, 110, 121,  95, 
  100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 120,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 120,  95, 105, 100,  32,  61,  32, 115, 105, 109, 112, 108, 101,  95, 112, 
  114, 105, 110, 116,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 112,  97, 114, 101, 110, 116, 115,  95, 104, 105, 115, 116, 
  111, 114, 121,  91, 120,  95, 105, 100,  93,  32,  61,  61,  32, 116, 114, 117, 
  101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 112, 108,  97,  99, 
  101,  95, 116, 104, 105, 115,  95, 119, 105, 116, 104,  95, 115, 116, 111, 112, 
  112, 101, 100,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 104, 105, 
  115, 116, 111, 114, 121,  91, 120,  95, 105, 100,  93,  32,  61,  61,  32, 116, 
  114, 117, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 101, 
   95, 114, 101, 112, 108,  97,  99, 101,  91,  48,  32,  43,  32,  49,  93,  32, 
   61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 
  108, 117,  97, 116, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 114, 101, 112, 108,  97,  99, 101,  95, 116, 
  104, 105, 115,  95, 119, 105, 116, 104,  95, 115, 116, 111, 112, 112, 101, 100, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 112,  40, 120,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  32,  61,  32, 100, 101, 
  108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99, 
   95, 102,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  32, 
   61,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95, 120, 115,  40, 120,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 101, 108, 105, 109,  95, 115,  32,  61,  32, 123, 100,  97, 116,  97, 
   95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 100,  97, 116,  97,  95, 108, 105, 115, 116,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 112, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 101, 114, 
  114, 111, 114,  95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 101, 114, 
  114, 111, 114,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 115, 121, 109, 
   98, 111, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 110, 117, 108, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105, 115, 
   95, 101, 108, 105, 109,  32,  61,  32, 102,  97, 108, 115, 101,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 100, 
  111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32, 
   48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60, 
   32,  40,  35, 101, 108, 105, 109,  95, 115,  41,  32, 100, 111,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 
  101, 113, 117,  97, 108,  95, 112,  40, 101, 108, 105, 109,  95, 115,  91, 105, 
   32,  43,  32,  49,  93,  44,  32, 102,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 115,  95, 101, 108, 
  105, 109,  32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
   32,  61,  32, 105,  32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 105, 115,  95, 101, 108, 105, 109, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  65,  83,  83,  69,  82,  84, 
   40,  40,  35, 120, 115,  41,  32,  61,  61,  32,  49,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  65,  83,  83,  69,  82,  84,  40, 114, 101, 102,  95, 110, 111, 118, 
   97, 108, 117, 101,  95, 114, 101, 112, 108,  97,  99, 101,  91,  49,  32,  43, 
   32,  49,  93,  32,  61,  61,  32, 102,  97, 108, 115, 101,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 105, 110, 110, 101, 114,  32,  61, 
   32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 120, 115,  91,  48,  32, 
   43,  32,  49,  93,  44,  32, 109,  97, 107, 101,  95, 104, 105, 115, 116, 111, 
  114, 121,  40,  41,  44,  32, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 
  101,  95, 114, 101, 112, 108,  97,  99, 101,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 101,  95, 114, 
  101, 112, 108,  97,  99, 101,  91,  49,  32,  43,  32,  49,  93,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 100, 111,  95, 114, 101, 119, 114, 105, 116, 101,  95, 102, 111, 114, 
   99, 101,  95,  97, 108, 108,  40,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 102,  44,  32, 123, 105, 110, 
  110, 101, 114, 125,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
   69,  82,  82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 
  113, 117,  97, 108,  95, 112,  40, 102,  44,  32, 101, 113, 117,  97, 108,  95, 
  112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 
  101, 112, 108,  97,  99, 101,  95, 116, 104, 105, 115,  95, 119, 105, 116, 104, 
   95, 115, 116, 111, 112, 112, 101, 100,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 
  105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 
  112,  40, 102,  44,  32,  97, 112, 112, 108, 121,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 112, 108,  97,  99, 101,  95, 
  116, 104, 105, 115,  95, 119, 105, 116, 104,  95, 115, 116, 111, 112, 112, 101, 
  100,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 106, 115,  98, 111, 
  111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102,  44,  32, 101, 118, 
   97, 108, 117,  97, 116, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 114, 101, 112, 108,  97,  99, 101,  95, 116, 104, 105, 115, 
   95, 119, 105, 116, 104,  95, 115, 116, 111, 112, 112, 101, 100,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 108, 115, 101, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 
  113, 117,  97, 108,  95, 112,  40, 102,  44,  32, 105, 102,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  65,  83,  83,  69,  82,  84,  40,  40,  35, 120, 115,  41,  32, 
   61,  61,  32,  51,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  65,  83,  83,  69,  82, 
   84,  40, 114, 101, 102,  95, 110, 111, 118,  97, 108, 117, 101,  95, 114, 101, 
  112, 108,  97,  99, 101,  91,  49,  32,  43,  32,  49,  93,  32,  61,  61,  32, 
  102,  97, 108, 115, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 116, 102,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108, 
   40, 120, 115,  91,  48,  32,  43,  32,  49,  93,  44,  32, 109,  97, 107, 101, 
   95, 104, 105, 115, 116, 111, 114, 121,  40,  41,  44,  32, 114, 101, 102,  95, 
  110, 111, 118,  97, 108, 117, 101,  95, 114, 101, 112, 108,  97,  99, 101,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 114, 101, 102,  95, 110, 111, 118, 
   97, 108, 117, 101,  95, 114, 101, 112, 108,  97,  99, 101,  91,  49,  32,  43, 
   32,  49,  93,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 100, 111,  95, 114, 101, 119, 114, 105, 
  116, 101,  95, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 
  105, 102,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 
  123, 116, 102,  44,  32, 120, 115,  91,  49,  32,  43,  32,  49,  93,  44,  32, 
  120, 115,  91,  50,  32,  43,  32,  49,  93, 125,  41,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 
  108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109, 
   95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 114, 101, 112, 108,  97,  99, 101,  95, 116, 104, 105, 115,  95, 119, 
  105, 116, 104,  95, 115, 116, 111, 112, 112, 101, 100,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 112,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 
  101, 112, 108,  97,  99, 101,  95, 116, 104, 105, 115,  95, 119, 105, 116, 104, 
   95, 115, 116, 111, 112, 112, 101, 100,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69, 
   82,  82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 104, 105, 115, 116, 
  111, 114, 121,  91, 120,  95, 105, 100,  93,  32,  61,  32, 116, 114, 117, 101, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95, 
   65, 114, 114,  97, 121,  80, 117, 115, 104,  40, 120, 115,  44,  32, 120,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 
  114,  99, 101,  49,  40, 120,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 100, 111,  95, 114, 
  101, 119, 114, 105, 116, 101,  40, 120,  41,  59,  10, 101, 110, 100,  59,  10, 
  102, 111, 114,  99, 101,  49,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 114,  97, 119,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 120,  32,  61,  32, 117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108, 
   40, 114,  97, 119,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 114, 101, 116,  59,  10,  32,  32,  32,  32,  65,  83,  83,  69,  82,  84, 
   40, 110, 111, 116,  32, 106, 117, 115, 116,  95, 112,  40, 120,  41,  41,  59, 
   10,  32,  32,  32,  32, 105, 102,  32, 100, 101, 108,  97, 121,  95, 101, 118, 
   97, 108, 117,  97, 116, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 114, 
  101,  97, 108,  95, 101, 118,  97, 108, 117,  97, 116, 101,  40, 100, 101, 108, 
   97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 101, 110, 118,  40, 
  120,  41,  44,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 
  116, 101,  95, 120,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 
  115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 102, 111, 114, 109,  95, 112,  40, 120,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 
  114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 
  109,  95,  97, 112, 112, 108, 121,  40, 100, 101, 108,  97, 121,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 101, 110, 118,  40, 120, 
   41,  44,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 102, 111, 114, 109,  95, 102,  40, 120,  41,  44,  32, 100, 101, 108,  97, 
  121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 120, 
  115,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 114, 101,  97, 
  108,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 
  112, 112, 108, 121,  40, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 102, 117, 110,  99,  95, 102,  40, 120,  41,  44,  32, 100, 101, 
  108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99, 
   95, 120, 115,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 
  101, 105, 102,  32, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 
  112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116,  32,  61,  32, 114, 101,  97, 108,  95,  97, 112, 112, 
  108, 121,  40, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 102, 
   40, 120,  41,  44,  32, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121, 
   95, 120, 115,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 
  120,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 
  101, 116,  32,  61,  32, 117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108, 
   40, 114, 101, 116,  41,  59,  10,  32,  32,  32,  32, 108,  97, 110, 103,  95, 
  115, 101, 116,  95, 100, 111,  40, 120,  44,  32, 114, 101, 116,  41,  59,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10, 
  101, 110, 100,  59,  10, 101, 110, 118,  95, 115, 101, 116,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118,  44,  32, 107, 101, 121, 
   44,  32, 118,  97, 108,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 114, 101, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 100, 
  111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 
  104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 101, 110, 118,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112, 
   40, 101, 110, 118,  91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32,  49, 
   93,  44,  32, 107, 101, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
   91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  32,  61,  32, 
  107, 101, 121,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116,  91,  40, 105,  32,  43,  32,  49,  41, 
   32,  43,  32,  49,  93,  32,  61,  32, 118,  97, 108,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  50,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 101, 
  110, 118,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116,  91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  32, 
   61,  32, 101, 110, 118,  91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32, 
   49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  91, 
   40, 105,  32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  32,  61,  32, 101, 
  110, 118,  91,  40, 105,  32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43, 
   32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
   91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  32,  61,  32, 
  101, 110, 118,  91,  40, 105,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116,  91,  40, 105,  32,  43,  32,  49,  41,  32,  43,  32, 
   49,  93,  32,  61,  32, 101, 110, 118,  91,  40, 105,  32,  43,  32,  49,  41, 
   32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  50,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 114, 101, 116,  91,  40,  40,  35, 101, 110, 118, 
   41,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  32,  61,  32, 107, 101, 
  121,  59,  10,  32,  32,  32,  32, 114, 101, 116,  91,  40,  40,  35, 101, 110, 
  118,  41,  32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  32,  61,  32, 118, 
   97, 108,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 
  101, 116,  59,  10, 101, 110, 100,  59,  10, 101, 110, 118,  95, 103, 101, 116, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118,  44, 
   32, 107, 101, 121,  44,  32, 100, 101, 102,  97, 117, 108, 116,  95, 118,  41, 
   10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40, 
   35, 101, 110, 118,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 
  113, 117,  97, 108,  95, 112,  40, 101, 110, 118,  91,  40, 105,  32,  43,  32, 
   48,  41,  32,  43,  32,  49,  93,  44,  32, 107, 101, 121,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 118,  91,  40, 105, 
   32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32, 
   50,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 100, 101, 102,  97, 117, 108, 116,  95, 118,  59,  10, 101, 110, 100, 
   59,  10, 109, 117, 115, 116,  95, 101, 110, 118,  95, 103, 101, 116,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118,  44,  32, 107, 
  101, 121,  41,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32, 
   60,  32,  40,  35, 101, 110, 118,  41,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 
  108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 101, 110, 118,  91,  40, 105, 
   32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  44,  32, 107, 101, 121,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 118, 
   91,  40, 105,  32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105, 
   32,  43,  32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 101, 110, 
  100,  59,  10, 101, 110, 118,  50, 118,  97, 108,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 101, 110, 118,  41,  10,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32, 110, 117, 108, 108,  95, 
  118,  59,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60, 
   32,  40,  35, 101, 110, 118,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 110, 101, 119, 
   95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  40, 110, 101, 
  119,  95, 108, 105, 115, 116,  40, 101, 110, 118,  91,  40, 105,  32,  43,  32, 
   48,  41,  32,  43,  32,  49,  93,  44,  32, 101, 110, 118,  91,  40, 105,  32, 
   43,  32,  49,  41,  32,  43,  32,  49,  93,  41,  44,  32, 114, 101, 116,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32, 
   61,  32, 105,  32,  43,  32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 100,  97, 116,  97, 
   40, 109,  97, 112, 112, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 114, 101, 116,  41,  41,  59, 
   10, 101, 110, 100,  59,  10, 101, 110, 118,  95, 102, 111, 114, 101,  97,  99, 
  104,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118, 
   44,  32, 102,  41,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105, 
   32,  60,  32,  40,  35, 101, 110, 118,  41,  32, 100, 111,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 102,  40, 101, 110, 118,  91,  40, 
  105,  32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  44,  32, 101, 110, 118, 
   91,  40, 105,  32,  43,  32,  49,  41,  32,  43,  32,  49,  93,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 
  105,  32,  43,  32,  50,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  10, 101, 110, 100,  59,  10, 
  114, 101,  97, 108,  95, 101, 118,  97, 108, 117,  97, 116, 101,  32,  61,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118,  44,  32, 114,  97, 
  119,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61, 
   32, 102, 111, 114,  99, 101,  49,  40, 114,  97, 119,  41,  59,  10,  32,  32, 
   32,  32, 105, 102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 
  117, 115, 116,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 118,  97, 
  108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120,  41,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 101, 114, 114, 111, 114,  95, 118,  32,  61,  32, 110, 101, 119,  95, 101, 
  114, 114, 111, 114,  40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 
  111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 117, 115, 
  101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 110, 101, 
  119,  95, 108, 105, 115, 116,  40, 101, 118,  97, 108, 117,  97, 116, 101,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 110, 101, 119, 
   95, 108, 105, 115, 116,  40, 101, 110, 118,  50, 118,  97, 108,  40, 101, 110, 
  118,  41,  44,  32, 120,  41,  41,  41,  41,  59,  10,  32,  32,  32,  32, 105, 
  102,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112, 
   40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 123, 125,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 
  115, 116,  32,  61,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  119, 104, 105, 108, 101,  32, 110, 111, 116,  32, 110, 117, 108, 108,  95, 112, 
   40, 114, 101, 115, 116,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32,  97, 110, 121,  95, 100, 101, 108, 
   97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 114, 101, 115, 116,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 118,  97, 108, 
  117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 
  114, 101, 115, 116,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95, 
   95,  65, 114, 114,  97, 121,  80, 117, 115, 104,  40, 120, 115,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100, 
   40, 114, 101, 115, 116,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 115, 116,  32,  61,  32, 
  102, 111, 114,  99, 101,  49,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 116,  97, 105, 108,  40, 114, 101, 115, 116,  41,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 
  101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 
  101, 113, 117,  97, 108,  95, 112,  40, 120, 115,  91,  48,  32,  43,  32,  49, 
   93,  44,  32, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32,  40,  35, 120, 115,  41,  32,  61,  61,  32,  49,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114, 
   95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 102,  32,  61,  32, 120, 115,  91,  49,  32,  43, 
   32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  32,  61,  32, 123, 125, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  50,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 
  105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 120, 115,  41,  32, 100, 111, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  97, 114, 103, 115,  91,  40, 105,  32,  45,  32,  50, 
   41,  32,  43,  32,  49,  93,  32,  61,  32, 120, 115,  91, 105,  32,  43,  32, 
   49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32, 
   49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 
  110,  95, 102, 111, 114, 109,  95,  97, 112, 112, 108, 121,  40, 101, 110, 118, 
   44,  32, 102,  44,  32,  97, 114, 103, 115,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 106, 115,  98, 111, 111, 
  108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 120, 115,  91,  48,  32,  43, 
   32,  49,  93,  44,  32, 102, 111, 114, 109,  95, 117, 115, 101,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  35, 
  120, 115,  41,  32,  61,  61,  32,  49,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  102,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 101, 118, 
   97, 108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120, 115,  91,  49, 
   32,  43,  32,  49,  93,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 100,  97, 116,  97, 
   95, 112,  40, 102,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  95, 116, 
  121, 112, 101,  32,  61,  32, 102, 111, 114,  99, 101,  49,  40, 100,  97, 116, 
   97,  95, 110,  97, 109, 101,  40, 102,  41,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  97, 110, 121,  95, 100, 
  101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 102,  95, 116, 121, 
  112, 101,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  101, 118,  97, 108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 110, 111, 116,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 102,  95, 
  116, 121, 112, 101,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 115, 121, 
  109,  98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102,  95, 116, 
  121, 112, 101,  44,  32, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 
  114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  95, 108, 105, 115, 116,  32, 
   61,  32, 102, 111, 114,  99, 101,  49,  40, 100,  97, 116,  97,  95, 108, 105, 
  115, 116,  40, 102,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121, 
   95, 106, 117, 115, 116,  95, 112,  40, 102,  95, 108, 105, 115, 116,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 118,  97, 108, 
  117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 
  102,  95, 108, 105, 115, 116,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102, 
   95, 120,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  40, 102,  95, 108, 105, 115, 116,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 102,  95, 108, 105, 115, 116,  95,  99, 100, 114,  32,  61,  32, 102, 
  111, 114,  99, 101,  49,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 116,  97, 105, 108,  40, 102,  95, 108, 105, 115, 116,  41,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 
  112,  40, 102,  95, 108, 105, 115, 116,  95,  99, 100, 114,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 118,  97, 108, 117,  97, 
  116, 101,  40, 101, 110, 118,  44,  32, 120,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 110, 
  117, 108, 108,  95, 112,  40, 102,  95, 108, 105, 115, 116,  95,  99, 100, 114, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 
  114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  32,  61,  32, 
  123, 101, 110, 118,  50, 118,  97, 108,  40, 101, 110, 118,  41, 125,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 105,  32,  61,  32,  50,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 
  101,  32, 105,  32,  60,  32,  40,  35, 120, 115,  41,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  97, 114, 103, 115,  91,  40, 105,  32,  45,  32,  49,  41,  32, 
   43,  32,  49,  93,  32,  61,  32, 120, 115,  91, 105,  32,  43,  32,  49,  93, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 112, 108, 121,  40, 102,  95, 
  120,  44,  32,  97, 114, 103, 115,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 108, 115, 101, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 
  101, 113, 117,  97, 108,  95, 112,  40, 120, 115,  91,  48,  32,  43,  32,  49, 
   93,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32,  40,  35, 120, 115,  41,  32,  61,  61, 
   32,  49,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 
  114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  32,  61,  32, 120, 115, 
   91,  49,  32,  43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  32, 
   61,  32, 123, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  50, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 120, 115, 
   41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  91,  40, 105, 
   32,  45,  32,  50,  41,  32,  43,  32,  49,  93,  32,  61,  32, 101, 118,  97, 
  108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120, 115,  91, 105,  32, 
   43,  32,  49,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105, 
   32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 
  102,  44,  32,  97, 114, 103, 115,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  32,  61,  32, 101, 118,  97, 
  108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120, 115,  91,  48,  32, 
   43,  32,  49,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  32,  61,  32, 
  123, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  49,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 120, 115,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  91,  40, 105,  32,  45, 
   32,  49,  41,  32,  43,  32,  49,  93,  32,  61,  32, 101, 118,  97, 108, 117, 
   97, 116, 101,  40, 101, 110, 118,  44,  32, 120, 115,  91, 105,  32,  43,  32, 
   49,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43, 
   32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 112, 108, 121, 
   40, 102,  44,  32,  97, 114, 103, 115,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 110, 117, 108, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 110,  97, 
  109, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 118,  95, 
  103, 101, 116,  40, 101, 110, 118,  44,  32, 120,  44,  32, 101, 114, 114, 111, 
  114,  95, 118,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102, 
   32, 101, 114, 114, 111, 114,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79, 
   82,  40,  41,  59,  10, 101, 110, 100,  59,  10, 110,  97, 109, 101,  95, 112, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 121, 109,  98, 111, 108, 
   95, 112,  40, 120,  41,  32, 111, 114,  32, 100,  97, 116,  97,  95, 112,  40, 
  120,  41,  59,  10, 101, 110, 100,  59,  10, 114, 101,  97, 108,  95,  97, 112, 
  112, 108, 121,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 102, 
   44,  32, 120, 115,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32, 
   32,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 118,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 101, 
  114, 114, 111, 114,  40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 
  111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 117, 115, 
  101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 110, 101, 
  119,  95, 108, 105, 115, 116,  40,  97, 112, 112, 108, 121,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 110, 101, 119,  95, 108, 105, 
  115, 116,  40, 102,  44,  32, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111, 
   95, 108, 105, 115, 116,  40, 120, 115,  41,  41,  41,  41,  41,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 102,  32,  61,  32, 
  102, 111, 114,  99, 101,  49,  40, 102,  41,  59,  10,  32,  32,  32,  32, 105, 
  102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 116, 
   95, 112,  40, 102,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 112, 108, 121,  40, 
  102,  44,  32, 120, 115,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 100,  97, 116,  97,  95, 
  112,  40, 102,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 101, 114, 
  114, 111, 114,  95, 118,  40,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  95, 116, 121, 112, 
  101,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 100,  97, 
  116,  97,  95, 110,  97, 109, 101,  40, 102,  41,  41,  59,  10,  32,  32,  32, 
   32, 105, 102,  32, 110, 111, 116,  32,  40, 115, 121, 109,  98, 111, 108,  95, 
  112,  40, 102,  95, 116, 121, 112, 101,  41,  32,  97, 110, 100,  32, 115, 121, 
  109,  98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102,  95, 116, 
  121, 112, 101,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 
  109,  98, 111, 108,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 
  101, 114, 114, 111, 114,  95, 118,  40,  41,  59,  10,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  95, 108, 
  105, 115, 116,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 
  100,  97, 116,  97,  95, 108, 105, 115, 116,  40, 102,  41,  41,  59,  10,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 112,  40, 102,  95, 108, 105, 115, 116,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 
  118,  40,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  95, 112,  97, 116,  32, 
   61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  95, 114, 101,  99,  40, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 
  100,  40, 102,  95, 108, 105, 115, 116,  41,  41,  59,  10,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 102,  95, 108, 105, 115, 116,  95,  99, 100, 114, 
   32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 102, 
   95, 108, 105, 115, 116,  41,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 
  110, 111, 116,  32,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 112,  40, 102,  95, 108, 105, 115, 116,  95,  99, 100, 114,  41,  32, 
   97, 110, 100,  32, 110, 117, 108, 108,  95, 112,  40, 102, 111, 114,  99, 101, 
   95,  97, 108, 108,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 116,  97, 105, 108,  40, 102,  95, 108, 105, 115, 116,  95,  99, 100, 
  114,  41,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 101, 
  114, 114, 111, 114,  95, 118,  40,  41,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102,  95,  99, 111, 
  100, 101,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  40, 102,  95, 108, 105, 115, 116,  95,  99, 100, 
  114,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 110, 
  118,  32,  61,  32, 101, 110, 118,  95, 110, 117, 108, 108,  95, 118,  59,  10, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  95, 105,  32,  61, 
   32,  48,  59,  10,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 110, 111, 
  116,  32, 110, 117, 108, 108,  95, 112,  40,  97, 114, 103, 115,  95, 112,  97, 
  116,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 110,  97, 109, 101,  95, 112,  40,  97, 114, 103, 115,  95, 112,  97, 116, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 110, 117, 108, 
  108,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  40,  35, 
  120, 115,  41,  32,  45,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105, 
   32,  62,  61,  32, 120, 115,  95, 105,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  120,  32,  61,  32, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  40, 120, 115,  91, 105,  32,  43,  32,  49,  93,  44,  32, 
  120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  45,  32, 
   49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 118,  32,  61,  32, 101, 110, 118,  95, 115, 101, 116, 
   40, 101, 110, 118,  44,  32,  97, 114, 103, 115,  95, 112,  97, 116,  44,  32, 
  120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  120, 115,  95, 105,  32,  61,  32,  35, 120, 115,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  95, 112,  97, 116, 
   32,  61,  32, 110, 117, 108, 108,  95, 118,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 112,  40,  97, 114, 103, 115,  95, 112,  97, 
  116,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 120, 115,  95, 105,  32,  60,  32,  40,  35, 
  120, 115,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 120, 115,  91, 120, 115,  95, 105,  32,  43,  32,  49,  93,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 120, 115,  95, 105,  32,  61,  32, 120, 115,  95, 105,  32,  43,  32,  49, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 118,  32,  61,  32, 101, 110, 118,  95, 115, 101, 116,  40, 
  101, 110, 118,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  40,  97, 114, 103, 115,  95, 112,  97, 116,  41, 
   44,  32, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  95, 112,  97, 116,  32,  61, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  40,  97, 114, 103, 115,  95, 112,  97, 116,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114, 
   95, 118,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 
  115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114, 
   95, 118,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 102, 
   32,  40,  35, 120, 115,  41,  32, 126,  61,  32, 120, 115,  95, 105,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 118,  40, 
   41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 101, 
  110, 118,  44,  32, 102,  95,  99, 111, 100, 101,  41,  59,  10, 101, 110, 100, 
   59,  10, 114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95,  97, 112, 112, 108, 121,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 102,  44,  32, 120, 115,  41,  10,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 101, 114, 114, 111, 114,  95, 118,  32,  61,  32, 
  110, 101, 119,  95, 101, 114, 114, 111, 114,  40, 115, 121, 115, 116, 101, 109, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102,  44,  32, 106, 
  115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  40, 120, 
  115,  41,  41,  41,  41,  59,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32, 
   48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101, 
   32, 105,  32,  60,  32,  40,  35, 114, 101,  97, 108,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  95, 115, 
   41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108, 
   95, 112,  40, 102,  44,  32, 114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  95, 115,  91, 
  105,  32,  43,  32,  49,  93,  91,  48,  32,  43,  32,  49,  93,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  97,  99, 116, 117,  97, 108, 
  108, 121,  95, 108, 101, 110, 103, 116, 104,  32,  61,  32, 114, 101,  97, 108, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 
  112, 108, 121,  95, 115,  91, 105,  32,  43,  32,  49,  93,  91,  49,  32,  43, 
   32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32,  40,  35, 120, 115,  41,  32, 126,  61, 
   32,  97,  99, 116, 117,  97, 108, 108, 121,  95, 108, 101, 110, 103, 116, 104, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 102,  32,  61,  32, 114, 101,  97, 108,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  95, 
  115,  91, 105,  32,  43,  32,  49,  93,  91,  50,  32,  43,  32,  49,  93,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32,  97,  99, 116, 117,  97, 108, 108, 121,  95, 108, 101, 110, 
  103, 116, 104,  32,  61,  61,  32,  49,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 102,  41,  40, 120, 115,  91, 
   48,  32,  43,  32,  49,  93,  44,  32, 101, 114, 114, 111, 114,  95, 118,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 108, 115, 101, 105, 102,  32,  97,  99, 116, 117,  97, 108, 108, 
  121,  95, 108, 101, 110, 103, 116, 104,  32,  61,  61,  32,  50,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 102, 
   41,  40, 120, 115,  91,  48,  32,  43,  32,  49,  93,  44,  32, 120, 115,  91, 
   49,  32,  43,  32,  49,  93,  44,  32, 101, 114, 114, 111, 114,  95, 118,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 108, 115, 101, 105, 102,  32,  97,  99, 116, 117,  97, 108, 108, 
  121,  95, 108, 101, 110, 103, 116, 104,  32,  61,  61,  32,  51,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 102, 
   41,  40, 120, 115,  91,  48,  32,  43,  32,  49,  93,  44,  32, 120, 115,  91, 
   49,  32,  43,  32,  49,  93,  44,  32, 120, 115,  91,  50,  32,  43,  32,  49, 
   93,  44,  32, 101, 114, 114, 111, 114,  95, 118,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61, 
   32, 105,  32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10, 
  101, 110, 100,  59,  10, 114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 102, 111, 114, 109,  95,  97, 112, 112, 108, 121,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 118,  44,  32, 102,  44,  32, 
  120, 115,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 114, 
  114, 111, 114,  95, 118,  32,  61,  32, 110, 101, 119,  95, 101, 114, 114, 111, 
  114,  40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 
  101, 110, 118,  50, 118,  97, 108,  40, 101, 110, 118,  41,  44,  32, 102,  44, 
   32, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116, 
   40, 120, 115,  41,  41,  41,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 
  106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102, 
   44,  32, 113, 117, 111, 116, 101,  95, 102, 111, 114, 109,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32,  40,  35, 120, 115,  41,  32, 126,  61,  32,  49,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 120, 115,  91,  48,  32,  43,  32,  49, 
   93,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 106, 115, 
   98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102,  44,  32, 
  108,  97, 109,  98, 100,  97,  95, 102, 111, 114, 109,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
   40,  35, 120, 115,  41,  32, 126,  61,  32,  50,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108,  97, 109,  98, 100, 
   97,  40, 101, 110, 118,  44,  32, 120, 115,  91,  48,  32,  43,  32,  49,  93, 
   44,  32, 120, 115,  91,  49,  32,  43,  32,  49,  93,  44,  32, 101, 114, 114, 
  111, 114,  95, 118,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 
  118,  59,  10, 101, 110, 100,  59,  10, 110, 101, 119,  95, 108,  97, 109,  98, 
  100,  97,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101, 110, 
  118,  44,  32,  97, 114, 103, 115,  95, 112,  97, 116,  44,  32,  98, 111, 100, 
  121,  44,  32, 101, 114, 114, 111, 114,  95, 118,  41,  10,  32,  32,  32,  32, 
  105, 102,  32, 101, 114, 114, 111, 114,  95, 118,  32,  61,  61,  32, 110, 105, 
  108,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  114, 114, 111, 114,  95, 118,  32,  61,  32, 102,  97, 108, 115, 101,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 118,  59,  10, 
   32,  32,  32,  32, 109,  97, 107, 101,  95, 101, 114, 114, 111, 114,  95, 118, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 114, 114, 111, 114,  95, 118, 
   32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 110, 101, 119,  95, 101, 114, 114, 111, 114,  40, 115, 121, 115, 116, 
  101, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 
  105, 115, 116,  40, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 101, 110, 118,  50, 118,  97, 
  108,  40, 101, 110, 118,  41,  44,  32, 108,  97, 109,  98, 100,  97,  95, 102, 
  111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  44,  32, 106, 115,  65, 114, 114,  97, 121,  95, 
  116, 111,  95, 108, 105, 115, 116,  40, 123,  97, 114, 103, 115,  95, 112,  97, 
  116,  44,  32,  98, 111, 100, 121, 125,  41,  41,  41,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 
  114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 109,  97, 107, 101,  95, 113, 117, 111, 116, 101, 
   59,  10,  32,  32,  32,  32, 109,  97, 107, 101,  95, 113, 117, 111, 116, 101, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 
  119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  44,  32, 113, 117, 111, 116, 101,  95, 102, 111, 114, 109,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 120,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10, 
   32,  32,  32,  32,  97, 114, 103, 115,  95, 112,  97, 116,  32,  61,  32, 102, 
  111, 114,  99, 101,  95,  97, 108, 108,  95, 114, 101,  99,  40,  97, 114, 103, 
  115,  95, 112,  97, 116,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 115,  32, 
   61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
   97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 115,  95, 100, 111, 116,  32, 
   61,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 116, 101, 114, 
   32,  61,  32,  97, 114, 103, 115,  95, 112,  97, 116,  59,  10,  32,  32,  32, 
   32, 119, 104, 105, 108, 101,  32, 110, 111, 116,  32, 110, 117, 108, 108,  95, 
  112,  40,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 116, 101, 114,  41, 
   32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 
   97, 109, 101,  95, 112,  40,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 
  116, 101, 114,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 
  121,  80, 117, 115, 104,  40,  97, 114, 103, 115,  95, 112,  97, 116,  95, 118, 
   97, 114, 115,  44,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 116, 
  101, 114,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 115,  95, 100, 111, 116, 
   32,  61,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 105, 116, 
  101, 114,  32,  61,  32, 110, 117, 108, 108,  95, 118,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40,  97, 114, 103, 115,  95, 
  112,  97, 116,  95, 105, 116, 101, 114,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95, 
   95,  65, 114, 114,  97, 121,  80, 117, 115, 104,  40,  97, 114, 103, 115,  95, 
  112,  97, 116,  95, 118,  97, 114, 115,  44,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40,  97, 114, 103, 115, 
   95, 112,  97, 116,  95, 105, 116, 101, 114,  41,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  95, 112,  97, 
  116,  95, 105, 116, 101, 114,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40,  97, 114, 103, 115,  95, 
  112,  97, 116,  95, 105, 116, 101, 114,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 107, 101,  95, 
  101, 114, 114, 111, 114,  95, 118,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32,  97, 114, 103, 115,  95, 112,  97, 
  116,  95, 118,  97, 114, 115,  95, 118,  97, 108,  32,  61,  32,  97, 114, 103, 
  115,  95, 112,  97, 116,  59,  10,  32,  32,  32,  32, 105, 102,  32,  97, 114, 
  103, 115,  95, 112,  97, 116,  95, 105, 115,  95, 100, 111, 116,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  97, 114, 103, 115,  95, 
  112,  97, 116,  95, 118,  97, 114, 115,  95, 118,  97, 108,  32,  61,  32, 106, 
  115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  40,  97, 
  114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 115,  41,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 101, 110, 118,  95, 118,  97, 114, 115,  32,  61,  32, 123, 125,  59,  10, 
   32,  32,  32,  32, 101, 110, 118,  95, 102, 111, 114, 101,  97,  99, 104,  40, 
  101, 110, 118,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 107,  44, 
   32, 118,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 
   97, 114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 115,  41,  32, 100, 
  111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 
  108,  95, 112,  40,  97, 114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 
  115,  91, 105,  32,  43,  32,  49,  93,  44,  32, 107,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121,  80, 117, 115, 104, 
   40, 101, 110, 118,  95, 118,  97, 114, 115,  44,  32, 107,  41,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 110, 101, 119,  95,  97, 114, 103, 115,  95, 112,  97, 116,  32, 
   61,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 115,  95, 
  118,  97, 108,  59,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  40,  35, 
  101, 110, 118,  95, 118,  97, 114, 115,  41,  32,  45,  32,  49,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  62, 
   61,  32,  48,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 110, 101, 119,  95,  97, 114, 103, 115,  95, 112,  97, 116,  32, 
   61,  32, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  40, 101, 110, 118,  95, 118,  97, 114, 115,  91, 105,  32,  43,  32, 
   49,  93,  44,  32, 110, 101, 119,  95,  97, 114, 103, 115,  95, 112,  97, 116, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
   32,  61,  32, 105,  32,  45,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 110, 101, 119,  95,  97, 114, 103, 115, 
   32,  61,  32,  97, 114, 103, 115,  95, 112,  97, 116,  95, 118,  97, 114, 115, 
   95, 118,  97, 108,  59,  10,  32,  32,  32,  32, 100, 111,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  40, 
   35, 101, 110, 118,  95, 118,  97, 114, 115,  41,  32,  45,  32,  49,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32, 
   62,  61,  32,  48,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 110, 101, 119,  95,  97, 114, 103, 115,  32,  61,  32, 110, 
  101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  40, 
  109,  97, 107, 101,  95, 113, 117, 111, 116, 101,  40, 109, 117, 115, 116,  95, 
  101, 110, 118,  95, 103, 101, 116,  40, 101, 110, 118,  44,  32, 101, 110, 118, 
   95, 118,  97, 114, 115,  91, 105,  32,  43,  32,  49,  93,  41,  41,  44,  32, 
  110, 101, 119,  95,  97, 114, 103, 115,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  45,  32,  49, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 110, 101, 119,  95, 100,  97, 116,  97,  40, 102, 117, 110,  99, 116, 105, 
  111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 
  105, 115, 116,  40,  97, 114, 103, 115,  95, 112,  97, 116,  44,  32, 110, 101, 
  119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  40, 109, 
   97, 107, 101,  95, 113, 117, 111, 116, 101,  40, 110, 101, 119,  95, 100,  97, 
  116,  97,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 
  111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 110, 101, 119, 
   95,  97, 114, 103, 115,  95, 112,  97, 116,  44,  32,  98, 111, 100, 121,  41, 
   41,  41,  44,  32, 110, 101, 119,  95,  97, 114, 103, 115,  41,  41,  41,  59, 
   10, 101, 110, 100,  59,  10, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117, 
   97, 108,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
  120,  44,  32, 121,  41,  10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61, 
   61,  32, 121,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 
  114,  99, 101,  95,  97, 108, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32, 
  121,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 121,  41, 
   59,  10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 121,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 110, 100,  95, 
   50,  59,  10,  32,  32,  32,  32, 101, 110, 100,  95,  50,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  44,  32, 102,  49, 
   44,  32, 102,  50,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 
  102,  49,  40, 120,  41,  44,  32, 102,  49,  40, 121,  41,  41,  32,  97, 110, 
  100,  32, 106, 115,  98, 111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112, 
   40, 102,  50,  40, 120,  41,  44,  32, 102,  50,  40, 121,  41,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108,  97, 110, 103,  95, 115, 101, 116,  95, 100, 111,  40, 120,  44,  32, 121, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 
  101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 105, 102,  32, 110, 
  117, 108, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 110, 117, 108, 
  108,  95, 112,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 
   97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 110, 103,  95, 115, 
  101, 116,  95, 100, 111,  40, 120,  44,  32, 110, 117, 108, 108,  95, 118,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 110, 103,  95, 115, 
  101, 116,  95, 100, 111,  40, 121,  44,  32, 110, 117, 108, 108,  95, 118,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 
  116,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 121,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 115, 121, 109,  98, 111, 108,  95, 101, 
  113, 117,  97, 108,  95, 112,  40, 120,  44,  32, 121,  41,  59,  10,  32,  32, 
   32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 121,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 100,  95,  50, 
   40, 120,  44,  32, 121,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 104, 101,  97, 100,  44,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  41,  59,  10,  32,  32, 
   32,  32, 101, 108, 115, 101, 105, 102,  32, 101, 114, 114, 111, 114,  95, 112, 
   40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 110, 111, 116,  32, 101, 114, 114, 111, 114,  95, 112,  40, 
  121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 100, 
   95,  50,  40, 120,  44,  32, 121,  44,  32, 101, 114, 114, 111, 114,  95, 110, 
   97, 109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  41, 
   59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100,  97, 116, 
   97,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 100,  97, 116,  97,  95, 
  112,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 
  110, 100,  95,  50,  40, 120,  44,  32, 121,  44,  32, 100,  97, 116,  97,  95, 
  110,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 108, 105, 115, 116,  41, 
   59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 101, 110, 
  100,  59,  10, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32, 
   32,  32, 120,  32,  61,  32, 117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 
  108,  40, 120,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  116, 101, 109, 112,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 112, 114, 101, 102, 105, 120,  32,  61,  32,  34,  34, 
   59,  10,  32,  32,  32,  32, 105, 102,  32, 110, 117, 108, 108,  95, 112,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32,  34,  40,  41,  34,  59,  10,  32,  32,  32, 
   32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32,  34,  40, 
   34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101, 102, 105, 
  120,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  119, 104, 105, 108, 101,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 112,  40, 120,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 
  109, 112,  32,  46,  46,  32,  40, 112, 114, 101, 102, 105, 120,  32,  46,  46, 
   32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 
  120,  41,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 112, 114, 101, 102, 105, 120,  32,  61,  32,  34,  32,  34,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 
  117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108,  40,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120,  41, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 117, 108, 108,  95, 112, 
   40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 109, 112, 
   32,  46,  46,  32,  34,  41,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 109, 112,  32,  46,  46, 
   32,  40,  40,  34,  32,  46,  32,  34,  32,  46,  46,  32, 115, 105, 109, 112, 
  108, 101,  95, 112, 114, 105, 110, 116,  40, 120,  41,  41,  32,  46,  46,  32, 
   34,  41,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 116, 101, 109, 112,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 100,  97, 116,  97,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
   34,  35,  34,  32,  46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 
  105, 110, 116,  40, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  40, 100,  97, 116,  97,  95, 110,  97, 109, 101,  40, 120, 
   41,  44,  32, 100,  97, 116,  97,  95, 108, 105, 115, 116,  40, 120,  41,  41, 
   41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 101, 114, 
  114, 111, 114,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  33,  34, 
   32,  46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116, 
   40, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  40, 101, 114, 114, 111, 114,  95, 110,  97, 109, 101,  40, 120,  41,  44, 
   32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  40, 120,  41,  41,  41, 
   59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 115, 121, 109, 
   98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 117, 110,  95, 
  115, 121, 109,  98, 111, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32, 101, 
  108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 
  117,  97, 116, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  40, 
   40,  34,  36,  40,  34,  32,  46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 
  112, 114, 105, 110, 116,  40, 101, 110, 118,  50, 118,  97, 108,  40, 100, 101, 
  108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 101, 110, 118, 
   40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  32,  34,  41,  32,  46, 
   46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 100, 
  101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 120,  40, 
  120,  41,  41,  41,  32,  46,  46,  32,  34,  41,  34,  59,  10,  32,  32,  32, 
   32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 112,  40, 120,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32,  40,  40,  40,  34,  37,  40,  34,  32,  46,  46,  32, 115, 
  105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 100, 101, 108,  97, 
  121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 102, 
   40, 120,  41,  41,  41,  32,  46,  46,  32,  34,  32,  34,  41,  32,  46,  46, 
   32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 106, 115, 
   65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  40, 100, 101, 
  108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99, 
   95, 120, 115,  40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  41,  34, 
   59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108, 
   97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 
  112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  40,  40,  40,  40,  34,  64, 
   40,  34,  32,  46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 
  110, 116,  40, 101, 110, 118,  50, 118,  97, 108,  40, 100, 101, 108,  97, 121, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 101, 110, 
  118,  40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  32,  34,  41,  32, 
   46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 
  100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 
  114, 109,  95, 102,  40, 120,  41,  41,  41,  32,  46,  46,  32,  34,  32,  34, 
   41,  32,  46,  46,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 
  116,  40, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 
  116,  40, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 111, 114, 109,  95, 120, 115,  40, 120,  41,  41,  41,  41,  32,  46,  46, 
   32,  34,  41,  34,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102, 
   32, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32,  40,  40,  40,  34,  94,  40,  34,  32,  46,  46, 
   32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 100, 101, 
  108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 102,  40, 120,  41,  41,  41, 
   32,  46,  46,  32,  34,  32,  34,  41,  32,  46,  46,  32, 115, 105, 109, 112, 
  108, 101,  95, 112, 114, 105, 110, 116,  40, 106, 115,  65, 114, 114,  97, 121, 
   95, 116, 111,  95, 108, 105, 115, 116,  40, 100, 101, 108,  97, 121,  95,  97, 
  112, 112, 108, 121,  95, 120, 115,  40, 120,  41,  41,  41,  41,  32,  46,  46, 
   32,  34,  41,  34,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41, 
   59,  10, 101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 115, 121, 109, 
   98, 111, 108,  95, 116,  32,  61,  32,  48,  59,  10,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 116,  32,  61,  32,  49,  59,  10, 110, 
  117, 108, 108,  95, 116,  32,  61,  32,  50,  59,  10, 100,  97, 116,  97,  95, 
  116,  32,  61,  32,  51,  59,  10, 101, 114, 114, 111, 114,  95, 116,  32,  61, 
   32,  52,  59,  10, 106, 117, 115, 116,  95, 116,  32,  61,  32,  53,  59,  10, 
  100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 116, 
   32,  61,  32,  54,  59,  10, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102, 117, 110,  99,  95, 116,  32,  61,  32,  55,  59,  10, 
  100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 
  114, 109,  95, 116,  32,  61,  32,  56,  59,  10, 100, 101, 108,  97, 121,  95, 
   97, 112, 112, 108, 121,  95, 116,  32,  61,  32,  57,  59,  10, 108, 111,  99, 
   97, 108,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  59,  10, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 123, 115, 121, 109,  98, 111, 108,  95, 116,  44,  32, 120, 125, 
   59,  10, 101, 110, 100,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 
  115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 
  115, 121, 109,  98, 111, 108,  95, 112,  32,  61,  32, 115, 121, 109,  98, 111, 
  108,  95, 112,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 117, 110,  95, 
  115, 121, 109,  98, 111, 108,  32,  61,  32, 117, 110,  95, 115, 121, 109,  98, 
  111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 101, 119,  95, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  32,  61,  32, 110, 
  101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 112,  32,  61,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 112,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 
  101,  97, 100,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 104, 101,  97, 100,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 116,  97, 105, 108,  59,  10, 110, 117, 108, 108,  95, 118,  32,  61, 
   32, 123, 110, 117, 108, 108,  95, 116, 125,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 110, 117, 108, 108,  95, 118,  32,  61,  32, 110, 117, 108, 108, 
   95, 118,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 117, 108, 108, 
   95, 112,  32,  61,  32, 110, 117, 108, 108,  95, 112,  59,  10, 101, 120, 112, 
  111, 114, 116, 115,  46, 110, 101, 119,  95, 100,  97, 116,  97,  32,  61,  32, 
  110, 101, 119,  95, 100,  97, 116,  97,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46, 100,  97, 116,  97,  95, 112,  32,  61,  32, 100,  97, 116,  97,  95, 
  112,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 100,  97, 116,  97,  95, 
  110,  97, 109, 101,  32,  61,  32, 100,  97, 116,  97,  95, 110,  97, 109, 101, 
   59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 100,  97, 116,  97,  95, 108, 
  105, 115, 116,  32,  61,  32, 100,  97, 116,  97,  95, 108, 105, 115, 116,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 101, 119,  95, 101, 114, 114, 
  111, 114,  32,  61,  32, 110, 101, 119,  95, 101, 114, 114, 111, 114,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 101, 114, 114, 111, 114,  95, 112,  32, 
   61,  32, 101, 114, 114, 111, 114,  95, 112,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 101, 114, 114, 111, 114,  95, 110,  97, 109, 101,  32,  61,  32, 
  101, 114, 114, 111, 114,  95, 110,  97, 109, 101,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  32,  61, 
   32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  59,  10, 101, 120, 112, 
  111, 114, 116, 115,  46, 101, 118,  97, 108, 117,  97, 116, 101,  32,  61,  32, 
  101, 118,  97, 108, 117,  97, 116, 101,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46,  97, 112, 112, 108, 121,  32,  61,  32,  97, 112, 112, 108, 121,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 111, 114,  99, 101,  95,  97, 
  108, 108,  95, 114, 101,  99,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 
  108, 108,  95, 114, 101,  99,  59,  10, 115, 121, 115, 116, 101, 109,  95, 115, 
  121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 
  111, 108,  40,  34, 229, 164, 170, 229, 167, 139, 229, 136, 157, 230, 160, 184, 
   34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 110,  97, 109, 101,  95, 115, 
  121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 
  111, 108,  40,  34, 231, 172, 166, 229, 144, 141,  34,  41,  59,  10, 102, 117, 
  110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 
  110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 229, 140, 150, 230, 
  187, 133,  34,  41,  59,  10, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 
  229, 188, 143, 229, 189, 162,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 
  101, 113, 117,  97, 108,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 231, 173, 137, 229, 144, 
  140,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 101, 118,  97, 108, 117, 
   97, 116, 101,  95, 115, 121, 109,  32,  61,  32, 110, 101, 119,  95, 115, 121, 
  109,  98, 111, 108,  40,  34, 232, 167, 163, 231, 174, 151,  34,  41,  59,  10, 
  108, 111,  99,  97, 108,  32, 116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 
  121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 
  111, 108,  40,  34, 231, 137, 185, 229, 174, 154, 229, 133, 182, 231, 137, 169, 
   34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 115, 111, 109, 101, 116, 104, 
  105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119, 
   95, 115, 121, 109,  98, 111, 108,  40,  34, 231, 156, 129, 231, 149, 165, 228, 
  184, 128, 231, 137, 169,  34,  41,  59,  10, 109,  97, 112, 112, 105, 110, 103, 
   95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 
  109,  98, 111, 108,  40,  34, 230, 152, 160, 232, 161, 168,  34,  41,  59,  10, 
  108, 111,  99,  97, 108,  32, 105, 102,  95, 115, 121, 109,  98, 111, 108,  32, 
   61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 232, 139, 
  165,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 116, 121, 112, 101,  65, 
  110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108, 
   32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 228, 
  184, 128, 233, 161, 158, 228, 189, 149, 231, 137, 169,  34,  41,  59,  10, 108, 
  111,  99,  97, 108,  32, 105, 115,  79, 114,  78, 111, 116,  95, 115, 121, 109, 
   98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108, 
   40,  34, 230, 152, 175, 233, 157, 158,  34,  41,  59,  10, 108, 111,  99,  97, 
  108,  32, 115, 117,  98,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 229, 133, 182, 229, 173, 
  144,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 116, 114, 117, 101,  95, 
  115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109, 
   98, 111, 108,  40,  34, 233, 153, 189,  34,  41,  59,  10, 108, 111,  99,  97, 
  108,  32, 102,  97, 108, 115, 101,  95, 115, 121, 109,  98, 111, 108,  32,  61, 
   32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 233, 153, 176, 
   34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 113, 117, 111, 116, 101,  95, 
  115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109, 
   98, 111, 108,  40,  34, 229, 188, 149, 231, 148, 168,  34,  41,  59,  10, 108, 
  111,  99,  97, 108,  32,  97, 112, 112, 108, 121,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 
  230, 135, 137, 231, 148, 168,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 
  110, 117, 108, 108,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 
  119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 231, 169, 186,  34,  41,  59, 
   10, 108, 111,  99,  97, 108,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119, 
   95, 115, 121, 109,  98, 111, 108,  40,  34, 233, 128, 163,  34,  41,  59,  10, 
  108, 111,  99,  97, 108,  32, 100,  97, 116,  97,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 
  230, 167, 139,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 101, 114, 114, 
  111, 114,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 
  115, 121, 109,  98, 111, 108,  40,  34, 232, 170, 164,  34,  41,  59,  10, 108, 
  111,  99,  97, 108,  32, 115, 121, 109,  98, 111, 108,  95, 115, 121, 109,  98, 
  111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40, 
   34, 232, 169, 158, 231, 180, 160,  34,  41,  59,  10, 108, 111,  99,  97, 108, 
   32, 108, 105, 115, 116,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  40,  34, 229, 136, 151,  34,  41, 
   59,  10, 108, 111,  99,  97, 108,  32, 104, 101,  97, 100,  95, 115, 121, 109, 
   98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108, 
   40,  34, 233, 166, 150,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 116, 
   97, 105, 108,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119, 
   95, 115, 121, 109,  98, 111, 108,  40,  34, 229, 176, 190,  34,  41,  59,  10, 
  108, 111,  99,  97, 108,  32, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 
  111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108,  40, 
   34, 231, 137, 169,  34,  41,  59,  10, 108, 111,  99,  97, 108,  32, 116, 104, 
  101,  87, 111, 114, 108, 100,  83, 116, 111, 112, 112, 101, 100,  95, 115, 121, 
  109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 
  108,  40,  34, 229, 174, 135, 229, 174, 153, 228, 186, 161, 231, 159, 163,  34, 
   41,  59,  10, 108, 111,  99,  97, 108,  32, 101, 102, 102, 101,  99, 116,  95, 
  115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109, 
   98, 111, 108,  40,  34, 230, 149, 136, 230, 135, 137,  34,  41,  59,  10, 108, 
  111,  99,  97, 108,  32, 115, 101, 113, 117, 101, 110, 116, 105,  97, 108,  87, 
  111, 114, 100,  70, 111, 114, 109,  97, 116, 105, 111, 110,  95, 115, 121, 109, 
   98, 111, 108,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 111, 108, 
   40,  34, 231, 130, 186, 231, 172, 166, 229, 144, 141, 233, 128, 163,  34,  41, 
   59,  10, 108, 111,  99,  97, 108,  32, 105, 110, 112, 117, 116,  79, 117, 116, 
  112, 117, 116,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 110, 101, 119, 
   95, 115, 121, 109,  98, 111, 108,  40,  34, 229, 135, 186, 229, 133, 165, 230, 
  148, 185, 230, 187, 133,  34,  41,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  32,  61, 
   32, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 110,  97, 109, 101,  95, 115, 121, 109, 
   98, 111, 108,  32,  61,  32, 110,  97, 109, 101,  95, 115, 121, 109,  98, 111, 
  108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 117, 110,  99, 116, 
  105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 
  112, 111, 114, 116, 115,  46, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 113, 117,  97, 108,  95, 115, 
  121, 109,  98, 111, 108,  32,  61,  32, 101, 113, 117,  97, 108,  95, 115, 121, 
  109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 118, 
   97, 108, 117,  97, 116, 101,  95, 115, 121, 109,  32,  61,  32, 101, 118,  97, 
  108, 117,  97, 116, 101,  95, 115, 121, 109,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 
  111, 108,  32,  61,  32, 116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 121, 
  109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 115, 111, 
  109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  32,  61, 
   32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 
  108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 109,  97, 112, 112, 105, 
  110, 103,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 109,  97, 112, 112, 
  105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 105, 102,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 
  105, 102,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 
  110,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 116, 121, 112, 101,  65, 
  110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108, 
   59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 105, 115,  79, 114,  78, 111, 
  116,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 105, 115,  79, 114,  78, 
  111, 116,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 115, 117,  98,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 
  115, 117,  98,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 116, 114, 117, 101,  95, 115, 121, 109,  98, 111, 108,  32, 
   61,  32, 116, 114, 117, 101,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 
  120, 112, 111, 114, 116, 115,  46, 102,  97, 108, 115, 101,  95, 115, 121, 109, 
   98, 111, 108,  32,  61,  32, 102,  97, 108, 115, 101,  95, 115, 121, 109,  98, 
  111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 113, 117, 111, 116, 
  101,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 113, 117, 111, 116, 101, 
   95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46,  97, 112, 112, 108, 121,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 
   97, 112, 112, 108, 121,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 
  112, 111, 114, 116, 115,  46, 110, 117, 108, 108,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 110, 117, 108, 108,  95, 115, 121, 109,  98, 111, 108,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 
  111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 100,  97, 116,  97, 
   95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 100,  97, 116,  97,  95, 115, 
  121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 
  114, 114, 111, 114,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 101, 114, 
  114, 111, 114,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 115, 121, 109,  98, 111, 108,  95, 115, 121, 109,  98, 111, 
  108,  32,  61,  32, 115, 121, 109,  98, 111, 108,  95, 115, 121, 109,  98, 111, 
  108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 108, 105, 115, 116,  95, 
  115, 121, 109,  98, 111, 108,  32,  61,  32, 108, 105, 115, 116,  95, 115, 121, 
  109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 104, 101, 
   97, 100,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 104, 101,  97, 100, 
   95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46, 116,  97, 105, 108,  95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 116, 
   97, 105, 108,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108, 
   32,  61,  32, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 116, 104, 101,  87, 111, 114, 108, 
  100,  83, 116, 111, 112, 112, 101, 100,  95, 115, 121, 109,  98, 111, 108,  32, 
   61,  32, 116, 104, 101,  87, 111, 114, 108, 100,  83, 116, 111, 112, 112, 101, 
  100,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46, 101, 102, 102, 101,  99, 116,  95, 115, 121, 109,  98, 111, 108,  32, 
   61,  32, 101, 102, 102, 101,  99, 116,  95, 115, 121, 109,  98, 111, 108,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 115, 101, 113, 117, 101, 110, 116, 
  105,  97, 108,  87, 111, 114, 100,  70, 111, 114, 109,  97, 116, 105, 111, 110, 
   95, 115, 121, 109,  98, 111, 108,  32,  61,  32, 115, 101, 113, 117, 101, 110, 
  116, 105,  97, 108,  87, 111, 114, 100,  70, 111, 114, 109,  97, 116, 105, 111, 
  110,  95, 115, 121, 109,  98, 111, 108,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46, 105, 110, 112, 117, 116,  79, 117, 116, 112, 117, 116,  95, 115, 121, 
  109,  98, 111, 108,  32,  61,  32, 105, 110, 112, 117, 116,  79, 117, 116, 112, 
  117, 116,  95, 115, 121, 109,  98, 111, 108,  59,  10, 116, 104, 101,  95, 119, 
  111, 114, 108, 100,  95, 115, 116, 111, 112, 112, 101, 100,  95, 118,  32,  61, 
   32, 110, 101, 119,  95, 101, 114, 114, 111, 114,  40, 115, 121, 115, 116, 101, 
  109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 
  115, 116,  40, 116, 104, 101,  87, 111, 114, 108, 100,  83, 116, 111, 112, 112, 
  101, 100,  95, 115, 121, 109,  98, 111, 108,  44,  32, 115, 111, 109, 101, 116, 
  104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  41,  59,  10, 108, 
  111,  99,  97, 108,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 
  109,  97, 107, 101,  59,  10, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   95, 109,  97, 107, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 
  101, 119,  95, 100,  97, 116,  97,  40, 110,  97, 109, 101,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 115, 121, 
  115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  41,  41, 
   59,  10, 101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 109,  97, 107, 
  101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 110, 101, 119,  95, 
  115, 121, 109,  95, 102,  59,  10, 109,  97, 107, 101,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 102,  95, 110, 101, 119,  95, 115, 121, 109,  95, 102,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  95, 115, 121, 109, 
   41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 107, 101,  40, 110, 101, 119, 
   95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 
  116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119, 
   95, 108, 105, 115, 116,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 
  121, 109,  98, 111, 108,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  95, 115, 121, 109,  41,  44, 
   32, 116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108, 
   41,  41,  59,  10, 101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 109, 
   97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 103, 101, 
  116,  95, 115, 121, 109,  95, 102,  59,  10, 109,  97, 107, 101,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102,  95, 103, 101, 116,  95, 115, 121, 109,  95, 
  102,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 116,  95, 115, 
  121, 109,  44,  32, 120,  95, 115, 121, 109,  41,  10,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 
  121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 
  109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 
  117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  110, 101, 119,  95, 108, 105, 115, 116,  40, 116,  95, 115, 121, 109,  41,  44, 
   32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 
  108,  41,  44,  32, 120,  95, 115, 121, 109,  41,  41,  59,  10, 101, 110, 100, 
   59,  10, 108, 111,  99,  97, 108,  32, 109,  97, 107, 101,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102,  95, 112,  95, 115, 121, 109,  95, 102,  59,  10, 
  109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 112, 
   95, 115, 121, 109,  95, 102,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 116,  95, 115, 121, 109,  41,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 109, 
   97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 
  101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 
  111, 108,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 105, 115, 
   79, 114,  78, 111, 116,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 
  119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116, 
   97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 116,  95, 
  115, 121, 109,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 
  121, 109,  98, 111, 108,  41,  41,  41,  41,  59,  10, 101, 110, 100,  59,  10, 
  108, 111,  99,  97, 108,  32, 110, 101, 119,  95, 100,  97, 116,  97,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 107, 
  101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 110, 101, 119,  95, 
  115, 121, 109,  95, 102,  40, 100,  97, 116,  97,  95, 115, 121, 109,  98, 111, 
  108,  41,  59,  10, 100,  97, 116,  97,  95, 110,  97, 109, 101,  95, 102, 117, 
  110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 
  121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 107, 101, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 103, 101, 116,  95, 115, 
  121, 109,  95, 102,  40, 100,  97, 116,  97,  95, 115, 121, 109,  98, 111, 108, 
   44,  32, 110,  97, 109, 101,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10, 
  100,  97, 116,  97,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 102,  95, 103, 101, 116,  95, 115, 121, 109,  95, 102, 
   40, 100,  97, 116,  97,  95, 115, 121, 109,  98, 111, 108,  44,  32, 108, 105, 
  115, 116,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10, 100,  97, 116,  97, 
   95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 
  112,  95, 115, 121, 109,  95, 102,  40, 100,  97, 116,  97,  95, 115, 121, 109, 
   98, 111, 108,  41,  59,  10, 108, 111,  99,  97, 108,  32, 110, 101, 119,  95, 
  101, 114, 114, 111, 114,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 102,  95, 110, 101, 119,  95, 115, 121, 109,  95, 102,  40, 101, 114, 114, 
  111, 114,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10, 101, 114, 114, 111, 
  114,  95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 102,  95, 103, 101, 116,  95, 115, 121, 109,  95, 102,  40, 101, 114, 
  114, 111, 114,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110,  97, 109, 101, 
   95, 115, 121, 109,  98, 111, 108,  41,  59,  10, 101, 114, 114, 111, 114,  95, 
  108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102,  95, 103, 101, 116,  95, 115, 121, 109,  95, 102,  40, 101, 114, 114, 111, 
  114,  95, 115, 121, 109,  98, 111, 108,  44,  32, 108, 105, 115, 116,  95, 115, 
  121, 109,  98, 111, 108,  41,  59,  10, 101, 114, 114, 111, 114,  95, 112,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 
  107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 112,  95, 115, 
  121, 109,  95, 102,  40, 101, 114, 114, 111, 114,  95, 115, 121, 109,  98, 111, 
  108,  41,  59,  10, 108, 111,  99,  97, 108,  32, 110, 101, 119,  95,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102,  95, 110, 101, 119,  95, 115, 121, 109,  95, 
  102,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 115, 
  121, 109,  98, 111, 108,  41,  59,  10,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 102,  95, 112,  95, 115, 121, 109,  95, 102,  40,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  41, 
   59,  10,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 
  101,  97, 100,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32, 
   61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
   95, 103, 101, 116,  95, 115, 121, 109,  95, 102,  40,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  104, 101,  97, 100,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 
  107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 103, 101, 116, 
   95, 115, 121, 109,  95, 102,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 116,  97, 105, 108, 
   95, 115, 121, 109,  98, 111, 108,  41,  59,  10, 115, 121, 109,  98, 111, 108, 
   95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 
  112,  95, 115, 121, 109,  95, 102,  40, 115, 121, 109,  98, 111, 108,  95, 115, 
  121, 109,  98, 111, 108,  41,  59,  10, 110, 117, 108, 108,  95, 112,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 109,  97, 107, 
  101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102,  95, 112,  95, 115, 121, 
  109,  95, 102,  40, 110, 117, 108, 108,  95, 115, 121, 109,  98, 111, 108,  41, 
   59,  10, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116, 
   40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 
  115, 121, 109,  98, 111, 108,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 105, 115,  79, 114,  78, 111, 116,  95, 115, 121, 109,  98, 111, 108, 
   44,  32, 101, 113, 117,  97, 108,  95, 115, 121, 109,  98, 111, 108,  41,  41, 
   41,  59,  10,  97, 112, 112, 108, 121,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 
  116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 
  121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 
  102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 
  108,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109, 
   98, 111, 108,  41,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 
  115, 121, 109,  98, 111, 108,  41,  44,  32,  97, 112, 112, 108, 121,  95, 115, 
  121, 109,  98, 111, 108,  41,  41,  59,  10, 101, 118,  97, 108, 117,  97, 116, 
  101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 107, 101,  40, 
  110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 
  111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 101, 118,  97, 108, 117,  97, 116, 101,  95, 115, 121, 109,  41,  41,  59, 
   10, 108, 111,  99,  97, 108,  32, 108, 105, 115, 116,  95,  99, 104, 111, 111, 
  115, 101,  79, 110, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  32,  61,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 102,  95, 103, 101, 116,  95, 115, 121, 109,  95, 102,  40, 108, 105, 115, 
  116,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 
  115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 
  110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 116, 104, 105, 110, 103,  95, 
  115, 121, 109,  98, 111, 108,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 
  103,  95, 115, 121, 109,  98, 111, 108,  41,  41,  59,  10, 105, 102,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 107, 101,  40, 110, 101, 119, 
   95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 
  116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 105, 102, 
   95, 115, 121, 109,  98, 111, 108,  41,  41,  59,  10, 113, 117, 111, 116, 101, 
   95, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 
  105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 
  111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 102, 111, 114, 109,  95, 
  115, 121, 109,  98, 111, 108,  44,  32, 113, 117, 111, 116, 101,  95, 115, 121, 
  109,  98, 111, 108,  41,  41,  59,  10, 108,  97, 109,  98, 100,  97,  95, 102, 
  111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 
  101, 119,  95, 108, 105, 115, 116,  40, 102, 117, 110,  99, 116, 105, 111, 110, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 115, 111, 109, 101, 116, 104, 105, 
  110, 103,  95, 115, 121, 109,  98, 111, 108,  44,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  41,  41,  44,  32, 116, 104, 
  101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  41,  59, 
   10, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   32,  61,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 
  107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108, 
   41,  41,  41,  59,  10, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   32,  61,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 
  107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108,  41,  41,  41,  59, 
   10, 102, 111, 114, 109,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  95, 109,  97, 107, 101,  40, 110, 101, 119,  95, 108, 105, 115, 116,  40, 
  102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 102, 111, 114, 
  109,  95, 115, 121, 109,  98, 111, 108,  41,  41,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 110, 101, 119,  95, 100,  97, 116,  97,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 110, 101, 119,  95, 100, 
   97, 116,  97,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 100,  97, 116,  97,  95, 110,  97, 
  109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32, 100,  97, 116,  97,  95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 
  100,  97, 116,  97,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  32,  61,  32, 100,  97, 116,  97,  95, 108, 105, 115, 
  116,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 
  120, 112, 111, 114, 116, 115,  46, 100,  97, 116,  97,  95, 112,  95, 102, 117, 
  110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 
  121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 100,  97, 116,  97, 
   95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 110, 101, 119,  95, 101, 114, 114, 111, 
  114,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 
  110, 101, 119,  95, 101, 114, 114, 111, 114,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 
  114, 114, 111, 114,  95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  32,  61,  32, 101, 114, 114, 111, 114,  95, 110,  97, 
  109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 101, 114, 114, 111, 114,  95, 108, 105, 
  115, 116,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46, 101, 114, 114, 111, 114,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 101, 114, 114, 111, 114,  95, 112,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   32,  61,  32, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   59,  10, 101, 120, 112, 111, 114, 116, 115,  46,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  32,  61,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 115, 121, 109,  98, 111, 108,  95, 112, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 115, 
  121, 109,  98, 111, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 117, 108, 
  108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32, 
   61,  32, 110, 117, 108, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 113, 
  117,  97, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  32,  61,  32, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115, 
   46,  97, 112, 112, 108, 121,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  32,  61,  32,  97, 112, 112, 108, 121,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 
  101, 118,  97, 108, 117,  97, 116, 101,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 101, 118,  97, 108, 117,  97, 116, 101,  95, 
  102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 
  111, 114, 116, 115,  46, 108, 105, 115, 116,  95,  99, 104, 111, 111, 115, 101, 
   79, 110, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32, 
   61,  32, 108, 105, 115, 116,  95,  99, 104, 111, 111, 115, 101,  79, 110, 101, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 
  112, 111, 114, 116, 115,  46, 105, 102,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 105, 102,  95, 102, 117, 110,  99, 116, 105, 
  111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 113, 
  117, 111, 116, 101,  95, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61,  32, 113, 
  117, 111, 116, 101,  95, 102, 111, 114, 109,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  59,  10, 101, 120, 
  112, 111, 114, 116, 115,  46, 108,  97, 109,  98, 100,  97,  95, 102, 111, 114, 
  109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  32,  61,  32, 108,  97, 109,  98, 100,  97,  95, 102, 111, 
  114, 109,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 111, 114, 109,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 
  109,  78,  97, 109, 101,  32,  61,  32, 102, 111, 114, 109,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78, 
   97, 109, 101,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 111, 114, 
  109,  95, 117, 115, 101,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   32,  61,  32, 102, 111, 114, 109,  95, 117, 115, 101,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  59,  10, 108, 111,  99,  97, 108,  32, 102,  97, 
  108, 115, 101,  95, 118,  32,  61,  32, 110, 101, 119,  95, 100,  97, 116,  97, 
   40, 102,  97, 108, 115, 101,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 
  101, 119,  95, 108, 105, 115, 116,  40,  41,  41,  59,  10, 108, 111,  99,  97, 
  108,  32, 116, 114, 117, 101,  95, 118,  32,  61,  32, 110, 101, 119,  95, 100, 
   97, 116,  97,  40, 116, 114, 117, 101,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40,  41,  41,  59,  10, 108, 111, 
   99,  97, 108,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 
  114,  97, 121,  59,  10, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 
  114, 114,  97, 121,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
  120, 115,  44,  32, 107,  95, 100, 111, 110, 101,  44,  32, 107,  95, 116,  97, 
  105, 108,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 
  116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 119, 104, 105, 108, 
  101,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112, 
   40, 120, 115,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121,  80, 117, 115, 104,  40, 
  114, 101, 116,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 120, 115,  32,  61,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120, 115,  41,  59, 
   10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 
  110, 117, 108, 108,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 107, 
   95, 100, 111, 110, 101,  40, 114, 101, 116,  41,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 107, 
   95, 116,  97, 105, 108,  40, 114, 101, 116,  44,  32, 120, 115,  41,  59,  10, 
  101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 109,  97, 121,  98, 101, 
   95, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121, 
   59,  10, 109,  97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111,  95, 
  106, 115,  65, 114, 114,  97, 121,  32,  61,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 120, 115,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 
  121,  40, 120, 115,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120, 
  115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 120, 115,  59,  10,  32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120, 115,  44,  32, 120,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 
  108, 115, 101,  59,  10,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10, 101, 
  110, 100,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 106, 115,  65, 114, 
  114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  32,  61,  32, 106, 115, 
   65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  59,  10, 101, 
  120, 112, 111, 114, 116, 115,  46, 109,  97, 121,  98, 101,  95, 108, 105, 115, 
  116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121,  32,  61,  32, 109, 
   97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 
  114, 114,  97, 121,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 110, 101, 
  119,  95, 108, 105, 115, 116,  32,  61,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 100, 101, 108,  97, 121, 
   95, 112,  32,  61,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 
  117, 115, 116,  95, 112,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 
  111, 114,  99, 101,  95,  97, 108, 108,  32,  61,  32, 102, 111, 114,  99, 101, 
   95,  97, 108, 108,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 102, 111, 
  114,  99, 101,  49,  32,  61,  32, 102, 111, 114,  99, 101,  49,  59,  10, 101, 
  110, 118,  95, 110, 117, 108, 108,  95, 118,  32,  61,  32, 123, 125,  59,  10, 
  108, 111,  99,  97, 108,  32, 118,  97, 108,  50, 101, 110, 118,  59,  10, 118, 
   97, 108,  50, 101, 110, 118,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 114, 
   99, 101,  95,  97, 108, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32, 105, 
  102,  32, 110, 111, 116,  32, 100,  97, 116,  97,  95, 112,  40, 120,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 115,  32,  61, 
   32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 100,  97, 116,  97,  95, 
  110,  97, 109, 101,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 105, 102, 
   32, 110, 111, 116,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 115,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 115, 
  121, 109,  98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 115,  44, 
   32, 109,  97, 112, 112, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32, 115,  32,  61,  32, 102, 111, 114,  99, 
  101,  95,  97, 108, 108,  40, 100,  97, 116,  97,  95, 108, 105, 115, 116,  40, 
  120,  41,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 115, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
  110, 117, 108, 108,  95, 112,  40, 102, 111, 114,  99, 101,  95,  97, 108, 108, 
   40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  40, 115,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 
  101,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32, 123, 125,  59,  10,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 102, 111, 
  114,  99, 101,  95,  97, 108, 108,  40,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 115,  41,  41,  59,  10,  32, 
   32,  32,  32, 119, 104, 105, 108, 101,  32, 110, 111, 116,  32, 110, 117, 108, 
  108,  95, 112,  40, 120, 115,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 102, 111, 114,  99, 101,  95, 
   97, 108, 108,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 104, 101,  97, 100,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 120, 115,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 
  108, 108,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  116,  97, 105, 108,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 107,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 114,  99, 101, 
   95,  97, 108, 108,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 116,  97, 105, 108,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 118,  32,  61,  32,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 110, 
  117, 108, 108,  95, 112,  40, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 
  108,  40, 120,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 
   97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  110, 111, 116,  95,  98, 114, 101,  97, 107, 101, 100,  32,  61,  32, 116, 114, 
  117, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 
  114, 101, 116,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 106, 115,  98, 111, 111, 
  108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 114, 101, 116,  91,  40, 105, 
   32,  43,  32,  48,  41,  32,  43,  32,  49,  93,  44,  32, 107,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116,  91,  40, 105,  32,  43, 
   32,  49,  41,  32,  43,  32,  49,  93,  32,  61,  32, 118,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 110, 111, 116,  95,  98, 114, 101,  97, 107, 101, 100,  32,  61,  32, 
  102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  50,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  95,  98, 114, 101,  97, 
  107, 101, 100,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121, 
   80, 117, 115, 104,  40, 114, 101, 116,  44,  32, 107,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95, 
   65, 114, 114,  97, 121,  80, 117, 115, 104,  40, 114, 101, 116,  44,  32, 118, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 114, 101, 116,  59,  10, 101, 110, 100,  59,  10, 101, 120, 112, 111, 
  114, 116, 115,  46, 101, 110, 118,  95, 110, 117, 108, 108,  95, 118,  32,  61, 
   32, 101, 110, 118,  95, 110, 117, 108, 108,  95, 118,  59,  10, 101, 120, 112, 
  111, 114, 116, 115,  46, 101, 110, 118,  95, 115, 101, 116,  32,  61,  32, 101, 
  110, 118,  95, 115, 101, 116,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 
  101, 110, 118,  95, 103, 101, 116,  32,  61,  32, 101, 110, 118,  95, 103, 101, 
  116,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 101, 110, 118,  50, 118, 
   97, 108,  32,  61,  32, 101, 110, 118,  50, 118,  97, 108,  59,  10, 101, 120, 
  112, 111, 114, 116, 115,  46, 101, 110, 118,  95, 102, 111, 114, 101,  97,  99, 
  104,  32,  61,  32, 101, 110, 118,  95, 102, 111, 114, 101,  97,  99, 104,  59, 
   10, 101, 120, 112, 111, 114, 116, 115,  46, 118,  97, 108,  50, 101, 110, 118, 
   32,  61,  32, 118,  97, 108,  50, 101, 110, 118,  59,  10, 108, 111,  99,  97, 
  108,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 112, 
   95, 102, 117, 110,  99,  59,  10, 109,  97, 107, 101,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 112,  95, 102, 117, 110,  99,  32,  61,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 112,  95, 115, 121, 109,  44,  32, 112,  95, 106, 
  115, 102, 117, 110,  99,  41,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 123, 112,  95, 115, 121, 109,  44,  32,  49,  44,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120,  44,  32, 101, 114, 114, 111, 114,  95, 118, 
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 
  114,  99, 101,  49,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 
  115, 116,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 
  108, 121,  40, 112,  95, 115, 121, 109,  44,  32, 123, 120, 125,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 112,  95, 106, 115, 102, 117, 110,  99,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  95, 
  118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 
  108, 115, 101,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100, 125,  59, 
   10, 101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 109,  97, 107, 101, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 103, 101, 116,  95, 102, 117, 110, 
   99,  59,  10, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  103, 101, 116,  95, 102, 117, 110,  99,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 102,  95, 115, 121, 109,  44,  32, 112,  95, 106, 115, 102, 
  117, 110,  99,  44,  32, 102,  95, 106, 115, 102, 117, 110,  99,  41,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 123, 102,  95, 115, 121, 109, 
   44,  32,  49,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44, 
   32, 101, 114, 114, 111, 114,  95, 118,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 120,  32,  61,  32, 102, 111, 114,  99, 101,  49,  40, 120,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  97, 110, 121,  95, 
  100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 120,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 102,  95, 115, 121, 109, 
   44,  32, 123, 120, 125,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 112, 
   95, 106, 115, 102, 117, 110,  99,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  95, 106, 115, 102, 117, 110,  99,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114, 
   95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100, 125,  59,  10, 101, 110, 
  100,  59,  10, 114, 101,  97, 108,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  95, 115,  32,  61,  32, 123, 
  109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 112,  95, 102, 
  117, 110,  99,  40, 100,  97, 116,  97,  95, 112,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 112,  41,  44, 
   32, 123, 110, 101, 119,  95, 100,  97, 116,  97,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  44,  32,  50,  44,  32, 110, 101, 119,  95, 100, 
   97, 116,  97, 125,  44,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 103, 101, 116,  95, 102, 117, 110,  99,  40, 100,  97, 116,  97, 
   95, 110,  97, 109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32, 100,  97, 116,  97,  95, 112,  44,  32, 100,  97, 116,  97,  95, 
  110,  97, 109, 101,  41,  44,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 103, 101, 116,  95, 102, 117, 110,  99,  40, 100,  97, 116, 
   97,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  44,  32, 100,  97, 116,  97,  95, 112,  44,  32, 100,  97, 116,  97, 
   95, 108, 105, 115, 116,  41,  44,  32, 109,  97, 107, 101,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 112,  95, 102, 117, 110,  99,  40, 101, 114, 114, 111, 
  114,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32, 101, 114, 114, 111, 114,  95, 112,  41,  44,  32, 123, 110, 101, 119,  95, 
  101, 114, 114, 111, 114,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 
  101,  44,  32,  50,  44,  32, 110, 101, 119,  95, 101, 114, 114, 111, 114, 125, 
   44,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 103, 
  101, 116,  95, 102, 117, 110,  99,  40, 101, 114, 114, 111, 114,  95, 110,  97, 
  109, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 
  101, 114, 114, 111, 114,  95, 112,  44,  32, 101, 114, 114, 111, 114,  95, 110, 
   97, 109, 101,  41,  44,  32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 103, 101, 116,  95, 102, 117, 110,  99,  40, 101, 114, 114, 111, 
  114,  95, 108, 105, 115, 116,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 
  109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 112,  44,  32, 101, 114, 114, 
  111, 114,  95, 108, 105, 115, 116,  41,  44,  32, 109,  97, 107, 101,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 112,  95, 102, 117, 110,  99,  40, 110, 117, 
  108, 108,  95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101, 
   44,  32, 110, 117, 108, 108,  95, 112,  41,  44,  32, 123, 110, 101, 119,  95, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  50,  44,  32, 110, 101, 119, 
   95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 125,  44,  32, 
  109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 112,  95, 102, 
  117, 110,  99,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  41,  44, 
   32, 109,  97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 103, 101, 
  116,  95, 102, 117, 110,  99,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 104, 101,  97, 100,  95, 102, 117, 110,  99, 116, 105, 111, 
  110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109, 
   78,  97, 109, 101,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 112,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 104, 101,  97, 100,  41,  44,  32, 109,  97, 107, 101,  95,  98, 
  117, 105, 108, 116, 105, 110,  95, 103, 101, 116,  95, 102, 117, 110,  99,  40, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 
  108,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 
  105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   41,  44,  32, 123, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  44,  32,  50,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 120,  44,  32, 121,  44,  32, 101, 114, 114, 111, 114, 
   95, 118,  41,  10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 
  121,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  95, 118,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 120,  32,  61,  32, 102, 111, 
  114,  99, 101,  49,  40, 120,  41,  59,  10,  32,  32,  32,  32, 121,  32,  61, 
   32, 102, 111, 114,  99, 101,  49,  40, 121,  41,  59,  10,  32,  32,  32,  32, 
  105, 102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 
  116,  95, 112,  40, 120,  41,  32, 111, 114,  32,  97, 110, 121,  95, 100, 101, 
  108,  97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 121,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 
  112, 112, 108, 121,  40, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110, 
   99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 
  115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 123, 120,  44,  32, 121, 125, 
   41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 
  102,  32, 120,  32,  61,  61,  32, 121,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 
  101,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32,  72,  95, 105, 102,  59,  10,  32,  32,  32, 
   32,  72,  95, 105, 102,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40,  98,  44,  32, 120,  44,  32, 121,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 110, 
   95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 105, 102,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 123,  98,  44,  32, 
  120,  44,  32, 121, 125,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59, 
   10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  72,  95,  97, 110, 100, 
   59,  10,  32,  32,  32,  32,  72,  95,  97, 110, 100,  32,  61,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  72,  95, 105, 102, 
   40, 120,  44,  32, 121,  44,  32, 102,  97, 108, 115, 101,  95, 118,  41,  59, 
   10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32,  65,  83, 
   83,  69,  82,  84,  40, 110, 111, 116,  32,  97, 110, 121,  95, 100, 101, 108, 
   97, 121,  95, 106, 117, 115, 116,  95, 112,  40, 120,  41,  41,  59,  10,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 110, 100,  95,  50,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  95,  50,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 120,  44,  32, 121,  44,  32, 102,  49,  44,  32, 102, 
   50,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32,  72,  95,  97, 110, 100,  40,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 101, 113, 117,  97, 108, 
   95, 112,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 
  116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 
  123, 102,  49,  40, 120,  41,  44,  32, 102,  49,  40, 121,  41, 125,  41,  44, 
   32,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 
  112, 108, 121,  40, 101, 113, 117,  97, 108,  95, 112,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  44,  32, 123, 102,  50,  40, 120,  41,  44, 
   32, 102,  50,  40, 121,  41, 125,  41,  41,  59,  10,  32,  32,  32,  32, 101, 
  110, 100,  59,  10,  32,  32,  32,  32, 105, 102,  32, 110, 117, 108, 108,  95, 
  112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 110, 111, 116,  32, 110, 117, 108, 108,  95, 112,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101, 
   95, 118,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 
  114, 117, 101,  95, 118,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 
  116,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 121,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  95, 118,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 115, 121, 109,  98, 111, 
  108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 120,  44,  32, 121,  41,  32, 
   97, 110, 100,  32, 116, 114, 117, 101,  95, 118,  41,  32, 111, 114,  32, 102, 
   97, 108, 115, 101,  95, 118,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 
  105, 102,  32, 100,  97, 116,  97,  95, 112,  40, 120,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116, 
   32, 100,  97, 116,  97,  95, 112,  40, 121,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  97, 108, 115, 101,  95, 118,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 101, 110, 100,  95,  50,  40, 120,  44,  32, 
  121,  44,  32, 100,  97, 116,  97,  95, 110,  97, 109, 101,  44,  32, 100,  97, 
  116,  97,  95, 108, 105, 115, 116,  41,  59,  10,  32,  32,  32,  32, 101, 108, 
  115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 121,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  95, 118,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 100,  95,  50,  40, 120, 
   44,  32, 121,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 116,  97, 105, 108,  41,  59,  10,  32,  32,  32,  32, 
  101, 108, 115, 101, 105, 102,  32, 101, 114, 114, 111, 114,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 110, 111, 116,  32, 101, 114, 114, 111, 114,  95, 112,  40, 121,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  95, 118, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 110, 100, 
   95,  50,  40, 120,  44,  32, 121,  44,  32, 101, 114, 114, 111, 114,  95, 110, 
   97, 109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  41, 
   59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 101, 110, 
  100, 125,  44,  32, 123,  97, 112, 112, 108, 121,  95, 102, 117, 110,  99, 116, 
  105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 116, 
  101, 109,  78,  97, 109, 101,  44,  32,  50,  44,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 102,  44,  32, 120, 115,  44,  32, 101, 114, 114, 111, 114, 
   95, 118,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 106, 115, 
  108, 105, 115, 116,  32,  61,  32, 123, 125,  59,  10,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 105, 116, 101, 114,  32,  61,  32, 102, 111, 114,  99, 
  101,  95,  97, 108, 108,  40, 120, 115,  41,  59,  10,  32,  32,  32,  32, 119, 
  104, 105, 108, 101,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 112,  40, 105, 116, 101, 114,  41,  32, 100, 111,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121, 
   80, 117, 115, 104,  40, 106, 115, 108, 105, 115, 116,  44,  32,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 105, 
  116, 101, 114,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  116, 101, 114,  32,  61,  32, 102, 111, 114,  99, 101,  95,  97, 108, 108,  40, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 
  108,  40, 105, 116, 101, 114,  41,  41,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 110, 117, 108, 
  108,  95, 112,  40, 105, 116, 101, 114,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 
  114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 112, 108, 121,  40, 
  102,  44,  32, 106, 115, 108, 105, 115, 116,  41,  59,  10, 101, 110, 100, 125, 
   44,  32, 123, 101, 118,  97, 108, 117,  97, 116, 101,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  44,  32,  50,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 101, 110, 118,  44,  32, 120,  44,  32, 101, 114, 114, 
  111, 114,  95, 118,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  109,  97, 121,  98, 101, 101, 110, 118,  32,  61,  32, 118,  97, 108,  50, 101, 
  110, 118,  40, 101, 110, 118,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 
  109,  97, 121,  98, 101, 101, 110, 118,  32,  61,  61,  32, 102,  97, 108, 115, 
  101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 109,  97, 121,  98, 101, 
  101, 110, 118,  44,  32, 120,  41,  59,  10, 101, 110, 100, 125,  44,  32, 109, 
   97, 107, 101,  95,  98, 117, 105, 108, 116, 105, 110,  95, 112,  95, 102, 117, 
  110,  99,  40, 115, 121, 109,  98, 111, 108,  95, 112,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  44,  32, 115, 121, 109,  98, 111, 108,  95, 
  112,  41,  44,  32, 123, 108, 105, 115, 116,  95,  99, 104, 111, 111, 115, 101, 
   79, 110, 101,  95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 
  108, 116, 105, 110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44, 
   32,  49,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120, 115,  44, 
   32, 101, 114, 114, 111, 114,  95, 118,  41,  10,  32,  32,  32,  32, 120, 115, 
   32,  61,  32, 102, 111, 114,  99, 101,  49,  40, 120, 115,  41,  59,  10,  32, 
   32,  32,  32, 105, 102,  32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 
  106, 117, 115, 116,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 
  117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 
  121,  40, 108, 105, 115, 116,  95,  99, 104, 111, 111, 115, 101,  79, 110, 101, 
   95, 102, 117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 123, 120, 
  115, 125,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 
  114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115,  41, 
   59,  10, 101, 110, 100, 125,  44,  32, 123, 105, 102,  95, 102, 117, 110,  99, 
  116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  44,  32,  51,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40,  98,  44,  32, 120,  44,  32, 121,  44,  32, 101, 114, 
  114, 111, 114,  95, 118,  41,  10,  32,  32,  32,  32,  98,  32,  61,  32, 102, 
  111, 114,  99, 101,  49,  40,  98,  41,  59,  10,  32,  32,  32,  32, 105, 102, 
   32,  97, 110, 121,  95, 100, 101, 108,  97, 121,  95, 106, 117, 115, 116,  95, 
  112,  40,  98,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 110, 
   95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 105, 102,  95, 102, 
  117, 110,  99, 116, 105, 111, 110,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  44,  32, 123,  98,  44,  32, 
  120,  44,  32, 121, 125,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 100,  97, 116,  97,  95, 
  112,  40,  98,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114,  95, 118, 
   59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 110,  97, 109,  32,  61,  32, 102, 111, 114,  99, 101,  95, 
   97, 108, 108,  40, 100,  97, 116,  97,  95, 110,  97, 109, 101,  40,  98,  41, 
   41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 115, 121, 
  109,  98, 111, 108,  95, 112,  40, 110,  97, 109,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  101, 114, 114, 111, 114,  95, 118,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 105, 102,  32, 115, 121, 109,  98, 111, 108,  95, 101, 
  113, 117,  97, 108,  95, 112,  40, 110,  97, 109,  44,  32, 116, 114, 117, 101, 
   95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 105, 102,  32, 115, 
  121, 109,  98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 110,  97, 
  109,  44,  32, 102,  97, 108, 115, 101,  95, 115, 121, 109,  98, 111, 108,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 121,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 114, 114, 111, 114, 
   95, 118,  59,  10, 101, 110, 100, 125, 125,  59,  10, 101, 120, 112, 111, 114, 
  116, 115,  46, 101, 113, 117,  97, 108,  95, 112,  32,  61,  32, 106, 115,  98, 
  111, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  59,  10, 108, 111,  99, 
   97, 108,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114, 
   99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  59,  10, 106, 115,  98, 111, 
  111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 
  108,  95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120, 
   44,  32, 121,  41,  10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61, 
   32, 121,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 120,  32,  61,  32, 117, 110,  95, 
  106, 117, 115, 116,  95,  97, 108, 108,  40, 120,  41,  59,  10,  32,  32,  32, 
   32, 121,  32,  61,  32, 117, 110,  95, 106, 117, 115, 116,  95,  97, 108, 108, 
   40, 121,  41,  59,  10,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61, 
   32, 121,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 
  110, 100,  95,  50,  59,  10,  32,  32,  32,  32, 101, 110, 100,  95,  50,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  44,  32, 121,  44, 
   32, 102,  49,  44,  32, 102,  50,  41,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 
  114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 102,  49,  40, 120, 
   41,  44,  32, 102,  49,  40, 121,  41,  41,  32,  97, 110, 100,  32, 106, 115, 
   98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 
  117,  97, 108,  95, 112,  40, 102,  50,  40, 120,  41,  44,  32, 102,  50,  40, 
  121,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 108,  97, 110, 103,  95, 115, 101, 116,  95, 100, 111, 
   40, 120,  44,  32, 121,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32, 
   32, 105, 102,  32, 110, 117, 108, 108,  95, 112,  40, 120,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 
  116,  32, 110, 117, 108, 108,  95, 112,  40, 121,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
   97, 110, 103,  95, 115, 101, 116,  95, 100, 111,  40, 120,  44,  32, 110, 117, 
  108, 108,  95, 118,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
   97, 110, 103,  95, 115, 101, 116,  95, 100, 111,  40, 121,  44,  32, 110, 117, 
  108, 108,  95, 118,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 
  101, 108, 115, 101, 105, 102,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 110, 111, 116,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 
  121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 121, 109, 
   98, 111, 108,  95, 101, 113, 117,  97, 108,  95, 112,  40, 120,  44,  32, 121, 
   41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
  110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 112,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 
  108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  101, 110, 100,  95,  50,  40, 120,  44,  32, 121,  44,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 101, 114, 
  114, 111, 114,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 101, 114, 114, 
  111, 114,  95, 112,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 101, 110, 100,  95,  50,  40, 120,  44,  32, 121,  44,  32, 101, 114, 
  114, 111, 114,  95, 110,  97, 109, 101,  44,  32, 101, 114, 114, 111, 114,  95, 
  108, 105, 115, 116,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 100,  97, 116,  97,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
  100,  97, 116,  97,  95, 112,  40, 121,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 101, 110, 100,  95,  50,  40, 120,  44,  32, 121,  44,  32, 
  100,  97, 116,  97,  95, 110,  97, 109, 101,  44,  32, 100,  97, 116,  97,  95, 
  108, 105, 115, 116,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101, 
   95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59, 
   10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 
  121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 112, 
   40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95, 
   98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95,  97, 112, 
  112, 108, 121,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 
  101, 110, 100,  59,  10, 108, 111,  99,  97, 108,  32, 115, 105, 109, 112, 108, 
  101,  95, 112, 114, 105, 110, 116,  95, 102, 111, 114,  99, 101,  95,  97, 108, 
  108,  95, 114, 101,  99,  59,  10, 115, 105, 109, 112, 108, 101,  95, 112, 114, 
  105, 110, 116,  95, 102, 111, 114,  99, 101,  95,  97, 108, 108,  95, 114, 101, 
   99,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 105, 109, 112, 108, 
  101,  95, 112, 114, 105, 110, 116,  40, 102, 111, 114,  99, 101,  95,  97, 108, 
  108,  95, 114, 101,  99,  40, 120,  41,  41,  59,  10, 101, 110, 100,  59,  10, 
  101, 120, 112, 111, 114, 116, 115,  46, 115, 105, 109, 112, 108, 101,  95, 112, 
  114, 105, 110, 116,  32,  61,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 
  105, 110, 116,  59,  10, 101, 120, 112, 111, 114, 116, 115,  46, 115, 105, 109, 
  112, 108, 101,  95, 112, 114, 105, 110, 116,  95, 102, 111, 114,  99, 101,  95, 
   97, 108, 108,  95, 114, 101,  99,  32,  61,  32, 115, 105, 109, 112, 108, 101, 
   95, 112, 114, 105, 110, 116,  95, 102, 111, 114,  99, 101,  95,  97, 108, 108, 
   95, 114, 101,  99,  59,  10, 108, 111,  99,  97, 108,  32, 115, 105, 109, 112, 
  108, 101,  95, 112,  97, 114, 115, 101,  59,  10, 115, 105, 109, 112, 108, 101, 
   95, 112,  97, 114, 115, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 115, 
  116,  97, 116, 101,  95,  99, 111, 110, 115, 116,  44,  32, 115, 116,  97, 116, 
  101,  44,  32, 101, 111, 102,  44,  32, 103, 101, 116,  44,  32, 112, 117, 116, 
   44,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  44,  32,  97, 
   95, 115, 112,  97,  99, 101,  95, 112,  44,  32, 115, 112,  97,  99, 101,  44, 
   32, 115, 121, 109,  98, 111, 108,  44,  32, 108, 105, 115, 116,  44,  32, 100, 
   97, 116,  97,  44,  32, 114, 101,  97, 100, 101, 114, 114, 111, 114,  44,  32, 
  114, 101,  97, 100, 101, 118,  97, 108,  44,  32, 114, 101,  97, 100, 102, 117, 
  110,  99,  97, 112, 112, 108, 121,  44,  32, 114, 101,  97, 100, 102, 111, 114, 
  109,  98, 117, 105, 108, 116, 105, 110,  44,  32, 114, 101,  97, 100,  97, 112, 
  112, 108, 121,  44,  32,  97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  44, 
   32, 118,  97, 108,  59,  10,  32,  32,  32,  32, 101, 111, 102,  32,  61,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  35, 115, 116,  97, 116, 
  101,  95,  99, 111, 110, 115, 116,  41,  32,  61,  61,  32, 115, 116,  97, 116, 
  101,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 
  103, 101, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  65,  83,  83,  69,  82,  84,  40, 
  110, 111, 116,  32, 101, 111, 102,  40,  41,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32, 
  115, 116,  97, 116, 101,  95,  99, 111, 110, 115, 116,  58, 115, 117,  98,  40, 
  115, 116,  97, 116, 101,  32,  43,  32,  49,  44,  32, 115, 116,  97, 116, 101, 
   32,  43,  32,  49,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 
  116,  97, 116, 101,  32,  61,  32, 115, 116,  97, 116, 101,  32,  43,  32,  49, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 114, 101, 116,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32, 
   32,  32,  32, 112, 117, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  65,  83,  83, 
   69,  82,  84,  40, 115, 116,  97, 116, 101,  95,  99, 111, 110, 115, 116,  58, 
  115, 117,  98,  40,  40, 115, 116,  97, 116, 101,  32,  45,  32,  49,  41,  32, 
   43,  32,  49,  44,  32,  40, 115, 116,  97, 116, 101,  32,  45,  32,  49,  41, 
   32,  43,  32,  49,  41,  32,  61,  61,  32, 120,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 115, 116,  97, 116, 101,  32,  61,  32, 115, 116,  97, 
  116, 101,  32,  45,  32,  49,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59, 
   10,  32,  32,  32,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 114, 114, 111, 114,  40,  34,  84, 104, 101, 
   76,  97, 110, 103, 117,  97, 103, 101,  32, 112,  97, 114, 115, 101,  32,  69, 
   82,  82,  79,  82,  33,  34,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   59,  10,  32,  32,  32,  32,  97,  95, 115, 112,  97,  99, 101,  95, 112,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  40,  40, 
  120,  32,  61,  61,  32,  34,  32,  34,  41,  32, 111, 114,  32,  40, 120,  32, 
   61,  61,  32,  34,  92, 110,  34,  41,  41,  32, 111, 114,  32,  40, 120,  32, 
   61,  61,  32,  34,  92, 116,  34,  41,  41,  32, 111, 114,  32,  40, 120,  32, 
   61,  61,  32,  34,  92, 114,  34,  41,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  59,  10,  32,  32,  32,  32, 115, 112,  97,  99, 101,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  97,  95, 
  115, 112,  97,  99, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 
  120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 119, 104, 105, 108, 101,  32,  97,  95, 115, 112,  97,  99, 101,  95, 
  112,  40, 120,  41,  32,  97, 110, 100,  32,  40, 110, 111, 116,  32, 101, 111, 
  102,  40,  41,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  97,  95, 115, 112,  97,  99, 
  101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59, 
   10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 115, 121, 
  109,  98, 111, 108,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102, 
   40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 
  103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32,  34,  34,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  97,  95, 
  115, 121, 109,  98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116, 
   40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 119, 104, 105, 108, 101,  32,  97,  95, 115, 121, 109,  98, 111, 
  108,  95, 112,  40, 120,  41,  32,  97, 110, 100,  32,  40, 110, 111, 116,  32, 
  101, 111, 102,  40,  41,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116,  32,  61,  32, 114, 101, 116,  32, 
   46,  46,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32,  97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116,  32,  61,  32, 114, 101, 116,  32,  46,  46,  32, 
  120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 
  120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 
  101, 119,  95, 115, 121, 109,  98, 111, 108,  40, 114, 101, 116,  41,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 108, 105, 115, 
  116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 116, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 
   32, 126,  61,  32,  34,  40,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32,  72,  79,  76,  69,  32,  61,  32, 110, 101, 119,  95, 
  115, 121, 109,  98, 111, 108,  40,  34,  33,  33,  64,  64,  82,  69,  65,  68, 
  124, 124,  72,  79,  76,  69,  64,  64,  33,  33,  34,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 116,  32, 
   61,  32,  72,  79,  76,  69,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 115, 101, 116,  95, 108,  97, 115, 116,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116,  95, 108,  97, 115, 116, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 108, 115, 116,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
  114, 101, 116,  32,  61,  61,  32,  72,  79,  76,  69,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116,  32,  61,  32, 108, 115, 116,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114, 101, 116,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101, 
   32, 116, 114, 117, 101,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 100,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 100,  32,  61,  61,  32,  72,  79,  76,  69,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  120,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 116,  97, 105, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  116,  97, 105, 108,  40, 120,  41,  32, 126,  61,  32,  72,  79,  76,  69,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79, 
   82,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 120,  91,  50,  32,  43,  32,  49,  93,  32,  61,  32, 108, 115, 116,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 108,  97, 115, 116, 
   95,  97, 100, 100,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 
  115, 116,  95,  97, 100, 100,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 115, 101, 116,  95, 108,  97, 115, 116,  40, 110, 101, 119,  95,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  40, 120,  44,  32,  72,  79, 
   76,  69,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101, 
   32, 116, 114, 117, 101,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 115, 112,  97,  99, 101,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102, 
   40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 
   97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 103, 101, 
  116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 120,  32,  61,  61,  32,  34,  41,  34,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 115, 101, 116,  95, 108,  97, 115, 116,  40, 110, 117, 108, 108,  95, 
  118,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 
   32,  61,  61,  32,  34,  46,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 112,  97, 
   99, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101,  32,  61,  32, 
  118,  97, 108,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 115, 101, 116,  95, 108,  97, 115, 116,  40, 
  101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 115, 112,  97,  99, 101,  40,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
  101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 103, 101, 116, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 120,  32, 126,  61,  32,  34,  41,  34,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 101,  32,  61,  32, 118,  97, 108,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 115, 116, 
   95,  97, 100, 100,  40, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32, 
   32,  32, 100,  97, 116,  97,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 
  111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32, 
   61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 120,  32, 126,  61,  32,  34,  35,  34,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 
  116,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 108, 
  105, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 120, 115,  32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 
  115,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101, 
   95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 110, 101, 119,  95, 100,  97, 116,  97,  40,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 
  120, 115,  41,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 116,  97, 105, 108,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 101, 114, 
  114, 111, 114,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 
  101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 120,  32, 126,  61,  32,  34,  33,  34,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 108, 105, 115, 116, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 
  115,  32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 
  114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 110, 101, 119,  95, 101, 114, 114, 111, 114,  40,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115, 
   41,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  116,  97, 105, 108,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32,  32, 101, 
  110, 100,  59,  10,  32,  32,  32,  32,  97,  95, 115, 121, 109,  98, 111, 108, 
   95, 112,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  97,  95, 115, 112, 
   97,  99, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 110, 111, 116,  95, 120, 115,  32,  61,  32, 123,  34,  40,  34,  44, 
   32,  34,  41,  34,  44,  32,  34,  33,  34,  44,  32,  34,  35,  34,  44,  32, 
   34,  46,  34,  44,  32,  34,  36,  34,  44,  32,  34,  37,  34,  44,  32,  34, 
   94,  34,  44,  32,  34,  64,  34,  44,  32,  34, 126,  34,  44,  32,  34,  47, 
   34,  44,  32,  34,  45,  34,  44,  32,  34,  62,  34,  44,  32,  34,  95,  34, 
   44,  32,  34,  58,  34,  44,  32,  34,  63,  34,  44,  32,  34,  91,  34,  44, 
   32,  34,  93,  34,  44,  32,  34,  38,  34, 125,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 
  101,  32, 105,  32,  60,  32,  40,  35, 110, 111, 116,  95, 120, 115,  41,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 110, 111, 116,  95, 120, 
  115,  91, 105,  32,  43,  32,  49,  93,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 118,  97, 108, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 115, 112,  97,  99, 101,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102, 115,  32, 
   61,  32, 123, 108, 105, 115, 116,  44,  32, 115, 121, 109,  98, 111, 108,  44, 
   32, 100,  97, 116,  97,  44,  32, 114, 101,  97, 100, 101, 114, 114, 111, 114, 
   44,  32, 114, 101,  97, 100, 101, 118,  97, 108,  44,  32, 114, 101,  97, 100, 
  102, 117, 110,  99,  97, 112, 112, 108, 121,  44,  32, 114, 101,  97, 100, 102, 
  111, 114, 109,  98, 117, 105, 108, 116, 105, 110,  44,  32, 114, 101,  97, 100, 
   97, 112, 112, 108, 121, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32, 
   60,  32,  40,  35, 102, 115,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 120,  32,  61,  32, 102, 115,  91, 105,  32,  43,  32,  49,  93,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 120,  32, 126,  61,  32, 102,  97, 108, 115, 101,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 
  115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 115, 116,  97, 116, 101,  95,  99, 
  111, 110, 115, 116,  32,  61,  32, 120,  59,  10,  32,  32,  32,  32, 115, 116, 
   97, 116, 101,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 119, 111, 
   59,  10,  32,  32,  32,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 
  116, 119, 111,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 112, 
  114, 101, 102, 105, 120,  44,  32, 107,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  99,  32, 
   61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32,  99,  32, 126,  61,  32, 112, 114, 101, 
  102, 105, 120,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40,  99,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 120, 115,  32,  61,  32, 108, 105, 115, 116,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 115,  32, 
   61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120, 115,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 110, 111, 116,  32,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 112,  40, 120,  41,  32,  97, 110, 100,  32, 110, 117, 108, 108, 
   95, 112,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  116,  97, 105, 108,  40, 120,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 107,  40,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  44, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101, 
   97, 100,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 107, 101,  95, 114, 101,  97, 
  100,  95, 116, 104, 114, 101, 101,  59,  10,  32,  32,  32,  32, 109,  97, 107, 
  101,  95, 114, 101,  97, 100,  95, 116, 104, 114, 101, 101,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 112, 114, 101, 102, 105, 120,  44,  32, 
  107,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 
  108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32,  99,  32,  61,  32, 103, 101, 116,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32,  99,  32, 126,  61,  32, 112, 114, 101, 102, 105, 120,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 112, 117, 116,  40,  99,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 108, 
  105, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 120, 115,  32,  61,  61,  32, 102,  97, 108, 115, 
  101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 
  114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 
  115,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 
   97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  120,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 116,  97, 105, 108,  40, 120, 115,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 
  101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  95, 100, 
   32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  116,  97, 105, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  40,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  95, 100,  41, 
   32,  97, 110, 100,  32, 110, 117, 108, 108,  95, 112,  40,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120,  95, 
  100,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 107,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  44,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120,  41, 
   44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 
  101,  97, 100,  40, 120,  95, 100,  41,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59, 
   10,  32,  32,  32,  32, 114, 101,  97, 100, 101, 118,  97, 108,  32,  61,  32, 
  109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 119, 111,  40,  34,  36, 
   34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 101,  44,  32, 120, 
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  101, 110, 118,  32,  61,  32, 118,  97, 108,  50, 101, 110, 118,  40, 101,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 110, 118, 
   32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 101, 118,  97, 108, 
  117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120,  41,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 
  102, 117, 110,  99,  97, 112, 112, 108, 121,  32,  61,  32, 109,  97, 107, 101, 
   95, 114, 101,  97, 100,  95, 116, 119, 111,  40,  34,  37,  34,  44,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 102,  44,  32, 120, 115,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 106, 115, 120, 
  115,  32,  61,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 
  114,  97, 121,  40, 120, 115,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120, 115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 120, 115,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120, 115,  44,  32, 121,  41,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 
  101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 102,  44,  32, 106, 115, 
  120, 115,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32, 
   32,  32,  32, 114, 101,  97, 100, 102, 111, 114, 109,  98, 117, 105, 108, 116, 
  105, 110,  32,  61,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 
  104, 114, 101, 101,  40,  34,  64,  34,  44,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 101,  44,  32, 102,  44,  32, 120, 115,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 106, 115, 120, 115,  32, 
   61,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 
  121,  40, 120, 115,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120, 
  115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 120, 115,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
  120, 115,  44,  32, 121,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 
  101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 101, 110, 118,  32,  61,  32, 118,  97, 108,  50, 101, 
  110, 118,  40, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 101, 110, 118,  32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 
  111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95,  97, 112, 
  112, 108, 121,  40, 101, 110, 118,  44,  32, 102,  44,  32, 106, 115, 120, 115, 
   41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32, 
   32, 114, 101,  97, 100,  97, 112, 112, 108, 121,  32,  61,  32, 109,  97, 107, 
  101,  95, 114, 101,  97, 100,  95, 116, 119, 111,  40,  34,  94,  34,  44,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  40, 102,  44,  32, 120, 115,  41,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 106, 115, 
  120, 115,  32,  61,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 
  114, 114,  97, 121,  40, 120, 115,  44,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120, 115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 115,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 120, 115,  44,  32, 121,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 
  115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 112, 108, 121,  40, 102, 
   44,  32, 106, 115, 120, 115,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   41,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 118,  97, 
  108,  40,  41,  59,  10, 101, 110, 100,  59,  10, 101, 120, 112, 111, 114, 116, 
  115,  46, 115, 105, 109, 112, 108, 101,  95, 112,  97, 114, 115, 101,  32,  61, 
   32, 115, 105, 109, 112, 108, 101,  95, 112,  97, 114, 115, 101,  59,  10, 108, 
  111,  99,  97, 108,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112,  97, 114, 
  115, 101,  59,  10,  99, 111, 109, 112, 108, 101, 120,  95, 112,  97, 114, 115, 
  101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 115, 116,  97, 116, 101,  95, 
   99, 111, 110, 115, 116,  44,  32, 115, 116,  97, 116, 101,  44,  32, 101, 111, 
  102,  44,  32, 103, 101, 116,  44,  32, 112, 117, 116,  44,  32, 112,  97, 114, 
  115, 101,  95, 101, 114, 114, 111, 114,  44,  32,  97,  95, 115, 112,  97,  99, 
  101,  95, 112,  44,  32, 115, 112,  97,  99, 101,  44,  32, 115, 121, 109,  98, 
  111, 108,  44,  32, 108, 105, 115, 116,  44,  32, 100,  97, 116,  97,  44,  32, 
  114, 101,  97, 100, 101, 114, 114, 111, 114,  44,  32, 114, 101,  97, 100, 101, 
  118,  97, 108,  44,  32, 114, 101,  97, 100, 102, 117, 110,  99,  97, 112, 112, 
  108, 121,  44,  32, 114, 101,  97, 100, 102, 111, 114, 109,  98, 117, 105, 108, 
  116, 105, 110,  44,  32, 114, 101,  97, 100,  97, 112, 112, 108, 121,  44,  32, 
   97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  44,  32, 118,  97, 108,  44, 
   32, 117, 110,  95, 109,  97, 121,  98, 101,  44,  32, 110, 111, 116,  95, 101, 
  111, 102,  44,  32,  97, 115, 115, 101, 114, 116,  95, 103, 101, 116,  44,  32, 
  114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112, 
   97,  99, 107,  44,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101, 
   59,  10,  32,  32,  32,  32, 101, 111, 102,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32,  40,  35, 115, 116,  97, 116, 101,  95,  99, 111, 
  110, 115, 116,  41,  32,  61,  61,  32, 115, 116,  97, 116, 101,  59,  10,  32, 
   32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 103, 101, 116,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  65,  83,  83,  69,  82,  84,  40, 110, 111, 116,  32, 
  101, 111, 102,  40,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32, 115, 116,  97, 116, 
  101,  95,  99, 111, 110, 115, 116,  58, 115, 117,  98,  40, 115, 116,  97, 116, 
  101,  32,  43,  32,  49,  44,  32, 115, 116,  97, 116, 101,  32,  43,  32,  49, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116,  97, 116, 101, 
   32,  61,  32, 115, 116,  97, 116, 101,  32,  43,  32,  49,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 114, 101, 116, 
   59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 112, 
  117, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  65,  83,  83,  69,  82,  84,  40, 
  115, 116,  97, 116, 101,  95,  99, 111, 110, 115, 116,  58, 115, 117,  98,  40, 
   40, 115, 116,  97, 116, 101,  32,  45,  32,  49,  41,  32,  43,  32,  49,  44, 
   32,  40, 115, 116,  97, 116, 101,  32,  45,  32,  49,  41,  32,  43,  32,  49, 
   41,  32,  61,  61,  32, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 115, 116,  97, 116, 101,  32,  61,  32, 115, 116,  97, 116, 101,  32,  45, 
   32,  49,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32, 
   32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 114, 114, 111, 114,  40,  34,  84, 104, 101,  76,  97, 110, 103, 
  117,  97, 103, 101,  32, 112,  97, 114, 115, 101,  32,  69,  82,  82,  79,  82, 
   33,  34,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32, 
   32,  32,  97,  95, 115, 112,  97,  99, 101,  95, 112,  32,  61,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32,  40,  40,  40, 120,  32,  61,  61, 
   32,  34,  32,  34,  41,  32, 111, 114,  32,  40, 120,  32,  61,  61,  32,  34, 
   92, 110,  34,  41,  41,  32, 111, 114,  32,  40, 120,  32,  61,  61,  32,  34, 
   92, 116,  34,  41,  41,  32, 111, 114,  32,  40, 120,  32,  61,  61,  32,  34, 
   92, 114,  34,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32, 
   32,  32,  32, 115, 112,  97,  99, 101,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 
   97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  97,  95, 115, 112,  97,  99, 
  101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 
  105, 108, 101,  32,  97,  95, 115, 112,  97,  99, 101,  95, 112,  40, 120,  41, 
   32,  97, 110, 100,  32,  40, 110, 111, 116,  32, 101, 111, 102,  40,  41,  41, 
   32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 110, 111, 116,  32,  97,  95, 115, 112,  97,  99, 101,  95, 112,  40, 
  120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 115, 121, 109,  98, 111, 108, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 116,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 114, 101, 116,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  97,  95, 115, 121, 109,  98, 
  111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 
  104, 105, 108, 101,  32,  97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  40, 
  120,  41,  32,  97, 110, 100,  32,  40, 110, 111, 116,  32, 101, 111, 102,  40, 
   41,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116,  32,  61,  32, 114, 101, 116,  32,  46,  46,  32, 120, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32, 
   61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
   97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116,  32,  61,  32, 114, 101, 116,  32,  46,  46,  32, 120,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 115, 
  121, 109,  98, 111, 108,  40, 114, 101, 116,  41,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 108, 105, 115, 116,  32,  61,  32, 
  102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32, 126,  61,  32, 
   34,  40,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32,  72,  79,  76,  69,  32,  61,  32, 110, 101, 119,  95, 115, 121, 109,  98, 
  111, 108,  40,  34,  33,  33,  64,  64,  82,  69,  65,  68, 124, 124,  72,  79, 
   76,  69,  64,  64,  33,  33,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 114, 101, 116,  32,  61,  32,  72,  79, 
   76,  69,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 115, 101, 116,  95, 108,  97, 115, 116,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 115, 101, 116,  95, 108,  97, 115, 116,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 108, 115, 116,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 114, 101, 116,  32, 
   61,  61,  32,  72,  79,  76,  69,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
   32,  61,  32, 108, 115, 116,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 120,  32,  61,  32, 114, 101, 116,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 116, 114, 117, 
  101,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  69,  82, 
   82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 100,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 116,  97, 105, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 100,  32, 
   61,  61,  32,  72,  79,  76,  69,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 
  108,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   40, 120,  41,  32, 126,  61,  32,  72,  79,  76,  69,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  91,  50, 
   32,  43,  32,  49,  93,  32,  61,  32, 108, 115, 116,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 108,  97, 115, 116,  95,  97, 100, 100, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 115, 116,  95,  97, 
  100, 100,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 116, 
   95, 108,  97, 115, 116,  40, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  40, 120,  44,  32,  72,  79,  76,  69,  41,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 116, 114, 117, 
  101,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 115, 112,  97,  99, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101, 
   95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
  120,  32,  61,  61,  32,  34,  41,  34,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 101, 
  116,  95, 108,  97, 115, 116,  40, 110, 117, 108, 108,  95, 118,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 
   34,  46,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 112,  97,  99, 101,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 101,  32,  61,  32, 118,  97, 108,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 115, 101, 116,  95, 108,  97, 115, 116,  40, 101,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  115, 112,  97,  99, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 120,  32, 126,  61,  32,  34,  41,  34,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 
  101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 114, 101, 116,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 101,  32,  61,  32, 118,  97, 108,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 108,  97, 115, 116,  95,  97, 100, 100, 
   40, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 100,  97, 
  116,  97,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 
  116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
  120,  32, 126,  61,  32,  34,  35,  34,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 108, 105, 115, 116,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 115, 
   32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 
  111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 110, 101, 119,  95, 100,  97, 116,  97,  40,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  44, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  40, 120, 115,  41,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 101, 114, 114, 111, 114,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 103, 101, 116,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32, 126, 
   61,  32,  34,  33,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40, 120,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 120, 115,  32,  61,  32, 108, 105, 115, 116,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 115,  32,  61,  61, 
   32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 
   97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 
  119,  95, 101, 114, 114, 111, 114,  40,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  44,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   40, 120, 115,  41,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59,  10, 
   32,  32,  32,  32,  97,  95, 115, 121, 109,  98, 111, 108,  95, 112,  32,  61, 
   32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32,  97,  95, 115, 112,  97,  99, 101,  95, 
  112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 110, 111, 
  116,  95, 120, 115,  32,  61,  32, 123,  34,  40,  34,  44,  32,  34,  41,  34, 
   44,  32,  34,  33,  34,  44,  32,  34,  35,  34,  44,  32,  34,  46,  34,  44, 
   32,  34,  36,  34,  44,  32,  34,  37,  34,  44,  32,  34,  94,  34,  44,  32, 
   34,  64,  34,  44,  32,  34, 126,  34,  44,  32,  34,  47,  34,  44,  32,  34, 
   45,  34,  44,  32,  34,  62,  34,  44,  32,  34,  95,  34,  44,  32,  34,  58, 
   34,  44,  32,  34,  63,  34,  44,  32,  34,  91,  34,  44,  32,  34,  93,  34, 
   44,  32,  34,  38,  34, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105,  32, 
   60,  32,  40,  35, 110, 111, 116,  95, 120, 115,  41,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 120,  32,  61,  61,  32, 110, 111, 116,  95, 120, 115,  91, 105,  32, 
   43,  32,  49,  93,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105,  32,  61,  32, 105,  32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 116, 114, 117, 101,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 118,  97, 108,  32,  61,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 115, 112,  97,  99, 101,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 102, 115,  32,  61,  32, 123, 108, 
  105, 115, 116,  44,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101, 
   44,  32, 100,  97, 116,  97,  44,  32, 114, 101,  97, 100, 101, 114, 114, 111, 
  114,  44,  32, 114, 101,  97, 100, 101, 118,  97, 108,  44,  32, 114, 101,  97, 
  100, 102, 117, 110,  99,  97, 112, 112, 108, 121,  44,  32, 114, 101,  97, 100, 
  102, 111, 114, 109,  98, 117, 105, 108, 116, 105, 110,  44,  32, 114, 101,  97, 
  100,  97, 112, 112, 108, 121, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 101,  32, 105, 
   32,  60,  32,  40,  35, 102, 115,  41,  32, 100, 111,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 120,  32,  61,  32, 102, 115,  91, 105,  32,  43,  32,  49,  93,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 120,  32, 126,  61,  32, 102,  97, 108, 115, 101, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32, 
   49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 
  114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 117, 110,  95, 109,  97, 121, 
   98, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 120,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61, 
   32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 
   97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 120,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 110, 111, 116,  95, 101, 111, 102, 
   32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 111, 116, 
   32, 101, 111, 102,  40,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  59, 
   10,  32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  95, 103, 101, 116,  32, 
   61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  99,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 117, 110,  95, 109,  97, 121,  98, 101,  40, 110, 
  111, 116,  95, 101, 111, 102,  40,  41,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 117, 110,  95, 109,  97, 121,  98, 101,  40, 103, 101, 116,  40, 
   41,  32,  61,  61,  32,  99,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100, 
   59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 
  101,  95, 110, 111,  95, 112,  97,  99, 107,  32,  61,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101, 
   95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114,  95, 109, 
  117, 115, 116,  44,  32, 109,  97, 121,  95, 120, 102, 120,  95, 120, 102,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101,  97, 100, 115, 121, 115, 
  110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 
  101, 114,  95, 109, 117, 115, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 
  111, 110,  40, 115, 116, 114, 105,  99, 116,  41,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 115, 116, 114, 105,  99, 116, 
   32,  61,  61,  32, 110, 105, 108,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 115, 116, 114, 
  105,  99, 116,  32,  61,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 114, 
  101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97, 
   99, 107,  95,  98, 114,  97,  99, 107, 101, 116,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101,  97, 100, 115, 121, 115, 110, 
   97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95,  98, 114,  97,  99, 
  107, 101, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40,  41, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  97, 115, 115, 101, 114, 116,  95, 103, 101, 116,  40,  34,  91,  34,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 
  115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 
  105, 110, 110, 101, 114,  95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 
  115, 101, 114, 116,  95, 103, 101, 116,  40,  34,  93,  34,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 102, 115,  32,  61, 
   32,  40, 115, 116, 114, 105,  99, 116,  32,  97, 110, 100,  32, 123, 108, 105, 
  115, 116,  44,  32, 115, 121, 109,  98, 111, 108,  44,  32, 114, 101,  97, 100, 
  115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 
   98, 114,  97,  99, 107, 101, 116,  44,  32, 100,  97, 116,  97,  44,  32, 114, 
  101,  97, 100, 101, 114, 114, 111, 114,  44,  32, 114, 101,  97, 100, 101, 118, 
   97, 108,  44,  32, 114, 101,  97, 100, 102, 117, 110,  99,  97, 112, 112, 108, 
  121,  44,  32, 114, 101,  97, 100, 102, 111, 114, 109,  98, 117, 105, 108, 116, 
  105, 110,  44,  32, 114, 101,  97, 100,  97, 112, 112, 108, 121, 125,  41,  32, 
  111, 114,  32, 123, 108, 105, 115, 116,  44,  32, 114, 101,  97, 100, 115, 121, 
  115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  44,  32, 100, 
   97, 116,  97,  44,  32, 114, 101,  97, 100, 101, 114, 114, 111, 114,  44,  32, 
  114, 101,  97, 100, 101, 118,  97, 108,  44,  32, 114, 101,  97, 100, 102, 117, 
  110,  99,  97, 112, 112, 108, 121,  44,  32, 114, 101,  97, 100, 102, 111, 114, 
  109,  98, 117, 105, 108, 116, 105, 110,  44,  32, 114, 101,  97, 100,  97, 112, 
  112, 108, 121, 125,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 105,  32,  61,  32,  48, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 102, 115, 
   41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 102, 115,  91, 105,  32,  43,  32,  49,  93,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 120,  32, 126,  61,  32, 102,  97, 108, 115, 
  101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105,  32,  61,  32, 105,  32,  43,  32,  49,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 
  111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 109,  97, 121,  95, 120, 
  102, 120,  95, 120, 102,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 104, 101,  97, 100,  32,  61, 
   32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 104, 101,  97, 100,  32,  61,  61,  32,  34, 
   46,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 121,  32, 
   61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 111, 
   95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 116, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 
  105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 
  111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 
  105, 115, 116,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 120,  41, 
   44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 
  111, 108,  41,  44,  32, 121,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 104, 101,  97, 100, 
   32,  61,  61,  32,  34,  58,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 121,  32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 
  109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114, 
   95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 110, 
  111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  121,  44,  32, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 104, 101,  97, 100,  32,  61, 
   61,  32,  34, 126,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 105, 115,  79, 114,  78, 
  111, 116,  95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 
  102,  32, 104, 101,  97, 100,  32,  61,  61,  32,  34,  64,  34,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 108, 111,  99,  97, 108,  32, 121,  32,  61,  32, 114, 101,  97, 
  100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107, 
   95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 116,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 
  121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 
  109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 
  117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   40, 120,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 
  109,  98, 111, 108,  41,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103, 
   95, 115, 121, 109,  98, 111, 108,  41,  44,  32, 121,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102, 
   32, 104, 101,  97, 100,  32,  61,  61,  32,  34,  63,  34,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 
  115, 116,  40, 105, 115,  79, 114,  78, 111, 116,  95, 115, 121, 109,  98, 111, 
  108,  44,  32, 120,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 104, 101,  97, 100,  32, 
   61,  61,  32,  34,  47,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 121, 115,  32,  61,  32, 123, 120, 125,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 105, 108, 
  101,  32, 116, 114, 117, 101,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 121,  32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110, 
   97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 
  114,  95, 109, 117, 115, 116,  40, 116, 114, 117, 101,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  95,  95,  84,  83,  95,  95,  65, 114, 114,  97, 121,  80, 117, 115, 
  104,  40, 121, 115,  44,  32, 121,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  99,  48,  32, 
   61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
   99,  48,  32, 126,  61,  32,  34,  47,  34,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40,  99,  48,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  98, 114, 101,  97, 107,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 115, 117,  98,  95, 115, 
  121, 109,  98, 111, 108,  44,  32, 106, 115,  65, 114, 114,  97, 121,  95, 116, 
  111,  95, 108, 105, 115, 116,  40, 121, 115,  41,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 
  116,  40, 104, 101,  97, 100,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 104, 101,  97, 100,  32,  61,  32, 103, 101, 116, 
   40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 104, 
  101,  97, 100,  32,  61,  61,  32,  34,  38,  34,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 117, 110,  95, 109, 
   97, 121,  98, 101,  40, 110, 111, 116,  95, 101, 111, 102,  40,  41,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32,  99,  48,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  99,  48, 
   32,  61,  61,  32,  34,  43,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 
  109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114, 
   95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109,  95, 115, 121, 
  109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 115, 
  121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  41, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 112, 117, 116,  40,  99,  48,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 
  111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 
  116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116, 
   40, 102, 111, 114, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102, 
   32, 104, 101,  97, 100,  32,  61,  61,  32,  34,  58,  34,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 117, 110, 
   95, 109,  97, 121,  98, 101,  40, 110, 111, 116,  95, 101, 111, 102,  40,  41, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32,  99,  48,  32,  61,  32, 103, 101, 116,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 
   99,  48,  32,  61,  61,  32,  34,  38,  34,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  97, 
  115, 115, 101, 114, 116,  95, 103, 101, 116,  40,  34,  62,  34,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 115, 121, 
  115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 
  110, 101, 114,  95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101, 
   65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 
  108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 111, 114, 109, 
   95, 115, 121, 109,  98, 111, 108,  44,  32, 110, 101, 119,  95, 108, 105, 115, 
  116,  40, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 
  108,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109, 
   98, 111, 108,  44,  32, 120,  41,  41,  44,  32, 116, 104, 101,  84, 104, 105, 
  110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  99, 
   48,  32,  61,  61,  32,  34,  62,  34,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110, 
   97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 
  114,  95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101,  65, 110, 
  110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  44, 
   32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 102, 117, 110,  99, 116, 105, 
  111, 110,  95, 115, 121, 109,  98, 111, 108,  44,  32, 115, 111, 109, 101, 116, 
  104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  44,  32, 120,  41,  44, 
   32, 116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 112, 117, 116,  40,  99,  48,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 
  111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 
  116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116, 
   40, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 
  115, 121, 109,  98, 111, 108,  44,  32, 120,  44,  32, 116, 104, 101,  84, 104, 
  105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 104, 101,  97, 100, 
   32,  61,  61,  32,  34,  43,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 
  111,  95, 112,  97,  99, 107,  95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 
  116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116, 
   40, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108,  44,  32, 
  120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 
  105, 102,  32, 104, 101,  97, 100,  32,  61,  61,  32,  34,  91,  34,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 115, 121, 
  115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  95, 105, 110, 
  110, 101, 114,  95, 109, 117, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  95, 103, 
  101, 116,  40,  34,  93,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 121,  95, 
  120, 102, 120,  95, 120, 102,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 104, 101,  97, 100,  32,  61, 
   61,  32,  34,  95,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  97, 115, 115, 101, 114, 116,  95, 103, 101, 
  116,  40,  34,  58,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 114, 101, 
   97, 100, 115, 121, 115, 110,  97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 
  107,  95, 105, 110, 110, 101, 114,  95, 109, 117, 115, 116,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 110, 101, 119,  95, 108, 105, 115, 116,  40, 116, 121, 112, 101, 
   65, 110, 110, 111, 116,  97, 116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 
  108,  44,  32, 120,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 
  115, 121, 109,  98, 111, 108,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 112, 117, 116,  40, 104, 101,  97, 100,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 115, 121, 109,  98, 111, 108,  40,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61, 
   32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 109,  97, 121, 
   95, 120, 102, 120,  95, 120, 102,  40, 120,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 
   32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 114, 101,  97, 
  100, 115, 121, 115, 110,  97, 109, 101,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 120,  32,  61,  32, 114, 101,  97, 100, 115, 121, 115, 110, 
   97, 109, 101,  95, 110, 111,  95, 112,  97,  99, 107,  40,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120,  32,  61,  61,  32, 102, 
   97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 115, 121, 109,  98, 111, 
  108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 121, 115, 
  116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 107, 101,  40, 120,  41,  59, 
   10,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 115, 116, 
   97, 116, 101,  95,  99, 111, 110, 115, 116,  32,  61,  32, 120,  59,  10,  32, 
   32,  32,  32, 115, 116,  97, 116, 101,  32,  61,  32,  48,  59,  10,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 107, 101,  95, 114, 101,  97, 
  100,  95, 116, 119, 111,  59,  10,  32,  32,  32,  32, 109,  97, 107, 101,  95, 
  114, 101,  97, 100,  95, 116, 119, 111,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 112, 114, 101, 102, 105, 120,  44,  32, 107,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40,  41,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 101, 111, 102,  40,  41,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32,  99,  32,  61,  32, 103, 101, 116,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  99,  32, 126, 
   61,  32, 112, 114, 101, 102, 105, 120,  32, 116, 104, 101, 110,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 112, 117, 
  116,  40,  99,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 102,  97, 108, 
  115, 101,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 120, 115,  32,  61,  32, 108, 105, 115, 116,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 120, 115,  32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 
  101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  99, 111, 110, 115, 
  116, 114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120, 115,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101, 
   95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120,  32,  61,  32, 
   99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 
  108,  40, 120, 115,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 110, 111, 116,  32,  40,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 120,  41,  32,  97, 110, 100, 
   32, 110, 117, 108, 108,  95, 112,  40,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120,  41,  41,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101, 
   95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 107,  40,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100, 
   40, 120, 115,  41,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 104, 101,  97, 100,  40, 120,  41,  41,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 107, 
  101,  95, 114, 101,  97, 100,  95, 116, 104, 114, 101, 101,  59,  10,  32,  32, 
   32,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 104, 114, 101, 
  101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 112, 114, 101, 
  102, 105, 120,  44,  32, 107,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 101, 111, 102,  40,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32,  99,  32,  61,  32, 
  103, 101, 116,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32,  99,  32, 126,  61,  32, 112, 114, 101, 102, 105, 
  120,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 112, 117, 116,  40,  99,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 102,  97, 108, 115, 101,  59,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
  115,  32,  61,  32, 108, 105, 115, 116,  40,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 120, 115,  32,  61,  61, 
   32, 102,  97, 108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32, 110, 111, 116,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 
  110,  95, 112,  40, 120, 115,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 120,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120, 115,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 
  111, 116,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 
  112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 120,  95, 100,  32,  61,  32,  99, 111, 110, 115, 116, 114, 117,  99, 
  116, 105, 111, 110,  95, 116,  97, 105, 108,  40, 120,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 111, 116, 
   32,  40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 112, 
   40, 120,  95, 100,  41,  32,  97, 110, 100,  32, 110, 117, 108, 108,  95, 112, 
   40,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 
  105, 108,  40, 120,  95, 100,  41,  41,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 
  114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 107,  40,  99, 111, 110, 115, 116, 114, 
  117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 115,  41,  44, 
   32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101, 
   97, 100,  40, 120,  41,  44,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  95, 104, 101,  97, 100,  40, 120,  95, 100,  41,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32,  32, 
   32, 101, 110, 100,  59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 101, 118, 
   97, 108,  32,  61,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 
  119, 111,  40,  34,  36,  34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 101,  44,  32, 120,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 101, 110, 118,  32,  61,  32, 118,  97, 108,  50, 101, 
  110, 118,  40, 101,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 
  102,  32, 101, 110, 118,  32,  61,  61,  32, 102,  97, 108, 115, 101,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 
  111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 
  100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 101, 118,  97, 108, 117,  97, 116, 101,  40, 101, 110, 118,  44,  32, 120, 
   41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32, 
   32, 114, 101,  97, 100, 102, 117, 110,  99,  97, 112, 112, 108, 121,  32,  61, 
   32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 119, 111,  40,  34, 
   37,  34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 102,  44,  32, 
  120, 115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 106, 115, 120, 115,  32,  61,  32, 108, 105, 115, 116,  95, 116, 111, 
   95, 106, 115,  65, 114, 114,  97, 121,  40, 120, 115,  44,  32, 102, 117, 110, 
   99, 116, 105, 111, 110,  40, 120, 115,  41,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 115,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120, 115,  44,  32, 121,  41,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  98, 117, 105, 
  108, 116, 105, 110,  95, 102, 117, 110,  99,  95,  97, 112, 112, 108, 121,  40, 
  102,  44,  32, 106, 115, 120, 115,  41,  59,  10,  32,  32,  32,  32, 101, 110, 
  100,  41,  59,  10,  32,  32,  32,  32, 114, 101,  97, 100, 102, 111, 114, 109, 
   98, 117, 105, 108, 116, 105, 110,  32,  61,  32, 109,  97, 107, 101,  95, 114, 
  101,  97, 100,  95, 116, 104, 114, 101, 101,  40,  34,  64,  34,  44,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 101,  44,  32, 102,  44,  32, 120, 115, 
   41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 
  106, 115, 120, 115,  32,  61,  32, 108, 105, 115, 116,  95, 116, 111,  95, 106, 
  115,  65, 114, 114,  97, 121,  40, 120, 115,  44,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 120, 115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 115,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  40, 120, 115,  44,  32, 121,  41,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 
   97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 101, 110, 118,  32,  61,  32, 
  118,  97, 108,  50, 101, 110, 118,  40, 101,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32, 105, 102,  32, 101, 110, 118,  32,  61,  61,  32, 102,  97, 
  108, 115, 101,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112,  97, 114, 115, 
  101,  95, 101, 114, 114, 111, 114,  40,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 
  114, 109,  95,  97, 112, 112, 108, 121,  40, 101, 110, 118,  44,  32, 102,  44, 
   32, 106, 115, 120, 115,  41,  59,  10,  32,  32,  32,  32, 101, 110, 100,  41, 
   59,  10,  32,  32,  32,  32, 114, 101,  97, 100,  97, 112, 112, 108, 121,  32, 
   61,  32, 109,  97, 107, 101,  95, 114, 101,  97, 100,  95, 116, 119, 111,  40, 
   34,  94,  34,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  40, 102,  44, 
   32, 120, 115,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 106, 115, 120, 115,  32,  61,  32, 108, 105, 115, 116,  95, 116, 
  111,  95, 106, 115,  65, 114, 114,  97, 121,  40, 120, 115,  44,  32, 102, 117, 
  110,  99, 116, 105, 111, 110,  40, 120, 115,  41,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 120, 115, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  44,  32, 102, 
  117, 110,  99, 116, 105, 111, 110,  40, 120, 115,  44,  32, 121,  41,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 112,  97, 114, 115, 101,  95, 101, 114, 114, 111, 114,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  41,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  97, 112, 
  112, 108, 121,  40, 102,  44,  32, 106, 115, 120, 115,  41,  59,  10,  32,  32, 
   32,  32, 101, 110, 100,  41,  59,  10,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 118,  97, 108,  40,  41,  59,  10, 101, 110, 100,  59,  10, 101, 
  120, 112, 111, 114, 116, 115,  46,  99, 111, 109, 112, 108, 101, 120,  95, 112, 
   97, 114, 115, 101,  32,  61,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 
   97, 114, 115, 101,  59,  10, 108, 111,  99,  97, 108,  32,  99, 111, 109, 112, 
  108, 101, 120,  95, 112, 114, 105, 110, 116,  59,  10,  99, 111, 109, 112, 108, 
  101, 120,  95, 112, 114, 105, 110, 116,  32,  61,  32, 102, 117, 110,  99, 116, 
  105, 111, 110,  40, 118,  97, 108,  41,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 
  101,  59,  10,  32,  32,  32,  32, 112, 114, 105, 110, 116,  95, 115, 121, 115, 
   95, 110,  97, 109, 101,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 110, 
   40, 120,  44,  32, 119, 104, 101, 114, 101,  41,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 115, 121, 109,  98, 111, 108,  95, 112,  40, 120, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 117, 110,  95, 115, 121, 109, 
   98, 111, 108,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 110, 110, 101, 114,  95,  98, 
  114,  97,  99, 107, 101, 116,  32,  61,  32, 102, 117, 110,  99, 116, 105, 111, 
  110,  40, 120,  41,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 105, 102,  32, 119, 104, 101, 114, 101,  32,  61,  61,  32,  34, 105, 110, 
  110, 101, 114,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32,  40,  34,  91,  34,  32,  46,  46,  32, 120,  41,  32,  46,  46,  32,  34, 
   93,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 108, 115, 101, 105, 102,  32, 119, 104, 101, 114, 101,  32,  61,  61,  32, 
   34, 116, 111, 112,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 120,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 121,  98, 
  101,  95, 120, 115,  32,  61,  32, 109,  97, 121,  98, 101,  95, 108, 105, 115, 
  116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121,  40, 120,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40, 109,  97, 
  121,  98, 101,  95, 120, 115,  32, 126,  61,  32, 102,  97, 108, 115, 101,  41, 
   32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101,  95, 120, 115, 
   41,  32,  61,  61,  32,  51,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 
  111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117, 
   97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  48,  32, 
   43,  32,  49,  93,  44,  32, 116, 121, 112, 101,  65, 110, 110, 111, 116,  97, 
  116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111, 
   99,  97, 108,  32, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  50,  32, 
   61,  32, 109,  97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111,  95, 
  106, 115,  65, 114, 114,  97, 121,  40, 109,  97, 121,  98, 101,  95, 120, 115, 
   91,  49,  32,  43,  32,  49,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40, 109,  97, 121,  98, 101, 
   95, 108, 115, 116,  95,  50,  32, 126,  61,  32, 102,  97, 108, 115, 101,  41, 
   32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101,  95, 108, 115, 
  116,  95,  50,  41,  32,  61,  61,  32,  51,  41,  41,  32,  97, 110, 100,  32, 
  106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 
  101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 108, 115, 
  116,  95,  50,  91,  48,  32,  43,  32,  49,  93,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 
  110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 118,  97, 114,  95,  50,  95,  49,  32, 
   61,  32, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  50,  91,  49,  32, 
   43,  32,  49,  93,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 121,  98, 
  101,  95, 108, 115, 116,  95,  51,  32,  61,  32, 109,  97, 121,  98, 101,  95, 
  108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121,  40, 
  118,  97, 114,  95,  50,  95,  49,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40, 109, 
   97, 121,  98, 101,  95, 108, 115, 116,  95,  51,  32, 126,  61,  32, 102,  97, 
  108, 115, 101,  41,  32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 
  101,  95, 108, 115, 116,  95,  51,  41,  32,  61,  61,  32,  49,  41,  41,  32, 
   97, 110, 100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 
  114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 
  101,  95, 108, 115, 116,  95,  50,  91,  50,  32,  43,  32,  49,  93,  44,  32, 
  115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  40, 
   40, 112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 
  109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  51,  91,  48,  32,  43,  32, 
   49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  32,  46,  46,  32, 
   34,  46,  34,  41,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 
  115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91, 
   50,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  40,  99, 111, 110, 115, 116, 
  114, 117,  99, 116, 105, 111, 110,  95, 112,  40, 118,  97, 114,  95,  50,  95, 
   49,  41,  32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111, 
   95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   40, 118,  97, 114,  95,  50,  95,  49,  41,  44,  32, 115, 111, 109, 101, 116, 
  104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  41,  32,  97, 110, 
  100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 
  101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 
  108, 115, 116,  95,  50,  91,  50,  32,  43,  32,  49,  93,  44,  32, 115, 111, 
  109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  32, 
  116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
  105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  40,  40, 112, 
  114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40,  99, 111, 
  110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 
  118,  97, 114,  95,  50,  95,  49,  41,  44,  32,  34, 105, 110, 110, 101, 114, 
   34,  41,  32,  46,  46,  32,  34,  64,  34,  41,  32,  46,  46,  32, 112, 114, 
  105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 109,  97, 121, 
   98, 101,  95, 120, 115,  91,  50,  32,  43,  32,  49,  93,  44,  32,  34, 105, 
  110, 110, 101, 114,  34,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 
  106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 
  101, 113, 117,  97, 108,  95, 112,  40, 118,  97, 114,  95,  50,  95,  49,  44, 
   32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 
  108,  41,  32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111, 
   95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109, 
   97, 121,  98, 101,  95, 120, 115,  91,  50,  32,  43,  32,  49,  93,  44,  32, 
  116, 104, 101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110, 
   32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  40,  34, 
   58,  62,  34,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 115, 
   95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95, 
   50,  91,  50,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114, 
   34,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 121,  98, 101, 
   95, 108, 115, 116,  95,  52,  52,  32,  61,  32, 109,  97, 121,  98, 101,  95, 
  108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121,  40, 
  109,  97, 121,  98, 101,  95, 120, 115,  91,  50,  32,  43,  32,  49,  93,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32,  40,  40, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114, 
   99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101, 
   95, 120, 115,  91,  49,  32,  43,  32,  49,  93,  44,  32, 102, 117, 110,  99, 
  116, 105, 111, 110,  95, 115, 121, 109,  98, 111, 108,  41,  32,  97, 110, 100, 
   32,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  52,  52,  32, 126, 
   61,  32, 102,  97, 108, 115, 101,  41,  41,  32,  97, 110, 100,  32,  40,  40, 
   35, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  52,  52,  41,  32,  61, 
   61,  32,  50,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 108, 
   95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 
  112,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  52,  52,  91,  48, 
   32,  43,  32,  49,  93,  44,  32, 105, 115,  79, 114,  78, 111, 116,  95, 115, 
  121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116, 
   40, 112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 
  109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  52,  52,  91,  49,  32,  43, 
   32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  32,  46,  46, 
   32,  34,  63,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32,  40,  40,  40, 109,  97, 121,  98, 101,  95, 108, 
  115, 116,  95,  50,  32, 126,  61,  32, 102,  97, 108, 115, 101,  41,  32,  97, 
  110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95, 
   50,  41,  32,  61,  61,  32,  50,  41,  41,  32,  97, 110, 100,  32, 106, 115, 
   98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 
  117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  50, 
   32,  43,  32,  49,  93,  44,  32, 116, 104, 101,  84, 104, 105, 110, 103,  95, 
  115, 121, 109,  98, 111, 108,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 
  111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117, 
   97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  50, 
   91,  48,  32,  43,  32,  49,  93,  44,  32, 102, 111, 114, 109,  95, 115, 121, 
  109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  32,  61,  32, 
  109,  97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115, 
   65, 114, 114,  97, 121,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95, 
   50,  91,  49,  32,  43,  32,  49,  93,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40, 
   40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  32, 126,  61, 
   32, 102,  97, 108, 115, 101,  41,  32,  97, 110, 100,  32,  40,  40,  35, 109, 
   97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  41,  32,  61,  61,  32, 
   51,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 
  111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 
  109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  91,  48,  32,  43, 
   32,  49,  93,  44,  32, 102, 117, 110,  99, 116, 105, 111, 110,  95, 115, 121, 
  109,  98, 111, 108,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 
  108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108, 
   95, 112,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  91, 
   49,  32,  43,  32,  49,  93,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 
  103,  95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 105, 110, 110, 101, 114,  95, 
   98, 114,  97,  99, 107, 101, 116,  40,  34,  58,  38,  62,  34,  32,  46,  46, 
   32, 112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 
  109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  56,  91,  50,  32,  43, 
   32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 104, 100,  32,  61,  32,  40, 106, 115,  98, 111, 
  111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 
  108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  50,  32,  43, 
   32,  49,  93,  44,  32, 115, 111, 109, 101, 116, 104, 105, 110, 103,  95, 115, 
  121, 109,  98, 111, 108,  41,  32,  97, 110, 100,  32,  34,  95,  34,  41,  32, 
  111, 114,  32,  40,  40, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 
  111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121, 
   98, 101,  95, 120, 115,  91,  50,  32,  43,  32,  49,  93,  44,  32, 116, 104, 
  101,  84, 104, 105, 110, 103,  95, 115, 121, 109,  98, 111, 108,  41,  32,  97, 
  110, 100,  32,  34,  34,  41,  32, 111, 114,  32, 112, 114, 105, 110, 116,  95, 
  115, 121, 115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 
  115,  91,  50,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114, 
   34,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32, 105, 110, 110, 101, 114,  95,  98, 114, 
   97,  99, 107, 101, 116,  40,  40, 104, 100,  32,  46,  46,  32,  34,  58,  34, 
   41,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110, 
   97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  49,  32,  43, 
   32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32,  40, 
  109,  97, 121,  98, 101,  95, 120, 115,  32, 126,  61,  32, 102,  97, 108, 115, 
  101,  41,  32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101,  95, 
  120, 115,  41,  32,  61,  61,  32,  50,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 106, 115, 
   98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 
  117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  48, 
   32,  43,  32,  49,  93,  44,  32, 102, 111, 114, 109,  95, 115, 121, 109,  98, 
  111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 109, 
   97, 121,  98, 101,  95, 108, 115, 116,  95,  50,  56,  56,  32,  61,  32, 109, 
   97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111,  95, 106, 115,  65, 
  114, 114,  97, 121,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  49,  32, 
   43,  32,  49,  93,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40, 109,  97, 121,  98, 
  101,  95, 108, 115, 116,  95,  50,  56,  56,  32, 126,  61,  32, 102,  97, 108, 
  115, 101,  41,  32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101, 
   95, 108, 115, 116,  95,  50,  56,  56,  41,  32,  61,  61,  32,  50,  41,  41, 
   32,  97, 110, 100,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 
  111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121, 
   98, 101,  95, 108, 115, 116,  95,  50,  56,  56,  91,  48,  32,  43,  32,  49, 
   93,  44,  32, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109,  98, 111, 108, 
   41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  40, 
   34,  38,  43,  34,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 
  115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116, 
   95,  50,  56,  56,  91,  49,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 
  110, 101, 114,  34,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116, 
   40,  34,  38,  34,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 
  115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91, 
   49,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41, 
   41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 
  108, 115, 101, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 
  102, 111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 
  121,  98, 101,  95, 120, 115,  91,  48,  32,  43,  32,  49,  93,  44,  32, 105, 
  115,  79, 114,  78, 111, 116,  95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 105, 110, 110, 101, 114, 
   95,  98, 114,  97,  99, 107, 101, 116,  40, 112, 114, 105, 110, 116,  95, 115, 
  121, 115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 115, 
   91,  49,  32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34, 
   41,  32,  46,  46,  32,  34, 126,  34,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 106, 115, 
   98, 111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 
  117,  97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  48, 
   32,  43,  32,  49,  93,  44,  32, 115, 121, 115, 116, 101, 109,  95, 115, 121, 
  109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 
  110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97,  99, 107, 101, 116,  40, 
   34,  43,  34,  32,  46,  46,  32, 112, 114, 105, 110, 116,  95, 115, 121, 115, 
   95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  49, 
   32,  43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  41, 
   59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 
  115, 101, 105, 102,  32, 106, 115,  98, 111, 111, 108,  95, 110, 111,  95, 102, 
  111, 114,  99, 101,  95, 101, 113, 117,  97, 108,  95, 112,  40, 109,  97, 121, 
   98, 101,  95, 120, 115,  91,  48,  32,  43,  32,  49,  93,  44,  32, 115, 117, 
   98,  95, 115, 121, 109,  98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56, 
   57,  51,  52,  32,  61,  32, 109,  97, 121,  98, 101,  95, 108, 105, 115, 116, 
   95, 116, 111,  95, 106, 115,  65, 114, 114,  97, 121,  40, 109,  97, 121,  98, 
  101,  95, 120, 115,  91,  49,  32,  43,  32,  49,  93,  41,  59,  10,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102, 
   32,  40, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  57,  51,  52, 
   32, 126,  61,  32, 102,  97, 108, 115, 101,  41,  32,  97, 110, 100,  32,  40, 
   40,  35, 109,  97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  57,  51,  52, 
   41,  32,  62,  32,  49,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  108, 111,  99,  97, 108,  32, 116, 109, 112,  32,  61,  32, 112, 114, 105, 110, 
  116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 101, 
   95, 108, 115, 116,  95,  56,  57,  51,  52,  91,  48,  32,  43,  32,  49,  93, 
   44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  59,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  100, 111,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 108, 
   32, 105,  32,  61,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  119, 104, 105, 108, 101,  32, 105,  32,  60,  32,  40,  35, 109,  97, 121,  98, 
  101,  95, 108, 115, 116,  95,  56,  57,  51,  52,  41,  32, 100, 111,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 116, 109, 112,  32,  61, 
   32, 116, 109, 112,  32,  46,  46,  32,  40,  34,  47,  34,  32,  46,  46,  32, 
  112, 114, 105, 110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 109, 
   97, 121,  98, 101,  95, 108, 115, 116,  95,  56,  57,  51,  52,  91, 105,  32, 
   43,  32,  49,  93,  44,  32,  34, 105, 110, 110, 101, 114,  34,  41,  41,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 105,  32,  61, 
   32, 105,  32,  43,  32,  49,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
  114, 101, 116, 117, 114, 110,  32, 105, 110, 110, 101, 114,  95,  98, 114,  97, 
   99, 107, 101, 116,  40, 116, 109, 112,  41,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 105, 102,  32, 119, 104, 101, 114, 101,  32,  61,  61,  32,  34, 
  105, 110, 110, 101, 114,  34,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 115, 
  105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 120,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 119, 
  104, 101, 114, 101,  32,  61,  61,  32,  34, 116, 111, 112,  34,  32, 116, 104, 
  101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 114, 
  101, 116, 117, 114, 110,  32, 115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 
  110, 116,  40, 115, 121, 115, 116, 101, 109,  78,  97, 109, 101,  95, 109,  97, 
  107, 101,  40, 120,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
  101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 
  114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10,  32,  32,  32,  32, 
  101, 110, 100,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 120, 
   32,  61,  32, 115, 105, 109, 112, 108, 101,  95, 112,  97, 114, 115, 101,  40, 
  115, 105, 109, 112, 108, 101,  95, 112, 114, 105, 110, 116,  40, 118,  97, 108, 
   41,  41,  59,  10,  32,  32,  32,  32, 108, 111,  99,  97, 108,  32, 116, 101, 
  109, 112,  32,  61,  32,  34,  34,  59,  10,  32,  32,  32,  32, 108, 111,  99, 
   97, 108,  32, 112, 114, 101, 102, 105, 120,  32,  61,  32,  34,  34,  59,  10, 
   32,  32,  32,  32, 105, 102,  32, 110, 117, 108, 108,  95, 112,  40, 120,  41, 
   32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 
  116, 117, 114, 110,  32,  34,  40,  41,  34,  59,  10,  32,  32,  32,  32, 101, 
  108, 115, 101, 105, 102,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 
  111, 110,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32, 
   32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32,  34,  40,  34,  59, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 112, 114, 101, 102, 105, 120,  32, 
   61,  32,  34,  34,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 119, 104, 
  105, 108, 101,  32,  99, 111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110, 
   95, 112,  40, 120,  41,  32, 100, 111,  10,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 109, 112, 
   32,  46,  46,  32,  40, 112, 114, 101, 102, 105, 120,  32,  46,  46,  32,  99, 
  111, 109, 112, 108, 101, 120,  95, 112, 114, 105, 110, 116,  40,  99, 111, 110, 
  115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 104, 101,  97, 100,  40, 120, 
   41,  41,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 
   32, 112, 114, 101, 102, 105, 120,  32,  61,  32,  34,  32,  34,  59,  10,  32, 
   32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 120,  32,  61,  32,  99, 
  111, 110, 115, 116, 114, 117,  99, 116, 105, 111, 110,  95, 116,  97, 105, 108, 
   40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32, 110, 117, 108, 108, 
   95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 
  109, 112,  32,  46,  46,  32,  34,  41,  34,  59,  10,  32,  32,  32,  32,  32, 
   32,  32,  32, 101, 108, 115, 101,  10,  32,  32,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32, 116, 101, 109, 112,  32,  61,  32, 116, 101, 109, 112,  32, 
   46,  46,  32,  40,  40,  34,  32,  46,  32,  34,  32,  46,  46,  32,  99, 111, 
  109, 112, 108, 101, 120,  95, 112, 114, 105, 110, 116,  40, 120,  41,  41,  32, 
   46,  46,  32,  34,  41,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 101, 110, 100,  10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32, 116, 101, 109, 112,  59,  10,  32,  32,  32,  32, 101, 108, 
  115, 101, 105, 102,  32, 100,  97, 116,  97,  95, 112,  40, 120,  41,  32, 116, 
  104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 111,  99,  97, 
  108,  32, 110,  97, 109, 101,  32,  61,  32, 100,  97, 116,  97,  95, 110,  97, 
  109, 101,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 108, 
  111,  99,  97, 108,  32, 108, 105, 115, 116,  32,  61,  32, 100,  97, 116,  97, 
   95, 108, 105, 115, 116,  40, 120,  41,  59,  10,  32,  32,  32,  32,  32,  32, 
   32,  32, 108, 111,  99,  97, 108,  32, 109,  97, 121,  98, 101,  95, 120, 115, 
   32,  61,  32, 109,  97, 121,  98, 101,  95, 108, 105, 115, 116,  95, 116, 111, 
   95, 106, 115,  65, 114, 114,  97, 121,  40, 108, 105, 115, 116,  41,  59,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 105, 102,  32,  40,  40,  40, 109,  97, 
  121,  98, 101,  95, 120, 115,  32, 126,  61,  32, 102,  97, 108, 115, 101,  41, 
   32,  97, 110, 100,  32,  40,  40,  35, 109,  97, 121,  98, 101,  95, 120, 115, 
   41,  32,  61,  61,  32,  50,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 
  111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117, 
   97, 108,  95, 112,  40, 110,  97, 109, 101,  44,  32, 110,  97, 109, 101,  95, 
  115, 121, 109,  98, 111, 108,  41,  41,  32,  97, 110, 100,  32, 106, 115,  98, 
  111, 111, 108,  95, 110, 111,  95, 102, 111, 114,  99, 101,  95, 101, 113, 117, 
   97, 108,  95, 112,  40, 109,  97, 121,  98, 101,  95, 120, 115,  91,  48,  32, 
   43,  32,  49,  93,  44,  32, 115, 121, 115, 116, 101, 109,  95, 115, 121, 109, 
   98, 111, 108,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32, 
   32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 112, 114, 105, 
  110, 116,  95, 115, 121, 115,  95, 110,  97, 109, 101,  40, 109,  97, 121,  98, 
  101,  95, 120, 115,  91,  49,  32,  43,  32,  49,  93,  44,  32,  34, 116, 111, 
  112,  34,  41,  59,  10,  32,  32,  32,  32,  32,  32,  32,  32, 101, 110, 100, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
   34,  35,  34,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 
  114, 105, 110, 116,  40, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117, 
   99, 116, 105, 111, 110,  40, 110,  97, 109, 101,  44,  32, 108, 105, 115, 116, 
   41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 101, 
  114, 114, 111, 114,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10,  32, 
   32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  34,  33, 
   34,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 114, 105, 
  110, 116,  40, 110, 101, 119,  95,  99, 111, 110, 115, 116, 114, 117,  99, 116, 
  105, 111, 110,  40, 101, 114, 114, 111, 114,  95, 110,  97, 109, 101,  40, 120, 
   41,  44,  32, 101, 114, 114, 111, 114,  95, 108, 105, 115, 116,  40, 120,  41, 
   41,  41,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 115, 
  121, 109,  98, 111, 108,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 117, 
  110,  95, 115, 121, 109,  98, 111, 108,  40, 120,  41,  59,  10,  32,  32,  32, 
   32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95, 101, 118, 
   97, 108, 117,  97, 116, 101,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110, 
   10,  32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32, 
   40,  40,  40,  34,  36,  40,  34,  32,  46,  46,  32,  99, 111, 109, 112, 108, 
  101, 120,  95, 112, 114, 105, 110, 116,  40, 101, 110, 118,  50, 118,  97, 108, 
   40, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 101,  95, 
  101, 110, 118,  40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  32,  34, 
   41,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 114, 105, 
  110, 116,  40, 100, 101, 108,  97, 121,  95, 101, 118,  97, 108, 117,  97, 116, 
  101,  95, 120,  40, 120,  41,  41,  41,  32,  46,  46,  32,  34,  41,  34,  59, 
   10,  32,  32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 
  121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 117, 110,  99,  95, 112, 
   40, 120,  41,  32, 116, 104, 101, 110,  10,  32,  32,  32,  32,  32,  32,  32, 
   32, 114, 101, 116, 117, 114, 110,  32,  40,  40,  40,  34,  37,  40,  34,  32, 
   46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 114, 105, 110, 116, 
   40, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 
  117, 110,  99,  95, 102,  40, 120,  41,  41,  41,  32,  46,  46,  32,  34,  32, 
   34,  41,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 114, 
  105, 110, 116,  40, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 
  105, 115, 116,  40, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 
  110,  95, 102, 117, 110,  99,  95, 120, 115,  40, 120,  41,  41,  41,  41,  32, 
   46,  46,  32,  34,  41,  34,  59,  10,  32,  32,  32,  32, 101, 108, 115, 101, 
  105, 102,  32, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110, 
   95, 102, 111, 114, 109,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 
   40,  40,  40,  40,  34,  64,  40,  34,  32,  46,  46,  32,  99, 111, 109, 112, 
  108, 101, 120,  95, 112, 114, 105, 110, 116,  40, 101, 110, 118,  50, 118,  97, 
  108,  40, 100, 101, 108,  97, 121,  95,  98, 117, 105, 108, 116, 105, 110,  95, 
  102, 111, 114, 109,  95, 101, 110, 118,  40, 120,  41,  41,  41,  41,  32,  46, 
   46,  32,  34,  32,  34,  41,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 
  120,  95, 112, 114, 105, 110, 116,  40, 100, 101, 108,  97, 121,  95,  98, 117, 
  105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 102,  40, 120,  41,  41, 
   41,  32,  46,  46,  32,  34,  32,  34,  41,  32,  46,  46,  32,  99, 111, 109, 
  112, 108, 101, 120,  95, 112, 114, 105, 110, 116,  40, 106, 115,  65, 114, 114, 
   97, 121,  95, 116, 111,  95, 108, 105, 115, 116,  40, 100, 101, 108,  97, 121, 
   95,  98, 117, 105, 108, 116, 105, 110,  95, 102, 111, 114, 109,  95, 120, 115, 
   40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  41,  34,  59,  10,  32, 
   32,  32,  32, 101, 108, 115, 101, 105, 102,  32, 100, 101, 108,  97, 121,  95, 
   97, 112, 112, 108, 121,  95, 112,  40, 120,  41,  32, 116, 104, 101, 110,  10, 
   32,  32,  32,  32,  32,  32,  32,  32, 114, 101, 116, 117, 114, 110,  32,  40, 
   40,  40,  34,  94,  40,  34,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 
  120,  95, 112, 114, 105, 110, 116,  40, 100, 101, 108,  97, 121,  95,  97, 112, 
  112, 108, 121,  95, 102,  40, 120,  41,  41,  41,  32,  46,  46,  32,  34,  32, 
   34,  41,  32,  46,  46,  32,  99, 111, 109, 112, 108, 101, 120,  95, 112, 114, 
  105, 110, 116,  40, 106, 115,  65, 114, 114,  97, 121,  95, 116, 111,  95, 108, 
  105, 115, 116,  40, 100, 101, 108,  97, 121,  95,  97, 112, 112, 108, 121,  95, 
  120, 115,  40, 120,  41,  41,  41,  41,  32,  46,  46,  32,  34,  41,  34,  59, 
   10,  32,  32,  32,  32, 101, 110, 100,  10,  32,  32,  32,  32, 114, 101, 116, 
  117, 114, 110,  32,  69,  82,  82,  79,  82,  40,  41,  59,  10, 101, 110, 100, 
   59,  10, 101, 120, 112, 111, 114, 116, 115,  46,  99, 111, 109, 112, 108, 101, 
  120,  95, 112, 114, 105, 110, 116,  32,  61,  32,  99, 111, 109, 112, 108, 101, 
  120,  95, 112, 114, 105, 110, 116,  59,  10, 114, 101, 116, 117, 114, 110,  32, 
  101, 120, 112, 111, 114, 116, 115,  59,  10,   0,
};

#define ZZ_LUAOPEN_NAME luaopen_lang

#include "luaot-generated-footer.c"
