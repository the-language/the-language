//
//	Package - transpiled by c4go
//
//	If you have found any issues, please raise an issue at:
//	https://github.com/Konstantin8105/c4go/
//

// Warning (*ast.FieldDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26632 :Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22256 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22262 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22276 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22362 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22406 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22408 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22437 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22486 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22538 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22550 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22556 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22559 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22580 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22581 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22582 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22590 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22590 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22596 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22597 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22598 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22599 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22616 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22755 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22765 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22814 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22816 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile BinaryOperator with type 'GCObject *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'GCObject *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22822 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22824 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22870 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22883 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22897 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22901 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22935 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22937 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22943 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22949 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23172 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23234 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23235 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25982 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26032 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26121 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26183 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26189 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26193 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26442 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26491 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26524 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26563 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26683 :Cannot casting {jmp_buf -> struct __jmp_buf_tag *}. err = Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26702 :Cannot casting {jmp_buf -> struct __jmp_buf_tag *}. err = Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26800 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26819 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26854 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26857 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26906 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26921 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26944 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26981 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27084 :cannot getName for: &ast.ConditionalOperator{Addr:0x55ad81049308, Pos:ast.Position{File:"/home/1828_sandbox/src/the-language/core/arch/c/lang.c", Line:27084, LineEnd:0, Column:9, ColumnEnd:45, StringValue:""}, Type:"Proto *(*)(lua_State *, ZIO *, Mbuffer *, const char *)", Type2:"", ChildNodes:[]ast.Node{(*ast.ParenExpr)(0xc003db06c0), (*ast.ImplicitCastExpr)(0xc003d5bcc0), (*ast.ImplicitCastExpr)(0xc003d5bd60)}}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27720 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27720 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27722 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27742 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27797 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27797 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpileToStmt : Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is luaM_realloc_. argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpileToStmt : Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is luaM_realloc_. argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28382 :cannot determine type for RHS 'decimal_point', will use 'void *' for all fields. Is lvalue = true. n.Name = `decimal_point`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28925 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30480 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31771 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31779 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31779 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31954 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31954 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32007 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32007 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32015 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ForStmt):  :0 :Cannot tranpile ForStmt: err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.WhileStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32015 :Cannot transpileToStmt : Cannot tranpile ForStmt: err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile BinaryOperator with type 'Value' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Value' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32205 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32205 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32585 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32589 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32606 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ImplicitCastExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile BinaryOperator with type 'const TValue *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is get_compTM. argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'const TValue *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is get_compTM. argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32823 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32922 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile BinaryOperator with type 'lua_Number' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'lua_Number' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33192 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33193 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33194 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33214 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33227 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33244 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33245 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33296 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt

package main

// #include </usr/include/setjmp.h>
// #include </usr/include/stdio.h>
// #include </usr/include/string.h>
import "C"

import "math"
import "github.com/Konstantin8105/c4go/linux"
import "unsafe"
import "github.com/Konstantin8105/c4go/noarch"

// lua_CFunction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:882
// Generated by make.rkt
//
//    The Language
//    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Affero General Public License as published
//    by the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Affero General Public License for more details.
//
//    You should have received a copy of the GNU Affero General Public License
//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
//
//-- #include "src.cpp/assert.h" start --
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/errno.h" start --
//-- #include "src.cpp/io.h" start --
//-- File: src.cpp/lang.cpp start --
// WARNING: This file was automatically generated by lua2c.
//-- #include "src.cpp/lauxlib.h" start --
//
//** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
//** Auxiliary functions for building Lua libraries
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/lua.h" start --
//
//** $Id: lua.h,v 1.218.1.7 2012/01/13 20:36:20 roberto Exp $
//** Lua - An Extensible Extension Language
//** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
//** See Copyright Notice at the end of this file
//
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/luaconf.h" start --
//
//** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
//** Configuration file for Lua
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/limits.h" start --
//-- #include "src.cpp/stddef.h" start --
//
//** ==================================================================
//** Search for "@@" to find all configurable definitions.
//** ===================================================================
//
//
//@@ LUA_ANSI controls the use of non-ansi features.
//** CHANGE it (define it) if you want Lua to avoid the use of any
//** non-ansi feature or library.
//
//
//@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
//@* Interfaces Extension (XSI).
//** CHANGE it (define it) if your system is XSI compatible.
//
//
//@@ LUA_PATH and LUA_CPATH are the names of the environment variables that
//@* Lua check to set its paths.
//@@ LUA_INIT is the name of the environment variable that Lua
//@* checks for initialization code.
//** CHANGE them if you want different names.
//
//
//@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
//@* Lua libraries.
//@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
//@* C libraries.
//** CHANGE them if your machine has a non-conventional directory
//** hierarchy or if you want to install your libraries in
//** non-conventional directories.
//
//
//@@ LUA_DIRSEP is the directory separator (for submodules).
//** CHANGE it if your machine does not use "/" as the directory separator
//** and is not Windows. (On Windows Lua automatically uses "\".)
//
//
//@@ LUA_PATHSEP is the character that separates templates in a path.
//@@ LUA_PATH_MARK is the string that marks the substitution points in a
//@* template.
//@@ LUA_EXECDIR in a Windows path is replaced by the executable's
//@* directory.
//@@ LUA_IGMARK is a mark to ignore all before it when bulding the
//@* luaopen_ function name.
//** CHANGE them if for some reason your system cannot use those
//** characters. (E.g., if one of those characters is a common character
//** in file/directory names.) Probably you do not need to change them.
//
//
//@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
//** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
//** machines, ptrdiff_t gives a good choice between int or long.)
//
//
//@@ LUA_API is a mark for all core API functions.
//@@ LUALIB_API is a mark for all standard library functions.
//** CHANGE them if you need to define those functions in some special way.
//** For instance, if you want to create one Windows DLL with the core and
//** the libraries, you may want to use the following definition (define
//** LUA_BUILD_AS_DLL to get it).
//
// more often than not the libs go together with the core
//
//@@ LUAI_FUNC is a mark for all extern functions that are not to be
//@* exported to outside modules.
//@@ LUAI_DATA is a mark for all extern (const) variables that are not to
//@* be exported to outside modules.
//** CHANGE them if you need to mark them in some special way. Elf/gcc
//** (versions 3.2 and later) mark them as "hidden" to optimize access
//** when Lua is compiled as a shared library.
//
//
//@@ LUA_QL describes how error messages quote program elements.
//** CHANGE it if you want a different appearance.
//
//
//@@ LUA_IDSIZE gives the maximum size for the description of the source
//@* of a function in debug information.
//** CHANGE it if you want a different size.
//
//
//** {==================================================================
//** Stand-alone configuration
//** ===================================================================
//
// }==================================================================
//
//@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
//@* as a percentage.
//** CHANGE it if you want the GC to run faster or slower (higher values
//** mean larger pauses which mean slower collection.) You can also change
//** this value dynamically.
//
//
//@@ LUAI_GCMUL defines the default speed of garbage collection relative to
//@* memory allocation as a percentage.
//** CHANGE it if you want to change the granularity of the garbage
//** collection. (Higher values mean coarser collections. 0 represents
//** infinity, where each step performs a full collection.) You can also
//** change this value dynamically.
//
//
//@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
//** CHANGE it (define it) if you want exact compatibility with the
//** behavior of setn/getn in Lua 5.0.
//
//
//@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.
//** CHANGE it to undefined as soon as you do not need a global 'loadlib'
//** function (the function is still available as 'package.loadlib').
//
//
//@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.
//** CHANGE it to undefined as soon as your programs use only '...' to
//** access vararg parameters (instead of the old 'arg' table).
//
//
//@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
//** CHANGE it to undefined as soon as your programs use 'math.fmod' or
//** the new '%' operator instead of 'math.mod'.
//
//
//@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
//@* facility.
//** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
//** off the advisory error when nesting [[...]].
//
//
//@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
//** CHANGE it to undefined as soon as you rename 'string.gfind' to
//** 'string.gmatch'.
//
//
//@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
//@* behavior.
//** CHANGE it to undefined as soon as you replace to 'luaL_register'
//** your uses of 'luaL_openlib'
//
//
//@@ luai_apicheck is the assert macro used by the Lua-C API.
//** CHANGE luai_apicheck if you want Lua to perform some checks in the
//** parameters it gets from API calls. This may slow down the interpreter
//** a bit, but may be quite useful when debugging C code that interfaces
//** with Lua. A useful redefinition is to use assert.h.
//
//
//@@ LUAI_BITSINT defines the number of bits in an int.
//** CHANGE here if Lua cannot automatically detect the number of bits of
//** your machine. Probably you do not need to change this.
//
// avoid overflows in comparison
// int has at least 32 bits
//
//@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
//@@ LUAI_INT32 is an signed integer with at least 32 bits.
//@@ LUAI_UMEM is an unsigned integer big enough to count the total
//@* memory used by Lua.
//@@ LUAI_MEM is a signed integer big enough to count the total memory
//@* used by Lua.
//** CHANGE here if for some weird reason the default definitions are not
//** good enough for your machine. (The definitions in the 'else'
//** part always works, but may waste space on machines with 64-bit
//** longs.) Probably you do not need to change this.
//
//
//@@ LUAI_MAXCALLS limits the number of nested calls.
//** CHANGE it if you need really deep recursive calls. This limit is
//** arbitrary; its only purpose is to stop infinite recursion before
//** exhausting memory.
//
//
//@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
//@* can use.
//** CHANGE it if you need lots of (Lua) stack space for your C
//** functions. This limit is arbitrary; its only purpose is to stop C
//** functions to consume unlimited stack space. (must be smaller than
//** -LUA_REGISTRYINDEX)
//
//
//** {==================================================================
//** CHANGE (to smaller values) the following definitions if your system
//** has a small C stack. (Or you may want to change them to larger
//** values if your system has a large C stack and these limits are
//** too rigid for you.) Some of these constants control the size of
//** stack-allocated arrays used by the compiler or the interpreter, while
//** others limit the maximum number of recursive calls that the compiler
//** or the interpreter can perform. Values too large may cause a C stack
//** overflow for some forms of deep constructs.
//** ===================================================================
//
//
//@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
//@* syntactical nested non-terminals in a program.
//
//
//@@ LUAI_MAXVARS is the maximum number of local variables per function
//@* (must be smaller than 250).
//
//
//@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
//@* (must be smaller than 250).
//
//
//@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
//
// }==================================================================
//
//** {==================================================================
//@@ LUA_NUMBER is the type of numbers in Lua.
//** CHANGE the following definitions only if you want to build Lua
//** with a number type different from double. You may also need to
//** change lua_number2int & lua_number2integer.
//** ===================================================================
//
//
//@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
//@* over a number.
//
//
//@@ LUA_NUMBER_SCAN is the format for reading numbers.
//@@ LUA_NUMBER_FMT is the format for writing numbers.
//@@ lua_number2str converts a number to a string.
//@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
//@@ lua_str2number converts a string to a number.
//
//
//@@ The luai_num* macros define the primitive operations over numbers.
//
//-- #include "src.cpp/math.h" start --
//
//@@ lua_number2int is a macro to convert lua_Number to int.
//@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
//** CHANGE them if you know a faster way to convert a lua_Number to
//** int (with any rounding method and without throwing errors) in your
//** system. In Pentium machines, a naive typecast from double to int
//** in C is extremely slow, so any alternative is worth trying.
//
// On a Pentium, resort to a trick
// }==================================================================
//
//@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
//** CHANGE it if your system requires alignments larger than double. (For
//** instance, if your system supports long doubles and they must be
//** aligned in 16-byte boundaries, then you should add long double in the
//** union.) Probably you do not need to change this.
//
//
//@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
//** CHANGE them if you prefer to use longjmp/setjmp even with C++
//** or if want/don't to use _longjmp/_setjmp instead of regular
//** longjmp/setjmp. By default, Lua handles errors with exceptions when
//** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
//** and with longjmp/setjmp otherwise.
//
// default handling with long jumps
//
//@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
//@* can do during pattern-matching.
//** CHANGE it if you need more captures. This limit is arbitrary.
//
//
//@@ lua_tmpnam is the function that the OS library uses to create a
//@* temporary name.
//@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
//** CHANGE them if you have an alternative to tmpnam (which is considered
//** insecure) or if you want the original tmpnam anyway.  By default, Lua
//** uses tmpnam except when POSIX is available, where it uses mkstemp.
//
//
//@@ lua_popen spawns a new process connected to the current one through
//@* the file streams.
//** CHANGE it if you have a way to implement it in your system.
//
//
//@@ LUA_DL_* define which dynamic-library system Lua should use.
//** CHANGE here if Lua has problems choosing the appropriate
//** dynamic-library system for your platform (either Windows' DLL, Mac's
//** dyld, or Unix's dlopen). If your system is some kind of Unix, there
//** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
//** it.  To use dlopen you also need to adapt the src/Makefile (probably
//** adding -ldl to the linker options), so Lua does not select it
//** automatically.  (When you change the makefile to add -ldl, you must
//** also add -DLUA_USE_DLOPEN.)
//** If you do not want any kind of dynamic library, undefine all these
//** options.
//** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
//
//
//@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
//@* (the data goes just *before* the lua_State pointer).
//** CHANGE (define) this if you really need that. This value must be
//** a multiple of the maximum alignment required for your machine.
//
//
//@@ luai_userstate* allow user-specific actions on threads.
//** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
//** extra when a thread is created/deleted/resumed/yielded.
//
//
//@@ LUA_INTFRMLEN is the length modifier for integer conversions
//@* in 'string.format'.
//@@ LUA_INTFRM_T is the integer type correspoding to the previous length
//@* modifier.
//** CHANGE them if your system supports long long or does not support long.
//
// ===================================================================
//
//** Local configuration. You can use this space to add your redefinitions
//** without modifying the main part of the file.
//
// mark for precompiled code (`<esc>Lua')
// option for multiple returns in `lua_pcall' and `lua_call'
//
//** pseudo-indices
//
// thread status; 0 is OK
type lua_CFunction func([]lua_State) int32

// lua_Reader - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:888
//
//** functions that read/write blocks when loading/dumping Lua chunks
//
type lua_Reader func([]lua_State, interface{}, []uint) []byte

// lua_Writer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:890
type lua_Writer func([]lua_State, interface{}, uint, interface{}) int32

// lua_Alloc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:896
//
//** prototype for memory-allocation functions
//
type lua_Alloc func(interface{}, interface{}, uint, uint) interface{}

// lua_Number - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:929
//
//** basic types
//
// minimum Lua stack available to a C function
//
//** generic extra include file
//
// type of numbers in Lua
type lua_Number = float64

// lua_Integer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:933
// type for integer functions
type lua_Integer = noarch.PtrdiffT

// lua_Hook - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1160
//
//** state manipulation
//
//
//** basic stack manipulation
//
//
//** access functions (stack -> C)
//
//
//** push functions (C -> stack)
//
//
//** get functions (Lua -> stack)
//
//
//** set functions (stack -> Lua)
//
//
//** `load' and `call' functions (load and run Lua code)
//
//
//** coroutine functions
//
//
//** garbage-collection function and options
//
//
//** miscellaneous functions
//
//
//** ===============================================================
//** some useful macros
//** ===============================================================
//
//
//** compatibility macros and functions
//
// hack
//
//** {======================================================================
//** Debug API
//** =======================================================================
//
//
//** Event codes
//
//
//** Event masks
//
// activation record
// Functions to be called by the debuger in specific events
type lua_Hook func([]lua_State, []lua_Debug)

// lua_Debug - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1176
type lua_Debug struct {
	event           int32
	name            []byte
	namewhat        []byte
	what            []byte
	source          []byte
	currentline     int32
	nups            int32
	linedefined     int32
	lastlinedefined int32
	short_src       [60]byte
	i_ci            int32
}

// luaL_Reg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1239
// (n)
// (n) `global', `local', `field', `method'
// (S) `Lua', `C', `main', `tail'
// (S)
// (l)
// (u) number of upvalues
// (S)
// (S)
// (S)
// private part
// active function
// }======================================================================
//
//* Copyright (C) 1994-2012 Lua.org, PUC-Rio.  All rights reserved.
//*
//* Permission is hereby granted, free of charge, to any person obtaining
//* a copy of this software and associated documentation files (the
//* "Software"), to deal in the Software without restriction, including
//* without limitation the rights to use, copy, modify, merge, publish,
//* distribute, sublicense, and/or sell copies of the Software, and to
//* permit persons to whom the Software is furnished to do so, subject to
//* the following conditions:
//*
//* The above copyright notice and this permission notice shall be
//* included in all copies or substantial portions of the Software.
//*
//* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// extra error code for `luaL_load'
type luaL_Reg struct {
	name  []byte
	func_ lua_CFunction
}

// luaL_Buffer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1333
//
//** ===============================================================
//** some useful macros
//** ===============================================================
//
//
//** {======================================================
//** Generic Buffer manipulation
//** =======================================================
//
type luaL_Buffer struct {
	p      []byte
	lvl    int32
	L      []lua_State
	buffer [8192]byte
}

// lc_args_t - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20765
// current position in buffer
// number of strings in the stack (level)
// compatibility only
// }======================================================
// compatibility with ref system
// pre-defined references
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lualib.h" start --
//
//** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
//** Lua standard libraries
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lua.h" start --
// Key to file-handle type
// open all previous libraries
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
// pushes new closure table onto the stack, using closure table at
// * given index as its parent
//-- #include "src.cpp/assert.h" start --
// __add metamethod handler.
// * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative.
// name: __TS__ArrayPush
// * function(arr, item)
// arr[#arr+1] = item
// return #arr
// name: ERROR
// * function()
// error("TheLanguage PANIC")
// 0 links to parent table
// gets upvalue with ID varid by consulting upvalue table at index
// * tidx for the upvalue table at given nesting level.
// 0 links to parent table
// name: ASSERT
// * function(x)
// if not x then
// return ERROR()
// name: symbol_p
// * function(x)
// return x[0 + 1] == 0
// name: un_symbol
// * function(x)
// return x[1 + 1]
// name: new_construction
// * function(x, y)
// return {construction_t, x, y}
// name: construction_p
// * function(x)
// return x[0 + 1] == construction_t
// name: construction_head
// * function(x)
// return x[1 + 1]
// name: construction_tail
// * function(x)
// return x[2 + 1]
// name: null_p
// * function(x)
// return x[0 + 1] == null_t
// name: new_data
// * function(x, y)
// return {data_t, x, y}
// name: data_p
// * function(x)
// return x[0 + 1] == data_t
// name: data_name
// * function(x)
// return x[1 + 1]
// name: data_list
// * function(x)
// return x[2 + 1]
// name: new_error
// * function(x, y)
// return {error_t, x, y}
// name: error_p
// * function(x)
// return x[0 + 1] == error_t
// name: error_name
// * function(x)
// return x[1 + 1]
// name: error_list
// * function(x)
// return x[2 + 1]
// name: lang_set_do
// * function(x, y)
// if x == y then
// return;
// x[0 + 1] = just_t
// x[1 + 1] = y
// x[2 + 1] = false
// x[3 + 1] = false
// name: just_p
// * function(x)
// return x[0 + 1] == just_t
// name: un_just
// * function(x)
// return x[1 + 1]
// name: evaluate
// * function(x, y)
// return {delay_evaluate_t, x, y}
// name: delay_evaluate_p
// * function(x)
// return x[0 + 1] == delay_evaluate_t
// name: delay_evaluate_env
// * function(x)
// return x[1 + 1]
// name: delay_evaluate_x
// * function(x)
// return x[2 + 1]
// name: builtin_form_apply
// * function(x, y, z)
// return {delay_builtin_form_t, x, y, z}
// name: delay_builtin_form_p
// * function(x)
// return x[0 + 1] == delay_builtin_form_t
// name: delay_builtin_form_env
// * function(x)
// return x[1 + 1]
// name: delay_builtin_form_f
// * function(x)
// return x[2 + 1]
// name: delay_builtin_form_xs
// * function(x)
// return x[3 + 1]
// name: builtin_func_apply
// * function(x, y)
// return {delay_builtin_func_t, x, y}
// name: delay_builtin_func_p
// * function(x)
// return x[0 + 1] == delay_builtin_func_t
// name: delay_builtin_func_f
// * function(x)
// return x[1 + 1]
// name: delay_builtin_func_xs
// * function(x)
// return x[2 + 1]
// name: apply
// * function(f, xs)
// return {delay_apply_t, f, xs}
// name: delay_apply_p
// * function(x)
// return x[0 + 1] == delay_apply_t
// name: delay_apply_f
// * function(x)
// return x[1 + 1]
// name: delay_apply_xs
// * function(x)
// return x[2 + 1]
// name: force_all_rec
// * function(raw)
// local x = force_all(raw)
// if data_p(x) then
// local a = x[1 + 1]
// local d = x[2 + 1]
// x[1 + 1] = force_all_rec(a)
// x[2 + 1] = force_all_rec(d)
// return x
// elseif error_p(x) then
// local a = x[1 + 1]
// local d = x[2 + 1]
// x[1 + 1] = force_all_rec(a)
// x[2 + 1] = force_all_rec(d)
// return x
// elseif construction_p(x) then
// local a = x[1 + 1]
// local d = x[2 + 1]
// x[1 + 1] = force_all_rec(a)
// x[2 + 1] = force_all_rec(d)
// return x
// return x
// name: symbol_equal_p
// * function(x, y)
// if x == y then
// return true
// if un_symbol(x) == un_symbol(y) then
// lang_set_do(x, y)
// return true
// else
//     * return false
// __sub metamethod handler.
// * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative.
// warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative.
// result similar to lvm.c l_strcmp
// name: jsArray_to_list
// * function(xs)
// local ret = null_v
// do
//   * local i = (#xs) - 1
// while i >= 0 do
// ret = new_construction(xs[i + 1], ret)
// i = i - 1
// internal: stack cleanup on scope exit
// return ret
// name: new_list
// * function(...)
// local xs = ({...})
// return jsArray_to_list(xs)
// name: un_just_all
// * function(raw)
// local x = raw
// local xs = {}
// while just_p(x) do
// __TS__ArrayPush(xs, x)
// x = un_just(x)
// do
//   * local i = 0
// while i < (#xs) do
// lang_set_do(xs[i + 1], x)
// i = i + 1
// internal: stack cleanup on scope exit
// return x
// name: any_delay_just_p
// * function(x)
// return (((just_p(x) or delay_evaluate_p(x)) or delay_builtin_form_p(x)) or
//   * delay_builtin_func_p(x)) or delay_apply_p(x)
// name: do_rewrite
// * function(newval)
// lang_set_do(x, newval)
// do
//   * local i = 0
// while i < (#xs) do
// lang_set_do(xs[i + 1], newval)
// i = i + 1
// internal: stack cleanup on scope exit
// return newval
// name: do_rewrite_force_all
// * function(newval)
// do_rewrite(newval)
// if any_delay_just_p(newval) then
// __TS__ArrayPush(xs, x)
// return force_all(newval, parents_history, {false, false}, xs)
// return newval
// name: replace_this_with_stopped
// * function()
// ref_novalue_replace[1 + 1] = true
// return do_rewrite_force_all(the_world_stopped_v)
// name: make_history
// * function()
// local ret = {}
// for x_id in pairs(history) do
//   * internal: local f, s, var = explist
// internal: local var_1, ..., var_n = f(s, var)
//     *           if var_1 == nil then break end
//     *           var = var_1
// internal: local x_id with idx 5
// ret[x_id] = true
// internal: stack cleanup on scope exit
// for x_id in pairs(parents_history) do
//   * internal: local f, s, var = explist
// internal: local var_1, ..., var_n = f(s, var)
//     *           if var_1 == nil then break end
//     *           var = var_1
// internal: local x_id with idx 5
// ret[x_id] = true
// internal: stack cleanup on scope exit
// return ret
// name: force_all
// * function(raw, parents_history, ref_novalue_replace, xs)
// if parents_history == nil then
// parents_history = {}
// if ref_novalue_replace == nil then
// ref_novalue_replace = {false, false}
// if xs == nil then
// xs = {}
// local x, do_rewrite, do_rewrite_force_all
// do_rewrite = function(newval)
//   *         lang_set_do(x, newval);
//   *         do
//   *             local i = 0;
//   *             while i < (#xs) do
//   *                 lang_set_do(xs[i + 1], newval);
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return newval;
//   *     end
// do_rewrite_force_all = function(newval)
//   *         do_rewrite(newval);
//   *         if any_delay_just_p(newval) then
//   *             __TS__ArrayPush(xs, x);
//   *             return force_all(newval, parents_history, {false, false}, xs);
//   *         end
//   *         return newval;
//   *     end
// local history = {}
// x = raw
// local replace_this_with_stopped
// replace_this_with_stopped = function()
//   *         ref_novalue_replace[1 + 1] = true;
//   *         return do_rewrite_force_all(the_world_stopped_v);
//   *     end
// local make_history
// make_history = function()
//   *         local ret = {};
//   *         for x_id in pairs(history) do
//   *             ret[x_id] = true;
//   *         end
//   *         for x_id in pairs(parents_history) do
//   *             ret[x_id] = true;
//   *         end
//   *         return ret;
//   *     end
// while any_delay_just_p(x) do
// local x_id = simple_print(x)
// if parents_history[x_id] == true then
// return replace_this_with_stopped()
// if history[x_id] == true then
// ref_novalue_replace[0 + 1] = true
// if delay_evaluate_p(x) then
// return replace_this_with_stopped()
// elseif delay_builtin_func_p(x) then
// local f = delay_builtin_func_f(x)
// local xs = delay_builtin_func_xs(x)
// local elim_s = {data_name_function_builtin_systemName,
//           * data_list_function_builtin_systemName,
//           * data_p_function_builtin_systemName,
//           * error_name_function_builtin_systemName,
//           * error_list_function_builtin_systemName,
//           * error_p_function_builtin_systemName,
//           * construction_p_function_builtin_systemName,
//           * construction_head_function_builtin_systemName,
//           * construction_tail_function_builtin_systemName,
//           * symbol_p_function_builtin_systemName,
//           * null_p_function_builtin_systemName}
// local is_elim = false
// do
//           * local i = 0
// while i < (#elim_s) do
// if jsbool_equal_p(elim_s[i + 1], f) then
// is_elim = true
// i = i + 1
// internal: stack cleanup on scope exit
// if is_elim then
// ASSERT((#xs) == 1)
// ASSERT(ref_novalue_replace[1 + 1] == false)
// local inner = force_all(xs[0 + 1], make_history(),
//             * ref_novalue_replace)
// if ref_novalue_replace[1 + 1] then
// return do_rewrite_force_all(builtin_func_apply(f, {inner}))
// else
//               * return ERROR()
// if jsbool_equal_p(f, equal_p_function_builtin_systemName) then
// return replace_this_with_stopped()
// elseif jsbool_equal_p(f, apply_function_builtin_systemName) then
//
// return replace_this_with_stopped()
// elseif jsbool_equal_p(f, evaluate_function_builtin_systemName)
//               * then
// return replace_this_with_stopped()
// elseif jsbool_equal_p(f, if_function_builtin_systemName) then
//
// ASSERT((#xs) == 3)
// ASSERT(ref_novalue_replace[1 + 1] == false)
// local tf = force_all(xs[0 + 1], make_history(),
//                   * ref_novalue_replace)
// if ref_novalue_replace[1 + 1] then
// return
//                     * do_rewrite_force_all(builtin_func_apply(if_function_builtin_systemName,
//                     * {tf, xs[1 + 1], xs[2 + 1]}))
// else
//                     * return ERROR()
// return ERROR()
// elseif delay_builtin_form_p(x) then
// return replace_this_with_stopped()
// elseif delay_apply_p(x) then
// return replace_this_with_stopped()
// return ERROR()
// history[x_id] = true
// __TS__ArrayPush(xs, x)
// x = force1(x)
// internal: stack cleanup on scope exit
// return do_rewrite(x)
// name: force1
// * function(raw)
// local x = un_just_all(raw)
// local ret
// ASSERT(not just_p(x))
// if delay_evaluate_p(x) then
// ret = real_evaluate(delay_evaluate_env(x), delay_evaluate_x(x))
// elseif delay_builtin_form_p(x) then
// ret = real_builtin_form_apply(delay_builtin_form_env(x),
//       * delay_builtin_form_f(x), delay_builtin_form_xs(x))
// elseif delay_builtin_func_p(x) then
// ret = real_builtin_func_apply(delay_builtin_func_f(x),
//         * delay_builtin_func_xs(x))
// elseif delay_apply_p(x) then
// ret = real_apply(delay_apply_f(x), delay_apply_xs(x))
// else
//           * ret = x
// ret = un_just_all(ret)
// lang_set_do(x, ret)
// return ret
// name: env_set
// * function(env, key, val)
// local ret = {}
// do
//   * local i = 0
// while i < (#env) do
// if jsbool_equal_p(env[(i + 0) + 1], key) then
// ret[(i + 0) + 1] = key
// ret[(i + 1) + 1] = val
// do
//       * i = i + 2
// while i < (#env) do
// ret[(i + 0) + 1] = env[(i + 0) + 1]
// ret[(i + 1) + 1] = env[(i + 1) + 1]
// i = i + 2
// return ret
// else
//       * ret[(i + 0) + 1] = env[(i + 0) + 1]
// ret[(i + 1) + 1] = env[(i + 1) + 1]
// i = i + 2
// internal: stack cleanup on scope exit
// ret[((#env) + 0) + 1] = key
// ret[((#env) + 1) + 1] = val
// return ret
// name: env_get
// * function(env, key, default_v)
// do
//   * local i = 0
// while i < (#env) do
// if jsbool_equal_p(env[(i + 0) + 1], key) then
// return env[(i + 1) + 1]
// i = i + 2
// internal: stack cleanup on scope exit
// return default_v
// name: must_env_get
// * function(env, key)
// do
//   * local i = 0
// while i < (#env) do
// if jsbool_equal_p(env[(i + 0) + 1], key) then
// return env[(i + 1) + 1]
// i = i + 2
// internal: stack cleanup on scope exit
// return ERROR()
// name: env2val
// * function(env)
// local ret = null_v
// do
//   * local i = 0
// while i < (#env) do
// ret = new_construction(new_list(env[(i + 0) + 1], env[(i + 1) + 1]), ret)
//
// i = i + 2
// internal: stack cleanup on scope exit
// return new_data(mapping_symbol, new_list(ret))
// name: env_foreach
// * function(env, f)
// do
//   * local i = 0
// while i < (#env) do
// f(env[(i + 0) + 1], env[(i + 1) + 1])
// i = i + 2
// internal: stack cleanup on scope exit
// name: real_evaluate
// * function(env, raw)
// local x = force1(raw)
// if any_delay_just_p(x) then
// return evaluate(env, x)
// local error_v = new_error(system_symbol,
//   * new_list(function_builtin_use_systemName,
//   * new_list(evaluate_function_builtin_systemName, new_list(env2val(env), x))))
//
// if construction_p(x) then
// local xs = {}
// local rest = x
// while not null_p(rest) do
// if any_delay_just_p(rest) then
// return evaluate(env, x)
// elseif construction_p(rest) then
// __TS__ArrayPush(xs, construction_head(rest))
// rest = force1(construction_tail(rest))
// else
//           * return error_v
// if jsbool_equal_p(xs[0 + 1], form_builtin_use_systemName) then
// if (#xs) == 1 then
// return error_v
// local f = xs[1 + 1]
// local args = {}
// do
//       * local i = 2
// while i < (#xs) do
// args[(i - 2) + 1] = xs[i + 1]
// i = i + 1
// internal: stack cleanup on scope exit
// return builtin_form_apply(env, f, args)
// elseif jsbool_equal_p(xs[0 + 1], form_use_systemName) then
// if (#xs) == 1 then
// return error_v
// local f = force_all(evaluate(env, xs[1 + 1]))
// if not data_p(f) then
// return error_v
// local f_type = force1(data_name(f))
// if any_delay_just_p(f_type) then
// return evaluate(env, x)
// if not symbol_p(f_type) then
// return error_v
// if not symbol_equal_p(f_type, form_symbol) then
// return error_v
// local f_list = force1(data_list(f))
// if any_delay_just_p(f_list) then
// return evaluate(env, x)
// if not construction_p(f_list) then
// return error_v
// local f_x = construction_head(f_list)
// local f_list_cdr = force1(construction_tail(f_list))
// if any_delay_just_p(f_list_cdr) then
// return evaluate(env, x)
// if not null_p(f_list_cdr) then
// return error_v
// local args = {env2val(env)}
// do
//         * local i = 2
// while i < (#xs) do
// args[(i - 1) + 1] = xs[i + 1]
// i = i + 1
// internal: stack cleanup on scope exit
// return apply(f_x, args)
// elseif jsbool_equal_p(xs[0 + 1], function_builtin_use_systemName)
//         * then
// if (#xs) == 1 then
// return error_v
// local f = xs[1 + 1]
// local args = {}
// do
//           * local i = 2
// while i < (#xs) do
// args[(i - 2) + 1] = evaluate(env, xs[i + 1])
// i = i + 1
// internal: stack cleanup on scope exit
// return builtin_func_apply(f, args)
// else
//           * local f = evaluate(env, xs[0 + 1])
// local args = {}
// do
//           * local i = 1
// while i < (#xs) do
// args[(i - 1) + 1] = evaluate(env, xs[i + 1])
// i = i + 1
// internal: stack cleanup on scope exit
// return apply(f, args)
// elseif null_p(x) then
// return x
// elseif name_p(x) then
// return env_get(env, x, error_v)
// elseif error_p(x) then
// return error_v
// return ERROR()
// name: name_p
// * function(x)
// return symbol_p(x) or data_p(x)
// name: make_error_v
// * function()
// return new_error(system_symbol, new_list(function_builtin_use_systemName,
//   * new_list(apply_function_builtin_systemName, new_list(f,
//   * jsArray_to_list(xs)))))
// name: real_apply
// * function(f, xs)
// local make_error_v
// make_error_v = function()
//   *         return new_error(system_symbol,
//   * new_list(function_builtin_use_systemName,
//   * new_list(apply_function_builtin_systemName, new_list(f,
//   * jsArray_to_list(xs)))));
//   *     end
// f = force1(f)
// if any_delay_just_p(f) then
// return apply(f, xs)
// if not data_p(f) then
// return make_error_v()
// local f_type = force_all(data_name(f))
// if not (symbol_p(f_type) and symbol_equal_p(f_type, function_symbol)) then
//
// return make_error_v()
// local f_list = force_all(data_list(f))
// if not construction_p(f_list) then
// return make_error_v()
// local args_pat = force_all_rec(construction_head(f_list))
// local f_list_cdr = force_all(construction_tail(f_list))
// if not (construction_p(f_list_cdr) and
//   * null_p(force_all(construction_tail(f_list_cdr)))) then
// return make_error_v()
// local f_code = construction_head(f_list_cdr)
// local env = env_null_v
// local xs_i = 0
// while not null_p(args_pat) do
// if name_p(args_pat) then
// local x = null_v
// do
//       * local i = (#xs) - 1
// while i >= xs_i do
// x = new_construction(xs[i + 1], x)
// i = i - 1
// internal: stack cleanup on scope exit
// env = env_set(env, args_pat, x)
// xs_i = #xs
// args_pat = null_v
// elseif construction_p(args_pat) then
// if xs_i < (#xs) then
// local x = xs[xs_i + 1]
// xs_i = xs_i + 1
// env = env_set(env, construction_head(args_pat), x)
// args_pat = construction_tail(args_pat)
// else
//           * return make_error_v()
// else
//         * return make_error_v()
// if (#xs) ~= xs_i then
// return make_error_v()
// return evaluate(env, f_code)
// name: real_builtin_func_apply
// * function(f, xs)
// local error_v = new_error(system_symbol,
//   * new_list(function_builtin_use_systemName, new_list(f,
//   * jsArray_to_list(xs))))
// do
//   * local i = 0
// while i < (#real_builtin_func_apply_s) do
// if jsbool_equal_p(f, real_builtin_func_apply_s[i + 1][0 + 1]) then
// local actually_length = real_builtin_func_apply_s[i + 1][1 + 1]
// if (#xs) ~= actually_length then
// return error_v
// local f = real_builtin_func_apply_s[i + 1][2 + 1]
// if actually_length == 1 then
// return (f)(xs[0 + 1], error_v)
// elseif actually_length == 2 then
// return (f)(xs[0 + 1], xs[1 + 1], error_v)
// elseif actually_length == 3 then
// return (f)(xs[0 + 1], xs[1 + 1], xs[2 + 1], error_v)
// return ERROR()
// i = i + 1
// internal: stack cleanup on scope exit
// return error_v
// name: real_builtin_form_apply
// * function(env, f, xs)
// local error_v = new_error(system_symbol,
//   * new_list(form_builtin_use_systemName, new_list(env2val(env), f,
//   * jsArray_to_list(xs))))
// if jsbool_equal_p(f, quote_form_builtin_systemName) then
// if (#xs) ~= 1 then
// return error_v
// return xs[0 + 1]
// elseif jsbool_equal_p(f, lambda_form_builtin_systemName) then
// if (#xs) ~= 2 then
// return error_v
// return new_lambda(env, xs[0 + 1], xs[1 + 1], error_v)
// return error_v
// name: make_error_v
// * function()
// if error_v == false then
// return new_error(system_symbol, new_list(form_builtin_use_systemName,
//     * new_list(env2val(env), lambda_form_builtin_systemName,
//     * jsArray_to_list({args_pat, body}))))
// else
//     * return error_v
// name: make_quote
// * function(x)
// return new_list(form_builtin_use_systemName, quote_form_builtin_systemName,
//   * x)
// function(k, v)
// do
//   * local i = 0
// while i < (#args_pat_vars) do
// if jsbool_equal_p(args_pat_vars[i + 1], k) then
// return;
// i = i + 1
// internal: stack cleanup on scope exit
// __TS__ArrayPush(env_vars, k)
// name: new_lambda
// * function(env, args_pat, body, error_v)
// if error_v == nil then
// error_v = false
// local make_error_v
// make_error_v = function()
//   *         if error_v == false then
//   *             return new_error(system_symbol,
//   * new_list(form_builtin_use_systemName, new_list(env2val(env),
//   * lambda_form_builtin_systemName, jsArray_to_list({args_pat, body}))));
//   *         else
//   *             return error_v;
//   *         end
//   *     end
// local make_quote
// make_quote = function(x)
//   *         return new_list(form_builtin_use_systemName,
//   * quote_form_builtin_systemName, x);
//   *     end
// args_pat = force_all_rec(args_pat)
// local args_pat_vars = {}
// local args_pat_is_dot = false
// local args_pat_iter = args_pat
// while not null_p(args_pat_iter) do
// if name_p(args_pat_iter) then
// __TS__ArrayPush(args_pat_vars, args_pat_iter)
// args_pat_is_dot = true
// args_pat_iter = null_v
// elseif construction_p(args_pat_iter) then
// __TS__ArrayPush(args_pat_vars, construction_head(args_pat_iter))
// args_pat_iter = construction_tail(args_pat_iter)
// else
//         * return make_error_v()
// local args_pat_vars_val = args_pat
// if args_pat_is_dot then
// args_pat_vars_val = jsArray_to_list(args_pat_vars)
// local env_vars = {}
// env_foreach(env, function(k, v)
//   *         do
//   *             local i = 0;
//   *             while i < (#args_pat_vars) do
//   *                 if jsbool_equal_p(args_pat_vars[i + 1], k) then
//   *                     return;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         __TS__ArrayPush(env_vars, k);
//   *     end)
// local new_args_pat = args_pat_vars_val
// do
//   * local i = (#env_vars) - 1
// while i >= 0 do
// new_args_pat = new_construction(env_vars[i + 1], new_args_pat)
// i = i - 1
// internal: stack cleanup on scope exit
// local new_args = args_pat_vars_val
// do
//   * local i = (#env_vars) - 1
// while i >= 0 do
// new_args = new_construction(make_quote(must_env_get(env, env_vars[i +
//     * 1])), new_args)
// i = i - 1
// internal: stack cleanup on scope exit
// return new_data(function_symbol, new_list(args_pat,
//   * new_construction(make_quote(new_data(function_symbol,
//   * new_list(new_args_pat, body))), new_args)))
// name: end_2
// * function(x, y, f1, f2)
// if jsbool_equal_p(f1(x), f1(y)) and jsbool_equal_p(f2(x), f2(y)) then
// lang_set_do(x, y)
// return true
// else
//     * return false
// name: jsbool_equal_p
// * function(x, y)
// if x == y then
// return true
// x = force_all(x)
// y = force_all(y)
// if x == y then
// return true
// local end_2
// end_2 = function(x, y, f1, f2)
//   *         if jsbool_equal_p(f1(x), f1(y)) and jsbool_equal_p(f2(x), f2(y))
//   * then
//   *             lang_set_do(x, y);
//   *             return true;
//   *         else
//   *             return false;
//   *         end
//   *     end
// if null_p(x) then
// if not null_p(y) then
// return false
// lang_set_do(x, null_v)
// lang_set_do(y, null_v)
// return true
// elseif symbol_p(x) then
// if not symbol_p(y) then
// return false
// return symbol_equal_p(x, y)
// elseif construction_p(x) then
// if not construction_p(y) then
// return false
// return end_2(x, y, construction_head, construction_tail)
// elseif error_p(x) then
// if not error_p(y) then
// return false
// return end_2(x, y, error_name, error_list)
// elseif data_p(x) then
// if not data_p(y) then
// return false
// return end_2(x, y, data_name, data_list)
// return ERROR()
// name: simple_print
// * function(x)
// x = un_just_all(x)
// local temp = ""
// local prefix = ""
// if null_p(x) then
// return "()"
// elseif construction_p(x) then
// temp = "("
// prefix = ""
// while construction_p(x) do
// temp = temp .. (prefix .. simple_print(construction_head(x)))
// prefix = " "
// x = un_just_all(construction_tail(x))
// if null_p(x) then
// temp = temp .. ")"
// else
//         * temp = temp .. ((" . " .. simple_print(x)) .. ")")
// return temp
// elseif data_p(x) then
// return "#" .. simple_print(new_construction(data_name(x),
//         * data_list(x)))
// elseif error_p(x) then
// return "!" .. simple_print(new_construction(error_name(x),
//           * error_list(x)))
// elseif symbol_p(x) then
// return un_symbol(x)
// elseif delay_evaluate_p(x) then
// return ((("$(" .. simple_print(env2val(delay_evaluate_env(x))))
//               * .. " ") .. simple_print(delay_evaluate_x(x))) .. ")"
// elseif delay_builtin_func_p(x) then
// return ((("%(" .. simple_print(delay_builtin_func_f(x))) .. "
//                 * ") ..
//                 * simple_print(jsArray_to_list(delay_builtin_func_xs(x)))) ..
//                 * ")"
// elseif delay_builtin_form_p(x) then
// return ((((("@(" ..
//                   * simple_print(env2val(delay_builtin_form_env(x)))) .. " ")
//                   * .. simple_print(delay_builtin_form_f(x))) .. " ") ..
//                   * simple_print(jsArray_to_list(delay_builtin_form_xs(x)))) ..
//                   * ")"
// elseif delay_apply_p(x) then
// return ((("^(" .. simple_print(delay_apply_f(x))) .. " ")
//                     * .. simple_print(jsArray_to_list(delay_apply_xs(x)))) ..
//                     * ")"
// return ERROR()
// name: new_symbol
// * function(x)
// return {symbol_t, x}
// name: systemName_make
// * function(x)
// return new_data(name_symbol, new_list(system_symbol, x))
// name: make_builtin_f_new_sym_f
// * function(x_sym)
// return systemName_make(new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, something_symbol, x_sym), theThing_symbol))
// name: make_builtin_f_get_sym_f
// * function(t_sym, x_sym)
// return systemName_make(new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_list(t_sym), something_symbol), x_sym))
// name: make_builtin_f_p_sym_f
// * function(t_sym)
// return systemName_make(new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, new_list(typeAnnotation_symbol, t_sym,
//   * something_symbol))))
// name: list_to_jsArray
// * function(xs, k_done, k_tail)
// local ret = {}
// while construction_p(xs) do
// __TS__ArrayPush(ret, construction_head(xs))
// xs = construction_tail(xs)
// if null_p(xs) then
// return k_done(ret)
// return k_tail(ret, xs)
// function(xs)
// return xs
// function(xs, x)
// return false
// name: maybe_list_to_jsArray
// * function(xs)
// return list_to_jsArray(xs, function(xs)
//   *         return xs;
//   *     end, function(xs, x)
//   *         return false;
//   *     end)
// name: val2env
// * function(x)
// x = force_all(x)
// if not data_p(x) then
// return false
// local s = force_all(data_name(x))
// if not symbol_p(s) then
// return false
// if not symbol_equal_p(s, mapping_symbol) then
// return false
// s = force_all(data_list(x))
// if not construction_p(s) then
// return false
// if not null_p(force_all(construction_tail(s))) then
// return false
// local ret = {}
// local xs = force_all(construction_head(s))
// while not null_p(xs) do
// if not construction_p(xs) then
// return false
// local x = force_all(construction_head(xs))
// xs = force_all(construction_tail(xs))
// if not construction_p(x) then
// return false
// local k = construction_head(x)
// x = force_all(construction_tail(x))
// if not construction_p(x) then
// return false
// local v = construction_head(x)
// if not null_p(force_all(construction_tail(x))) then
// return false
// local not_breaked = true
// do
//     * local i = 0
// while i < (#ret) do
// if jsbool_equal_p(ret[(i + 0) + 1], k) then
// ret[(i + 1) + 1] = v
// not_breaked = false
// break
// i = i + 2
// internal: stack cleanup on scope exit
// if not_breaked then
// __TS__ArrayPush(ret, k)
// __TS__ArrayPush(ret, v)
// internal: stack cleanup on scope exit
// return ret
// function(x, error_v)
// x = force1(x)
// if any_delay_just_p(x) then
// return builtin_func_apply(p_sym, {x})
// if p_jsfunc(x) then
// return true_v
// return false_v
// name: make_builtin_p_func
// * function(p_sym, p_jsfunc)
// return {p_sym, 1, function(x, error_v)
//   *         x = force1(x);
//   *         if any_delay_just_p(x) then
//   *             return builtin_func_apply(p_sym, {x});
//   *         end
//   *         if p_jsfunc(x) then
//   *             return true_v;
//   *         end
//   *         return false_v;
//   *     end}
// function(x, error_v)
// x = force1(x)
// if any_delay_just_p(x) then
// return builtin_func_apply(f_sym, {x})
// if p_jsfunc(x) then
// return f_jsfunc(x)
// return error_v
// name: make_builtin_get_func
// * function(f_sym, p_jsfunc, f_jsfunc)
// return {f_sym, 1, function(x, error_v)
//   *         x = force1(x);
//   *         if any_delay_just_p(x) then
//   *             return builtin_func_apply(f_sym, {x});
//   *         end
//   *         if p_jsfunc(x) then
//   *             return f_jsfunc(x);
//   *         end
//   *         return error_v;
//   *     end}
// name: H_if
// * function(b, x, y)
// return builtin_func_apply(if_function_builtin_systemName, {b, x, y})
// name: H_and
// * function(x, y)
// return H_if(x, y, false_v)
// name: end_2
// * function(x, y, f1, f2)
// return H_and(builtin_func_apply(equal_p_function_builtin_systemName,
//   * {f1(x), f1(y)}), builtin_func_apply(equal_p_function_builtin_systemName,
//   * {f2(x), f2(y)}))
// function(x, y, error_v)
// if x == y then
// return true_v
// x = force1(x)
// y = force1(y)
// if any_delay_just_p(x) or any_delay_just_p(y) then
// return builtin_func_apply(equal_p_function_builtin_systemName, {x, y})
// if x == y then
// return true_v
// local H_if
// H_if = function(b, x, y)
//   *         return builtin_func_apply(if_function_builtin_systemName, {b, x,
//   * y});
//   *     end
// local H_and
// H_and = function(x, y)
//   *         return H_if(x, y, false_v);
//   *     end
// ASSERT(not any_delay_just_p(x))
// local end_2
// end_2 = function(x, y, f1, f2)
//   *         return
//   * H_and(builtin_func_apply(equal_p_function_builtin_systemName, {f1(x),
//   * f1(y)}), builtin_func_apply(equal_p_function_builtin_systemName, {f2(x),
//   * f2(y)}));
//   *     end
// if null_p(x) then
// if not null_p(x) then
// return false_v
// return true_v
// elseif symbol_p(x) then
// if not symbol_p(y) then
// return false_v
// return (symbol_equal_p(x, y) and true_v) or false_v
// elseif data_p(x) then
// if not data_p(y) then
// return false_v
// return end_2(x, y, data_name, data_list)
// elseif construction_p(x) then
// if not construction_p(y) then
// return false_v
// return end_2(x, y, construction_head, construction_tail)
// elseif error_p(x) then
// if not error_p(y) then
// return false_v
// return end_2(x, y, error_name, error_list)
// return ERROR()
// function(f, xs, error_v)
// local jslist = {}
// local iter = force_all(xs)
// while construction_p(iter) do
// __TS__ArrayPush(jslist, construction_head(iter))
// iter = force_all(construction_tail(iter))
// if not null_p(iter) then
// return error_v
// return apply(f, jslist)
// function(env, x, error_v)
// local maybeenv = val2env(env)
// if maybeenv == false then
// return error_v
// return evaluate(maybeenv, x)
// function(xs, error_v)
// xs = force1(xs)
// if any_delay_just_p(xs) then
// return builtin_func_apply(list_chooseOne_function_builtin_systemName,
//     * {xs})
// if not construction_p(xs) then
// return error_v
// return construction_head(xs)
// function(b, x, y, error_v)
// b = force1(b)
// if any_delay_just_p(b) then
// return builtin_func_apply(if_function_builtin_systemName, {b, x, y})
// if not data_p(b) then
// return error_v
// local nam = force_all(data_name(b))
// if not symbol_p(nam) then
// return error_v
// if symbol_equal_p(nam, true_symbol) then
// return x
// if symbol_equal_p(nam, false_symbol) then
// return y
// return error_v
// name: end_2
// * function(x, y, f1, f2)
// if jsbool_no_force_equal_p(f1(x), f1(y)) and jsbool_no_force_equal_p(f2(x),
//   * f2(y)) then
// lang_set_do(x, y)
// return true
// else
//     * return false
// name: jsbool_no_force_equal_p
// * function(x, y)
// if x == y then
// return true
// x = un_just_all(x)
// y = un_just_all(y)
// if x == y then
// return true
// local end_2
// end_2 = function(x, y, f1, f2)
//   *         if jsbool_no_force_equal_p(f1(x), f1(y)) and
//   * jsbool_no_force_equal_p(f2(x), f2(y)) then
//   *             lang_set_do(x, y);
//   *             return true;
//   *         else
//   *             return false;
//   *         end
//   *     end
// if null_p(x) then
// if not null_p(y) then
// return false
// lang_set_do(x, null_v)
// lang_set_do(y, null_v)
// return true
// elseif symbol_p(x) then
// if not symbol_p(y) then
// return false
// return symbol_equal_p(x, y)
// elseif construction_p(x) then
// if not construction_p(y) then
// return false
// return end_2(x, y, construction_head, construction_tail)
// elseif error_p(x) then
// if not error_p(y) then
// return false
// return end_2(x, y, error_name, error_list)
// elseif data_p(x) then
// if not data_p(y) then
// return false
// return end_2(x, y, data_name, data_list)
// elseif delay_evaluate_p(x) then
// return false
// elseif delay_builtin_func_p(x) then
// return false
// elseif delay_builtin_form_p(x) then
// return false
// elseif delay_apply_p(x) then
// return false
// return ERROR()
// name: simple_print_force_all_rec
// * function(x)
// return simple_print(force_all_rec(x))
// name: eof
// * function()
// return (#state_const) == state
// name: get
// * function()
// ASSERT(not eof())
// local ret = state_const:sub(state + 1, state + 1)
// state = state + 1
// return ret
// name: put
// * function(x)
// ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x)
// state = state - 1
// name: parse_error
// * function()
// error("TheLanguage parse ERROR!")
// name: a_space_p
// * function(x)
// return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r")
// name: space
// * function()
// if eof() then
// return false
// local x = get()
// if not a_space_p(x) then
// put(x)
// return false
// while a_space_p(x) and (not eof()) do
// x = get()
// if not a_space_p(x) then
// put(x)
// return true
// name: symbol
// * function()
// if eof() then
// return false
// local x = get()
// local ret = ""
// if not a_symbol_p(x) then
// put(x)
// return false
// while a_symbol_p(x) and (not eof()) do
// ret = ret .. x
// x = get()
// if a_symbol_p(x) then
// ret = ret .. x
// else
//     * put(x)
// return new_symbol(ret)
// name: set_last
// * function(lst)
// if ret == HOLE then
// ret = lst
// return;
// local x = ret
// while true do
// if not construction_p(x) then
// return ERROR()
// local d = construction_tail(x)
// if d == HOLE then
// break
// x = construction_tail(x)
// internal: stack cleanup on scope exit
// if not construction_p(x) then
// return ERROR()
// if construction_tail(x) ~= HOLE then
// return ERROR()
// x[2 + 1] = lst
// name: last_add
// * function(x)
// set_last(new_construction(x, HOLE))
// name: list
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "(" then
// put(x)
// return false
// local HOLE = new_symbol("!!@@READ||HOLE@@!!")
// local ret = HOLE
// local set_last
// set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end
// local last_add
// last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end
// while true do
// space()
// if eof() then
// return parse_error()
// x = get()
// if x == ")" then
// set_last(null_v)
// return ret
// if x == "." then
// space()
// local e = val()
// set_last(e)
// space()
// if eof() then
// return parse_error()
// x = get()
// if x ~= ")" then
// return parse_error()
// return ret
// put(x)
// local e = val()
// last_add(e)
// internal: stack cleanup on scope exit
// name: data
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "#" then
// put(x)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// return new_data(construction_head(xs), construction_tail(xs))
// name: readerror
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "!" then
// put(x)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// return new_error(construction_head(xs), construction_tail(xs))
// name: a_symbol_p
// * function(x)
// if a_space_p(x) then
// return false
// local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~", "/", "-",
//   * ">", "_", ":", "?", "[", "]", "&"}
// do
//   * local i = 0
// while i < (#not_xs) do
// if x == not_xs[i + 1] then
// return false
// i = i + 1
// internal: stack cleanup on scope exit
// return true
// name: val
// * function()
// space()
// local fs = {list, symbol, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}
// do
//   * local i = 0
// while i < (#fs) do
// local x = fs[i + 1]()
// if x ~= false then
// return x
// i = i + 1
// internal: stack cleanup on scope exit
// internal: stack cleanup on scope exit
// return parse_error()
// function()
// if eof() then
// return false
// local c = get()
// if c ~= prefix then
// put(c)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// local x = construction_tail(xs)
// if not (construction_p(x) and null_p(construction_tail(x))) then
// return parse_error()
// return k(construction_head(xs), construction_head(x))
// name: make_read_two
// * function(prefix, k)
// return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end
// function()
// if eof() then
// return false
// local c = get()
// if c ~= prefix then
// put(c)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// local x = construction_tail(xs)
// if not construction_p(x) then
// return parse_error()
// local x_d = construction_tail(x)
// if not (construction_p(x_d) and null_p(construction_tail(x_d))) then
// return parse_error()
// return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d))
// name: make_read_three
// * function(prefix, k)
// return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end
// function(e, x)
// local env = val2env(e)
// if env == false then
// return parse_error()
// return evaluate(env, x)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// return builtin_func_apply(f, jsxs)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(e, f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// local env = val2env(e)
// if env == false then
// return parse_error()
// return builtin_form_apply(env, f, jsxs)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// return apply(f, jsxs)
// name: simple_parse
// * function(x)
// local state_const, state, eof, get, put, parse_error, a_space_p, space,
//   * symbol, list, data, readerror, readeval, readfuncapply, readformbuiltin,
//   * readapply, a_symbol_p, val
// eof = function()
//   *         return (#state_const) == state;
//   *     end
// get = function()
//   *         ASSERT(not eof());
//   *         local ret = state_const:sub(state + 1, state + 1);
//   *         state = state + 1;
//   *         return ret;
//   *     end
// put = function(x)
//   *         ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x);
//   *         state = state - 1;
//   *     end
// parse_error = function()
//   *         error("TheLanguage parse ERROR!");
//   *     end
// a_space_p = function(x)
//   *         return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r");
//   *     end
// space = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if not a_space_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_space_p(x) and (not eof()) do
//   *             x = get();
//   *         end
//   *         if not a_space_p(x) then
//   *             put(x);
//   *         end
//   *         return true;
//   *     end
// symbol = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         local ret = "";
//   *         if not a_symbol_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_symbol_p(x) and (not eof()) do
//   *             ret = ret .. x;
//   *             x = get();
//   *         end
//   *         if a_symbol_p(x) then
//   *             ret = ret .. x;
//   *         else
//   *             put(x);
//   *         end
//   *         return new_symbol(ret);
//   *     end
// list = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "(" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local HOLE = new_symbol("!!@@READ||HOLE@@!!");
//   *         local ret = HOLE;
//   *         local set_last;
//   *         set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end;
//   *         local last_add;
//   *         last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end;
//   *         while true do
//   *             space();
//   *             if eof() then
//   *                 return parse_error();
//   *             end
//   *             x = get();
//   *             if x == ")" then
//   *                 set_last(null_v);
//   *                 return ret;
//   *             end
//   *             if x == "." then
//   *                 space();
//   *                 local e = val();
//   *                 set_last(e);
//   *                 space();
//   *                 if eof() then
//   *                     return parse_error();
//   *                 end
//   *                 x = get();
//   *                 if x ~= ")" then
//   *                     return parse_error();
//   *                 end
//   *                 return ret;
//   *             end
//   *             put(x);
//   *             local e = val();
//   *             last_add(e);
//   *         end
//   *     end
// data = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "#" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_data(construction_head(xs), construction_tail(xs));
//   *     end
// readerror = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "!" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_error(construction_head(xs), construction_tail(xs));
//   *     end
// a_symbol_p = function(x)
//   *         if a_space_p(x) then
//   *             return false;
//   *         end
//   *         local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~",
//   * "/", "-", ">", "_", ":", "?", "[", "]", "&"};
//   *         do
//   *             local i = 0;
//   *             while i < (#not_xs) do
//   *                 if x == not_xs[i + 1] then
//   *                     return false;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return true;
//   *     end
// val = function()
//   *         space();
//   *         local fs = {list, symbol, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply};
//   *         do
//   *             local i = 0;
//   *             while i < (#fs) do
//   *                 local x = fs[i + 1]();
//   *                 if x ~= false then
//   *                     return x;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return parse_error();
//   *     end
// state_const = x
// state = 0
// local make_read_two
// make_read_two = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end;
//   *     end
// local make_read_three
// make_read_three = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end;
//   *     end
// readeval = make_read_two("$", function(e, x)
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return evaluate(env, x);
//   *     end)
// readfuncapply = make_read_two("%", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return builtin_func_apply(f, jsxs);
//   *     end)
// readformbuiltin = make_read_three("@", function(e, f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return builtin_form_apply(env, f, jsxs);
//   *     end)
// readapply = make_read_two("^", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return apply(f, jsxs);
//   *     end)
// return val()
// name: eof
// * function()
// return (#state_const) == state
// name: get
// * function()
// ASSERT(not eof())
// local ret = state_const:sub(state + 1, state + 1)
// state = state + 1
// return ret
// name: put
// * function(x)
// ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x)
// state = state - 1
// name: parse_error
// * function()
// error("TheLanguage parse ERROR!")
// name: a_space_p
// * function(x)
// return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r")
// name: space
// * function()
// if eof() then
// return false
// local x = get()
// if not a_space_p(x) then
// put(x)
// return false
// while a_space_p(x) and (not eof()) do
// x = get()
// if not a_space_p(x) then
// put(x)
// return true
// name: symbol
// * function()
// if eof() then
// return false
// local x = get()
// local ret = ""
// if not a_symbol_p(x) then
// put(x)
// return false
// while a_symbol_p(x) and (not eof()) do
// ret = ret .. x
// x = get()
// if a_symbol_p(x) then
// ret = ret .. x
// else
//     * put(x)
// return new_symbol(ret)
// name: set_last
// * function(lst)
// if ret == HOLE then
// ret = lst
// return;
// local x = ret
// while true do
// if not construction_p(x) then
// return ERROR()
// local d = construction_tail(x)
// if d == HOLE then
// break
// x = construction_tail(x)
// internal: stack cleanup on scope exit
// if not construction_p(x) then
// return ERROR()
// if construction_tail(x) ~= HOLE then
// return ERROR()
// x[2 + 1] = lst
// name: last_add
// * function(x)
// set_last(new_construction(x, HOLE))
// name: list
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "(" then
// put(x)
// return false
// local HOLE = new_symbol("!!@@READ||HOLE@@!!")
// local ret = HOLE
// local set_last
// set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end
// local last_add
// last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end
// while true do
// space()
// if eof() then
// return parse_error()
// x = get()
// if x == ")" then
// set_last(null_v)
// return ret
// if x == "." then
// space()
// local e = val()
// set_last(e)
// space()
// if eof() then
// return parse_error()
// x = get()
// if x ~= ")" then
// return parse_error()
// return ret
// put(x)
// local e = val()
// last_add(e)
// internal: stack cleanup on scope exit
// name: data
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "#" then
// put(x)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// return new_data(construction_head(xs), construction_tail(xs))
// name: readerror
// * function()
// if eof() then
// return false
// local x = get()
// if x ~= "!" then
// put(x)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// return new_error(construction_head(xs), construction_tail(xs))
// name: a_symbol_p
// * function(x)
// if a_space_p(x) then
// return false
// local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~", "/", "-",
//   * ">", "_", ":", "?", "[", "]", "&"}
// do
//   * local i = 0
// while i < (#not_xs) do
// if x == not_xs[i + 1] then
// return false
// i = i + 1
// internal: stack cleanup on scope exit
// return true
// name: val
// * function()
// space()
// local fs = {list, readsysname, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}
// do
//   * local i = 0
// while i < (#fs) do
// local x = fs[i + 1]()
// if x ~= false then
// return x
// i = i + 1
// internal: stack cleanup on scope exit
// internal: stack cleanup on scope exit
// return parse_error()
// name: un_maybe
// * function(x)
// if x == false then
// return parse_error()
// return x
// name: not_eof
// * function()
// return not eof()
// name: assert_get
// * function(c)
// un_maybe(not_eof())
// un_maybe(get() == c)
// name: readsysname_no_pack_bracket
// * function()
// assert_get("[")
// local x = readsysname_no_pack_inner_must()
// assert_get("]")
// return x
// name: readsysname_no_pack_inner_must
// * function(strict)
// if strict == nil then
// strict = false
// local readsysname_no_pack_bracket
// readsysname_no_pack_bracket = function()
//   *                 assert_get("[");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 assert_get("]");
//   *                 return x;
//   *             end
// local fs = (strict and {list, symbol, readsysname_no_pack_bracket, data,
//   * readerror, readeval, readfuncapply, readformbuiltin, readapply}) or {list,
//   * readsysname_no_pack, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}
// do
//   * local i = 0
// while i < (#fs) do
// local x = fs[i + 1]()
// if x ~= false then
// return x
// i = i + 1
// internal: stack cleanup on scope exit
// internal: stack cleanup on scope exit
// return parse_error()
// name: may_xfx_xf
// * function(x)
// if eof() then
// return x
// local head = get()
// if head == "." then
// local y = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, new_list(function_symbol,
//     * new_list(x), something_symbol), y)
// elseif head == ":" then
// local y = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, y, x)
// elseif head == "~" then
// return new_list(isOrNot_symbol, x)
// elseif head == "@" then
// local y = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, new_list(function_symbol,
//           * new_construction(x, something_symbol), something_symbol), y)
// elseif head == "?" then
// return new_list(typeAnnotation_symbol, function_symbol,
//             * new_list(isOrNot_symbol, x))
// elseif head == "/" then
// local ys = {x}
// while true do
// local y = readsysname_no_pack_inner_must(true)
// __TS__ArrayPush(ys, y)
// if eof() then
// break
// local c0 = get()
// if c0 ~= "/" then
// put(c0)
// break
// internal: stack cleanup on scope exit
// return new_list(sub_symbol, jsArray_to_list(ys))
// else
//               * put(head)
// return x
// return ERROR()
// name: readsysname_no_pack
// * function()
// local readsysname_no_pack_inner_must, may_xfx_xf
// readsysname_no_pack_inner_must = function(strict)
//   *             if strict == nil then
//   *                 strict = false;
//   *             end
//   *             local readsysname_no_pack_bracket;
//   *             readsysname_no_pack_bracket = function()
//   *                 assert_get("[");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 assert_get("]");
//   *                 return x;
//   *             end;
//   *             local fs = (strict and {list, symbol,
//   * readsysname_no_pack_bracket, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}) or {list, readsysname_no_pack, data,
//   * readerror, readeval, readfuncapply, readformbuiltin, readapply};
//   *             do
//   *                 local i = 0;
//   *                 while i < (#fs) do
//   *                     local x = fs[i + 1]();
//   *                     if x ~= false then
//   *                         return x;
//   *                     end
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return parse_error();
//   *         end
// may_xfx_xf = function(x)
//   *             if eof() then
//   *                 return x;
//   *             end
//   *             local head = get();
//   *             if head == "." then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_list(x), something_symbol), y);
//   *             elseif head == ":" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol, y, x);
//   *             elseif head == "~" then
//   *                 return new_list(isOrNot_symbol, x);
//   *             elseif head == "@" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_construction(x, something_symbol),
//   * something_symbol), y);
//   *             elseif head == "?" then
//   *                 return new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, x));
//   *             elseif head == "/" then
//   *                 local ys = {x};
//   *                 while true do
//   *                     local y = readsysname_no_pack_inner_must(true);
//   *                     __TS__ArrayPush(ys, y);
//   *                     if eof() then
//   *                         break;
//   *                     end
//   *                     local c0 = get();
//   *                     if c0 ~= "/" then
//   *                         put(c0);
//   *                         break;
//   *                     end
//   *                 end
//   *                 return new_list(sub_symbol, jsArray_to_list(ys));
//   *             else
//   *                 put(head);
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end
// if eof() then
// return false
// local head = get()
// if head == "&" then
// un_maybe(not_eof())
// local c0 = get()
// if c0 == "+" then
// local x = readsysname_no_pack_inner_must()
// return new_list(form_symbol, new_list(system_symbol, x))
// else
//       * put(c0)
// local x = readsysname_no_pack_inner_must()
// return new_list(form_symbol, x)
// elseif head == ":" then
// un_maybe(not_eof())
// local c0 = get()
// if c0 == "&" then
// assert_get(">")
// local x = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, new_list(form_symbol,
//         * new_list(function_symbol, something_symbol, x)), theThing_symbol)
// elseif c0 == ">" then
// local x = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, new_list(function_symbol,
//           * something_symbol, x), theThing_symbol)
// else
//           * put(c0)
// local x = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, x, theThing_symbol)
// elseif head == "+" then
// local x = readsysname_no_pack_inner_must()
// return new_list(system_symbol, x)
// elseif head == "[" then
// local x = readsysname_no_pack_inner_must()
// assert_get("]")
// return may_xfx_xf(x)
// elseif head == "_" then
// assert_get(":")
// local x = readsysname_no_pack_inner_must()
// return new_list(typeAnnotation_symbol, x, something_symbol)
// else
//             * put(head)
// local x = symbol()
// if x == false then
// return false
// return may_xfx_xf(x)
// return ERROR()
// name: readsysname
// * function()
// local x = readsysname_no_pack()
// if x == false then
// return false
// if symbol_p(x) then
// return x
// return systemName_make(x)
// function()
// if eof() then
// return false
// local c = get()
// if c ~= prefix then
// put(c)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// local x = construction_tail(xs)
// if not (construction_p(x) and null_p(construction_tail(x))) then
// return parse_error()
// return k(construction_head(xs), construction_head(x))
// name: make_read_two
// * function(prefix, k)
// return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end
// function()
// if eof() then
// return false
// local c = get()
// if c ~= prefix then
// put(c)
// return false
// local xs = list()
// if xs == false then
// return parse_error()
// if not construction_p(xs) then
// return parse_error()
// local x = construction_tail(xs)
// if not construction_p(x) then
// return parse_error()
// local x_d = construction_tail(x)
// if not (construction_p(x_d) and null_p(construction_tail(x_d))) then
// return parse_error()
// return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d))
// name: make_read_three
// * function(prefix, k)
// return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end
// function(e, x)
// local env = val2env(e)
// if env == false then
// return parse_error()
// return evaluate(env, x)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// return builtin_func_apply(f, jsxs)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(e, f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// local env = val2env(e)
// if env == false then
// return parse_error()
// return builtin_form_apply(env, f, jsxs)
// function(xs)
// return xs
// function(xs, y)
// return parse_error()
// function(f, xs)
// local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end)
// return apply(f, jsxs)
// name: complex_parse
// * function(x)
// local state_const, state, eof, get, put, parse_error, a_space_p, space,
//   * symbol, list, data, readerror, readeval, readfuncapply, readformbuiltin,
//   * readapply, a_symbol_p, val, un_maybe, not_eof, assert_get,
//   * readsysname_no_pack, readsysname
// eof = function()
//   *         return (#state_const) == state;
//   *     end
// get = function()
//   *         ASSERT(not eof());
//   *         local ret = state_const:sub(state + 1, state + 1);
//   *         state = state + 1;
//   *         return ret;
//   *     end
// put = function(x)
//   *         ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x);
//   *         state = state - 1;
//   *     end
// parse_error = function()
//   *         error("TheLanguage parse ERROR!");
//   *     end
// a_space_p = function(x)
//   *         return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r");
//   *     end
// space = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if not a_space_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_space_p(x) and (not eof()) do
//   *             x = get();
//   *         end
//   *         if not a_space_p(x) then
//   *             put(x);
//   *         end
//   *         return true;
//   *     end
// symbol = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         local ret = "";
//   *         if not a_symbol_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_symbol_p(x) and (not eof()) do
//   *             ret = ret .. x;
//   *             x = get();
//   *         end
//   *         if a_symbol_p(x) then
//   *             ret = ret .. x;
//   *         else
//   *             put(x);
//   *         end
//   *         return new_symbol(ret);
//   *     end
// list = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "(" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local HOLE = new_symbol("!!@@READ||HOLE@@!!");
//   *         local ret = HOLE;
//   *         local set_last;
//   *         set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end;
//   *         local last_add;
//   *         last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end;
//   *         while true do
//   *             space();
//   *             if eof() then
//   *                 return parse_error();
//   *             end
//   *             x = get();
//   *             if x == ")" then
//   *                 set_last(null_v);
//   *                 return ret;
//   *             end
//   *             if x == "." then
//   *                 space();
//   *                 local e = val();
//   *                 set_last(e);
//   *                 space();
//   *                 if eof() then
//   *                     return parse_error();
//   *                 end
//   *                 x = get();
//   *                 if x ~= ")" then
//   *                     return parse_error();
//   *                 end
//   *                 return ret;
//   *             end
//   *             put(x);
//   *             local e = val();
//   *             last_add(e);
//   *         end
//   *     end
// data = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "#" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_data(construction_head(xs), construction_tail(xs));
//   *     end
// readerror = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "!" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_error(construction_head(xs), construction_tail(xs));
//   *     end
// a_symbol_p = function(x)
//   *         if a_space_p(x) then
//   *             return false;
//   *         end
//   *         local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~",
//   * "/", "-", ">", "_", ":", "?", "[", "]", "&"};
//   *         do
//   *             local i = 0;
//   *             while i < (#not_xs) do
//   *                 if x == not_xs[i + 1] then
//   *                     return false;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return true;
//   *     end
// val = function()
//   *         space();
//   *         local fs = {list, readsysname, data, readerror, readeval,
//   * readfuncapply, readformbuiltin, readapply};
//   *         do
//   *             local i = 0;
//   *             while i < (#fs) do
//   *                 local x = fs[i + 1]();
//   *                 if x ~= false then
//   *                     return x;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return parse_error();
//   *     end
// un_maybe = function(x)
//   *         if x == false then
//   *             return parse_error();
//   *         end
//   *         return x;
//   *     end
// not_eof = function()
//   *         return not eof();
//   *     end
// assert_get = function(c)
//   *         un_maybe(not_eof());
//   *         un_maybe(get() == c);
//   *     end
// readsysname_no_pack = function()
//   *         local readsysname_no_pack_inner_must, may_xfx_xf;
//   *         readsysname_no_pack_inner_must = function(strict)
//   *             if strict == nil then
//   *                 strict = false;
//   *             end
//   *             local readsysname_no_pack_bracket;
//   *             readsysname_no_pack_bracket = function()
//   *                 assert_get("[");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 assert_get("]");
//   *                 return x;
//   *             end;
//   *             local fs = (strict and {list, symbol,
//   * readsysname_no_pack_bracket, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}) or {list, readsysname_no_pack, data,
//   * readerror, readeval, readfuncapply, readformbuiltin, readapply};
//   *             do
//   *                 local i = 0;
//   *                 while i < (#fs) do
//   *                     local x = fs[i + 1]();
//   *                     if x ~= false then
//   *                         return x;
//   *                     end
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return parse_error();
//   *         end;
//   *         may_xfx_xf = function(x)
//   *             if eof() then
//   *                 return x;
//   *             end
//   *             local head = get();
//   *             if head == "." then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_list(x), something_symbol), y);
//   *             elseif head == ":" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol, y, x);
//   *             elseif head == "~" then
//   *                 return new_list(isOrNot_symbol, x);
//   *             elseif head == "@" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_construction(x, something_symbol),
//   * something_symbol), y);
//   *             elseif head == "?" then
//   *                 return new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, x));
//   *             elseif head == "/" then
//   *                 local ys = {x};
//   *                 while true do
//   *                     local y = readsysname_no_pack_inner_must(true);
//   *                     __TS__ArrayPush(ys, y);
//   *                     if eof() then
//   *                         break;
//   *                     end
//   *                     local c0 = get();
//   *                     if c0 ~= "/" then
//   *                         put(c0);
//   *                         break;
//   *                     end
//   *                 end
//   *                 return new_list(sub_symbol, jsArray_to_list(ys));
//   *             else
//   *                 put(head);
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end;
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local head = get();
//   *         if head == "&" then
//   *             un_maybe(not_eof());
//   *             local c0 = get();
//   *             if c0 == "+" then
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(form_symbol, new_list(system_symbol, x));
//   *             else
//   *                 put(c0);
//   *             end
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(form_symbol, x);
//   *         elseif head == ":" then
//   *             un_maybe(not_eof());
//   *             local c0 = get();
//   *             if c0 == "&" then
//   *                 assert_get(">");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(form_symbol, new_list(function_symbol, something_symbol, x)),
//   * theThing_symbol);
//   *             elseif c0 == ">" then
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, something_symbol, x), theThing_symbol);
//   *             else
//   *                 put(c0);
//   *             end
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(typeAnnotation_symbol, x, theThing_symbol);
//   *         elseif head == "+" then
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(system_symbol, x);
//   *         elseif head == "[" then
//   *             local x = readsysname_no_pack_inner_must();
//   *             assert_get("]");
//   *             return may_xfx_xf(x);
//   *         elseif head == "_" then
//   *             assert_get(":");
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(typeAnnotation_symbol, x, something_symbol);
//   *         else
//   *             put(head);
//   *             local x = symbol();
//   *             if x == false then
//   *                 return false;
//   *             end
//   *             return may_xfx_xf(x);
//   *         end
//   *         return ERROR();
//   *     end
// readsysname = function()
//   *         local x = readsysname_no_pack();
//   *         if x == false then
//   *             return false;
//   *         end
//   *         if symbol_p(x) then
//   *             return x;
//   *         end
//   *         return systemName_make(x);
//   *     end
// state_const = x
// state = 0
// local make_read_two
// make_read_two = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end;
//   *     end
// local make_read_three
// make_read_three = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end;
//   *     end
// readeval = make_read_two("$", function(e, x)
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return evaluate(env, x);
//   *     end)
// readfuncapply = make_read_two("%", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return builtin_func_apply(f, jsxs);
//   *     end)
// readformbuiltin = make_read_three("@", function(e, f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return builtin_form_apply(env, f, jsxs);
//   *     end)
// readapply = make_read_two("^", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return apply(f, jsxs);
//   *     end)
// return val()
// name: inner_bracket
// * function(x)
// if where == "inner" then
// return ("[" .. x) .. "]"
// elseif where == "top" then
// return x
// return ERROR()
// name: print_sys_name
// * function(x, where)
// if symbol_p(x) then
// return un_symbol(x)
// local inner_bracket
// inner_bracket = function(x)
//   *             if where == "inner" then
//   *                 return ("[" .. x) .. "]";
//   *             elseif where == "top" then
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end
// local maybe_xs = maybe_list_to_jsArray(x)
// if ((maybe_xs ~= false) and ((#maybe_xs) == 3)) and
//   * jsbool_no_force_equal_p(maybe_xs[0 + 1], typeAnnotation_symbol) then
// local maybe_lst_2 = maybe_list_to_jsArray(maybe_xs[1 + 1])
// if ((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 3)) and
//     * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], function_symbol) then
// local var_2_1 = maybe_lst_2[1 + 1]
// local maybe_lst_3 = maybe_list_to_jsArray(var_2_1)
// if ((maybe_lst_3 ~= false) and ((#maybe_lst_3) == 1)) and
//       * jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
// return inner_bracket((print_sys_name(maybe_lst_3[0 + 1], "inner") ..
//         * ".") .. print_sys_name(maybe_xs[2 + 1], "inner"))
// elseif (construction_p(var_2_1) and
//         * jsbool_no_force_equal_p(construction_tail(var_2_1),
//         * something_symbol)) and jsbool_no_force_equal_p(maybe_lst_2[2 + 1],
//         * something_symbol) then
// return inner_bracket((print_sys_name(construction_head(var_2_1),
//           * "inner") .. "@") .. print_sys_name(maybe_xs[2 + 1], "inner"))
// elseif jsbool_no_force_equal_p(var_2_1, something_symbol) and
//           * jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) then
// return inner_bracket(":>" .. print_sys_name(maybe_lst_2[2 + 1],
//             * "inner"))
// local maybe_lst_44 = maybe_list_to_jsArray(maybe_xs[2 + 1])
// if ((jsbool_no_force_equal_p(maybe_xs[1 + 1], function_symbol) and
//     * (maybe_lst_44 ~= false)) and ((#maybe_lst_44) == 2)) and
//     * jsbool_no_force_equal_p(maybe_lst_44[0 + 1], isOrNot_symbol) then
// return inner_bracket(print_sys_name(maybe_lst_44[1 + 1], "inner") ..
//       * "?")
// if (((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 2)) and
//     * jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol)) and
//     * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], form_symbol) then
// local maybe_lst_88 = maybe_list_to_jsArray(maybe_lst_2[1 + 1])
// if (((maybe_lst_88 ~= false) and ((#maybe_lst_88) == 3)) and
//       * jsbool_no_force_equal_p(maybe_lst_88[0 + 1], function_symbol)) and
//       * jsbool_no_force_equal_p(maybe_lst_88[1 + 1], something_symbol) then
// return inner_bracket(":&>" .. print_sys_name(maybe_lst_88[2 + 1],
//         * "inner"))
// local hd = (jsbool_no_force_equal_p(maybe_xs[2 + 1], something_symbol)
//     * and "_") or ((jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol)
//     * and "") or print_sys_name(maybe_xs[2 + 1], "inner"))
// return inner_bracket((hd .. ":") .. print_sys_name(maybe_xs[1 + 1],
//     * "inner"))
// elseif (maybe_xs ~= false) and ((#maybe_xs) == 2) then
// if jsbool_no_force_equal_p(maybe_xs[0 + 1], form_symbol) then
// local maybe_lst_288 = maybe_list_to_jsArray(maybe_xs[1 + 1])
// if ((maybe_lst_288 ~= false) and ((#maybe_lst_288) == 2)) and
//         * jsbool_no_force_equal_p(maybe_lst_288[0 + 1], system_symbol) then
// return inner_bracket("&+" .. print_sys_name(maybe_lst_288[1 + 1],
//           * "inner"))
// return inner_bracket("&" .. print_sys_name(maybe_xs[1 + 1], "inner"))
//
// elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], isOrNot_symbol) then
//
// return inner_bracket(print_sys_name(maybe_xs[1 + 1], "inner") ..
//           * "~")
// elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol) then
//
// return inner_bracket("+" .. print_sys_name(maybe_xs[1 + 1],
//             * "inner"))
// elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], sub_symbol) then
//
// local maybe_lst_8934 = maybe_list_to_jsArray(maybe_xs[1 + 1])
//
// if (maybe_lst_8934 ~= false) and ((#maybe_lst_8934) > 1) then
//
// local tmp = print_sys_name(maybe_lst_8934[0 + 1], "inner")
// do
//                 * local i = 1
// while i < (#maybe_lst_8934) do
// tmp = tmp .. ("/" .. print_sys_name(maybe_lst_8934[i + 1],
//                   * "inner"))
// i = i + 1
// internal: stack cleanup on scope exit
// return inner_bracket(tmp)
// if where == "inner" then
// return simple_print(x)
// elseif where == "top" then
// return simple_print(systemName_make(x))
// return ERROR()
// name: complex_print
// * function(val)
// local print_sys_name
// print_sys_name = function(x, where)
//   *         if symbol_p(x) then
//   *             return un_symbol(x);
//   *         end
//   *         local inner_bracket;
//   *         inner_bracket = function(x)
//   *             if where == "inner" then
//   *                 return ("[" .. x) .. "]";
//   *             elseif where == "top" then
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end;
//   *         local maybe_xs = maybe_list_to_jsArray(x);
//   *         if ((maybe_xs ~= false) and ((#maybe_xs) == 3)) and
//   * jsbool_no_force_equal_p(maybe_xs[0 + 1], typeAnnotation_symbol) then
//   *             local maybe_lst_2 = maybe_list_to_jsArray(maybe_xs[1 + 1]);
//   *             if ((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 3)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], function_symbol) then
//   *                 local var_2_1 = maybe_lst_2[1 + 1];
//   *                 local maybe_lst_3 = maybe_list_to_jsArray(var_2_1);
//   *                 if ((maybe_lst_3 ~= false) and ((#maybe_lst_3) == 1)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
//   *                     return inner_bracket((print_sys_name(maybe_lst_3[0 +
//   * 1], "inner") .. ".") .. print_sys_name(maybe_xs[2 + 1], "inner"));
//   *                 elseif (construction_p(var_2_1) and
//   * jsbool_no_force_equal_p(construction_tail(var_2_1), something_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
//   *                     return
//   * inner_bracket((print_sys_name(construction_head(var_2_1), "inner") .. "@")
//   * .. print_sys_name(maybe_xs[2 + 1], "inner"));
//   *                 elseif jsbool_no_force_equal_p(var_2_1, something_symbol)
//   * and jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) then
//   *                     return inner_bracket(":>" ..
//   * print_sys_name(maybe_lst_2[2 + 1], "inner"));
//   *                 end
//   *             end
//   *             local maybe_lst_44 = maybe_list_to_jsArray(maybe_xs[2 + 1]);
//   *             if ((jsbool_no_force_equal_p(maybe_xs[1 + 1], function_symbol)
//   * and (maybe_lst_44 ~= false)) and ((#maybe_lst_44) == 2)) and
//   * jsbool_no_force_equal_p(maybe_lst_44[0 + 1], isOrNot_symbol) then
//   *                 return inner_bracket(print_sys_name(maybe_lst_44[1 + 1],
//   * "inner") .. "?");
//   *             end
//   *             if (((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 2)) and
//   * jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], form_symbol) then
//   *                 local maybe_lst_88 = maybe_list_to_jsArray(maybe_lst_2[1 +
//   * 1]);
//   *                 if (((maybe_lst_88 ~= false) and ((#maybe_lst_88) == 3))
//   * and jsbool_no_force_equal_p(maybe_lst_88[0 + 1], function_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_88[1 + 1], something_symbol) then
//   *                     return inner_bracket(":&>" ..
//   * print_sys_name(maybe_lst_88[2 + 1], "inner"));
//   *                 end
//   *             end
//   *             local hd = (jsbool_no_force_equal_p(maybe_xs[2 + 1],
//   * something_symbol) and "_") or ((jsbool_no_force_equal_p(maybe_xs[2 + 1],
//   * theThing_symbol) and "") or print_sys_name(maybe_xs[2 + 1], "inner"));
//   *             return inner_bracket((hd .. ":") .. print_sys_name(maybe_xs[1 +
//   * 1], "inner"));
//   *         elseif (maybe_xs ~= false) and ((#maybe_xs) == 2) then
//   *             if jsbool_no_force_equal_p(maybe_xs[0 + 1], form_symbol) then
//   *                 local maybe_lst_288 = maybe_list_to_jsArray(maybe_xs[1 +
//   * 1]);
//   *                 if ((maybe_lst_288 ~= false) and ((#maybe_lst_288) == 2))
//   * and jsbool_no_force_equal_p(maybe_lst_288[0 + 1], system_symbol) then
//   *                     return inner_bracket("&+" ..
//   * print_sys_name(maybe_lst_288[1 + 1], "inner"));
//   *                 end
//   *                 return inner_bracket("&" .. print_sys_name(maybe_xs[1 + 1],
//   * "inner"));
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], isOrNot_symbol)
//   * then
//   *                 return inner_bracket(print_sys_name(maybe_xs[1 + 1],
//   * "inner") .. "~");
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol)
//   * then
//   *                 return inner_bracket("+" .. print_sys_name(maybe_xs[1 + 1],
//   * "inner"));
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], sub_symbol)
//   * then
//   *                 local maybe_lst_8934 = maybe_list_to_jsArray(maybe_xs[1 +
//   * 1]);
//   *                 if (maybe_lst_8934 ~= false) and ((#maybe_lst_8934) > 1)
//   * then
//   *                     local tmp = print_sys_name(maybe_lst_8934[0 + 1],
//   * "inner");
//   *                     do
//   *                         local i = 1;
//   *                         while i < (#maybe_lst_8934) do
//   *                             tmp = tmp .. ("/" ..
//   * print_sys_name(maybe_lst_8934[i + 1], "inner"));
//   *                             i = i + 1;
//   *                         end
//   *                     end
//   *                     return inner_bracket(tmp);
//   *                 end
//   *             end
//   *         end
//   *         if where == "inner" then
//   *             return simple_print(x);
//   *         elseif where == "top" then
//   *             return simple_print(systemName_make(x));
//   *         end
//   *         return ERROR();
//   *     end
// local x = simple_parse(simple_print(val))
// local temp = ""
// local prefix = ""
// if null_p(x) then
// return "()"
// elseif construction_p(x) then
// temp = "("
// prefix = ""
// while construction_p(x) do
// temp = temp .. (prefix .. complex_print(construction_head(x)))
// prefix = " "
// x = construction_tail(x)
// if null_p(x) then
// temp = temp .. ")"
// else
//         * temp = temp .. ((" . " .. complex_print(x)) .. ")")
// return temp
// elseif data_p(x) then
// local name = data_name(x)
// local list = data_list(x)
// local maybe_xs = maybe_list_to_jsArray(list)
// if (((maybe_xs ~= false) and ((#maybe_xs) == 2)) and
//         * jsbool_no_force_equal_p(name, name_symbol)) and
//         * jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol) then
// return print_sys_name(maybe_xs[1 + 1], "top")
// return "#" .. complex_print(new_construction(name, list))
// elseif error_p(x) then
// return "!" .. complex_print(new_construction(error_name(x),
//           * error_list(x)))
// elseif symbol_p(x) then
// return un_symbol(x)
// elseif delay_evaluate_p(x) then
// return ((("$(" ..
//               * complex_print(env2val(delay_evaluate_env(x)))) .. " ") ..
//               * complex_print(delay_evaluate_x(x))) .. ")"
// elseif delay_builtin_func_p(x) then
// return ((("%(" .. complex_print(delay_builtin_func_f(x))) ..
//                 * " ") ..
//                 * complex_print(jsArray_to_list(delay_builtin_func_xs(x)))) ..
//                 * ")"
// elseif delay_builtin_form_p(x) then
// return ((((("@(" ..
//                   * complex_print(env2val(delay_builtin_form_env(x)))) .. " ")
//                   * .. complex_print(delay_builtin_form_f(x))) .. " ") ..
//                   * complex_print(jsArray_to_list(delay_builtin_form_xs(x))))
//                   * .. ")"
// elseif delay_apply_p(x) then
// return ((("^(" .. complex_print(delay_apply_f(x))) .. "
//                     * ") .. complex_print(jsArray_to_list(delay_apply_xs(x))))
//                     * .. ")"
// return ERROR()
// name: (main)
// * function(...)
// -- Generated by make.rkt
//   * --    The Language
//   * --    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>
//   * --    This program is free software: you can redistribute it and/or modify
//   * --    it under the terms of the GNU Affero General Public License as
//   * published
//   * --    by the Free Software Foundation, either version 3 of the License, or
//   * --    (at your option) any later version.
//   * --    This program is distributed in the hope that it will be useful,
//   * --    but WITHOUT ANY WARRANTY; without even the implied warranty of
//   * --    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   * --    GNU Affero General Public License for more details.
//   * --    You should have received a copy of the GNU Affero General Public
//   * License
//   * --    along with this program.  If not, see
//   * <https://www.gnu.org/licenses/>.
//   * local __TS__ArrayPush = function(arr, item)
//   *     arr[#arr+1] = item
//   *     return #arr
//   * end
// local exports = {}
// local ERROR, ASSERT, construction_t, null_t, data_t, error_t, just_t,
//   * delay_evaluate_t, delay_builtin_func_t, delay_builtin_form_t,
//   * delay_apply_t, symbol_p, un_symbol, new_construction, construction_p,
//   * construction_head, construction_tail, null_v, null_p, new_data, data_p,
//   * data_name, data_list, new_error, error_p, error_name, error_list,
//   * lang_set_do, just_p, un_just, evaluate, delay_evaluate_p,
//   * delay_evaluate_env, delay_evaluate_x, builtin_form_apply,
//   * delay_builtin_form_p, delay_builtin_form_env, delay_builtin_form_f,
//   * delay_builtin_form_xs, builtin_func_apply, delay_builtin_func_p,
//   * delay_builtin_func_f, delay_builtin_func_xs, apply, delay_apply_p,
//   * delay_apply_f, delay_apply_xs, force_all_rec, system_symbol,
//   * function_symbol, form_symbol, mapping_symbol, the_world_stopped_v,
//   * data_name_function_builtin_systemName,
//   * data_list_function_builtin_systemName, data_p_function_builtin_systemName,
//   * error_name_function_builtin_systemName,
//   * error_list_function_builtin_systemName,
//   * error_p_function_builtin_systemName,
//   * construction_p_function_builtin_systemName,
//   * construction_head_function_builtin_systemName,
//   * construction_tail_function_builtin_systemName,
//   * symbol_p_function_builtin_systemName, null_p_function_builtin_systemName,
//   * equal_p_function_builtin_systemName, apply_function_builtin_systemName,
//   * evaluate_function_builtin_systemName, if_function_builtin_systemName,
//   * quote_form_builtin_systemName, lambda_form_builtin_systemName,
//   * function_builtin_use_systemName, form_builtin_use_systemName,
//   * form_use_systemName, symbol_equal_p, jsArray_to_list, new_list,
//   * un_just_all, any_delay_just_p, force_all, force1, env_null_v, env_set,
//   * env_get, must_env_get, env2val, env_foreach, real_evaluate, name_p,
//   * real_builtin_func_apply_s, real_apply, real_builtin_func_apply,
//   * real_builtin_form_apply, new_lambda, jsbool_equal_p, simple_print
// ERROR = function()
//   *     error("TheLanguage PANIC");
//   * end
// ASSERT = function(x)
//   *     if not x then
//   *         return ERROR();
//   *     end
//   * end
// symbol_p = function(x)
//   *     return x[0 + 1] == 0;
//   * end
// un_symbol = function(x)
//   *     return x[1 + 1];
//   * end
// new_construction = function(x, y)
//   *     return {construction_t, x, y};
//   * end
// construction_p = function(x)
//   *     return x[0 + 1] == construction_t;
//   * end
// construction_head = function(x)
//   *     return x[1 + 1];
//   * end
// construction_tail = function(x)
//   *     return x[2 + 1];
//   * end
// null_p = function(x)
//   *     return x[0 + 1] == null_t;
//   * end
// new_data = function(x, y)
//   *     return {data_t, x, y};
//   * end
// data_p = function(x)
//   *     return x[0 + 1] == data_t;
//   * end
// data_name = function(x)
//   *     return x[1 + 1];
//   * end
// data_list = function(x)
//   *     return x[2 + 1];
//   * end
// new_error = function(x, y)
//   *     return {error_t, x, y};
//   * end
// error_p = function(x)
//   *     return x[0 + 1] == error_t;
//   * end
// error_name = function(x)
//   *     return x[1 + 1];
//   * end
// error_list = function(x)
//   *     return x[2 + 1];
//   * end
// lang_set_do = function(x, y)
//   *     if x == y then
//   *         return;
//   *     end
//   *     x[0 + 1] = just_t;
//   *     x[1 + 1] = y;
//   *     x[2 + 1] = false;
//   *     x[3 + 1] = false;
//   * end
// just_p = function(x)
//   *     return x[0 + 1] == just_t;
//   * end
// un_just = function(x)
//   *     return x[1 + 1];
//   * end
// evaluate = function(x, y)
//   *     return {delay_evaluate_t, x, y};
//   * end
// delay_evaluate_p = function(x)
//   *     return x[0 + 1] == delay_evaluate_t;
//   * end
// delay_evaluate_env = function(x)
//   *     return x[1 + 1];
//   * end
// delay_evaluate_x = function(x)
//   *     return x[2 + 1];
//   * end
// builtin_form_apply = function(x, y, z)
//   *     return {delay_builtin_form_t, x, y, z};
//   * end
// delay_builtin_form_p = function(x)
//   *     return x[0 + 1] == delay_builtin_form_t;
//   * end
// delay_builtin_form_env = function(x)
//   *     return x[1 + 1];
//   * end
// delay_builtin_form_f = function(x)
//   *     return x[2 + 1];
//   * end
// delay_builtin_form_xs = function(x)
//   *     return x[3 + 1];
//   * end
// builtin_func_apply = function(x, y)
//   *     return {delay_builtin_func_t, x, y};
//   * end
// delay_builtin_func_p = function(x)
//   *     return x[0 + 1] == delay_builtin_func_t;
//   * end
// delay_builtin_func_f = function(x)
//   *     return x[1 + 1];
//   * end
// delay_builtin_func_xs = function(x)
//   *     return x[2 + 1];
//   * end
// apply = function(f, xs)
//   *     return {delay_apply_t, f, xs};
//   * end
// delay_apply_p = function(x)
//   *     return x[0 + 1] == delay_apply_t;
//   * end
// delay_apply_f = function(x)
//   *     return x[1 + 1];
//   * end
// delay_apply_xs = function(x)
//   *     return x[2 + 1];
//   * end
// force_all_rec = function(raw)
//   *     local x = force_all(raw);
//   *     if data_p(x) then
//   *         local a = x[1 + 1];
//   *         local d = x[2 + 1];
//   *         x[1 + 1] = force_all_rec(a);
//   *         x[2 + 1] = force_all_rec(d);
//   *         return x;
//   *     elseif error_p(x) then
//   *         local a = x[1 + 1];
//   *         local d = x[2 + 1];
//   *         x[1 + 1] = force_all_rec(a);
//   *         x[2 + 1] = force_all_rec(d);
//   *         return x;
//   *     elseif construction_p(x) then
//   *         local a = x[1 + 1];
//   *         local d = x[2 + 1];
//   *         x[1 + 1] = force_all_rec(a);
//   *         x[2 + 1] = force_all_rec(d);
//   *         return x;
//   *     end
//   *     return x;
//   * end
// symbol_equal_p = function(x, y)
//   *     if x == y then
//   *         return true;
//   *     end
//   *     if un_symbol(x) == un_symbol(y) then
//   *         lang_set_do(x, y);
//   *         return true;
//   *     else
//   *         return false;
//   *     end
//   * end
// jsArray_to_list = function(xs)
//   *     local ret = null_v;
//   *     do
//   *         local i = (#xs) - 1;
//   *         while i >= 0 do
//   *             ret = new_construction(xs[i + 1], ret);
//   *             i = i - 1;
//   *         end
//   *     end
//   *     return ret;
//   * end
// new_list = function(...)
//   *     local xs = ({...});
//   *     return jsArray_to_list(xs);
//   * end
// un_just_all = function(raw)
//   *     local x = raw;
//   *     local xs = {};
//   *     while just_p(x) do
//   *         __TS__ArrayPush(xs, x);
//   *         x = un_just(x);
//   *     end
//   *     do
//   *         local i = 0;
//   *         while i < (#xs) do
//   *             lang_set_do(xs[i + 1], x);
//   *             i = i + 1;
//   *         end
//   *     end
//   *     return x;
//   * end
// any_delay_just_p = function(x)
//   *     return (((just_p(x) or delay_evaluate_p(x)) or delay_builtin_form_p(x))
//   * or delay_builtin_func_p(x)) or delay_apply_p(x);
//   * end
// force_all = function(raw, parents_history, ref_novalue_replace, xs)
//   *     if parents_history == nil then
//   *         parents_history = {};
//   *     end
//   *     if ref_novalue_replace == nil then
//   *         ref_novalue_replace = {false, false};
//   *     end
//   *     if xs == nil then
//   *         xs = {};
//   *     end
//   *     local x, do_rewrite, do_rewrite_force_all;
//   *     do_rewrite = function(newval)
//   *         lang_set_do(x, newval);
//   *         do
//   *             local i = 0;
//   *             while i < (#xs) do
//   *                 lang_set_do(xs[i + 1], newval);
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return newval;
//   *     end;
//   *     do_rewrite_force_all = function(newval)
//   *         do_rewrite(newval);
//   *         if any_delay_just_p(newval) then
//   *             __TS__ArrayPush(xs, x);
//   *             return force_all(newval, parents_history, {false, false}, xs);
//   *         end
//   *         return newval;
//   *     end;
//   *     local history = {};
//   *     x = raw;
//   *     local replace_this_with_stopped;
//   *     replace_this_with_stopped = function()
//   *         ref_novalue_replace[1 + 1] = true;
//   *         return do_rewrite_force_all(the_world_stopped_v);
//   *     end;
//   *     local make_history;
//   *     make_history = function()
//   *         local ret = {};
//   *         for x_id in pairs(history) do
//   *             ret[x_id] = true;
//   *         end
//   *         for x_id in pairs(parents_history) do
//   *             ret[x_id] = true;
//   *         end
//   *         return ret;
//   *     end;
//   *     while any_delay_just_p(x) do
//   *         local x_id = simple_print(x);
//   *         if parents_history[x_id] == true then
//   *             return replace_this_with_stopped();
//   *         end
//   *         if history[x_id] == true then
//   *             ref_novalue_replace[0 + 1] = true;
//   *             if delay_evaluate_p(x) then
//   *                 return replace_this_with_stopped();
//   *             elseif delay_builtin_func_p(x) then
//   *                 local f = delay_builtin_func_f(x);
//   *                 local xs = delay_builtin_func_xs(x);
//   *                 local elim_s = {data_name_function_builtin_systemName,
//   * data_list_function_builtin_systemName, data_p_function_builtin_systemName,
//   * error_name_function_builtin_systemName,
//   * error_list_function_builtin_systemName,
//   * error_p_function_builtin_systemName,
//   * construction_p_function_builtin_systemName,
//   * construction_head_function_builtin_systemName,
//   * construction_tail_function_builtin_systemName,
//   * symbol_p_function_builtin_systemName, null_p_function_builtin_systemName};
//   *                 local is_elim = false;
//   *                 do
//   *                     local i = 0;
//   *                     while i < (#elim_s) do
//   *                         if jsbool_equal_p(elim_s[i + 1], f) then
//   *                             is_elim = true;
//   *                         end
//   *                         i = i + 1;
//   *                     end
//   *                 end
//   *                 if is_elim then
//   *                     ASSERT((#xs) == 1);
//   *                     ASSERT(ref_novalue_replace[1 + 1] == false);
//   *                     local inner = force_all(xs[0 + 1], make_history(),
//   * ref_novalue_replace);
//   *                     if ref_novalue_replace[1 + 1] then
//   *                         return do_rewrite_force_all(builtin_func_apply(f,
//   * {inner}));
//   *                     else
//   *                         return ERROR();
//   *                     end
//   *                 end
//   *                 if jsbool_equal_p(f, equal_p_function_builtin_systemName)
//   * then
//   *                     return replace_this_with_stopped();
//   *                 elseif jsbool_equal_p(f, apply_function_builtin_systemName)
//   * then
//   *                     return replace_this_with_stopped();
//   *                 elseif jsbool_equal_p(f,
//   * evaluate_function_builtin_systemName) then
//   *                     return replace_this_with_stopped();
//   *                 elseif jsbool_equal_p(f, if_function_builtin_systemName)
//   * then
//   *                     ASSERT((#xs) == 3);
//   *                     ASSERT(ref_novalue_replace[1 + 1] == false);
//   *                     local tf = force_all(xs[0 + 1], make_history(),
//   * ref_novalue_replace);
//   *                     if ref_novalue_replace[1 + 1] then
//   *                         return
//   * do_rewrite_force_all(builtin_func_apply(if_function_builtin_systemName,
//   * {tf, xs[1 + 1], xs[2 + 1]}));
//   *                     else
//   *                         return ERROR();
//   *                     end
//   *                 end
//   *                 return ERROR();
//   *             elseif delay_builtin_form_p(x) then
//   *                 return replace_this_with_stopped();
//   *             elseif delay_apply_p(x) then
//   *                 return replace_this_with_stopped();
//   *             end
//   *             return ERROR();
//   *         end
//   *         history[x_id] = true;
//   *         __TS__ArrayPush(xs, x);
//   *         x = force1(x);
//   *     end
//   *     return do_rewrite(x);
//   * end
// force1 = function(raw)
//   *     local x = un_just_all(raw);
//   *     local ret;
//   *     ASSERT(not just_p(x));
//   *     if delay_evaluate_p(x) then
//   *         ret = real_evaluate(delay_evaluate_env(x), delay_evaluate_x(x));
//   *     elseif delay_builtin_form_p(x) then
//   *         ret = real_builtin_form_apply(delay_builtin_form_env(x),
//   * delay_builtin_form_f(x), delay_builtin_form_xs(x));
//   *     elseif delay_builtin_func_p(x) then
//   *         ret = real_builtin_func_apply(delay_builtin_func_f(x),
//   * delay_builtin_func_xs(x));
//   *     elseif delay_apply_p(x) then
//   *         ret = real_apply(delay_apply_f(x), delay_apply_xs(x));
//   *     else
//   *         ret = x;
//   *     end
//   *     ret = un_just_all(ret);
//   *     lang_set_do(x, ret);
//   *     return ret;
//   * end
// env_set = function(env, key, val)
//   *     local ret = {};
//   *     do
//   *         local i = 0;
//   *         while i < (#env) do
//   *             if jsbool_equal_p(env[(i + 0) + 1], key) then
//   *                 ret[(i + 0) + 1] = key;
//   *                 ret[(i + 1) + 1] = val;
//   *                 do
//   *                     i = i + 2;
//   *                     while i < (#env) do
//   *                         ret[(i + 0) + 1] = env[(i + 0) + 1];
//   *                         ret[(i + 1) + 1] = env[(i + 1) + 1];
//   *                         i = i + 2;
//   *                     end
//   *                 end
//   *                 return ret;
//   *             else
//   *                 ret[(i + 0) + 1] = env[(i + 0) + 1];
//   *                 ret[(i + 1) + 1] = env[(i + 1) + 1];
//   *             end
//   *             i = i + 2;
//   *         end
//   *     end
//   *     ret[((#env) + 0) + 1] = key;
//   *     ret[((#env) + 1) + 1] = val;
//   *     return ret;
//   * end
// env_get = function(env, key, default_v)
//   *     do
//   *         local i = 0;
//   *         while i < (#env) do
//   *             if jsbool_equal_p(env[(i + 0) + 1], key) then
//   *                 return env[(i + 1) + 1];
//   *             end
//   *             i = i + 2;
//   *         end
//   *     end
//   *     return default_v;
//   * end
// must_env_get = function(env, key)
//   *     do
//   *         local i = 0;
//   *         while i < (#env) do
//   *             if jsbool_equal_p(env[(i + 0) + 1], key) then
//   *                 return env[(i + 1) + 1];
//   *             end
//   *             i = i + 2;
//   *         end
//   *     end
//   *     return ERROR();
//   * end
// env2val = function(env)
//   *     local ret = null_v;
//   *     do
//   *         local i = 0;
//   *         while i < (#env) do
//   *             ret = new_construction(new_list(env[(i + 0) + 1], env[(i + 1) +
//   * 1]), ret);
//   *             i = i + 2;
//   *         end
//   *     end
//   *     return new_data(mapping_symbol, new_list(ret));
//   * end
// env_foreach = function(env, f)
//   *     do
//   *         local i = 0;
//   *         while i < (#env) do
//   *             f(env[(i + 0) + 1], env[(i + 1) + 1]);
//   *             i = i + 2;
//   *         end
//   *     end
//   * end
// real_evaluate = function(env, raw)
//   *     local x = force1(raw);
//   *     if any_delay_just_p(x) then
//   *         return evaluate(env, x);
//   *     end
//   *     local error_v = new_error(system_symbol,
//   * new_list(function_builtin_use_systemName,
//   * new_list(evaluate_function_builtin_systemName, new_list(env2val(env),
//   * x))));
//   *     if construction_p(x) then
//   *         local xs = {};
//   *         local rest = x;
//   *         while not null_p(rest) do
//   *             if any_delay_just_p(rest) then
//   *                 return evaluate(env, x);
//   *             elseif construction_p(rest) then
//   *                 __TS__ArrayPush(xs, construction_head(rest));
//   *                 rest = force1(construction_tail(rest));
//   *             else
//   *                 return error_v;
//   *             end
//   *         end
//   *         if jsbool_equal_p(xs[0 + 1], form_builtin_use_systemName) then
//   *             if (#xs) == 1 then
//   *                 return error_v;
//   *             end
//   *             local f = xs[1 + 1];
//   *             local args = {};
//   *             do
//   *                 local i = 2;
//   *                 while i < (#xs) do
//   *                     args[(i - 2) + 1] = xs[i + 1];
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return builtin_form_apply(env, f, args);
//   *         elseif jsbool_equal_p(xs[0 + 1], form_use_systemName) then
//   *             if (#xs) == 1 then
//   *                 return error_v;
//   *             end
//   *             local f = force_all(evaluate(env, xs[1 + 1]));
//   *             if not data_p(f) then
//   *                 return error_v;
//   *             end
//   *             local f_type = force1(data_name(f));
//   *             if any_delay_just_p(f_type) then
//   *                 return evaluate(env, x);
//   *             end
//   *             if not symbol_p(f_type) then
//   *                 return error_v;
//   *             end
//   *             if not symbol_equal_p(f_type, form_symbol) then
//   *                 return error_v;
//   *             end
//   *             local f_list = force1(data_list(f));
//   *             if any_delay_just_p(f_list) then
//   *                 return evaluate(env, x);
//   *             end
//   *             if not construction_p(f_list) then
//   *                 return error_v;
//   *             end
//   *             local f_x = construction_head(f_list);
//   *             local f_list_cdr = force1(construction_tail(f_list));
//   *             if any_delay_just_p(f_list_cdr) then
//   *                 return evaluate(env, x);
//   *             end
//   *             if not null_p(f_list_cdr) then
//   *                 return error_v;
//   *             end
//   *             local args = {env2val(env)};
//   *             do
//   *                 local i = 2;
//   *                 while i < (#xs) do
//   *                     args[(i - 1) + 1] = xs[i + 1];
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return apply(f_x, args);
//   *         elseif jsbool_equal_p(xs[0 + 1], function_builtin_use_systemName)
//   * then
//   *             if (#xs) == 1 then
//   *                 return error_v;
//   *             end
//   *             local f = xs[1 + 1];
//   *             local args = {};
//   *             do
//   *                 local i = 2;
//   *                 while i < (#xs) do
//   *                     args[(i - 2) + 1] = evaluate(env, xs[i + 1]);
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return builtin_func_apply(f, args);
//   *         else
//   *             local f = evaluate(env, xs[0 + 1]);
//   *             local args = {};
//   *             do
//   *                 local i = 1;
//   *                 while i < (#xs) do
//   *                     args[(i - 1) + 1] = evaluate(env, xs[i + 1]);
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return apply(f, args);
//   *         end
//   *     elseif null_p(x) then
//   *         return x;
//   *     elseif name_p(x) then
//   *         return env_get(env, x, error_v);
//   *     elseif error_p(x) then
//   *         return error_v;
//   *     end
//   *     return ERROR();
//   * end
// name_p = function(x)
//   *     return symbol_p(x) or data_p(x);
//   * end
// real_apply = function(f, xs)
//   *     local make_error_v;
//   *     make_error_v = function()
//   *         return new_error(system_symbol,
//   * new_list(function_builtin_use_systemName,
//   * new_list(apply_function_builtin_systemName, new_list(f,
//   * jsArray_to_list(xs)))));
//   *     end;
//   *     f = force1(f);
//   *     if any_delay_just_p(f) then
//   *         return apply(f, xs);
//   *     end
//   *     if not data_p(f) then
//   *         return make_error_v();
//   *     end
//   *     local f_type = force_all(data_name(f));
//   *     if not (symbol_p(f_type) and symbol_equal_p(f_type, function_symbol))
//   * then
//   *         return make_error_v();
//   *     end
//   *     local f_list = force_all(data_list(f));
//   *     if not construction_p(f_list) then
//   *         return make_error_v();
//   *     end
//   *     local args_pat = force_all_rec(construction_head(f_list));
//   *     local f_list_cdr = force_all(construction_tail(f_list));
//   *     if not (construction_p(f_list_cdr) and
//   * null_p(force_all(construction_tail(f_list_cdr)))) then
//   *         return make_error_v();
//   *     end
//   *     local f_code = construction_head(f_list_cdr);
//   *     local env = env_null_v;
//   *     local xs_i = 0;
//   *     while not null_p(args_pat) do
//   *         if name_p(args_pat) then
//   *             local x = null_v;
//   *             do
//   *                 local i = (#xs) - 1;
//   *                 while i >= xs_i do
//   *                     x = new_construction(xs[i + 1], x);
//   *                     i = i - 1;
//   *                 end
//   *             end
//   *             env = env_set(env, args_pat, x);
//   *             xs_i = #xs;
//   *             args_pat = null_v;
//   *         elseif construction_p(args_pat) then
//   *             if xs_i < (#xs) then
//   *                 local x = xs[xs_i + 1];
//   *                 xs_i = xs_i + 1;
//   *                 env = env_set(env, construction_head(args_pat), x);
//   *                 args_pat = construction_tail(args_pat);
//   *             else
//   *                 return make_error_v();
//   *             end
//   *         else
//   *             return make_error_v();
//   *         end
//   *     end
//   *     if (#xs) ~= xs_i then
//   *         return make_error_v();
//   *     end
//   *     return evaluate(env, f_code);
//   * end
// real_builtin_func_apply = function(f, xs)
//   *     local error_v = new_error(system_symbol,
//   * new_list(function_builtin_use_systemName, new_list(f,
//   * jsArray_to_list(xs))));
//   *     do
//   *         local i = 0;
//   *         while i < (#real_builtin_func_apply_s) do
//   *             if jsbool_equal_p(f, real_builtin_func_apply_s[i + 1][0 + 1])
//   * then
//   *                 local actually_length = real_builtin_func_apply_s[i + 1][1
//   * + 1];
//   *                 if (#xs) ~= actually_length then
//   *                     return error_v;
//   *                 end
//   *                 local f = real_builtin_func_apply_s[i + 1][2 + 1];
//   *                 if actually_length == 1 then
//   *                     return (f)(xs[0 + 1], error_v);
//   *                 elseif actually_length == 2 then
//   *                     return (f)(xs[0 + 1], xs[1 + 1], error_v);
//   *                 elseif actually_length == 3 then
//   *                     return (f)(xs[0 + 1], xs[1 + 1], xs[2 + 1], error_v);
//   *                 end
//   *                 return ERROR();
//   *             end
//   *             i = i + 1;
//   *         end
//   *     end
//   *     return error_v;
//   * end
// real_builtin_form_apply = function(env, f, xs)
//   *     local error_v = new_error(system_symbol,
//   * new_list(form_builtin_use_systemName, new_list(env2val(env), f,
//   * jsArray_to_list(xs))));
//   *     if jsbool_equal_p(f, quote_form_builtin_systemName) then
//   *         if (#xs) ~= 1 then
//   *             return error_v;
//   *         end
//   *         return xs[0 + 1];
//   *     elseif jsbool_equal_p(f, lambda_form_builtin_systemName) then
//   *         if (#xs) ~= 2 then
//   *             return error_v;
//   *         end
//   *         return new_lambda(env, xs[0 + 1], xs[1 + 1], error_v);
//   *     end
//   *     return error_v;
//   * end
// new_lambda = function(env, args_pat, body, error_v)
//   *     if error_v == nil then
//   *         error_v = false;
//   *     end
//   *     local make_error_v;
//   *     make_error_v = function()
//   *         if error_v == false then
//   *             return new_error(system_symbol,
//   * new_list(form_builtin_use_systemName, new_list(env2val(env),
//   * lambda_form_builtin_systemName, jsArray_to_list({args_pat, body}))));
//   *         else
//   *             return error_v;
//   *         end
//   *     end;
//   *     local make_quote;
//   *     make_quote = function(x)
//   *         return new_list(form_builtin_use_systemName,
//   * quote_form_builtin_systemName, x);
//   *     end;
//   *     args_pat = force_all_rec(args_pat);
//   *     local args_pat_vars = {};
//   *     local args_pat_is_dot = false;
//   *     local args_pat_iter = args_pat;
//   *     while not null_p(args_pat_iter) do
//   *         if name_p(args_pat_iter) then
//   *             __TS__ArrayPush(args_pat_vars, args_pat_iter);
//   *             args_pat_is_dot = true;
//   *             args_pat_iter = null_v;
//   *         elseif construction_p(args_pat_iter) then
//   *             __TS__ArrayPush(args_pat_vars,
//   * construction_head(args_pat_iter));
//   *             args_pat_iter = construction_tail(args_pat_iter);
//   *         else
//   *             return make_error_v();
//   *         end
//   *     end
//   *     local args_pat_vars_val = args_pat;
//   *     if args_pat_is_dot then
//   *         args_pat_vars_val = jsArray_to_list(args_pat_vars);
//   *     end
//   *     local env_vars = {};
//   *     env_foreach(env, function(k, v)
//   *         do
//   *             local i = 0;
//   *             while i < (#args_pat_vars) do
//   *                 if jsbool_equal_p(args_pat_vars[i + 1], k) then
//   *                     return;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         __TS__ArrayPush(env_vars, k);
//   *     end);
//   *     local new_args_pat = args_pat_vars_val;
//   *     do
//   *         local i = (#env_vars) - 1;
//   *         while i >= 0 do
//   *             new_args_pat = new_construction(env_vars[i + 1], new_args_pat);
//   *             i = i - 1;
//   *         end
//   *     end
//   *     local new_args = args_pat_vars_val;
//   *     do
//   *         local i = (#env_vars) - 1;
//   *         while i >= 0 do
//   *             new_args = new_construction(make_quote(must_env_get(env,
//   * env_vars[i + 1])), new_args);
//   *             i = i - 1;
//   *         end
//   *     end
//   *     return new_data(function_symbol, new_list(args_pat,
//   * new_construction(make_quote(new_data(function_symbol,
//   * new_list(new_args_pat, body))), new_args)));
//   * end
// jsbool_equal_p = function(x, y)
//   *     if x == y then
//   *         return true;
//   *     end
//   *     x = force_all(x);
//   *     y = force_all(y);
//   *     if x == y then
//   *         return true;
//   *     end
//   *     local end_2;
//   *     end_2 = function(x, y, f1, f2)
//   *         if jsbool_equal_p(f1(x), f1(y)) and jsbool_equal_p(f2(x), f2(y))
//   * then
//   *             lang_set_do(x, y);
//   *             return true;
//   *         else
//   *             return false;
//   *         end
//   *     end;
//   *     if null_p(x) then
//   *         if not null_p(y) then
//   *             return false;
//   *         end
//   *         lang_set_do(x, null_v);
//   *         lang_set_do(y, null_v);
//   *         return true;
//   *     elseif symbol_p(x) then
//   *         if not symbol_p(y) then
//   *             return false;
//   *         end
//   *         return symbol_equal_p(x, y);
//   *     elseif construction_p(x) then
//   *         if not construction_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, construction_head, construction_tail);
//   *     elseif error_p(x) then
//   *         if not error_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, error_name, error_list);
//   *     elseif data_p(x) then
//   *         if not data_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, data_name, data_list);
//   *     end
//   *     return ERROR();
//   * end
// simple_print = function(x)
//   *     x = un_just_all(x);
//   *     local temp = "";
//   *     local prefix = "";
//   *     if null_p(x) then
//   *         return "()";
//   *     elseif construction_p(x) then
//   *         temp = "(";
//   *         prefix = "";
//   *         while construction_p(x) do
//   *             temp = temp .. (prefix .. simple_print(construction_head(x)));
//   *             prefix = " ";
//   *             x = un_just_all(construction_tail(x));
//   *         end
//   *         if null_p(x) then
//   *             temp = temp .. ")";
//   *         else
//   *             temp = temp .. ((" . " .. simple_print(x)) .. ")");
//   *         end
//   *         return temp;
//   *     elseif data_p(x) then
//   *         return "#" .. simple_print(new_construction(data_name(x),
//   * data_list(x)));
//   *     elseif error_p(x) then
//   *         return "!" .. simple_print(new_construction(error_name(x),
//   * error_list(x)));
//   *     elseif symbol_p(x) then
//   *         return un_symbol(x);
//   *     elseif delay_evaluate_p(x) then
//   *         return ((("$(" .. simple_print(env2val(delay_evaluate_env(x)))) ..
//   * " ") .. simple_print(delay_evaluate_x(x))) .. ")";
//   *     elseif delay_builtin_func_p(x) then
//   *         return ((("%(" .. simple_print(delay_builtin_func_f(x))) .. " ") ..
//   * simple_print(jsArray_to_list(delay_builtin_func_xs(x)))) .. ")";
//   *     elseif delay_builtin_form_p(x) then
//   *         return ((((("@(" ..
//   * simple_print(env2val(delay_builtin_form_env(x)))) .. " ") ..
//   * simple_print(delay_builtin_form_f(x))) .. " ") ..
//   * simple_print(jsArray_to_list(delay_builtin_form_xs(x)))) .. ")";
//   *     elseif delay_apply_p(x) then
//   *         return ((("^(" .. simple_print(delay_apply_f(x))) .. " ") ..
//   * simple_print(jsArray_to_list(delay_apply_xs(x)))) .. ")";
//   *     end
//   *     return ERROR();
//   * end
// local symbol_t = 0
// construction_t = 1
// null_t = 2
// data_t = 3
// error_t = 4
// just_t = 5
// delay_evaluate_t = 6
// delay_builtin_func_t = 7
// delay_builtin_form_t = 8
// delay_apply_t = 9
// local new_symbol
// new_symbol = function(x)
//   *     return {symbol_t, x};
//   * end
// exports.new_symbol = new_symbol
// exports.symbol_p = symbol_p
// exports.un_symbol = un_symbol
// exports.new_construction = new_construction
// exports.construction_p = construction_p
// exports.construction_head = construction_head
// exports.construction_tail = construction_tail
// null_v = {null_t}
// exports.null_v = null_v
// exports.null_p = null_p
// exports.new_data = new_data
// exports.data_p = data_p
// exports.data_name = data_name
// exports.data_list = data_list
// exports.new_error = new_error
// exports.error_p = error_p
// exports.error_name = error_name
// exports.error_list = error_list
// exports.evaluate = evaluate
// exports.apply = apply
// exports.force_all_rec = force_all_rec
// system_symbol = new_symbol("太始初核")
// local name_symbol = new_symbol("符名")
// function_symbol = new_symbol("化滅")
// form_symbol = new_symbol("式形")
// local equal_symbol = new_symbol("等同")
// local evaluate_sym = new_symbol("解算")
// local theThing_symbol = new_symbol("特定其物")
// local something_symbol = new_symbol("省略一物")
// mapping_symbol = new_symbol("映表")
// local if_symbol = new_symbol("若")
// local typeAnnotation_symbol = new_symbol("一類何物")
// local isOrNot_symbol = new_symbol("是非")
// local sub_symbol = new_symbol("其子")
// local true_symbol = new_symbol("陽")
// local false_symbol = new_symbol("陰")
// local quote_symbol = new_symbol("引用")
// local apply_symbol = new_symbol("應用")
// local null_symbol = new_symbol("空")
// local construction_symbol = new_symbol("連")
// local data_symbol = new_symbol("構")
// local error_symbol = new_symbol("誤")
// local symbol_symbol = new_symbol("詞素")
// local list_symbol = new_symbol("列")
// local head_symbol = new_symbol("首")
// local tail_symbol = new_symbol("尾")
// local thing_symbol = new_symbol("物")
// local theWorldStopped_symbol = new_symbol("宇宙亡矣")
// local effect_symbol = new_symbol("效應")
// local sequentialWordFormation_symbol = new_symbol("為符名連")
// local inputOutput_symbol = new_symbol("出入改滅")
// exports.system_symbol = system_symbol
// exports.name_symbol = name_symbol
// exports.function_symbol = function_symbol
// exports.form_symbol = form_symbol
// exports.equal_symbol = equal_symbol
// exports.evaluate_sym = evaluate_sym
// exports.theThing_symbol = theThing_symbol
// exports.something_symbol = something_symbol
// exports.mapping_symbol = mapping_symbol
// exports.if_symbol = if_symbol
// exports.typeAnnotation_symbol = typeAnnotation_symbol
// exports.isOrNot_symbol = isOrNot_symbol
// exports.sub_symbol = sub_symbol
// exports.true_symbol = true_symbol
// exports.false_symbol = false_symbol
// exports.quote_symbol = quote_symbol
// exports.apply_symbol = apply_symbol
// exports.null_symbol = null_symbol
// exports.construction_symbol = construction_symbol
// exports.data_symbol = data_symbol
// exports.error_symbol = error_symbol
// exports.symbol_symbol = symbol_symbol
// exports.list_symbol = list_symbol
// exports.head_symbol = head_symbol
// exports.tail_symbol = tail_symbol
// exports.thing_symbol = thing_symbol
// exports.theWorldStopped_symbol = theWorldStopped_symbol
// exports.effect_symbol = effect_symbol
// exports.sequentialWordFormation_symbol = sequentialWordFormation_symbol
// exports.inputOutput_symbol = inputOutput_symbol
// the_world_stopped_v = new_error(system_symbol,
//   * new_list(theWorldStopped_symbol, something_symbol))
// local systemName_make
// systemName_make = function(x)
//   *     return new_data(name_symbol, new_list(system_symbol, x));
//   * end
// local make_builtin_f_new_sym_f
// make_builtin_f_new_sym_f = function(x_sym)
//   *     return systemName_make(new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, something_symbol, x_sym), theThing_symbol));
//   * end
// local make_builtin_f_get_sym_f
// make_builtin_f_get_sym_f = function(t_sym, x_sym)
//   *     return systemName_make(new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_list(t_sym), something_symbol), x_sym));
//   * end
// local make_builtin_f_p_sym_f
// make_builtin_f_p_sym_f = function(t_sym)
//   *     return systemName_make(new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, new_list(typeAnnotation_symbol, t_sym,
//   * something_symbol))));
//   * end
// local new_data_function_builtin_systemName =
//   * make_builtin_f_new_sym_f(data_symbol)
// data_name_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(data_symbol, name_symbol)
// data_list_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(data_symbol, list_symbol)
// data_p_function_builtin_systemName = make_builtin_f_p_sym_f(data_symbol)
// local new_error_function_builtin_systemName =
//   * make_builtin_f_new_sym_f(error_symbol)
// error_name_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(error_symbol, name_symbol)
// error_list_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(error_symbol, list_symbol)
// error_p_function_builtin_systemName = make_builtin_f_p_sym_f(error_symbol)
//
// local new_construction_function_builtin_systemName =
//   * make_builtin_f_new_sym_f(construction_symbol)
// construction_p_function_builtin_systemName =
//   * make_builtin_f_p_sym_f(construction_symbol)
// construction_head_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(construction_symbol, head_symbol)
// construction_tail_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(construction_symbol, tail_symbol)
// symbol_p_function_builtin_systemName =
//   * make_builtin_f_p_sym_f(symbol_symbol)
// null_p_function_builtin_systemName = make_builtin_f_p_sym_f(null_symbol)
// equal_p_function_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, equal_symbol)))
// apply_function_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, new_list(function_symbol,
//   * new_construction(function_symbol, something_symbol), something_symbol),
//   * apply_symbol))
// evaluate_function_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, function_symbol,
//   * evaluate_sym))
// local list_chooseOne_function_builtin_systemName =
//   * make_builtin_f_get_sym_f(list_symbol, new_list(typeAnnotation_symbol,
//   * thing_symbol, something_symbol))
// if_function_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, function_symbol,
//   * if_symbol))
// quote_form_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, form_symbol, quote_symbol))
//
// lambda_form_builtin_systemName =
//   * systemName_make(new_list(typeAnnotation_symbol, new_list(form_symbol,
//   * new_list(function_symbol, something_symbol, function_symbol)),
//   * theThing_symbol))
// function_builtin_use_systemName = systemName_make(new_list(form_symbol,
//   * new_list(system_symbol, function_symbol)))
// form_builtin_use_systemName = systemName_make(new_list(form_symbol,
//   * new_list(system_symbol, form_symbol)))
// form_use_systemName = systemName_make(new_list(form_symbol, form_symbol))
//
// exports.new_data_function_builtin_systemName =
//   * new_data_function_builtin_systemName
// exports.data_name_function_builtin_systemName =
//   * data_name_function_builtin_systemName
// exports.data_list_function_builtin_systemName =
//   * data_list_function_builtin_systemName
// exports.data_p_function_builtin_systemName =
//   * data_p_function_builtin_systemName
// exports.new_error_function_builtin_systemName =
//   * new_error_function_builtin_systemName
// exports.error_name_function_builtin_systemName =
//   * error_name_function_builtin_systemName
// exports.error_list_function_builtin_systemName =
//   * error_list_function_builtin_systemName
// exports.error_p_function_builtin_systemName =
//   * error_p_function_builtin_systemName
// exports.new_construction_function_builtin_systemName =
//   * new_construction_function_builtin_systemName
// exports.construction_p_function_builtin_systemName =
//   * construction_p_function_builtin_systemName
// exports.construction_head_function_builtin_systemName =
//   * construction_head_function_builtin_systemName
// exports.construction_tail_function_builtin_systemName =
//   * construction_tail_function_builtin_systemName
// exports.symbol_p_function_builtin_systemName =
//   * symbol_p_function_builtin_systemName
// exports.null_p_function_builtin_systemName =
//   * null_p_function_builtin_systemName
// exports.equal_p_function_builtin_systemName =
//   * equal_p_function_builtin_systemName
// exports.apply_function_builtin_systemName =
//   * apply_function_builtin_systemName
// exports.evaluate_function_builtin_systemName =
//   * evaluate_function_builtin_systemName
// exports.list_chooseOne_function_builtin_systemName =
//   * list_chooseOne_function_builtin_systemName
// exports.if_function_builtin_systemName = if_function_builtin_systemName
// exports.quote_form_builtin_systemName = quote_form_builtin_systemName
// exports.lambda_form_builtin_systemName = lambda_form_builtin_systemName
// exports.function_builtin_use_systemName = function_builtin_use_systemName
//
// exports.form_builtin_use_systemName = form_builtin_use_systemName
// exports.form_use_systemName = form_use_systemName
// local false_v = new_data(false_symbol, new_list())
// local true_v = new_data(true_symbol, new_list())
// local list_to_jsArray
// list_to_jsArray = function(xs, k_done, k_tail)
//   *     local ret = {};
//   *     while construction_p(xs) do
//   *         __TS__ArrayPush(ret, construction_head(xs));
//   *         xs = construction_tail(xs);
//   *     end
//   *     if null_p(xs) then
//   *         return k_done(ret);
//   *     end
//   *     return k_tail(ret, xs);
//   * end
// local maybe_list_to_jsArray
// maybe_list_to_jsArray = function(xs)
//   *     return list_to_jsArray(xs, function(xs)
//   *         return xs;
//   *     end, function(xs, x)
//   *         return false;
//   *     end);
//   * end
// exports.jsArray_to_list = jsArray_to_list
// exports.maybe_list_to_jsArray = maybe_list_to_jsArray
// exports.new_list = new_list
// exports.delay_p = any_delay_just_p
// exports.force_all = force_all
// exports.force1 = force1
// env_null_v = {}
// local val2env
// val2env = function(x)
//   *     x = force_all(x);
//   *     if not data_p(x) then
//   *         return false;
//   *     end
//   *     local s = force_all(data_name(x));
//   *     if not symbol_p(s) then
//   *         return false;
//   *     end
//   *     if not symbol_equal_p(s, mapping_symbol) then
//   *         return false;
//   *     end
//   *     s = force_all(data_list(x));
//   *     if not construction_p(s) then
//   *         return false;
//   *     end
//   *     if not null_p(force_all(construction_tail(s))) then
//   *         return false;
//   *     end
//   *     local ret = {};
//   *     local xs = force_all(construction_head(s));
//   *     while not null_p(xs) do
//   *         if not construction_p(xs) then
//   *             return false;
//   *         end
//   *         local x = force_all(construction_head(xs));
//   *         xs = force_all(construction_tail(xs));
//   *         if not construction_p(x) then
//   *             return false;
//   *         end
//   *         local k = construction_head(x);
//   *         x = force_all(construction_tail(x));
//   *         if not construction_p(x) then
//   *             return false;
//   *         end
//   *         local v = construction_head(x);
//   *         if not null_p(force_all(construction_tail(x))) then
//   *             return false;
//   *         end
//   *         local not_breaked = true;
//   *         do
//   *             local i = 0;
//   *             while i < (#ret) do
//   *                 if jsbool_equal_p(ret[(i + 0) + 1], k) then
//   *                     ret[(i + 1) + 1] = v;
//   *                     not_breaked = false;
//   *                     break;
//   *                 end
//   *                 i = i + 2;
//   *             end
//   *         end
//   *         if not_breaked then
//   *             __TS__ArrayPush(ret, k);
//   *             __TS__ArrayPush(ret, v);
//   *         end
//   *     end
//   *     return ret;
//   * end
// exports.env_null_v = env_null_v
// exports.env_set = env_set
// exports.env_get = env_get
// exports.env2val = env2val
// exports.env_foreach = env_foreach
// exports.val2env = val2env
// local make_builtin_p_func
// make_builtin_p_func = function(p_sym, p_jsfunc)
//   *     return {p_sym, 1, function(x, error_v)
//   *         x = force1(x);
//   *         if any_delay_just_p(x) then
//   *             return builtin_func_apply(p_sym, {x});
//   *         end
//   *         if p_jsfunc(x) then
//   *             return true_v;
//   *         end
//   *         return false_v;
//   *     end};
//   * end
// local make_builtin_get_func
// make_builtin_get_func = function(f_sym, p_jsfunc, f_jsfunc)
//   *     return {f_sym, 1, function(x, error_v)
//   *         x = force1(x);
//   *         if any_delay_just_p(x) then
//   *             return builtin_func_apply(f_sym, {x});
//   *         end
//   *         if p_jsfunc(x) then
//   *             return f_jsfunc(x);
//   *         end
//   *         return error_v;
//   *     end};
//   * end
// real_builtin_func_apply_s =
//   * {make_builtin_p_func(data_p_function_builtin_systemName, data_p),
//   * {new_data_function_builtin_systemName, 2, new_data},
//   * make_builtin_get_func(data_name_function_builtin_systemName, data_p,
//   * data_name), make_builtin_get_func(data_list_function_builtin_systemName,
//   * data_p, data_list),
//   * make_builtin_p_func(error_p_function_builtin_systemName, error_p),
//   * {new_error_function_builtin_systemName, 2, new_error},
//   * make_builtin_get_func(error_name_function_builtin_systemName, error_p,
//   * error_name), make_builtin_get_func(error_list_function_builtin_systemName,
//   * error_p, error_list),
//   * make_builtin_p_func(null_p_function_builtin_systemName, null_p),
//   * {new_construction_function_builtin_systemName, 2, new_construction},
//   * make_builtin_p_func(construction_p_function_builtin_systemName,
//   * construction_p),
//   * make_builtin_get_func(construction_head_function_builtin_systemName,
//   * construction_p, construction_head),
//   * make_builtin_get_func(construction_tail_function_builtin_systemName,
//   * construction_p, construction_tail), {equal_p_function_builtin_systemName,
//   * 2, function(x, y, error_v)
//   *     if x == y then
//   *         return true_v;
//   *     end
//   *     x = force1(x);
//   *     y = force1(y);
//   *     if any_delay_just_p(x) or any_delay_just_p(y) then
//   *         return builtin_func_apply(equal_p_function_builtin_systemName, {x,
//   * y});
//   *     end
//   *     if x == y then
//   *         return true_v;
//   *     end
//   *     local H_if;
//   *     H_if = function(b, x, y)
//   *         return builtin_func_apply(if_function_builtin_systemName, {b, x,
//   * y});
//   *     end;
//   *     local H_and;
//   *     H_and = function(x, y)
//   *         return H_if(x, y, false_v);
//   *     end;
//   *     ASSERT(not any_delay_just_p(x));
//   *     local end_2;
//   *     end_2 = function(x, y, f1, f2)
//   *         return
//   * H_and(builtin_func_apply(equal_p_function_builtin_systemName, {f1(x),
//   * f1(y)}), builtin_func_apply(equal_p_function_builtin_systemName, {f2(x),
//   * f2(y)}));
//   *     end;
//   *     if null_p(x) then
//   *         if not null_p(x) then
//   *             return false_v;
//   *         end
//   *         return true_v;
//   *     elseif symbol_p(x) then
//   *         if not symbol_p(y) then
//   *             return false_v;
//   *         end
//   *         return (symbol_equal_p(x, y) and true_v) or false_v;
//   *     elseif data_p(x) then
//   *         if not data_p(y) then
//   *             return false_v;
//   *         end
//   *         return end_2(x, y, data_name, data_list);
//   *     elseif construction_p(x) then
//   *         if not construction_p(y) then
//   *             return false_v;
//   *         end
//   *         return end_2(x, y, construction_head, construction_tail);
//   *     elseif error_p(x) then
//   *         if not error_p(y) then
//   *             return false_v;
//   *         end
//   *         return end_2(x, y, error_name, error_list);
//   *     end
//   *     return ERROR();
//   * end}, {apply_function_builtin_systemName, 2, function(f, xs, error_v)
//   *     local jslist = {};
//   *     local iter = force_all(xs);
//   *     while construction_p(iter) do
//   *         __TS__ArrayPush(jslist, construction_head(iter));
//   *         iter = force_all(construction_tail(iter));
//   *     end
//   *     if not null_p(iter) then
//   *         return error_v;
//   *     end
//   *     return apply(f, jslist);
//   * end}, {evaluate_function_builtin_systemName, 2, function(env, x, error_v)
//   *     local maybeenv = val2env(env);
//   *     if maybeenv == false then
//   *         return error_v;
//   *     end
//   *     return evaluate(maybeenv, x);
//   * end}, make_builtin_p_func(symbol_p_function_builtin_systemName, symbol_p),
//   * {list_chooseOne_function_builtin_systemName, 1, function(xs, error_v)
//   *     xs = force1(xs);
//   *     if any_delay_just_p(xs) then
//   *         return
//   * builtin_func_apply(list_chooseOne_function_builtin_systemName, {xs});
//   *     end
//   *     if not construction_p(xs) then
//   *         return error_v;
//   *     end
//   *     return construction_head(xs);
//   * end}, {if_function_builtin_systemName, 3, function(b, x, y, error_v)
//   *     b = force1(b);
//   *     if any_delay_just_p(b) then
//   *         return builtin_func_apply(if_function_builtin_systemName, {b, x,
//   * y});
//   *     end
//   *     if not data_p(b) then
//   *         return error_v;
//   *     end
//   *     local nam = force_all(data_name(b));
//   *     if not symbol_p(nam) then
//   *         return error_v;
//   *     end
//   *     if symbol_equal_p(nam, true_symbol) then
//   *         return x;
//   *     end
//   *     if symbol_equal_p(nam, false_symbol) then
//   *         return y;
//   *     end
//   *     return error_v;
//   * end}}
// exports.equal_p = jsbool_equal_p
// local jsbool_no_force_equal_p
// jsbool_no_force_equal_p = function(x, y)
//   *     if x == y then
//   *         return true;
//   *     end
//   *     x = un_just_all(x);
//   *     y = un_just_all(y);
//   *     if x == y then
//   *         return true;
//   *     end
//   *     local end_2;
//   *     end_2 = function(x, y, f1, f2)
//   *         if jsbool_no_force_equal_p(f1(x), f1(y)) and
//   * jsbool_no_force_equal_p(f2(x), f2(y)) then
//   *             lang_set_do(x, y);
//   *             return true;
//   *         else
//   *             return false;
//   *         end
//   *     end;
//   *     if null_p(x) then
//   *         if not null_p(y) then
//   *             return false;
//   *         end
//   *         lang_set_do(x, null_v);
//   *         lang_set_do(y, null_v);
//   *         return true;
//   *     elseif symbol_p(x) then
//   *         if not symbol_p(y) then
//   *             return false;
//   *         end
//   *         return symbol_equal_p(x, y);
//   *     elseif construction_p(x) then
//   *         if not construction_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, construction_head, construction_tail);
//   *     elseif error_p(x) then
//   *         if not error_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, error_name, error_list);
//   *     elseif data_p(x) then
//   *         if not data_p(y) then
//   *             return false;
//   *         end
//   *         return end_2(x, y, data_name, data_list);
//   *     elseif delay_evaluate_p(x) then
//   *         return false;
//   *     elseif delay_builtin_func_p(x) then
//   *         return false;
//   *     elseif delay_builtin_form_p(x) then
//   *         return false;
//   *     elseif delay_apply_p(x) then
//   *         return false;
//   *     end
//   *     return ERROR();
//   * end
// local simple_print_force_all_rec
// simple_print_force_all_rec = function(x)
//   *     return simple_print(force_all_rec(x));
//   * end
// exports.simple_print = simple_print
// exports.simple_print_force_all_rec = simple_print_force_all_rec
// local simple_parse
// simple_parse = function(x)
//   *     local state_const, state, eof, get, put, parse_error, a_space_p, space,
//   * symbol, list, data, readerror, readeval, readfuncapply, readformbuiltin,
//   * readapply, a_symbol_p, val;
//   *     eof = function()
//   *         return (#state_const) == state;
//   *     end;
//   *     get = function()
//   *         ASSERT(not eof());
//   *         local ret = state_const:sub(state + 1, state + 1);
//   *         state = state + 1;
//   *         return ret;
//   *     end;
//   *     put = function(x)
//   *         ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x);
//   *         state = state - 1;
//   *     end;
//   *     parse_error = function()
//   *         error("TheLanguage parse ERROR!");
//   *     end;
//   *     a_space_p = function(x)
//   *         return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r");
//   *     end;
//   *     space = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if not a_space_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_space_p(x) and (not eof()) do
//   *             x = get();
//   *         end
//   *         if not a_space_p(x) then
//   *             put(x);
//   *         end
//   *         return true;
//   *     end;
//   *     symbol = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         local ret = "";
//   *         if not a_symbol_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_symbol_p(x) and (not eof()) do
//   *             ret = ret .. x;
//   *             x = get();
//   *         end
//   *         if a_symbol_p(x) then
//   *             ret = ret .. x;
//   *         else
//   *             put(x);
//   *         end
//   *         return new_symbol(ret);
//   *     end;
//   *     list = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "(" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local HOLE = new_symbol("!!@@READ||HOLE@@!!");
//   *         local ret = HOLE;
//   *         local set_last;
//   *         set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end;
//   *         local last_add;
//   *         last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end;
//   *         while true do
//   *             space();
//   *             if eof() then
//   *                 return parse_error();
//   *             end
//   *             x = get();
//   *             if x == ")" then
//   *                 set_last(null_v);
//   *                 return ret;
//   *             end
//   *             if x == "." then
//   *                 space();
//   *                 local e = val();
//   *                 set_last(e);
//   *                 space();
//   *                 if eof() then
//   *                     return parse_error();
//   *                 end
//   *                 x = get();
//   *                 if x ~= ")" then
//   *                     return parse_error();
//   *                 end
//   *                 return ret;
//   *             end
//   *             put(x);
//   *             local e = val();
//   *             last_add(e);
//   *         end
//   *     end;
//   *     data = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "#" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_data(construction_head(xs), construction_tail(xs));
//   *     end;
//   *     readerror = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "!" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_error(construction_head(xs), construction_tail(xs));
//   *     end;
//   *     a_symbol_p = function(x)
//   *         if a_space_p(x) then
//   *             return false;
//   *         end
//   *         local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~",
//   * "/", "-", ">", "_", ":", "?", "[", "]", "&"};
//   *         do
//   *             local i = 0;
//   *             while i < (#not_xs) do
//   *                 if x == not_xs[i + 1] then
//   *                     return false;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return true;
//   *     end;
//   *     val = function()
//   *         space();
//   *         local fs = {list, symbol, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply};
//   *         do
//   *             local i = 0;
//   *             while i < (#fs) do
//   *                 local x = fs[i + 1]();
//   *                 if x ~= false then
//   *                     return x;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return parse_error();
//   *     end;
//   *     state_const = x;
//   *     state = 0;
//   *     local make_read_two;
//   *     make_read_two = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end;
//   *     end;
//   *     local make_read_three;
//   *     make_read_three = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end;
//   *     end;
//   *     readeval = make_read_two("$", function(e, x)
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return evaluate(env, x);
//   *     end);
//   *     readfuncapply = make_read_two("%", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return builtin_func_apply(f, jsxs);
//   *     end);
//   *     readformbuiltin = make_read_three("@", function(e, f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return builtin_form_apply(env, f, jsxs);
//   *     end);
//   *     readapply = make_read_two("^", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return apply(f, jsxs);
//   *     end);
//   *     return val();
//   * end
// exports.simple_parse = simple_parse
// local complex_parse
// complex_parse = function(x)
//   *     local state_const, state, eof, get, put, parse_error, a_space_p, space,
//   * symbol, list, data, readerror, readeval, readfuncapply, readformbuiltin,
//   * readapply, a_symbol_p, val, un_maybe, not_eof, assert_get,
//   * readsysname_no_pack, readsysname;
//   *     eof = function()
//   *         return (#state_const) == state;
//   *     end;
//   *     get = function()
//   *         ASSERT(not eof());
//   *         local ret = state_const:sub(state + 1, state + 1);
//   *         state = state + 1;
//   *         return ret;
//   *     end;
//   *     put = function(x)
//   *         ASSERT(state_const:sub((state - 1) + 1, (state - 1) + 1) == x);
//   *         state = state - 1;
//   *     end;
//   *     parse_error = function()
//   *         error("TheLanguage parse ERROR!");
//   *     end;
//   *     a_space_p = function(x)
//   *         return (((x == " ") or (x == "\n")) or (x == "\t")) or (x == "\r");
//   *     end;
//   *     space = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if not a_space_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_space_p(x) and (not eof()) do
//   *             x = get();
//   *         end
//   *         if not a_space_p(x) then
//   *             put(x);
//   *         end
//   *         return true;
//   *     end;
//   *     symbol = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         local ret = "";
//   *         if not a_symbol_p(x) then
//   *             put(x);
//   *             return false;
//   *         end
//   *         while a_symbol_p(x) and (not eof()) do
//   *             ret = ret .. x;
//   *             x = get();
//   *         end
//   *         if a_symbol_p(x) then
//   *             ret = ret .. x;
//   *         else
//   *             put(x);
//   *         end
//   *         return new_symbol(ret);
//   *     end;
//   *     list = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "(" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local HOLE = new_symbol("!!@@READ||HOLE@@!!");
//   *         local ret = HOLE;
//   *         local set_last;
//   *         set_last = function(lst)
//   *             if ret == HOLE then
//   *                 ret = lst;
//   *                 return;
//   *             end
//   *             local x = ret;
//   *             while true do
//   *                 if not construction_p(x) then
//   *                     return ERROR();
//   *                 end
//   *                 local d = construction_tail(x);
//   *                 if d == HOLE then
//   *                     break;
//   *                 end
//   *                 x = construction_tail(x);
//   *             end
//   *             if not construction_p(x) then
//   *                 return ERROR();
//   *             end
//   *             if construction_tail(x) ~= HOLE then
//   *                 return ERROR();
//   *             end
//   *             x[2 + 1] = lst;
//   *         end;
//   *         local last_add;
//   *         last_add = function(x)
//   *             set_last(new_construction(x, HOLE));
//   *         end;
//   *         while true do
//   *             space();
//   *             if eof() then
//   *                 return parse_error();
//   *             end
//   *             x = get();
//   *             if x == ")" then
//   *                 set_last(null_v);
//   *                 return ret;
//   *             end
//   *             if x == "." then
//   *                 space();
//   *                 local e = val();
//   *                 set_last(e);
//   *                 space();
//   *                 if eof() then
//   *                     return parse_error();
//   *                 end
//   *                 x = get();
//   *                 if x ~= ")" then
//   *                     return parse_error();
//   *                 end
//   *                 return ret;
//   *             end
//   *             put(x);
//   *             local e = val();
//   *             last_add(e);
//   *         end
//   *     end;
//   *     data = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "#" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_data(construction_head(xs), construction_tail(xs));
//   *     end;
//   *     readerror = function()
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local x = get();
//   *         if x ~= "!" then
//   *             put(x);
//   *             return false;
//   *         end
//   *         local xs = list();
//   *         if xs == false then
//   *             return parse_error();
//   *         end
//   *         if not construction_p(xs) then
//   *             return parse_error();
//   *         end
//   *         return new_error(construction_head(xs), construction_tail(xs));
//   *     end;
//   *     a_symbol_p = function(x)
//   *         if a_space_p(x) then
//   *             return false;
//   *         end
//   *         local not_xs = {"(", ")", "!", "#", ".", "$", "%", "^", "@", "~",
//   * "/", "-", ">", "_", ":", "?", "[", "]", "&"};
//   *         do
//   *             local i = 0;
//   *             while i < (#not_xs) do
//   *                 if x == not_xs[i + 1] then
//   *                     return false;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return true;
//   *     end;
//   *     val = function()
//   *         space();
//   *         local fs = {list, readsysname, data, readerror, readeval,
//   * readfuncapply, readformbuiltin, readapply};
//   *         do
//   *             local i = 0;
//   *             while i < (#fs) do
//   *                 local x = fs[i + 1]();
//   *                 if x ~= false then
//   *                     return x;
//   *                 end
//   *                 i = i + 1;
//   *             end
//   *         end
//   *         return parse_error();
//   *     end;
//   *     un_maybe = function(x)
//   *         if x == false then
//   *             return parse_error();
//   *         end
//   *         return x;
//   *     end;
//   *     not_eof = function()
//   *         return not eof();
//   *     end;
//   *     assert_get = function(c)
//   *         un_maybe(not_eof());
//   *         un_maybe(get() == c);
//   *     end;
//   *     readsysname_no_pack = function()
//   *         local readsysname_no_pack_inner_must, may_xfx_xf;
//   *         readsysname_no_pack_inner_must = function(strict)
//   *             if strict == nil then
//   *                 strict = false;
//   *             end
//   *             local readsysname_no_pack_bracket;
//   *             readsysname_no_pack_bracket = function()
//   *                 assert_get("[");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 assert_get("]");
//   *                 return x;
//   *             end;
//   *             local fs = (strict and {list, symbol,
//   * readsysname_no_pack_bracket, data, readerror, readeval, readfuncapply,
//   * readformbuiltin, readapply}) or {list, readsysname_no_pack, data,
//   * readerror, readeval, readfuncapply, readformbuiltin, readapply};
//   *             do
//   *                 local i = 0;
//   *                 while i < (#fs) do
//   *                     local x = fs[i + 1]();
//   *                     if x ~= false then
//   *                         return x;
//   *                     end
//   *                     i = i + 1;
//   *                 end
//   *             end
//   *             return parse_error();
//   *         end;
//   *         may_xfx_xf = function(x)
//   *             if eof() then
//   *                 return x;
//   *             end
//   *             local head = get();
//   *             if head == "." then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_list(x), something_symbol), y);
//   *             elseif head == ":" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol, y, x);
//   *             elseif head == "~" then
//   *                 return new_list(isOrNot_symbol, x);
//   *             elseif head == "@" then
//   *                 local y = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, new_construction(x, something_symbol),
//   * something_symbol), y);
//   *             elseif head == "?" then
//   *                 return new_list(typeAnnotation_symbol, function_symbol,
//   * new_list(isOrNot_symbol, x));
//   *             elseif head == "/" then
//   *                 local ys = {x};
//   *                 while true do
//   *                     local y = readsysname_no_pack_inner_must(true);
//   *                     __TS__ArrayPush(ys, y);
//   *                     if eof() then
//   *                         break;
//   *                     end
//   *                     local c0 = get();
//   *                     if c0 ~= "/" then
//   *                         put(c0);
//   *                         break;
//   *                     end
//   *                 end
//   *                 return new_list(sub_symbol, jsArray_to_list(ys));
//   *             else
//   *                 put(head);
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end;
//   *         if eof() then
//   *             return false;
//   *         end
//   *         local head = get();
//   *         if head == "&" then
//   *             un_maybe(not_eof());
//   *             local c0 = get();
//   *             if c0 == "+" then
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(form_symbol, new_list(system_symbol, x));
//   *             else
//   *                 put(c0);
//   *             end
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(form_symbol, x);
//   *         elseif head == ":" then
//   *             un_maybe(not_eof());
//   *             local c0 = get();
//   *             if c0 == "&" then
//   *                 assert_get(">");
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(form_symbol, new_list(function_symbol, something_symbol, x)),
//   * theThing_symbol);
//   *             elseif c0 == ">" then
//   *                 local x = readsysname_no_pack_inner_must();
//   *                 return new_list(typeAnnotation_symbol,
//   * new_list(function_symbol, something_symbol, x), theThing_symbol);
//   *             else
//   *                 put(c0);
//   *             end
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(typeAnnotation_symbol, x, theThing_symbol);
//   *         elseif head == "+" then
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(system_symbol, x);
//   *         elseif head == "[" then
//   *             local x = readsysname_no_pack_inner_must();
//   *             assert_get("]");
//   *             return may_xfx_xf(x);
//   *         elseif head == "_" then
//   *             assert_get(":");
//   *             local x = readsysname_no_pack_inner_must();
//   *             return new_list(typeAnnotation_symbol, x, something_symbol);
//   *         else
//   *             put(head);
//   *             local x = symbol();
//   *             if x == false then
//   *                 return false;
//   *             end
//   *             return may_xfx_xf(x);
//   *         end
//   *         return ERROR();
//   *     end;
//   *     readsysname = function()
//   *         local x = readsysname_no_pack();
//   *         if x == false then
//   *             return false;
//   *         end
//   *         if symbol_p(x) then
//   *             return x;
//   *         end
//   *         return systemName_make(x);
//   *     end;
//   *     state_const = x;
//   *     state = 0;
//   *     local make_read_two;
//   *     make_read_two = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not (construction_p(x) and null_p(construction_tail(x)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x));
//   *         end;
//   *     end;
//   *     local make_read_three;
//   *     make_read_three = function(prefix, k)
//   *         return function()
//   *             if eof() then
//   *                 return false;
//   *             end
//   *             local c = get();
//   *             if c ~= prefix then
//   *                 put(c);
//   *                 return false;
//   *             end
//   *             local xs = list();
//   *             if xs == false then
//   *                 return parse_error();
//   *             end
//   *             if not construction_p(xs) then
//   *                 return parse_error();
//   *             end
//   *             local x = construction_tail(xs);
//   *             if not construction_p(x) then
//   *                 return parse_error();
//   *             end
//   *             local x_d = construction_tail(x);
//   *             if not (construction_p(x_d) and null_p(construction_tail(x_d)))
//   * then
//   *                 return parse_error();
//   *             end
//   *             return k(construction_head(xs), construction_head(x),
//   * construction_head(x_d));
//   *         end;
//   *     end;
//   *     readeval = make_read_two("$", function(e, x)
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return evaluate(env, x);
//   *     end);
//   *     readfuncapply = make_read_two("%", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return builtin_func_apply(f, jsxs);
//   *     end);
//   *     readformbuiltin = make_read_three("@", function(e, f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         local env = val2env(e);
//   *         if env == false then
//   *             return parse_error();
//   *         end
//   *         return builtin_form_apply(env, f, jsxs);
//   *     end);
//   *     readapply = make_read_two("^", function(f, xs)
//   *         local jsxs = list_to_jsArray(xs, function(xs)
//   *             return xs;
//   *         end, function(xs, y)
//   *             return parse_error();
//   *         end);
//   *         return apply(f, jsxs);
//   *     end);
//   *     return val();
//   * end
// exports.complex_parse = complex_parse
// local complex_print
// complex_print = function(val)
//   *     local print_sys_name;
//   *     print_sys_name = function(x, where)
//   *         if symbol_p(x) then
//   *             return un_symbol(x);
//   *         end
//   *         local inner_bracket;
//   *         inner_bracket = function(x)
//   *             if where == "inner" then
//   *                 return ("[" .. x) .. "]";
//   *             elseif where == "top" then
//   *                 return x;
//   *             end
//   *             return ERROR();
//   *         end;
//   *         local maybe_xs = maybe_list_to_jsArray(x);
//   *         if ((maybe_xs ~= false) and ((#maybe_xs) == 3)) and
//   * jsbool_no_force_equal_p(maybe_xs[0 + 1], typeAnnotation_symbol) then
//   *             local maybe_lst_2 = maybe_list_to_jsArray(maybe_xs[1 + 1]);
//   *             if ((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 3)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], function_symbol) then
//   *                 local var_2_1 = maybe_lst_2[1 + 1];
//   *                 local maybe_lst_3 = maybe_list_to_jsArray(var_2_1);
//   *                 if ((maybe_lst_3 ~= false) and ((#maybe_lst_3) == 1)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
//   *                     return inner_bracket((print_sys_name(maybe_lst_3[0 +
//   * 1], "inner") .. ".") .. print_sys_name(maybe_xs[2 + 1], "inner"));
//   *                 elseif (construction_p(var_2_1) and
//   * jsbool_no_force_equal_p(construction_tail(var_2_1), something_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
//   *                     return
//   * inner_bracket((print_sys_name(construction_head(var_2_1), "inner") .. "@")
//   * .. print_sys_name(maybe_xs[2 + 1], "inner"));
//   *                 elseif jsbool_no_force_equal_p(var_2_1, something_symbol)
//   * and jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) then
//   *                     return inner_bracket(":>" ..
//   * print_sys_name(maybe_lst_2[2 + 1], "inner"));
//   *                 end
//   *             end
//   *             local maybe_lst_44 = maybe_list_to_jsArray(maybe_xs[2 + 1]);
//   *             if ((jsbool_no_force_equal_p(maybe_xs[1 + 1], function_symbol)
//   * and (maybe_lst_44 ~= false)) and ((#maybe_lst_44) == 2)) and
//   * jsbool_no_force_equal_p(maybe_lst_44[0 + 1], isOrNot_symbol) then
//   *                 return inner_bracket(print_sys_name(maybe_lst_44[1 + 1],
//   * "inner") .. "?");
//   *             end
//   *             if (((maybe_lst_2 ~= false) and ((#maybe_lst_2) == 2)) and
//   * jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_2[0 + 1], form_symbol) then
//   *                 local maybe_lst_88 = maybe_list_to_jsArray(maybe_lst_2[1 +
//   * 1]);
//   *                 if (((maybe_lst_88 ~= false) and ((#maybe_lst_88) == 3))
//   * and jsbool_no_force_equal_p(maybe_lst_88[0 + 1], function_symbol)) and
//   * jsbool_no_force_equal_p(maybe_lst_88[1 + 1], something_symbol) then
//   *                     return inner_bracket(":&>" ..
//   * print_sys_name(maybe_lst_88[2 + 1], "inner"));
//   *                 end
//   *             end
//   *             local hd = (jsbool_no_force_equal_p(maybe_xs[2 + 1],
//   * something_symbol) and "_") or ((jsbool_no_force_equal_p(maybe_xs[2 + 1],
//   * theThing_symbol) and "") or print_sys_name(maybe_xs[2 + 1], "inner"));
//   *             return inner_bracket((hd .. ":") .. print_sys_name(maybe_xs[1 +
//   * 1], "inner"));
//   *         elseif (maybe_xs ~= false) and ((#maybe_xs) == 2) then
//   *             if jsbool_no_force_equal_p(maybe_xs[0 + 1], form_symbol) then
//   *                 local maybe_lst_288 = maybe_list_to_jsArray(maybe_xs[1 +
//   * 1]);
//   *                 if ((maybe_lst_288 ~= false) and ((#maybe_lst_288) == 2))
//   * and jsbool_no_force_equal_p(maybe_lst_288[0 + 1], system_symbol) then
//   *                     return inner_bracket("&+" ..
//   * print_sys_name(maybe_lst_288[1 + 1], "inner"));
//   *                 end
//   *                 return inner_bracket("&" .. print_sys_name(maybe_xs[1 + 1],
//   * "inner"));
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], isOrNot_symbol)
//   * then
//   *                 return inner_bracket(print_sys_name(maybe_xs[1 + 1],
//   * "inner") .. "~");
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol)
//   * then
//   *                 return inner_bracket("+" .. print_sys_name(maybe_xs[1 + 1],
//   * "inner"));
//   *             elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], sub_symbol)
//   * then
//   *                 local maybe_lst_8934 = maybe_list_to_jsArray(maybe_xs[1 +
//   * 1]);
//   *                 if (maybe_lst_8934 ~= false) and ((#maybe_lst_8934) > 1)
//   * then
//   *                     local tmp = print_sys_name(maybe_lst_8934[0 + 1],
//   * "inner");
//   *                     do
//   *                         local i = 1;
//   *                         while i < (#maybe_lst_8934) do
//   *                             tmp = tmp .. ("/" ..
//   * print_sys_name(maybe_lst_8934[i + 1], "inner"));
//   *                             i = i + 1;
//   *                         end
//   *                     end
//   *                     return inner_bracket(tmp);
//   *                 end
//   *             end
//   *         end
//   *         if where == "inner" then
//   *             return simple_print(x);
//   *         elseif where == "top" then
//   *             return simple_print(systemName_make(x));
//   *         end
//   *         return ERROR();
//   *     end;
//   *     local x = simple_parse(simple_print(val));
//   *     local temp = "";
//   *     local prefix = "";
//   *     if null_p(x) then
//   *         return "()";
//   *     elseif construction_p(x) then
//   *         temp = "(";
//   *         prefix = "";
//   *         while construction_p(x) do
//   *             temp = temp .. (prefix .. complex_print(construction_head(x)));
//   *             prefix = " ";
//   *             x = construction_tail(x);
//   *         end
//   *         if null_p(x) then
//   *             temp = temp .. ")";
//   *         else
//   *             temp = temp .. ((" . " .. complex_print(x)) .. ")");
//   *         end
//   *         return temp;
//   *     elseif data_p(x) then
//   *         local name = data_name(x);
//   *         local list = data_list(x);
//   *         local maybe_xs = maybe_list_to_jsArray(list);
//   *         if (((maybe_xs ~= false) and ((#maybe_xs) == 2)) and
//   * jsbool_no_force_equal_p(name, name_symbol)) and
//   * jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol) then
//   *             return print_sys_name(maybe_xs[1 + 1], "top");
//   *         end
//   *         return "#" .. complex_print(new_construction(name, list));
//   *     elseif error_p(x) then
//   *         return "!" .. complex_print(new_construction(error_name(x),
//   * error_list(x)));
//   *     elseif symbol_p(x) then
//   *         return un_symbol(x);
//   *     elseif delay_evaluate_p(x) then
//   *         return ((("$(" .. complex_print(env2val(delay_evaluate_env(x)))) ..
//   * " ") .. complex_print(delay_evaluate_x(x))) .. ")";
//   *     elseif delay_builtin_func_p(x) then
//   *         return ((("%(" .. complex_print(delay_builtin_func_f(x))) .. " ")
//   * .. complex_print(jsArray_to_list(delay_builtin_func_xs(x)))) .. ")";
//   *     elseif delay_builtin_form_p(x) then
//   *         return ((((("@(" ..
//   * complex_print(env2val(delay_builtin_form_env(x)))) .. " ") ..
//   * complex_print(delay_builtin_form_f(x))) .. " ") ..
//   * complex_print(jsArray_to_list(delay_builtin_form_xs(x)))) .. ")";
//   *     elseif delay_apply_p(x) then
//   *         return ((("^(" .. complex_print(delay_apply_f(x))) .. " ") ..
//   * complex_print(jsArray_to_list(delay_apply_xs(x)))) .. ")";
//   *     end
//   *     return ERROR();
//   * end
// exports.complex_print = complex_print
// return exports
// from lua.c
// 'message' not a string?
// keep it intact
// pass error message
// skip this function and traceback
// call debug.traceback
//FIX-IMROVE:progname
// function index
// push traceback function
// put it under chunk and args
//FIX? signal(SIGINT, laction);
//FIX? signal(SIGINT, SIG_DFL);
// remove traceback function
// force a complete garbage collection in case of errors
// status OK
type lc_args_t struct {
	c int32
	v [][]byte
}

// lang_state - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20805
// create global arg table
//-- #include "src.cpp/lang.h" start --
// TODO: Lua 錯誤處理
type lang_state struct {
	L           []lua_State
	exports_ref int32
}

// lang_value - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20809
type lang_value struct {
	lua_ref int32
}

// lu_int32 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20999
//-- File: src.cpp/lang.cpp end --
//-- #include "src.cpp/lang.h" start --
//-- File: src.cpp/lapi.cpp start --
//
//** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
//** Lua API
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/assert.h" start --
//-- #include "src.cpp/math.h" start --
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lapi.h" start --
//
//** $Id: lapi.h,v 2.2.1.1 2007/12/27 13:02:25 roberto Exp $
//** Auxiliary functions from Lua API
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//
//** $Id: lobject.h,v 2.20.1.2 2008/08/06 13:29:48 roberto Exp $
//** Type definitions for Lua objects
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/llimits.h" start --
//
//** $Id: llimits.h,v 1.69.1.1 2007/12/27 13:02:25 roberto Exp $
//** Limits, basic types, and some other `installation-dependent' definitions
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/limits.h" start --
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/lua.h" start --
type lu_int32 = uint32

// lu_mem - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21001
type lu_mem = uint

// l_mem - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21003
type l_mem = noarch.PtrdiffT

// lu_byte - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21008
// chars used as small naturals (so that `char' is reserved for characters)
type lu_byte = uint8

type L_Umaxalign struct{ memory unsafe.Pointer }

func (unionVar *L_Umaxalign) copy() L_Umaxalign {
	var buffer [8]byte
	for i := range // L_Umaxalign - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21028
	//
	//** conversion of pointer to integer
	//** this is for hashing only; there is no problem if the integer
	//** cannot hold the whole pointer value
	//
	// type to ensure maximum alignment
	buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion L_Umaxalign
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *L_Umaxalign) u() *float64 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*float64)(unionVar.memory)
}
func (unionVar *L_Umaxalign) s() *interface{} {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*interface{})(unionVar.memory)
}
func (unionVar *L_Umaxalign) l() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

// l_uacNumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21032
// result of a `usual argument conversion' over lua_Number
type l_uacNumber = float64

// Instruction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21069
// internal assertions for in-house debugging
//
//** type for virtual-machine instructions
//** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
//
type Instruction = lu_int32

// GCheader - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21144
// maximum stack for a Lua function
// minimum size for the string table (must be power of 2)
// minimum size for string buffer
//
//** macro to control inclusion of some hard tests on stack reallocation
//
//-- #include "src.cpp/lua.h" start --
// tags for values visible from Lua
//
//** Extra tags for non-values
//
//
//** Union of all collectable objects
//
//
//** Common Header for all collectable objects (in macro form, to be
//** included in other objects)
//
//
//** Common header in struct form
//
type GCheader struct {
	next   []GCObject
	tt     lu_byte
	marked lu_byte
}

type Value struct{ memory unsafe.Pointer }

func (unionVar *Value) copy() Value {
	var buffer [8]byte
	for i := range // Value - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21154
	//
	//** Union of all Lua values
	//
	buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion Value
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *Value) gc() *[]GCObject {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[]GCObject)(unionVar.memory)
}
func (unionVar *Value) p() *interface{} {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*interface{})(unionVar.memory)
}
func (unionVar *Value) n() *lua_Number {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*lua_Number)(unionVar.memory)
}
func (unionVar *Value) b() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

// lua_TValue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21168
//
//** Tagged Values
//
type lua_TValue struct {
	value Value
	tt    int32
}

// TValue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21168
type TValue = lua_TValue

// StkId - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21288
// Macros to test type
// Macros to access values
//
//** for internal debug only
//
// Macros to set values
//
//** different types of sets, according to destination
//
// from stack to (same) stack
// to stack (not from same stack)
// from table to same table
// to table
// to new object
// index to stack elements
type StkId = []TValue

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21294
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296
//
//** String headers for string table
//
// ensures maximum alignment for strings
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ struct {
	next     []GCObject
	tt       lu_byte
	marked   lu_byte
	reserved lu_byte
	hash     uint32
	len_     uint
}
type TString struct{ memory unsafe.Pointer }

func (unionVar *TString) copy() TString {
	var buffer [24]byte
	for i := range buffer {
		buffer[i] = (*((*[24]byte)(unionVar.memory)))[i]
	}
	var newUnion TString
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *TString) dummy() *L_Umaxalign {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*L_Umaxalign)(unionVar.memory)
}
func (unionVar *TString) tsv() *__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_)(unionVar.memory)
}

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21310
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312
// ensures maximum alignment for `local' udata
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ struct {
	next      []GCObject
	tt        lu_byte
	marked    lu_byte
	metatable []Table
	env       []Table
	len_      uint
}
type Udata struct{ memory unsafe.Pointer }

func (unionVar *Udata) copy() Udata {
	var buffer [40]byte
	for i := range buffer {
		buffer[i] = (*((*[40]byte)(unionVar.memory)))[i]
	}
	var newUnion Udata
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *Udata) dummy() *L_Umaxalign {
	if unionVar.memory == nil {
		var buffer [40]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*L_Umaxalign)(unionVar.memory)
}
func (unionVar *Udata) uv() *__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ {
	if unionVar.memory == nil {
		var buffer [40]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_)(unionVar.memory)
}

// Proto - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21326
//
//** Function Prototypes
//
type Proto struct {
	next            []GCObject
	tt              lu_byte
	marked          lu_byte
	k               []TValue
	code            []Instruction
	p               [][]Proto
	lineinfo        []int32
	locvars         []LocVar
	upvalues        [][]TString
	source          []TString
	sizeupvalues    int32
	sizek           int32
	sizecode        int32
	sizelineinfo    int32
	sizep           int32
	sizelocvars     int32
	linedefined     int32
	lastlinedefined int32
	gclist          []GCObject
	nups            lu_byte
	numparams       lu_byte
	is_vararg       lu_byte
	maxstacksize    lu_byte
}

// LocVar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21357
// constants used by the function
// functions defined inside the function
// map from opcodes to source lines
// information about local variables
// upvalue names
// size of `k'
// size of `p'
// number of upvalues
// masks for new-style vararg
type LocVar struct {
	varname []TString
	startpc int32
	endpc   int32
}

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21369
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21372
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21374
// first point where variable is active
// first point where variable is dead
//
//** Upvalues
//
// points to stack or to its own value
// the value (when closed)
// double linked list (when open)
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_ struct {
	prev []UpVal
	next []UpVal
}
type __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_ struct{ memory unsafe.Pointer }

func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_) copy() __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_ {
	var buffer [48]byte
	for i := range buffer {
		buffer[i] = (*((*[48]byte)(unionVar.memory)))[i]
	}
	var newUnion __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_) value() *TValue {
	if unionVar.memory == nil {
		var buffer [48]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*TValue)(unionVar.memory)
}
func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_) l() *__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_ {
	if unionVar.memory == nil {
		var buffer [48]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21374_5_)(unionVar.memory)
}

type UpVal struct {
	next   []GCObject
	tt     lu_byte
	marked lu_byte
	v      []TValue
	u      __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21372_3_
}

// CClosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21390
//
//** Closures
//
type CClosure struct {
	next      []GCObject
	tt        lu_byte
	marked    lu_byte
	isC       lu_byte
	nupvalues lu_byte
	gclist    []GCObject
	env       []Table
	f         lua_CFunction
	upvalue   [1]TValue
}

// LClosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21397
type LClosure struct {
	next      []GCObject
	tt        lu_byte
	marked    lu_byte
	isC       lu_byte
	nupvalues lu_byte
	gclist    []GCObject
	env       []Table
	p         []Proto
	upvals    [1][]UpVal
}

type Closure struct{ memory unsafe.Pointer }

func (unionVar *Closure) copy() Closure {
	var buffer [48]byte
	for i := range // Closure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21404
	buffer {
		buffer[i] = (*((*[48]byte)(unionVar.memory)))[i]
	}
	var newUnion Closure
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *Closure) c() *CClosure {
	if unionVar.memory == nil {
		var buffer [48]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*CClosure)(unionVar.memory)
}
func (unionVar *Closure) l() *LClosure {
	if unionVar.memory == nil {
		var buffer [48]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*LClosure)(unionVar.memory)
}

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21418
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419
//
//** Tables
//
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ struct {
	value Value
	tt    int32
	next  []Node
}
type TKey struct{ memory unsafe.Pointer }

func (unionVar *TKey) copy() TKey {
	var buffer [24]byte
	for i := range buffer {
		buffer[i] = (*((*[24]byte)(unionVar.memory)))[i]
	}
	var newUnion TKey
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *TKey) nk() *__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_)(unionVar.memory)
}
func (unionVar *TKey) tvk() *TValue {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*TValue)(unionVar.memory)
}

// Node - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21427
// for chaining
type Node struct {
	i_val TValue
	i_key TKey
}

// Table - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21433
type Table struct {
	next      []GCObject
	tt        lu_byte
	marked    lu_byte
	flags     lu_byte
	lsizenode lu_byte
	metatable []Table
	array     []TValue
	node      []Node
	lastfree  []Node
	gclist    []GCObject
	sizearray int32
}

// luaO_nilobject_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21460
// 1<<p means tagmethod(p) is not present
// log2 of size of `node' array
// array part
// any free position is before this position
// size of `array' array
//
//** `module' operation for hashing (size is always a power of 2)
//
var luaO_nilobject_ TValue

// TM_INDEX - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21526
//-- #include "src.cpp/ldebug.h" start --
//
//** $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
//** Auxiliary functions from Debug Interface module
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lstate.h" start --
//
//** $Id: lstate.h,v 2.24.1.2 2008/01/03 15:20:39 roberto Exp $
//** Global State
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/ltm.h" start --
//
//** $Id: ltm.h,v 2.6.1.1 2007/12/27 13:02:25 roberto Exp $
//** Tag methods
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//
//* WARNING: if you change the order of this enumeration,
//* grep "ORDER TM"
//
const (
	TM_INDEX    int32 = 0
	TM_NEWINDEX       = 1
	TM_GC             = 2
	TM_MODE           = 3
	TM_EQ             = 4
	TM_ADD            = 5
	TM_SUB            = 6
	TM_MUL            = 7
	TM_DIV            = 8
	TM_MOD            = 9
	TM_POW            = 10
	TM_UNM            = 11
	TM_LEN            = 12
	TM_LT             = 13
	TM_LE             = 14
	TM_CONCAT         = 15
	TM_CALL           = 16
	TM_N              = 17
)

// TMS - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21526
type TMS int32

// luaT_typenames - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21554
// last tag method with `fast' access
// number of elements in the enum
var luaT_typenames [][]byte

// ZIO - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21632
//-- #include "src.cpp/lzio.h" start --
//
//** $Id: lzio.h,v 1.21.1.1 2007/12/27 13:02:25 roberto Exp $
//** Buffered streams
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lmem.h" start --
//
//** $Id: lmem.h,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
//** Interface to Memory Manager
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/llimits.h" start --
//-- #include "src.cpp/lua.h" start --
type ZIO = Zio

// Mbuffer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21638
type Mbuffer struct {
	buffer   []byte
	n        uint
	buffsize uint
}

// Zio - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21670
// read next n bytes
// --------- Private Part ------------------
type Zio struct {
	n      uint
	p      []byte
	reader lua_Reader
	data   interface{}
	L      []lua_State
}

// stringtable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21706
// bytes still unread
// current position in buffer
// additional data
// Lua state (for reader)
// defined in ldo.c
// table of globals
// registry
// extra stack space to handle TM calls and some other extras
type stringtable struct {
	hash [][]GCObject
	nuse lu_int32
	size int32
}

// CallInfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21716
// number of elements
//
//** informations about a call
//
type CallInfo struct {
	base      StkId
	func_     StkId
	top       StkId
	savedpc   []Instruction
	nresults  int32
	tailcalls int32
}

// global_State - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21736
// base for this function
// function index in the stack
// top for this function
// expected number of results from this function
// number of tail calls lost under this entry
//
//** `global state', shared by all threads of this state
//
type global_State struct {
	strt         stringtable
	frealloc     lua_Alloc
	ud           interface{}
	currentwhite lu_byte
	gcstate      lu_byte
	sweepstrgc   int32
	rootgc       []GCObject
	sweepgc      [][]GCObject
	gray         []GCObject
	grayagain    []GCObject
	weak         []GCObject
	tmudata      []GCObject
	buff         Mbuffer
	GCthreshold  lu_mem
	totalbytes   lu_mem
	estimate     lu_mem
	gcdept       lu_mem
	gcpause      int32
	gcstepmul    int32
	panic_       lua_CFunction
	l_registry   TValue
	mainthread   []lua_State
	uvhead       UpVal
	mt           [9][]Table
	tmname       [17][]TString
}

// lua_State - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21768
// hash table for strings
// function to reallocate memory
// auxiliary data to `frealloc'
// state of garbage collector
// position of sweep in `strt'
// list of all collectable objects
// position of sweep in `rootgc'
// list of gray objects
// list of objects to be traversed atomically
// list of weak tables (to be cleared)
// last element of list of userdata to be GC
// temporary buffer for string concatentation
// number of bytes currently allocated
// an estimate of number of bytes actually in use
// how much GC is `behind schedule'
// size of pause between successive GCs
// GC `granularity'
// to be called in unprotected errors
// head of double-linked list of all open upvalues
// metatables for basic types
// array with tag-method names
//
//** `per thread' state
//
type lua_State struct {
	next          []GCObject
	tt            lu_byte
	marked        lu_byte
	status        lu_byte
	top           StkId
	base          StkId
	l_G           []global_State
	ci            []CallInfo
	savedpc       []Instruction
	stack_last    StkId
	stack         StkId
	end_ci        []CallInfo
	base_ci       []CallInfo
	stacksize     int32
	size_ci       int32
	nCcalls       uint16
	baseCcalls    uint16
	hookmask      lu_byte
	allowhook     lu_byte
	basehookcount int32
	hookcount     int32
	hook          lua_Hook
	l_gt          TValue
	env           TValue
	openupval     []GCObject
	gclist        []GCObject
	errorJmp      []lua_longjmp
	errfunc       noarch.PtrdiffT
}

type GCObject struct{ memory unsafe.Pointer }

func (unionVar *GCObject) copy() GCObject {
	var buffer [176]byte
	for i := range // GCObject - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21804
	// first free slot in the stack
	// base of current function
	// call info for current function
	// `savedpc' of current function
	// last free slot in the stack
	// stack base
	// points after end of ci array
	// array of CallInfo's
	// size of array `base_ci'
	// number of nested C calls
	// nested C calls when resuming coroutine
	// table of globals
	// temporary place for environments
	// list of open upvalues in this stack
	// current error recover point
	// current error handling function (stack index)
	//
	//** Union of all collectable objects
	//
	buffer {
		buffer[i] = (*((*[176]byte)(unionVar.memory)))[i]
	}
	var newUnion GCObject
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *GCObject) gch() *GCheader {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*GCheader)(unionVar.memory)
}
func (unionVar *GCObject) ts() *TString {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*TString)(unionVar.memory)
}
func (unionVar *GCObject) u() *Udata {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*Udata)(unionVar.memory)
}
func (unionVar *GCObject) cl() *Closure {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*Closure)(unionVar.memory)
}
func (unionVar *GCObject) h() *Table {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*Table)(unionVar.memory)
}
func (unionVar *GCObject) p() *Proto {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*Proto)(unionVar.memory)
}
func (unionVar *GCObject) uv() *UpVal {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*UpVal)(unionVar.memory)
}
func (unionVar *GCObject) th() *lua_State {
	if unionVar.memory == nil {
		var buffer [176]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*lua_State)(unionVar.memory)
}

// Pfunc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21900
// thread
// macros to convert a GCObject into a specific value
// macro to convert any Lua object into a GCObject
//-- #include "src.cpp/ldo.h" start --
//
//** $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
//** Stack and Call structure of Lua
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lzio.h" start --
// results from luaD_precall
// type of protected functions, to be ran by `runprotected'
type Pfunc func([]lua_State, interface{})

// lua_ident - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22227
//-- #include "src.cpp/lfunc.h" start --
//
//** $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
//** Auxiliary functions to manipulate prototypes and closures
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lgc.h" start --
//
//** $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
//** Garbage Collector
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//
//** Possible states of the Garbage Collector
//
//
//** some userful bit tricks
//
//
//** Layout for bit use in `marked' field:
//** bit 0 - object is white (type 0)
//** bit 1 - object is white (type 1)
//** bit 2 - object is black
//** bit 3 - for userdata: has been finalized
//** bit 3 - for tables: has weak keys
//** bit 4 - for tables: has weak values
//** bit 5 - object is fixed (should not be collected)
//** bit 6 - object is "super" fixed (only the main thread)
//
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//
//** $Id: lstring.h,v 1.43.1.1 2007/12/27 13:02:25 roberto Exp $
//** String table (keep all strings handled by Lua)
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/ltable.h" start --
//
//** $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
//** Lua tables (hash)
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/ltm.h" start --
//-- #include "src.cpp/lundump.h" start --
//
//** $Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
//** load precompiled Lua chunks
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lzio.h" start --
// load one chunk; from lundump.c
// make header; from lundump.c
// dump one chunk; from ldump.c
// for header of binary files -- this is Lua 5.1
// for header of binary files -- this is the official format
// size of header of binary files
//-- #include "src.cpp/lvm.h" start --
//
//** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
//** Lua virtual machine
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/ltm.h" start --
var lua_ident []byte = []byte("$Lua: Lua 5.1.5 Copyright (C) 1994-2012 Lua.org, PUC-Rio $\n$Authors: R. Ierusalimschy, L. H. de Figueiredo & W. Celes $\n$URL: www.lua.org $\n\x00")

// CallS - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22985
// pseudo-indices
// no enclosing function?
// use global table as environment
// stack overflow
//
//** basic stack manipulation
//
// `subtract' index (index is negative)
// explicit test for incompatible code
// function upvalue?
//
//** access functions (stack -> C)
//
// may call tag method
// may call tag method
// `luaV_tostring' may create a new string
// conversion failed?
// previous call may reallocate the stack
// `luaV_tostring' may create a new string
//
//** push functions (C -> stack)
//
// ensure that true is 1
//
//** get functions (Lua -> stack)
//
//
//** set functions (stack -> Lua)
//
// pop index and value
// pop value
//
//** `load' and `call' functions (run Lua code)
//
//
//** Execute a protected call.
//
// data to `f_call'
type CallS struct {
	func_    StkId
	nresults int32
}

// CCallS - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23024
// function to be called
//
//** Execute a protected C call.
//
// data to `f_Ccall'
type CCallS struct {
	func_ lua_CFunction
	ud    interface{}
}

// LoadF - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23806
// push function
// push only argument
//
//** Garbage-collection function
//
// GC values are expressed in Kbytes: #bytes/2^10
// end of cycle?
// signal it
// invalid option
//
//** miscellaneous functions
//
// to avoid warnings
// no more elements
// remove key
// push empty string
// else n == 1; nothing to do
//-- File: src.cpp/lapi.cpp end --
//-- #include "src.cpp/lapi.h" start --
//-- File: src.cpp/lauxlib.cpp start --
//
//** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
//** Auxiliary functions for building Lua libraries
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/errno.h" start --
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
// This file uses only the official API of Lua.
//** Any function declared here could be written as an application function.
//
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lauxlib.h" start --
// convert a stack index to positive
//
//** {======================================================
//** Error-report functions
//** =======================================================
//
// no stack frame?
// do not count `self'
// error is in the self argument itself?
// check function at level
// get info about it
// is there info?
// else, no information available...
// }======================================================
// get registry.name
// name already in use?
// leave previous value on top, but return 0
// create metatable
// registry.name = metatable
// value is a userdata?
// does it have a metatable?
// get correct metatable
// does it have the correct mt?
// remove both metatables
// else error
// to avoid warnings
// avoid extra test when d is not 0
// avoid extra test when d is not 0
// no metatable?
// remove metatable and metafield
// remove only metatable
// no metafield?
// check whether lib already exists
// get _LOADED[libname]
// not found?
// remove previous result
// try global variable (and create one if it does not exist)
// _LOADED[libname] = new table
// remove _LOADED table
// move library table to below upvalues
// copy upvalues to the top
// remove upvalues
//
//** {======================================================
//** getn-setn: size for arrays
//** =======================================================
//
// }======================================================
// push prefix
// push replacement in place of pattern
// continue after `p'
// push last suffix
// no such field?
// remove this nil
// new table for field
// set new table into field
// field has a non-table value?
// remove table and value
// return problematic part of the name
// remove previous table
//
//** {======================================================
//** Generic Buffer manipulation
//** =======================================================
//
// put nothing on stack
// number of levels to concat
// fit into buffer?
// put it there
// remove from stack
// put buffer before new value
// add new value into B stack
// }======================================================
// remove from stack
// `nil' has a unique fixed reference
// get first free element
// ref = t[FREELIST_REF]
// remove it from stack
// any free element?
// remove it from list
// (t[FREELIST_REF] = t[ref])
// no free elements
// create new reference
// t[ref] = t[FREELIST_REF]
// t[FREELIST_REF] = ref
//
//** {======================================================
//** Load functions
//** =======================================================
//
type LoadF struct {
	extraline int32
	f         *noarch.File
	buff      [8192]byte
}

// LoadS - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23877
// index of filename on the stack
// Unix exec. file?
// skip first line
// binary file?
// reopen in binary mode
// skip eventual `#!...'
// close file (even in case of errors)
// ignore results from `lua_load'
type LoadS struct {
	s    []byte
	size uint
}

// base_funcs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24387
// }======================================================
// to avoid warnings
//-- File: src.cpp/lauxlib.cpp end --
//-- #include "src.cpp/lauxlib.h" start --
//-- File: src.cpp/lbaselib.cpp start --
//
//** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
//** Basic library
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lauxlib.h" start --
//-- #include "src.cpp/lualib.h" start --
//
//** If your system does not support `stdout', you can just remove this function.
//** If you need, you can define your own `print' function, following this
//** model but changing `fputs' to put the strings at a proper place
//** (a console window or a log file, for instance).
//
// number of arguments
// function to be called
// value to print
// get result
// pop result
// standard conversion
// at least one valid digit?
// skip trailing spaces
// no invalid trailing characters?
// else not a number
// add extra information?
// no metatable
// returns either __metatable field (if present) or metatable
// is a C function?
// return the thread's global env.
// change environment of current thread
// create a 2nd argument if there isn't one
// return generator,
// state,
// and initial value
// next value
// return generator,
// state,
// and initial value
// OK?
// put before error message
// return nil plus error message
//
//** Reader for generic `load' function: `lua_load' uses the
//** stack for internal stuff, so the reader cannot change the
//** stack top. Instead, it keeps its resulting string in a
//** reserved slot inside the stack.
//
// to avoid warnings
// get function
// call it
// save string in a reserved stack slot
// to avoid warnings
// function, eventual name, plus one reserved slot
// empty range
// number of elements
// n <= 0 means arith. overflow
// push arg[i] (avoiding overflow problems)
// push arg[i + 1...e]
// return status + all results
// put error function under function to be called
// return status + all results
// is there a metafield?
// use its value
// create proxy
// no metatable
// create a new metatable `m' ...
// ... and mark `m' as a valid metatable
// weaktable[m] = true
// to check if weaktable[metatable(u)] == true
// remove value
// metatable is valid; get it
var base_funcs []luaL_Reg = []luaL_Reg{{[]byte("assert\x00"), luaB_assert}, {[]byte("collectgarbage\x00"), luaB_collectgarbage}, {[]byte("dofile\x00"), luaB_dofile}, {[]byte("error\x00"), luaB_error}, {[]byte("gcinfo\x00"), luaB_gcinfo}, {[]byte("getfenv\x00"), luaB_getfenv}, {[]byte("getmetatable\x00"), luaB_getmetatable}, {[]byte("loadfile\x00"), luaB_loadfile}, {[]byte("load\x00"), luaB_load}, {[]byte("loadstring\x00"), luaB_loadstring}, {[]byte("next\x00"), luaB_next}, {[]byte("pcall\x00"), luaB_pcall}, {[]byte("print\x00"), luaB_print}, {[]byte("rawequal\x00"), luaB_rawequal}, {[]byte("rawget\x00"), luaB_rawget}, {[]byte("rawset\x00"), luaB_rawset}, {[]byte("select\x00"), luaB_select}, {[]byte("setfenv\x00"), luaB_setfenv}, {[]byte("setmetatable\x00"), luaB_setmetatable}, {[]byte("tonumber\x00"), luaB_tonumber}, {[]byte("tostring\x00"), luaB_tostring}, {[]byte("type\x00"), luaB_type}, {[]byte("unpack\x00"), luaB_unpack}, {[]byte("xpcall\x00"), luaB_xpcall}, {nil, nil}}

// statnames - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24427
//
//** {======================================================
//** Coroutine library
//** =======================================================
//
var statnames [][]byte = [][]byte{[]byte("running\x00"), []byte("suspended\x00"), []byte("normal\x00"), []byte("dead\x00")}

// co_funcs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24545
// does it have frames?
// it is running
// initial state
// some error occured
// error flag
// move yielded values
// move error message
// error flag
// return false + error message
// return true + `resume' returns
// error object is a string?
// add extra info
// propagate error
// move function to top
// move function from L to NL
// main thread is not a coroutine
var co_funcs []luaL_Reg = []luaL_Reg{{[]byte("create\x00"), luaB_cocreate}, {[]byte("resume\x00"), luaB_coresume}, {[]byte("running\x00"), luaB_corunning}, {[]byte("status\x00"), luaB_costatus}, {[]byte("wrap\x00"), luaB_cowrap}, {[]byte("yield\x00"), luaB_yield}, {nil, nil}}

// RESERVED - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24645
// }======================================================
// set global _G
// open lib into global table
// set global _VERSION
// `ipairs' and `pairs' need auxiliary functions as upvalues
// `newproxy' needs a weaktable as upvalue
// new table `w'
// `w' will be its own metatable
// metatable(w).__mode = "kv"
// set global `newproxy'
//-- File: src.cpp/lbaselib.cpp end --
//-- File: src.cpp/lcode.cpp start --
//
//** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
//** Code generator for Lua
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lcode.h" start --
//
//** $Id: lcode.h,v 1.48.1.1 2007/12/27 13:02:25 roberto Exp $
//** Code generator for Lua
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/llex.h" start --
//
//** $Id: llex.h,v 1.58.1.1 2007/12/27 13:02:25 roberto Exp $
//** Lexical Analyzer
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lzio.h" start --
// maximum length of a reserved word
//
//* WARNING: if you change the order of this enumeration,
//* grep "ORDER RESERVED"
//
type RESERVED = int32

const (
	TK_AND      RESERVED = 257
	TK_BREAK             = 258
	TK_DO                = 259
	TK_ELSE              = 260
	TK_ELSEIF            = 261
	TK_END               = 262
	TK_FALSE             = 263
	TK_FOR               = 264
	TK_FUNCTION          = 265
	TK_IF                = 266
	TK_IN                = 267
	TK_LOCAL             = 268
	TK_NIL               = 269
	TK_NOT               = 270
	TK_OR                = 271
	TK_REPEAT            = 272
	TK_RETURN            = 273
	TK_THEN              = 274
	TK_TRUE              = 275
	TK_UNTIL             = 276
	TK_WHILE             = 277
	TK_CONCAT            = 278
	TK_DOTS              = 279
	TK_EQ                = 280
	TK_GE                = 281
	TK_LE                = 282
	TK_NE                = 283
	TK_NUMBER            = 284
	TK_NAME              = 285
	TK_STRING            = 286
	TK_EOS               = 287
)

// luaX_tokens - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24661
// terminal symbols denoted by reserved words
// other terminal symbols
// number of reserved words
// array with token `names'
var luaX_tokens [][]byte

type SemInfo struct{ memory unsafe.Pointer }

func (unionVar *SemInfo) copy() SemInfo {
	var buffer [8]byte
	for i := range // SemInfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24664
	buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion SemInfo
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *SemInfo) r() *lua_Number {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*lua_Number)(unionVar.memory)
}
func (unionVar *SemInfo) ts() *[]TString {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[]TString)(unionVar.memory)
}

// Token - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24670
// semantics information
type Token struct {
	token   int32
	seminfo SemInfo
}

// LexState - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24676
type LexState struct {
	current    int32
	linenumber int32
	lastline   int32
	t          Token
	lookahead  Token
	fs         []FuncState
	L          []lua_State
	z          []ZIO
	buff       []Mbuffer
	source     []TString
	decpoint   byte
}

// OpMode - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24736
// current character (charint)
// input line counter
// line of last token `consumed'
// current token
// look ahead token
// `FuncState' is private to the parser
// input stream
// buffer for tokens
// current source name
// locale decimal point
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lopcodes.h" start --
//
//** $Id: lopcodes.h,v 1.125.1.1 2007/12/27 13:02:25 roberto Exp $
//** Opcodes for Lua virtual machine
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/llimits.h" start --
//===========================================================================
//  We assume that instructions are unsigned numbers.
//  All instructions have an opcode in the first 6 bits.
//  Instructions can have the following fields:
//	`A' : 8 bits
//	`B' : 9 bits
//	`C' : 9 bits
//	`Bx' : 18 bits (`B' and `C' together)
//	`sBx' : signed Bx
//
//  A signed argument is represented in excess K; that is, the number
//  value is the unsigned value minus K. K is exactly the maximum value
//  for that argument (so that -max is represented by 0, and +max is
//  represented by 2*max), which is half the maximum for the corresponding
//  unsigned argument.
//===========================================================================
// basic instruction format
type OpMode = int32

const (
	iABC  OpMode = 0
	iABx         = 1
	iAsBx        = 2
)

// OP_MOVE - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24855
//
//** size and position of opcode arguments.
//
//
//** limits for opcode arguments.
//** we use (signed) int to manipulate most arguments,
//** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
//
// creates a mask with `n' 1 bits at position `p'
// creates a mask with `n' 0 bits at position `p'
//
//** the following macros help to manipulate instructions
//
//
//** Macros to operate RK indices
//
// this bit 1 means constant (0 means register)
// test whether value is a constant
// gets the index of the constant
// code a constant index as a RK value
//
//** invalid register that fits in 8 bits
//
//
//** R(x) - register
//** Kst(x) - constant (in constant table)
//** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
//
//
//** grep "ORDER OP" if you change these enums
//
const (
	OP_MOVE      int32 = 0
	OP_LOADK           = 1
	OP_LOADBOOL        = 2
	OP_LOADNIL         = 3
	OP_GETUPVAL        = 4
	OP_GETGLOBAL       = 5
	OP_GETTABLE        = 6
	OP_SETGLOBAL       = 7
	OP_SETUPVAL        = 8
	OP_SETTABLE        = 9
	OP_NEWTABLE        = 10
	OP_SELF            = 11
	OP_ADD             = 12
	OP_SUB             = 13
	OP_MUL             = 14
	OP_DIV             = 15
	OP_MOD             = 16
	OP_POW             = 17
	OP_UNM             = 18
	OP_NOT             = 19
	OP_LEN             = 20
	OP_CONCAT          = 21
	OP_JMP             = 22
	OP_EQ              = 23
	OP_LT              = 24
	OP_LE              = 25
	OP_TEST            = 26
	OP_TESTSET         = 27
	OP_CALL            = 28
	OP_TAILCALL        = 29
	OP_RETURN          = 30
	OP_FORLOOP         = 31
	OP_FORPREP         = 32
	OP_TFORLOOP        = 33
	OP_SETLIST         = 34
	OP_CLOSE           = 35
	OP_CLOSURE         = 36
	OP_VARARG          = 37
)

// OpCode - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24855
type OpCode int32

// OpArgMask - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24950
//----------------------------------------------------------------------
//name		args	description
//------------------------------------------------------------------------
//	A B	R(A) := R(B)
//	A Bx	R(A) := Kst(Bx)
//	A B C	R(A) := (Bool)B; if (C) pc++
//	A B	R(A) := ... := R(B) := nil
//	A B	R(A) := UpValue[B]
//	A Bx	R(A) := Gbl[Kst(Bx)]
//	A B C	R(A) := R(B)[RK(C)]
//	A Bx	Gbl[Kst(Bx)] := R(A)
//	A B	UpValue[B] := R(A)
//	A B C	R(A)[RK(B)] := RK(C)
//	A B C	R(A) := {} (size = B,C)
//	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]
//	A B C	R(A) := RK(B) + RK(C)
//	A B C	R(A) := RK(B) - RK(C)
//	A B C	R(A) := RK(B) * RK(C)
//	A B C	R(A) := RK(B) / RK(C)
//	A B C	R(A) := RK(B) % RK(C)
//	A B C	R(A) := RK(B) ^ RK(C)
//	A B	R(A) := -R(B)
//	A B	R(A) := not R(B)
//	A B	R(A) := length of R(B)
//	A B C	R(A) := R(B).. ... ..R(C)
//	sBx	pc+=sBx
//	A B C	if ((RK(B) == RK(C)) ~= A) then pc++
//	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++
//	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++
//	A C	if not (R(A) <=> C) then pc++
//	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++
//	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
//	A B C	return R(A)(R(A+1), ... ,R(A+B-1))
//	A B	return R(A), ... ,R(A+B-2)	(see note)
//	A sBx	R(A)+=R(A+2);
//			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
//	A sBx	R(A)-=R(A+2); pc+=sBx
//	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
//                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
//	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
//	A 	close all variables in the stack up to (>=) R(A)
//	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
//	A B	R(A), R(A+1), ..., R(A+B-1) = vararg
//===========================================================================
//  Notes:
//  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
//      and can be 0: OP_CALL then sets `top' to last_result+1, so
//      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.
//
//  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
//      set top (like in OP_CALL with C == 0).
//
//  (*) In OP_RETURN, if (B == 0) then return up to `top'
//
//  (*) In OP_SETLIST, if (B == 0) then B = `top';
//      if (C == 0) then next `instruction' is real C
//
//  (*) For comparisons, A specifies what condition the test should accept
//      (true or false).
//
//  (*) All `skips' (pc++) assume that next instruction is a jump
//===========================================================================
//
//** masks for instruction properties. The format is:
//** bits 0-1: op mode
//** bits 2-3: C arg mode
//** bits 4-5: B arg mode
//** bit 6: instruction set register A
//** bit 7: operator is a test
//
type OpArgMask = int32

const (
	OpArgN OpArgMask = 0
	OpArgU           = 1
	OpArgR           = 2
	OpArgK           = 3
)

// luaP_opmodes - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24957
// argument is not used
// argument is used
// argument is a register or a jump offset
// argument is a constant or register/constant
var luaP_opmodes []lu_byte = make([]lu_byte, 38)

// luaP_opnames - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24966
// opcode names
var luaP_opnames [][]byte = make([][]byte, 39)

// VVOID - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24994
// number of list items to accumulate before a SETLIST instruction
//-- #include "src.cpp/lparser.h" start --
//
//** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
//** Lua Parser
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/llimits.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lzio.h" start --
//
//** Expression descriptor
//
const (
	VVOID      int32 = 0
	VNIL             = 1
	VTRUE            = 2
	VFALSE           = 3
	VK               = 4
	VKNUM            = 5
	VLOCAL           = 6
	VUPVAL           = 7
	VGLOBAL          = 8
	VINDEXED         = 9
	VJMP             = 10
	VRELOCABLE       = 11
	VNONRELOC        = 12
	VCALL            = 13
	VVARARG          = 14
)

// expkind - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24994
type expkind int32

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25012
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25014
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25015
// no value
// info = index of constant in `k'
// nval = numerical value
// info = local register
// info = index of upvalue in `upvalues'
// info = index of table; aux = index of global name in `k'
// info = table register; aux = index register (or `k')
// info = instruction pc
// info = instruction pc
// info = result register
// info = instruction pc
// info = instruction pc
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_ struct {
	info int32
	aux  int32
}
type __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_ struct{ memory unsafe.Pointer }

func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_) copy() __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_ {
	var buffer [24]byte
	for i := range buffer {
		buffer[i] = (*((*[24]byte)(unionVar.memory)))[i]
	}
	var newUnion __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_) s() *__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_ {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25015_5_)(unionVar.memory)
}
func (unionVar *__union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_) nval() *lua_Number {
	if unionVar.memory == nil {
		var buffer [24]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*lua_Number)(unionVar.memory)
}

type expdesc struct {
	k int32
	u __union_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_25014_3_
	t int32
	f int32
}

// upvaldesc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25023
// patch list of `exit when true'
// patch list of `exit when false'
type upvaldesc struct {
	k    lu_byte
	info lu_byte
}

// FuncState - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25033
// defined in lparser.c
// state needed to generate code for a given function
type FuncState struct {
	f          []Proto
	h          []Table
	prev       []FuncState
	ls         []LexState
	L          []lua_State
	bl         []BlockCnt
	pc         int32
	lasttarget int32
	jpc        int32
	freereg    int32
	nk         int32
	np         int32
	nlocvars   int16
	nactvar    lu_byte
	upvalues   [60]upvaldesc
	actvar     [200]uint16
}

// BinOpr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25071
// current function header
// table to find (and reuse) elements in `k'
// enclosing function
// lexical state
// copy of the Lua state
// chain of current blocks
// next position to code (equivalent to `ncode')
// `pc' of last `jump target'
// list of pending jumps to `pc'
// first free register
// number of elements in `k'
// number of elements in `p'
// number of elements in `locvars'
// number of active local variables
// upvalues
// declared-variable stack
//
//** Marks the end of a patch list. It is an invalid value both as an absolute
//** address, and as a list link (would link an element to itself).
//
//
//** grep "ORDER OPR" if you change these enums
//
type BinOpr = int32

const (
	OPR_ADD      BinOpr = 0
	OPR_SUB             = 1
	OPR_MUL             = 2
	OPR_DIV             = 3
	OPR_MOD             = 4
	OPR_POW             = 5
	OPR_CONCAT          = 6
	OPR_NE              = 7
	OPR_EQ              = 8
	OPR_LT              = 9
	OPR_LE              = 10
	OPR_GT              = 11
	OPR_GE              = 12
	OPR_AND             = 13
	OPR_OR              = 14
	OPR_NOBINOPR        = 15
)

// BinOpr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25071
type BinOpr int32

// UnOpr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25081
type UnOpr = int32

const (
	OPR_MINUS   UnOpr = 0
	OPR_NOT           = 1
	OPR_LEN           = 2
	OPR_NOUNOPR       = 3
)

// UnOpr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25081
type UnOpr int32

// lua_longjmp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26630
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/llex.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lopcodes.h" start --
//-- #include "src.cpp/lparser.h" start --
//-- #include "src.cpp/ltable.h" start --
// no jumps to current position?
// function start?
// positions are already clean
// can connect both?
// else no optimization
// save list of jumps to here
// keep them on hold
//
//** returns current `pc' and marks it as a jump target (to avoid wrong
//** optimizations with consecutive instructions not in the same basic block).
//
// point to itself represents end of list
// end of list
// turn offset into absolute position
//
//** check whether list has any jump that do not produce a value
//** (or produce an inverted value)
//
// not found
// cannot patch other instructions
// no register to put value or register already has the value
// jump to default target
// find last element
// constant not found; create a new entry
// cannot use nil as key; instead use table itself to represent nil
// expression is an open function call?
// expression is an open function call?
// can relocate its simple result
// there is one value available (somewhere)
// those instructions may be jump targets
// nothing to do...
// put this jump in `t' list
// position after whole expression
// position of an eventual LOAD false
// position of an eventual LOAD true
// exp is already in a register
// reg. is not a local?
// put value on it
// default
// constant fit in RK operand?
// constant fit in argC?
// not a constant in the right range: put it in a register
// invalid var kind to store
// remove previous OP_NOT
// else go through
// pc of last jump
// always true; do nothing
// insert last jump in `f' list
// pc of last jump
// always false; do nothing
// insert last jump in `t' list
// cannot happen
// interchange true and false lists
// do not attempt to divide by 0
// do not attempt to divide by 0
// no constant folding for 'len'
// do not attempt to produce NaN
// exchange args to replace by `<' or `<='
// o1 <==> o2
// cannot operate on non-numeric constants
// cannot operate on constants
// operand must be on the `stack'
// list must be closed
// list must be closed
// operand must be on the 'stack'
// `pc' will change
// put new instruction in code array
// save corresponding line information
// free registers with list values
//-- File: src.cpp/lcode.cpp end --
//-- #include "src.cpp/lcode.h" start --
//-- File: src.cpp/ldebug.cpp start --
//
//** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
//** Debug Interface
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lapi.h" start --
//-- #include "src.cpp/lcode.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lopcodes.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/ltm.h" start --
//-- #include "src.cpp/lvm.h" start --
// function is not a Lua function?
// only active lua functions have current-line information
//
//** this function can be called asynchronous (e.g. during a signal)
//
// turn off hooks?
// Lua function?
// skip lost tail calls
// level found?
// level is of a lost tail call?
// no such level
// is a local variable in a Lua function
// is 'n' inside 'ci' stack?
// pop value
// not found
// handled by lua_getinfo
// invalid option
// skip the '>'
// pop function
// no tail call?
//
//** {======================================================
//** Symbolic Execution and code checker
//** =======================================================
//
// invalid instruction after an open call
// stores position of last instruction that changed `reg'
// points to final return (a `neutral' instruction)
// check that it does not jump to a setlist count; this
//               is tricky, because the count from a previous setlist may
//               have the same value of an invalid setlist; so, we must
//               go all the way back to the first of them (if any)
// if 'j' is even, previous value is not a setlist (even if
//               it looks like one)
// change register `a'
// check skip
// does it jump?
// check its jump
// set registers from `a' to `b'
// at least two operands
// at least one result (control variable)
// space for results
// affect all regs above its base
// go through
// not full check and jump is forward and do not skip `lastpc'?
// do the jump
// c = num. returns
// affect all registers above base
// b = num. returns
// tracing?
// do not 'execute' these pseudo-instructions
// }======================================================
// a Lua function?
// is a local?
// try symbolic execution
// global index
// move from `b' to `a'
// get name for `b'
// key index
// upvalue index
// key index
// no useful name found
// calling function is not Lua (or is unknown)
// calling function
// no useful name can be found
// only ANSI way to check whether a pointer points to an array
// first operand is wrong
// is Lua code?
// add file:line information
// is there an error handling function?
// move argument
// push function
// call it
//-- File: src.cpp/ldebug.cpp end --
//-- #include "src.cpp/ldebug.h" start --
//-- File: src.cpp/ldo.cpp start --
//
//** $Id: ldo.c,v 2.38.1.4 2012/01/18 02:27:10 roberto Exp $
//** Stack and Call structure of Lua
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/setjmp.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lopcodes.h" start --
//-- #include "src.cpp/lparser.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/ltm.h" start --
//-- #include "src.cpp/lundump.h" start --
//-- #include "src.cpp/lvm.h" start --
//-- #include "src.cpp/lzio.h" start --
//
//** {======================================================
//** Error-recovery functions
//** =======================================================
//
// chain list of long jump buffers
// Warning (*ast.FieldDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26632 :Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
type lua_longjmp struct {
	previous []lua_longjmp
	b        jmp_buf
	status   int32
}

// SParser - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27071
// error code
// error message on current top
// there was an overflow?
// can `undo' overflow?
// close eventual pending closures
// chain new error handler
// restore old error handler
// }======================================================
// double size is enough?
// overflow while handling overflow?
// tail call; no debug information about it
// ensure minimum stack size
// cannot call hooks inside a hook
// compat. with old-style vararg?
// number of extra arguments
// create `arg' table
// put extra arguments into `arg' table
// store counter in field `n'
// move fixed parameters to final position
// first fixed argument
// final position of first argument
// add `arg' parameter
// Open a hole inside the stack at `func'
// previous call may change stack
// tag method is the new function to be called
// `func' is not a function?
// check the `function' tag method
// Lua function? prepare its call
// no varargs?
// vararg function
// previous call may change the stack
// now `enter' new function
// starting point
// hooks assume 'pc' is already incremented
// correct 'pc'
// if is a C function, call it
// ensure minimum stack size
// now `enter' new function
// do the actual call
// yielding?
// next call may change stack
// Lua function?
// tail calls
// res == final position of 1st result
// restore base
// restore savedpc
// move results to correct place
// 0 iff wanted == LUA_MULTRET
//
//** Call a function (C or Lua). The function to be called is at *func.
//** The arguments are on the stack, right after the function.
//** When returns, all the results are on the stack, starting at the original
//** function position.
//
// error while handing stack error
// is a Lua function?
// call it
// start coroutine?
// resuming from previous yield
// `common' yield?
// finish interrupted execution of `OP_CALL'
// complete it...
// and correct top if not multiple results
// yielded inside a hook: just continue its execution
// error?
// mark thread as `dead'
// protect stack slots below
// an error occurred?
// close eventual pending closures
//
//** Execute a protected parser.
//
// data to `f_parser'
type SParser struct {
	z    []ZIO
	buff Mbuffer
	name []byte
}

// DumpState - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27127
// buffer to be used by the scanner
// initialize eventual upvalues
//-- File: src.cpp/ldo.cpp end --
//-- #include "src.cpp/ldo.h" start --
//-- File: src.cpp/ldump.cpp start --
//
//** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
//** save precompiled Lua chunks
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lundump.h" start --
type DumpState struct {
	L      []lua_State
	writer lua_Writer
	data   interface{}
	strip  int32
	status int32
}

// lualibs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28184
// include trailing '\0'
// cannot happen
//
//** dump Lua function as precompiled chunk
//
//-- File: src.cpp/ldump.cpp end --
//-- File: src.cpp/lfunc.cpp start --
//
//** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
//** Auxiliary functions to manipulate prototypes and closures
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
// found a corresponding upvalue?
// is it dead?
// ressurect it
// not found: create a new one
// current value lives in the stack
// chain it in the proper position
// double link it in `uvhead' list
// remove from `uvhead' list
// is it open?
// remove from open list
// free upvalue
// remove from `open' list
// free upvalue
// now current value lives here
// link upvalue into `gcroot' list
//
//** Look for n-th local variable at line `line' in function `func'.
//** Returns NULL if not found.
//
// is variable active?
// not found
//-- File: src.cpp/lfunc.cpp end --
//-- #include "src.cpp/lfunc.h" start --
//-- File: src.cpp/lgc.cpp start --
//
//** $Id: lgc.c,v 2.38.1.2 2011/03/18 18:05:38 roberto Exp $
//** Garbage Collector
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/ltm.h" start --
// dead key; remove it
// udata are never gray
// closed?
// open upvalues are never black
// may be marked, if left from previous GC
// move `dead' udata that need finalization to list `tmudata'
// don't bother with them
// don't need finalization
// must call its gc method
// link `curr' at the end of `tmudata' list
// list is empty?
// creates a circular list
// is there a weak mode?
// is really weak?
// clear bits
// must be cleared after GC, ...
// ... so put in the appropriate list
// remove empty entries
//
//** All marks are conditional because a GC may happen while the
//** prototype is still being created
//
// mark literals
// mark upvalue names
// mark nested protos
// mark local-variable names
// mark its upvalues
// mark its upvalues
// number of `ci' in use
// part of stack in use
// handling overflow?
// do not touch the stacks
// still big enough...
// still big enough...
//
//** traverse one gray object, turning it to black.
//** Returns `quantity' traversed.
//
// table is weak?
// keep it gray
//
//** The next function tells whether a key or value can be cleared from
//** a weak table. Non-collectable objects are never removed from weak
//** tables. Strings behave as `values', so are never removed too. for
//** other objects: if really collected, cannot keep them; for userdata
//** being finalized, keep them in keys, but not in values
//
// strings are `values', so are never weak
//
//** clear collected entries from weaktables
//
// value was collected?
// remove value
// non-empty entry?
// remove value ...
// remove entry from table
// sweep open upvalues of each thread
// not dead?
// make it white (for next cycle)
// must erase `curr'
// is the first element of the list?
// adjust first
// check size of string hash
// table is too big
// check size of buffer
// buffer too big?
// get first element
// remove udata from `tmudata'
// last element?
// return it to `root' list
// stop debug hooks during GC tag method
// avoid GC steps
// restore hooks
// restore threshold
//
//** Call all GC tag methods
//
// mask to collect all elements
// free all string lists
// mark root set
// make global table be traversed before main stack
// total size of userdata to be finalized
// remark occasional upvalues of (maybe) dead threads
// traverse objects cautch by write barrier and by 'remarkupvals'
// remark weak tables
// mark running thread
// mark basic metatables (again)
// remark gray again
// separate userdata to be finalized
// mark `preserved' userdata
// remark, to propagate `preserveness'
// remove collected objects from weak tables
// flip current white
// first estimate
//lua_checkmemory(L);
// start a new collection
// no more `gray' objects
// finish mark phase
// nothing more to sweep?
// end sweep-string phase
// nothing more to sweep?
// end sweep phase
// end collection
// no limit
// - lim/g->gcstepmul;
// reset sweep marks to sweep all elements (returning them to white)
// reset other collector lists
// finish any pending sweep phase
// must keep invariant?
// restore invariant
// don't mind
// mark as white just to avoid other barriers
// make table gray (again)
// link upvalue into `rootgc' list
// closed upvalues need barrier
// sweep phase: sweep it (turning it into white)
//-- File: src.cpp/lgc.cpp end --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/limits.h" start --
//-- File: src.cpp/linit.cpp start --
//
//** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
//** Initialization of libraries for lua.c
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lauxlib.h" start --
//-- #include "src.cpp/lualib.h" start --
var lualibs []luaL_Reg = []luaL_Reg{{[]byte("\x00"), luaopen_base}, {[]byte("string\x00"), luaopen_string}, {nil, nil}}

// luaX_tokens - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28236
//-- File: src.cpp/linit.cpp end --
//-- File: src.cpp/llex.cpp start --
//
//** $Id: llex.c,v 2.20.1.2 2009/11/23 14:58:22 roberto Exp $
//** Lexical Analyzer
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/locale.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/llex.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lparser.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/lzio.h" start --
// ORDER RESERVED
var luaX_tokens [][]byte = [][]byte{[]byte("and\x00"), []byte("break\x00"), []byte("do\x00"), []byte("else\x00"), []byte("elseif\x00"), []byte("end\x00"), []byte("false\x00"), []byte("for\x00"), []byte("function\x00"), []byte("if\x00"), []byte("in\x00"), []byte("local\x00"), []byte("nil\x00"), []byte("not\x00"), []byte("or\x00"), []byte("repeat\x00"), []byte("return\x00"), []byte("then\x00"), []byte("true\x00"), []byte("until\x00"), []byte("while\x00"), []byte("..\x00"), []byte("...\x00"), []byte("==\x00"), []byte(">=\x00"), []byte("<=\x00"), []byte("~=\x00"), []byte("<number>\x00"), []byte("<name>\x00"), []byte("<string>\x00"), []byte("<eof>\x00"), nil}

// luaO_nilobject_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28784
// reserved words are never collected
// reserved word
// entry for `str'
// make sure `str' will not be collected
// skip `\n' or `\r'
// skip `\n\r' or `\r\n'
// no look-ahead token
// initialize buffer
// read first char
//
//** =======================================================
//** LEXICAL ANALYZER
//** =======================================================
//
// format error: try to update decimal point separator
// try updated decimal separator
// format error with correct decimal point: no more options
// undo change (for error message)
// LUA_NUMBER
// `E'?
// optional exponent sign
// follow locale for decimal point
// format error?
// try to update decimal point separator
// avoid warnings when `cont' is not used
// skip 2nd `['
// string starts with a newline?
// skip it
// to avoid warnings
// skip 2nd `['
// skip 2nd `]'
// avoid wasting space
// to avoid warnings
// to avoid warnings
// do not save the `\'
// go through
// will raise an error next loop
// handles \\, \", \', and \?
// \xxx
// skip delimiter
// else is a comment
// `skip_sep' may dirty the buffer
// long comment
// else short comment
// ...
// ..
// identifier or reserved word
// reserved word?
// single-char tokens (+ - / ...)
// is there a look-ahead token?
// use this one
// and discharge it
// read next token
//-- File: src.cpp/llex.cpp end --
//-- #include "src.cpp/llex.h" start --
//-- #include "src.cpp/llimits.h" start --
//-- File: src.cpp/lmem.cpp start --
//
//** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
//** Interface to Memory Manager
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//
//** About the realloc function:
//** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
//** (`osize' is the old size, `nsize' is the new size)
//**
//** Lua ensures that (ptr == NULL) iff (osize == 0).
//**
//** * frealloc(ud, NULL, 0, x) creates a new block of size `x'
//**
//** * frealloc(ud, p, x, 0) frees the block `p'
//** (in this specific case, frealloc must return NULL).
//** particularly, frealloc(ud, NULL, 0, 0) does nothing
//** (which is equivalent to free(NULL) in ANSI C)
//**
//** frealloc returns NULL if it cannot create or reallocate the area
//** (any reallocation to an equal or smaller size cannot fail!)
//
// cannot double it?
// cannot grow even a little?
// still have at least one free place
// minimum size
// update only when everything else is OK
// to avoid warnings
//
//** generic allocation routine.
//
//-- File: src.cpp/lmem.cpp end --
//-- #include "src.cpp/lmem.h" start --
//-- File: src.cpp/lobject.cpp start --
//
//** $Id: lobject.c,v 2.22.1.1 2007/12/27 13:02:25 roberto Exp $
//** Some generic functions over Lua objects
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/lvm.h" start --
var luaO_nilobject_ TValue = TValue{Value{nil}, 0}

// luaP_opnames - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28992
//
//** converts an integer to a "floating point byte", represented as
//** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
//** eeeee != 0 and (xxx) otherwise.
//
// expoent
// converts back
// boolean true must be 1 !!
// conversion failed
// maybe an hexadecimal constant?
// most common case
// invalid trailing characters?
// this function handles only `%d', `%c', %f, %p, and `%s' formats
// should be enough space for a `%p'
// remove first char
// ensures null termination
// out = "source", or "...source"
// skip the `@'
// get last part of file name
// out = [string "string"]
// stop at first newline
// must truncate?
//-- File: src.cpp/lobject.cpp end --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/locale.h" start --
//-- File: src.cpp/lopcodes.cpp start --
//
//** $Id: lopcodes.c,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/lopcodes.h" start --
// ORDER OP
var luaP_opnames [][]byte = [][]byte{[]byte("MOVE\x00"), []byte("LOADK\x00"), []byte("LOADBOOL\x00"), []byte("LOADNIL\x00"), []byte("GETUPVAL\x00"), []byte("GETGLOBAL\x00"), []byte("GETTABLE\x00"), []byte("SETGLOBAL\x00"), []byte("SETUPVAL\x00"), []byte("SETTABLE\x00"), []byte("NEWTABLE\x00"), []byte("SELF\x00"), []byte("ADD\x00"), []byte("SUB\x00"), []byte("MUL\x00"), []byte("DIV\x00"), []byte("MOD\x00"), []byte("POW\x00"), []byte("UNM\x00"), []byte("NOT\x00"), []byte("LEN\x00"), []byte("CONCAT\x00"), []byte("JMP\x00"), []byte("EQ\x00"), []byte("LT\x00"), []byte("LE\x00"), []byte("TEST\x00"), []byte("TESTSET\x00"), []byte("CALL\x00"), []byte("TAILCALL\x00"), []byte("RETURN\x00"), []byte("FORLOOP\x00"), []byte("FORPREP\x00"), []byte("TFORLOOP\x00"), []byte("SETLIST\x00"), []byte("CLOSE\x00"), []byte("CLOSURE\x00"), []byte("VARARG\x00"), nil}

// luaP_opmodes - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29037
var luaP_opmodes []lu_byte = []lu_byte{lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABx)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABx)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABx)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgR << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iAsBx)))), lu_byte((1<<uint64(7) | 0<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((1<<uint64(7) | 0<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((1<<uint64(7) | 0<<uint64(6) | int32((OpArgK << uint64(4))) | int32((OpArgK << uint64(2))) | int32((iABC)))), lu_byte((1<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((1<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iAsBx)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgR << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iAsBx)))), lu_byte((1<<uint64(7) | 0<<uint64(6) | int32((OpArgN << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgU << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 0<<uint64(6) | int32((OpArgN << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABx)))), lu_byte((0<<uint64(7) | 1<<uint64(6) | int32((OpArgU << uint64(4))) | int32((OpArgN << uint64(2))) | int32((iABC))))}

// BlockCnt - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29122
//       T  A    B       C     mode		   opcode
// OP_MOVE
// OP_LOADK
// OP_LOADBOOL
// OP_LOADNIL
// OP_GETUPVAL
// OP_GETGLOBAL
// OP_GETTABLE
// OP_SETGLOBAL
// OP_SETUPVAL
// OP_SETTABLE
// OP_NEWTABLE
// OP_SELF
// OP_ADD
// OP_SUB
// OP_MUL
// OP_DIV
// OP_MOD
// OP_POW
// OP_UNM
// OP_NOT
// OP_LEN
// OP_CONCAT
// OP_JMP
// OP_EQ
// OP_LT
// OP_LE
// OP_TEST
// OP_TESTSET
// OP_CALL
// OP_TAILCALL
// OP_RETURN
// OP_FORLOOP
// OP_FORPREP
// OP_TFORLOOP
// OP_SETLIST
// OP_CLOSE
// OP_CLOSURE
// OP_VARARG
//-- File: src.cpp/lopcodes.cpp end --
//-- #include "src.cpp/lopcodes.h" start --
//-- File: src.cpp/lparser.cpp start --
//
//** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
//** Lua Parser
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lcode.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/llex.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lopcodes.h" start --
//-- #include "src.cpp/lparser.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//
//** nodes for block list (list of active blocks)
//
type BlockCnt struct {
	previous    []BlockCnt
	breaklist   int32
	nactvar     lu_byte
	upval       lu_byte
	isbreakable lu_byte
}

// ConsControl - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29516
// chain
// list of jumps out of this loop
// # active locals outside the breakable structure
// true if some variable in the block is an upvalue
// true if `block' is a loop
//
//** prototypes for recursive non-terminal functions
//
// new one
// not found
// no more levels?
// default is global variable
// look up at current level
// local will be used as an upval
// not found at current level; try upper one
// else was LOCAL or UPVAL
// upvalue in this level
// info points to global name
// includes call itself
// last exp. provides the difference
// close last expression
// a block either controls scope or breaks (never both)
// free registers
// linked list of funcstates
// registers 0/1 are always valid
// anchor table of constants and prototype (to avoid being collected)
// final return
// last token read was anchored in defunct function; must reanchor it
// remove table and prototype from the stack
// main func. is always vararg
// read first token
//============================================================
// GRAMMAR RULES
//============================================================
// field -> ['.' | ':'] NAME
// skip the dot or colon
// index -> '[' expr ']'
// skip the '['
//
//** {======================================================================
//** Rules for Constructors
//** =======================================================================
//
type ConsControl struct {
	v       expdesc
	t       []expdesc
	nh      int32
	na      int32
	tostore int32
}

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_29892_14_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29892
// last list item read
// table descriptor
// total number of `record' elements
// total number of array elements
// number of array elements pending to be stored
// recfield -> (NAME | `['exp1`]') = exp1
// ls->t.token == '['
// free registers
// there is no list item
// flush
// no more items pending
// do not count last expression (unknown number of elements)
// constructor -> ??
// no value (yet)
// fix it at stack top (for gc)
// may be listfields or recfields
// expression?
// constructor_item -> recfield
// constructor_part -> listfield
// set initial array size
// set initial table size
// }======================================================================
// parlist -> [ param { `,' param } ]
// is `parlist' not empty?
// param -> NAME
// param -> `...'
// use `arg' as default name
// reserve register for parameters
// body ->  `(' parlist `)' chunk END
// explist1 -> expr { `,' expr }
// at least one expression
// funcargs -> `(' [ explist1 ] `)'
// arg list is empty?
// funcargs -> constructor
// funcargs -> STRING
// must use `seminfo' before `next'
// base register for call
// open call
// close last argument
// call remove function and arguments and leaves
//                            (unless changed) one result
//
//** {======================================================================
//** Expression parsing
//** =======================================================================
//
// prefixexp -> NAME | '(' expr ')'
// primaryexp ->
//        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs }
// field
// `[' exp1 `]'
// `:' NAME funcargs
// funcargs
// simpleexp -> NUMBER | STRING | NIL | true | false | ... |
//                  constructor | FUNCTION body | primaryexp
// vararg
// don't need 'arg'
// constructor
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_29892_14_ struct {
	left  lu_byte
	right lu_byte
}

// priority - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29892
var priority []__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_29892_14_ = []__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_29892_14_{{lu_byte(6), lu_byte(6)}, {lu_byte(6), lu_byte(6)}, {lu_byte(7), lu_byte(7)}, {lu_byte(7), lu_byte(7)}, {lu_byte(7), lu_byte(7)}, {lu_byte(10), lu_byte(9)}, {lu_byte(5), lu_byte(4)}, {lu_byte(3), lu_byte(3)}, {lu_byte(3), lu_byte(3)}, {lu_byte(3), lu_byte(3)}, {lu_byte(3), lu_byte(3)}, {lu_byte(3), lu_byte(3)}, {lu_byte(3), lu_byte(3)}, {lu_byte(2), lu_byte(2)}, {lu_byte(1), lu_byte(1)}}

// LHS_assign - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29978
// left priority for each binary operator
// right priority
// ORDER OPR
// `+' `-' `/' `%'
// power and concat (right associative)
// equality and inequality
// order
// logical (and/or)
//
//** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
//** where `binop' is any binary operator with a priority higher than `limit'
//
// expand while operators have priorities higher than `limit'
// read sub-expression with higher priority
// return first untreated operator
// }====================================================================
//
//** {======================================================================
//** Rules for Statements
//** =======================================================================
//
// block -> chunk
//
//** structure to chain all variables in the left-hand side of an
//** assignment
//
type LHS_assign struct {
	prev []LHS_assign
	v    expdesc
}

// LG - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30460
// variable (global, local, upvalue, or indexed)
//
//** check whether, in an assignment to a local variable, the local variable
//** is needed in a previous assignment (to a table). If so, save original
//** local value in a safe place and use this safe copy in the previous
//** assignment.
//
// eventual position to save local variable
// conflict?
// previous assignment will use safe copy
// conflict?
// previous assignment will use safe copy
// make copy
// assignment -> `,' primaryexp assignment
// assignment -> `=' explist1
// remove extra values
// close last expression
// avoid default
// default assignment
// cond -> exp
// read condition
// `falses' are all equal here
// whilestat -> WHILE cond DO block END
// skip WHILE
// false conditions finish the loop
// repeatstat -> REPEAT block UNTIL cond
// loop block
// scope block
// skip REPEAT
// read condition (inside scope block)
// no upvalues?
// finish scope
// close the loop
// complete semantics when there are upvalues
// if condition then break
// else...
// finish scope...
// and repeat
// finish loop
// forbody -> DO block
// control variables
// scope for declared variables
// end of scope for declared variables
// pretend that `OP_FOR' starts the loop
// fornum -> NAME = exp1,exp1[,exp1] forbody
// initial value
// limit
// optional step
// default step = 1
// forlist -> NAME {,NAME} IN explist1 forbody
// create control variables
// create declared variables
// extra space to call generator
// forstat -> FOR (fornum | forlist) END
// scope for loop and control variables
// skip `for'
// first variable name
// loop scope (`break' jumps to this point)
// test_then_block -> [IF | ELSEIF] cond THEN block
// skip IF or ELSEIF
// `then' part
// ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
// IF cond THEN block
// ELSEIF cond THEN block
// skip ELSE (after patch, for correct line info)
// `else' part
// debug information will only see the variable after this point!
// stat -> LOCAL NAME {`,' NAME} [`=' explist1]
// funcname -> NAME {field} [`:' NAME]
// funcstat -> FUNCTION funcname body
// skip FUNCTION
// definition `happens' in the first line
// stat -> func | assignment
// stat -> func
// call statement uses no results
// stat -> assignment
// stat -> RETURN explist
// registers with returned values
// skip RETURN
// return no values
// optional return values
// tail call?
// return all values
// only one single value?
// values must go to the `stack'
// return all `active' values
// may be needed for error messages
// stat -> ifstat
// stat -> whilestat
// stat -> DO block END
// skip DO
// stat -> forstat
// stat -> repeatstat
// stat -> funcstat
// stat -> localstat
// skip LOCAL
// local function?
// stat -> retstat
// must be last statement
// stat -> breakstat
// skip BREAK
// must be last statement
// to avoid warnings
// chunk -> { stat [`;'] }
// free registers
// }======================================================================
//-- File: src.cpp/lparser.cpp end --
//-- #include "src.cpp/lparser.h" start --
//-- File: src.cpp/lstate.cpp start --
//
//** $Id: lstate.c,v 2.36.1.2 2008/01/03 15:20:39 roberto Exp $
//** Global State
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/llex.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/ltm.h" start --
//
//** Main thread combines a thread state and the global state
//
type LG struct {
	l lua_State
	g global_State
}

// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_30933_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30928
// __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_30933_3_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30933
// initialize CallInfo array
// initialize stack array
// initialize first ci
// `function' entry for this `ci'
//
//** open parts that may cause memory-allocation errors
//
// init stack
// table of globals
// registry
// initial size of string table
// close all upvalues for this thread
// collect all objects
// init stack
// share table of globals
// close all upvalues for this thread
// mark it as unfinished state
// memory allocation error: free partial state
// call GC metamethods for all udata
// only the main thread can be closed
// close all upvalues for this thread
// separate udata that have GC metamethods
// no error function during GC metamethods
// repeat until no more errors
//-- File: src.cpp/lstate.cpp end --
//-- #include "src.cpp/lstate.h" start --
//-- File: src.cpp/lstring.cpp start --
//
//** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
//** String table (keeps all strings handled by Lua)
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
// cannot resize during GC traverse
// rehash
// for each node in the list
// save next
// new position
// chain it
// ending 0
// chain new entry
// too crowded
// seed
// if string is too long, don't hash all its chars
// compute hash
// string may be dead
// not found
// is not finalized
// chain it on udata list (after main thread)
//-- File: src.cpp/lstring.cpp end --
//-- #include "src.cpp/lstring.h" start --
//-- File: src.cpp/lstrlib.cpp start --
//
//** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
//** Standard library for string operations and pattern-matching
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/ctype.h" start --
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lauxlib.h" start --
//-- #include "src.cpp/lualib.h" start --
// macro to `unsign' a character
// relative string position: negative means back from end
// empty interval; return no values
// overflow?
// number of arguments
//
//** {======================================================
//** PATTERN MATCHING
//** =======================================================
//
// init of source string
// end (`\0') of source string
// total number of captures (finished or unfinished)
type __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_30933_3_ struct {
	init_ []byte
	len_  noarch.PtrdiffT
}
type MatchState struct {
	src_init []byte
	src_end  []byte
	L        []lua_State
	level    int32
	capture  [32]__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_30933_3_
}

// strlib - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31585
// look for a `]'
// skip escapes (e.g. `%]')
// skip the `^'
// matches any char
// string ends out of balance
// counts maximum expand for item
// keeps trying to match with the maximum repetitions
// else didn't match; reduce 1 repetition to try again
// try with one more repetition
// match failed?
// undo capture
// close capture
// match failed?
// undo capture
// using goto's to optimize tail recursion
// start capture
// position capture?
// end capture
// balanced string?
// else return match(ms, s, p+4);
// frontier?
// points to what is next
// else return match(ms, s, ep);
// capture results (%0-%9)?
// else return match(ms, s, p+2)
// case default
// end of pattern
// match succeeded
// is the `$' the last char in pattern?
// check end of string
// it is a pattern item
// points to what is next
// optional
// else return match(ms, s, ep+1);
// 0 or more repetitions
// 1 or more repetitions
// 0 or more repetitions (minimum)
// else return match(ms, s+1, ep);
// empty strings are everywhere
// avoids a negative `l1'
// to search for a `*s2' inside `s1'
// 1st char will be checked by `memchr'
// `s2' cannot be found after that
// 1st char is already checked
// correct `l1' and `s1' to try again
// not found
// ms->level == 0, too
// add whole match
// number of strings pushed
// explicit request?
// or no special characters?
// do a plain search
// start
// end
// not found
// empty match? go at least one position
// not found
// skip ESC
// add capture to accumulated result
// nil or false?
// keep original text
// add result to accumulator
// non empty match?
// skip it
// number of substitutions
// }======================================================
// maximum size of each formatted item (> len(format('%99.99f', -1e308)))
// valid flags in a format specification
//
//** maximum size of each format specification (such as '%-099.99d')
//** (+10 accounts for %99.99x plus margin of error)
//
// skip flags
// skip width
// (2 digits at most)
// skip precision
// (2 digits at most)
// %%
// format item
// to store the format (`%...')
// to store the formatted item
// skip the 'addsize' at the end
// no precision and string is too long to be formatted;
//               keep original string
// skip the `addsize' at the end
// also treat cases `pnLlh'
var strlib []luaL_Reg = []luaL_Reg{{[]byte("byte\x00"), str_byte}, {[]byte("char\x00"), str_char}, {[]byte("dump\x00"), str_dump}, {[]byte("find\x00"), str_find}, {[]byte("format\x00"), str_format}, {[]byte("gfind\x00"), gfind_nodef}, {[]byte("gmatch\x00"), gmatch}, {[]byte("gsub\x00"), str_gsub}, {[]byte("len\x00"), str_len}, {[]byte("lower\x00"), str_lower}, {[]byte("match\x00"), str_match}, {[]byte("rep\x00"), str_rep}, {[]byte("reverse\x00"), str_reverse}, {[]byte("sub\x00"), str_sub}, {[]byte("upper\x00"), str_upper}, {nil, nil}}

// dummynode_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31707
// create metatable for strings
// dummy string
// set string metatable
// pop dummy string
// string library...
// ...is the __index metamethod
// pop metatable
//
//** Open string library
//
//-- File: src.cpp/lstrlib.cpp end --
//-- File: src.cpp/ltable.cpp start --
//
//** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
//** Lua tables (hash)
//** See Copyright Notice in lua.h
//
//
//** Implementation of tables (aka arrays, objects, or hash tables).
//** Tables keep its elements in two parts: an array part and a hash part.
//** Non-negative integer keys are all candidates to be kept in the array
//** part. The actual size of the array is the largest `n' such that at
//** least half the slots between 0 and n are in use.
//** Hash uses a mix of chained scatter table with Brent's variation.
//** A main invariant of these tables is that, if an element is not
//** in its main position (i.e. the `original' position that its hash gives
//** to it), then the colliding element is in its own main position.
//** Hence even when the load factor reaches 100%, performance remains good.
//
//-- #include "src.cpp/math.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lgc.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/ltable.h" start --
//
//** max size of array part is 2^MAXBITS
//
//
//** for some types, it is better to avoid modulus by power of 2, as
//** they tend to have many 2 factors.
//
//
//** number of ints inside a lua_Number
//
var dummynode_ Node = Node{TValue{Value{nil}, 0}, TKey{__struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_{Value{nil}, 0, nil}}}

// luaT_typenames - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32247
// value
// key
//
//** hash for lua_Numbers
//
// avoid problems with -0
//
//** returns the `main' position of an element in a table (that is, the index
//** of its hash value)
//
//
//** returns the index for `key' if `key' is an appropriate key to live in
//** the array part of the table, -1 otherwise.
//
// `key' did not match some condition
//
//** returns the index of a `key' for table traversals. First goes all
//** elements in the array part, then elements in the hash part. The
//** beginning of a traversal is signalled by -1.
//
// first iteration
// is `key' inside array part?
// yes; that's the index (corrected to C)
// check whether `key' is somewhere in the chain
// key may be dead already, but it is ok to use it in `next'
// key index in hash table
// hash elements are numbered after array ones
// key not found
// to avoid warnings
// find original element
// try first array part
// a non-nil value?
// then hash part
// a non-nil value?
// no more elements
//
//** {=============================================================
//** Rehash
//** ==============================================================
//
// 2^i
// number of elements smaller than 2^i
// number of elements to go to array part
// optimal size for array part
// more than half elements present?
// optimal size (till now)
// all elements smaller than n will go to array part
// all elements already counted
// is `key' an appropriate array index?
// count as such
// 2^lg
// summation of `nums'
// count to traverse all array keys
// for each slice
// counter
// adjust upper limit
// no more elements to count
// count elements in range (2^(lg-1), 2^lg]
// total number of elements
// summation of `nums'
// no elements to hash part?
// use common `dummynode'
// all positions are free
// save old hash ...
// array part must grow?
// create new hash part with appropriate size
// array part must shrink?
// re-insert elements from vanishing slice
// shrink array
// re-insert elements from hash part
// free old array
// nums[i] = number of keys between 2^(i-1) and 2^i
// reset counts
// count keys in array part
// all those keys are integer keys
// count keys in hash part
// count extra key
// compute new size for array part
// resize the table to new computed sizes
//
//** }=============================================================
//
// temporary values (kept only if some malloc fails)
// could not find a free place
//
//** inserts a new key into a hash table; first, check whether key's main
//** position is free. If not, check whether colliding node is in its main
//** position or not: if it is not, move colliding node to an empty place and
//** put new key in its main position; otherwise (colliding node is in its main
//** position), new key goes to an empty position.
//
// get a free place
// cannot find a free place?
// grow table
// re-insert key into grown table
// is colliding node out of its main position?
// yes; move colliding node into free position
// find previous
// redo the chain with `n' in place of `mp'
// copy colliding node into free pos. (mp->next also goes)
// now `mp' is free
// colliding node is in its own main position
// new node will go into free position
// chain new position
//
//** search function for integers
//
// (1 <= key && key <= t->sizearray)
// check whether `key' is somewhere in the chain
// that's it
//
//** search function for strings
//
// check whether `key' is somewhere in the chain
// that's it
//
//** main search function
//
// index is int?
// use specialized version
// else go through
// check whether `key' is somewhere in the chain
// that's it
// i is zero or a present index
// find `i' and `j' such that i is present and j is not
// overflow?
// table was built with bad purposes: resort to linear search
// now do a binary search between them
//
//** Try to find a boundary in table `t'. A `boundary' is an integer index
//** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
//
// there is a boundary in the array part: (binary) search for it
// else must find a boundary in hash part
// hash part is empty?
// that is easy...
//-- File: src.cpp/ltable.cpp end --
//-- #include "src.cpp/ltable.h" start --
//-- File: src.cpp/ltm.cpp start --
//
//** $Id: ltm.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
//** Tag methods
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstate.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/ltable.h" start --
//-- #include "src.cpp/ltm.h" start --
var luaT_typenames [][]byte = [][]byte{[]byte("nil\x00"), []byte("boolean\x00"), []byte("userdata\x00"), []byte("number\x00"), []byte("string\x00"), []byte("table\x00"), []byte("function\x00"), []byte("userdata\x00"), []byte("thread\x00"), []byte("proto\x00"), []byte("upval\x00")}

// LoadState - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32329
// ORDER TM
// never collect these names
//
//** function to be used with macro "fasttm": optimized for absence of
//** tag methods
//
// no tag method?
// cache this fact
//-- File: src.cpp/ltm.cpp end --
//-- #include "src.cpp/ltm.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/luaconf.h" start --
//-- #include "src.cpp/lualib.h" start --
//-- File: src.cpp/lundump.cpp start --
//
//** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
//** load precompiled Lua chunks
//** See Copyright Notice in lua.h
//
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/lua.h" start --
//-- #include "src.cpp/ldebug.h" start --
//-- #include "src.cpp/ldo.h" start --
//-- #include "src.cpp/lfunc.h" start --
//-- #include "src.cpp/lmem.h" start --
//-- #include "src.cpp/lobject.h" start --
//-- #include "src.cpp/lstring.h" start --
//-- #include "src.cpp/lundump.h" start --
//-- #include "src.cpp/lzio.h" start --
type LoadState struct {
	L    []lua_State
	Z    []ZIO
	b    []Mbuffer
	name []byte
}

// lc_newclosuretable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1425
func lc_newclosuretable(L []lua_State, idx int32) {
	lua_createtable(L, 0, 0)
	lua_pushvalue(L, idx)
	lua_rawseti(L, -2, 0)
}

// lc_add - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1436
func lc_add(L []lua_State, idxa int32, idxb int32) {
	if lua_isnumber(L, idxa) != 0 && lua_isnumber(L, idxb) != 0 {
		lua_pushnumber(L, lua_tonumber(L, idxa)+lua_tonumber(L, idxb))
	} else {
		if luaL_getmetafield(L, idxa, []byte("__add\x00")) != 0 || luaL_getmetafield(L, idxb, []byte("__add\x00")) != 0 {
			lua_pushvalue(L, func() int32 {
				if idxa < 0 && idxa > -10000 {
					return idxa - 1
				}
				return idxa
			}())
			lua_pushvalue(L, func() int32 {
				if idxb < 0 && idxb > -10000 {
					return idxb - 2
				}
				return idxb
			}())
			lua_call(L, 2, 1)
		} else {
			luaL_error(L, []byte("attempt to perform arithmetic\x00"))
		}
	}
}

// lcf1___TS__ArrayPush - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1453
func lcf1___TS__ArrayPush(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_pushvalue(L, 2)
	var lc2 float64 = float64(lua_objlen(L, 1))
	lua_pushnumber(L, lua_Number((lc2)))
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_insert(L, -2)
	lua_settable(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1467, []byte("int lcf1___TS__ArrayPush(lua_State *)\x00"))
		}
	}()
	var lc3 float64 = float64(lua_objlen(L, 1))
	lua_pushnumber(L, lua_Number((lc3)))
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1473, []byte("int lcf1___TS__ArrayPush(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_ERROR - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1478
func lcf1_ERROR(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lua_getfield(L, -10001, []byte("error\x00"))
	lua_pushlstring(L, []byte("TheLanguage PANIC\x00"), uint(18/1-1))
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1486, []byte("int lcf1_ERROR(lua_State *)\x00"))
		}
	}()
	return 0
}

// lc_setupvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1490
func lc_setupvalue(L []lua_State, tidx int32, level int32, varid int32) {
	if level == 0 {
		lua_rawseti(L, tidx, varid)
	} else {
		lua_pushvalue(L, tidx)
		for func() int32 {
			level--
			return level
		}() >= 0 {
			lua_rawgeti(L, tidx, 0)
			lua_remove(L, -2)
			tidx = -1
		}
		lua_insert(L, -2)
		lua_rawseti(L, -2, varid)
		lua_settop(L, -(1)-1)
	}
}

// lc_getupvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1508
func lc_getupvalue(L []lua_State, tidx int32, level int32, varid int32) {
	if level == 0 {
		lua_rawgeti(L, tidx, varid)
	} else {
		lua_pushvalue(L, tidx)
		for func() int32 {
			level--
			return level
		}() >= 0 {
			lua_rawgeti(L, tidx, 0)
			lua_remove(L, -2)
			tidx = -1
		}
		lua_rawgeti(L, -1, varid)
		lua_remove(L, -2)
	}
}

// lcf1_ASSERT - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1525
func lcf1_ASSERT(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc5 int32 = 1
	)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, 1))))
	var lc6 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc6 != 0 {
		var lc7 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 96)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc7
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1541, []byte("int lcf1_ASSERT(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc5)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1544, []byte("int lcf1_ASSERT(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_symbol_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1550
func lcf1_symbol_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lua_pushnumber(L, 0)
	var lc8 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc8)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1562, []byte("int lcf1_symbol_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_un_symbol - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1567
func lcf1_un_symbol(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1575, []byte("int lcf1_un_symbol(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_new_construction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1580
func lcf1_new_construction(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 94)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1593, []byte("int lcf1_new_construction(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_construction_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1598
func lcf1_construction_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 94)
	var lc9 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc9)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1610, []byte("int lcf1_construction_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_construction_head - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1615
func lcf1_construction_head(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1623, []byte("int lcf1_construction_head(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_construction_tail - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1628
func lcf1_construction_tail(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1636, []byte("int lcf1_construction_tail(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_null_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1641
func lcf1_null_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 93)
	var lc10 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc10)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1653, []byte("int lcf1_null_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_new_data - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1658
func lcf1_new_data(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 92)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1671, []byte("int lcf1_new_data(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_data_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1676
func lcf1_data_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 92)
	var lc11 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc11)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1688, []byte("int lcf1_data_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_data_name - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1693
func lcf1_data_name(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1701, []byte("int lcf1_data_name(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_data_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1706
func lcf1_data_list(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1714, []byte("int lcf1_data_list(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_new_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1719
func lcf1_new_error(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 91)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1732, []byte("int lcf1_new_error(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_error_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1737
func lcf1_error_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 91)
	var lc12 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc12)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1749, []byte("int lcf1_error_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_error_name - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1754
func lcf1_error_name(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1762, []byte("int lcf1_error_name(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_error_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1767
func lcf1_error_list(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1775, []byte("int lcf1_error_list(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_lang_set_do - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1780
func lcf1_lang_set_do(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	const (
		lc13 int32 = 2
	)
	var lc14 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc14)
	var lc15 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc15 != 0 {
		return 0
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1794, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc13)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1797, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 90)
	lua_pushnumber(L, 1)
	lua_insert(L, -2)
	lua_settable(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1804, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	lua_pushnumber(L, 2)
	lua_insert(L, -2)
	lua_settable(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1811, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 0)
	lua_pushnumber(L, 3)
	lua_insert(L, -2)
	lua_settable(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1818, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 0)
	lua_pushnumber(L, 4)
	lua_insert(L, -2)
	lua_settable(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1825, []byte("int lcf1_lang_set_do(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_just_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1831
func lcf1_just_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 90)
	var lc16 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc16)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1843, []byte("int lcf1_just_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_un_just - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1848
func lcf1_un_just(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1856, []byte("int lcf1_un_just(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_evaluate - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1861
func lcf1_evaluate(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 89)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1874, []byte("int lcf1_evaluate(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_evaluate_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1879
func lcf1_delay_evaluate_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 89)
	var lc17 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc17)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1891, []byte("int lcf1_delay_evaluate_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_evaluate_env - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1896
func lcf1_delay_evaluate_env(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1904, []byte("int lcf1_delay_evaluate_env(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_evaluate_x - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1909
func lcf1_delay_evaluate_x(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1917, []byte("int lcf1_delay_evaluate_x(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_builtin_form_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1922
func lcf1_builtin_form_apply(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lua_createtable(L, 4, 0)
	lc_getupvalue(L, -10002-1, 0, 87)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	lua_pushvalue(L, 3)
	lua_rawseti(L, -2, 4)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1937, []byte("int lcf1_builtin_form_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_form_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1942
func lcf1_delay_builtin_form_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 87)
	var lc18 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc18)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1954, []byte("int lcf1_delay_builtin_form_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_form_env - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1959
func lcf1_delay_builtin_form_env(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1967, []byte("int lcf1_delay_builtin_form_env(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_form_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1972
func lcf1_delay_builtin_form_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1980, []byte("int lcf1_delay_builtin_form_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_form_xs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1985
func lcf1_delay_builtin_form_xs(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 4)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 1993, []byte("int lcf1_delay_builtin_form_xs(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_builtin_func_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:1998
func lcf1_builtin_func_apply(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 88)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2011, []byte("int lcf1_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_func_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2016
func lcf1_delay_builtin_func_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 88)
	var lc19 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc19)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2028, []byte("int lcf1_delay_builtin_func_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_func_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2033
func lcf1_delay_builtin_func_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2041, []byte("int lcf1_delay_builtin_func_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_builtin_func_xs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2046
func lcf1_delay_builtin_func_xs(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2054, []byte("int lcf1_delay_builtin_func_xs(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2059
func lcf1_apply(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, -10002-1, 0, 86)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2072, []byte("int lcf1_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_apply_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2077
func lcf1_delay_apply_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 1)
	lua_gettable(L, 1)
	lc_getupvalue(L, -10002-1, 0, 86)
	var lc20 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc20)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2089, []byte("int lcf1_delay_apply_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_apply_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2094
func lcf1_delay_apply_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 2)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2102, []byte("int lcf1_delay_apply_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_delay_apply_xs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2107
func lcf1_delay_apply_xs(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushnumber(L, 3)
	lua_gettable(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2115, []byte("int lcf1_delay_apply_xs(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_force_all_rec - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2120
func lcf1_force_all_rec(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 18)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2128, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
		}
	}()
	const (
		lc21 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 76)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	var lc22 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc22 != 0 {
		lua_pushnumber(L, 2)
		lua_gettable(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2142, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 3)
		lua_gettable(L, 2)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2147, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 49)
		lua_pushvalue(L, 3)
		lua_call(L, 1, 1)
		lua_pushnumber(L, 2)
		lua_insert(L, -2)
		lua_settable(L, 2)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2156, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 49)
		lua_pushvalue(L, 4)
		lua_call(L, 1, 1)
		lua_pushnumber(L, 3)
		lua_insert(L, -2)
		lua_settable(L, 2)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2165, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
			}
		}()
		lua_pushvalue(L, 2)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2170, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc23 int32 = 2
		)
		lc_getupvalue(L, -10002-1, 0, 72)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		var lc24 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc24 != 0 {
			lua_pushnumber(L, 2)
			lua_gettable(L, 2)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2185, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 3)
			lua_gettable(L, 2)
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2190, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, -10002-1, 0, 49)
			lua_pushvalue(L, 3)
			lua_call(L, 1, 1)
			lua_pushnumber(L, 2)
			lua_insert(L, -2)
			lua_settable(L, 2)
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2199, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, -10002-1, 0, 49)
			lua_pushvalue(L, 4)
			lua_call(L, 1, 1)
			lua_pushnumber(L, 3)
			lua_insert(L, -2)
			lua_settable(L, 2)
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2208, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
				}
			}()
			lua_pushvalue(L, 2)
			return 1
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2213, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc25 int32 = 2
			)
			lc_getupvalue(L, -10002-1, 0, 82)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			var lc26 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc26 != 0 {
				lua_pushnumber(L, 2)
				lua_gettable(L, 2)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2228, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 3)
				lua_gettable(L, 2)
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2233, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 49)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				lua_pushnumber(L, 2)
				lua_insert(L, -2)
				lua_settable(L, 2)
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2242, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 49)
				lua_pushvalue(L, 4)
				lua_call(L, 1, 1)
				lua_pushnumber(L, 3)
				lua_insert(L, -2)
				lua_settable(L, 2)
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2251, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
					}
				}()
				lua_pushvalue(L, 2)
				return 1
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2256, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc25)))
		}
		lua_settop(L, int32((lc23)))
	}
	lua_settop(L, int32((lc21)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2263, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2268, []byte("int lcf1_force_all_rec(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_symbol_equal_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2273
func lcf1_symbol_equal_p(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	const (
		lc27 int32 = 2
	)
	var lc28 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc28)
	var lc29 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc29 != 0 {
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2288, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc27)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2291, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
		}
	}()
	const (
		lc30 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 84)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 0, 84)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	var lc31 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc31)
	var lc32 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc32 != 0 {
		lc_getupvalue(L, -10002-1, 0, 69)
		lua_pushvalue(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2313, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2318, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
			}
		}()
	} else {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2325, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc30)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2328, []byte("int lcf1_symbol_equal_p(lua_State *)\x00"))
		}
	}()
	return 0
}

// lc_sub - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2334
func lc_sub(L []lua_State, idxa int32, idxb int32) {
	if lua_isnumber(L, idxa) != 0 && lua_isnumber(L, idxb) != 0 {
		lua_pushnumber(L, lua_tonumber(L, idxa)-lua_tonumber(L, idxb))
	} else {
		if luaL_getmetafield(L, idxa, []byte("__sub\x00")) != 0 || luaL_getmetafield(L, idxb, []byte("__sub\x00")) != 0 {
			lua_pushvalue(L, func() int32 {
				if idxa < 0 && idxa > -10000 {
					return idxa - 1
				}
				return idxa
			}())
			lua_pushvalue(L, func() int32 {
				if idxb < 0 && idxb > -10000 {
					return idxb - 2
				}
				return idxb
			}())
			lua_call(L, 2, 1)
		} else {
			luaL_error(L, []byte("attempt to perform arithmetic\x00"))
		}
	}
}

// lc_le - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2350
func lc_le(L []lua_State, idxa int32, idxb int32) (c4goDefaultReturn int32) {
	if lua_type(L, idxa) == 3 && lua_type(L, idxb) == 3 {
		return noarch.BoolToInt(lua_tonumber(L, idxa) <= lua_tonumber(L, idxb))
	} else if lua_type(L, idxa) == 4 && lua_type(L, idxb) == 4 {
		return noarch.BoolToInt(lua_lessthan(L, idxa, idxb) != 0 || lua_rawequal(L, idxa, idxb) != 0)
	} else if luaL_getmetafield(L, idxa, []byte("__le\x00")) != 0 || luaL_getmetafield(L, idxb, []byte("__le\x00")) != 0 {
		lua_pushvalue(L, func() int32 {
			if idxa < 0 && idxa > -10000 {
				return idxa - 1
			}
			return idxa
		}())
		lua_pushvalue(L, func() int32 {
			if idxb < 0 && idxb > -10000 {
				return idxb - 2
			}
			return idxb
		}())
		lua_call(L, 2, 1)
		var result int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		return result
	} else if luaL_getmetafield(L, idxa, []byte("__lt\x00")) != 0 || luaL_getmetafield(L, idxb, []byte("__lt\x00")) != 0 {
		lua_pushvalue(L, func() int32 {
			if idxb < 0 && idxb > -10000 {
				return idxb - 1
			}
			return idxb
		}())
		lua_pushvalue(L, func() int32 {
			if idxa < 0 && idxa > -10000 {
				return idxa - 2
			}
			return idxa
		}())
		lua_call(L, 2, 1)
		var result int32 = noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1)))
		lua_settop(L, -(1)-1)
		return result
	} else {
		return luaL_error(L, []byte("attempt to compare\x00"))
	}
	return
}

// lcf1_jsArray_to_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2380
func lcf1_jsArray_to_list(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 79)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2386, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
		}
	}()
	var lc33 float64 = float64(lua_objlen(L, 1))
	lua_pushnumber(L, lua_Number((lc33)))
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2396, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
		}
	}()
	const (
		lc34 int32 = 3
	)
	for 1 != 0 {
		lua_pushnumber(L, 0)
		var lc35 int32 = lc_le(L, -1, 3)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc35)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 83)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 1)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2419, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_sub(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2426, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc34)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2429, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2433, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2438, []byte("int lcf1_jsArray_to_list(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_new_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2443
func lcf1_new_list(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	var lc_nactualargs int32 = lua_gettop(L)
	var lc_nextra int32 = lc_nactualargs - int32((lc_nformalargs))
	lua_createtable(L, 1, 0)
	var lc36 int32 = lua_gettop(L)
	{
		var i int32
		for i = int32((lc_nformalargs + int32((int32((1)))))); i <= lc_nactualargs; i++ {
			lua_pushvalue(L, i)
		}
	}
	for lua_gettop(L) > lc36 {
		lua_rawseti(L, lc36, 0+(lua_gettop(L)-lc36))
	}
	func() {
		if lua_gettop(L)-lc_nextra == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2460, []byte("int lcf1_new_list(lua_State *)\x00"))
		}
	}()
	var lc37 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 22)
	lua_pushvalue(L, 1+lc_nextra)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc37
	func() {
		if lua_gettop(L)-lc_nextra == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2468, []byte("int lcf1_new_list(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_un_just_all - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2473
func lcf1_un_just_all(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2479, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2483, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	const (
		lc38 int32 = 3
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 68)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 1, 1)
		lua_pushvalue(L, 3)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2501, []byte("int lcf1_un_just_all(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 67)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2508, []byte("int lcf1_un_just_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc38)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2511, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2516, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	const (
		lc39 int32 = 4
	)
	for 1 != 0 {
		var lc40 float64 = float64(lua_objlen(L, 3))
		lua_pushnumber(L, lua_Number((lc40)))
		var lc41 int32 = lua_lessthan(L, 4, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc41)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 69)
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_gettable(L, 3)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2539, []byte("int lcf1_un_just_all(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_replace(L, 4)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2546, []byte("int lcf1_un_just_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc39)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2549, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2553, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2558, []byte("int lcf1_un_just_all(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_any_delay_just_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2563
func lcf1_any_delay_just_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 68)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 65)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 61)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 56)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 52)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
	}
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2597, []byte("int lcf1_any_delay_just_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_do_rewrite - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2602
func lcf1_do_rewrite(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 2, 69)
	lc_getupvalue(L, -10002-1, 0, 102)
	lua_pushvalue(L, 1)
	lua_call(L, 2, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2611, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2616, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
		}
	}()
	const (
		lc53 int32 = 2
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 1, 99)
		var lc54 float64 = float64(lua_objlen(L, -1))
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, lua_Number((lc54)))
		var lc55 int32 = lua_lessthan(L, 2, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc55)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 2, 69)
		lc_getupvalue(L, -10002-1, 1, 99)
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushvalue(L, 1)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2643, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2650, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc53)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2653, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2657, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2662, []byte("int lcf1_do_rewrite(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_do_rewrite_force_all - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2667
func lcf1_do_rewrite_force_all(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 101)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2675, []byte("int lcf1_do_rewrite_force_all(lua_State *)\x00"))
		}
	}()
	const (
		lc56 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 2, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc57 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc57 != 0 {
		lc_getupvalue(L, -10002-1, 3, 1)
		lc_getupvalue(L, -10002-1, 1, 99)
		lc_getupvalue(L, -10002-1, 0, 102)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2691, []byte("int lcf1_do_rewrite_force_all(lua_State *)\x00"))
			}
		}()
		var lc58 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 2, 18)
		lua_pushvalue(L, 1)
		lc_getupvalue(L, -10002-1, 1, 97)
		lua_createtable(L, 2, 0)
		lua_pushboolean(L, 0)
		lua_rawseti(L, -2, 1)
		lua_pushboolean(L, 0)
		lua_rawseti(L, -2, 2)
		lc_getupvalue(L, -10002-1, 1, 99)
		lua_call(L, 4, -1)
		return lua_gettop(L) - lc58
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2706, []byte("int lcf1_do_rewrite_force_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc56)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2709, []byte("int lcf1_do_rewrite_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2714, []byte("int lcf1_do_rewrite_force_all(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_replace_this_with_stopped - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2719
func lcf1_replace_this_with_stopped(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lua_pushboolean(L, 1)
	lc_getupvalue(L, -10002-1, 2, 98)
	lua_insert(L, -2)
	lua_pushnumber(L, 2)
	lua_insert(L, -2)
	lua_settable(L, -3)
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2731, []byte("int lcf1_replace_this_with_stopped(lua_State *)\x00"))
		}
	}()
	var lc60 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 100)
	lc_getupvalue(L, -10002-1, 3, 44)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc60
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2739, []byte("int lcf1_replace_this_with_stopped(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_history - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2744
func lcf1_make_history(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2750, []byte("int lcf1_make_history(lua_State *)\x00"))
		}
	}()
	const (
		lc61 int32 = 1
	)
	lua_getfield(L, -10001, []byte("pairs\x00"))
	lc_getupvalue(L, -10002-1, 0, 103)
	lua_call(L, 1, 3)
	for 1 != 0 {
		lua_pushvalue(L, -3)
		lua_pushvalue(L, -3)
		lua_pushvalue(L, -3)
		lua_call(L, 2, 1)
		if lua_type(L, -1) == 0 {
			break
		}
		lua_pushvalue(L, -1)
		lua_replace(L, -3)
		lua_pushboolean(L, 1)
		lua_pushvalue(L, 5)
		lua_insert(L, -2)
		lua_settable(L, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2780, []byte("int lcf1_make_history(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc61)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2786, []byte("int lcf1_make_history(lua_State *)\x00"))
		}
	}()
	const (
		lc62 int32 = 1
	)
	lua_getfield(L, -10001, []byte("pairs\x00"))
	lc_getupvalue(L, -10002-1, 2, 97)
	lua_call(L, 1, 3)
	for 1 != 0 {
		lua_pushvalue(L, -3)
		lua_pushvalue(L, -3)
		lua_pushvalue(L, -3)
		lua_call(L, 2, 1)
		if lua_type(L, -1) == 0 {
			break
		}
		lua_pushvalue(L, -1)
		lua_replace(L, -3)
		lua_pushboolean(L, 1)
		lua_pushvalue(L, 5)
		lua_insert(L, -2)
		lua_settable(L, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2816, []byte("int lcf1_make_history(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc62)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2822, []byte("int lcf1_make_history(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2827, []byte("int lcf1_make_history(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_force_all - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:2832
func lcf1_force_all(L []lua_State) (c4goDefaultReturn int32) {
	lua_checkstack(L, 25)
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	lc_newclosuretable(L, -10002-1)
	const (
		lc42 int32 = 5
	)
	func() {
		if lua_gettop(L) == int32((lc42)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc42)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2838, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 97)
	lua_pushvalue(L, 3)
	lua_rawseti(L, -2, 98)
	lua_pushvalue(L, 4)
	lua_rawseti(L, -2, 99)
	const (
		lc43 int32 = 5
	)
	lc_getupvalue(L, int32((lc42)), 0, 97)
	lua_pushnil(L)
	var lc44 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc44)
	var lc45 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc45 != 0 {
		lua_createtable(L, 0, 0)
		lc_setupvalue(L, int32((lc42)), 0, 97)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2860, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc43)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2863, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	const (
		lc46 int32 = 5
	)
	lc_getupvalue(L, int32((lc42)), 0, 98)
	lua_pushnil(L)
	var lc47 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc47)
	var lc48 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc48 != 0 {
		lua_createtable(L, 2, 0)
		lua_pushboolean(L, 0)
		lua_rawseti(L, -2, 1)
		lua_pushboolean(L, 0)
		lua_rawseti(L, -2, 2)
		lc_setupvalue(L, int32((lc42)), 0, 98)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2883, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc46)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2886, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	const (
		lc49 int32 = 5
	)
	lc_getupvalue(L, int32((lc42)), 0, 99)
	lua_pushnil(L)
	var lc50 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc50)
	var lc51 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc51 != 0 {
		lua_createtable(L, 0, 0)
		lc_setupvalue(L, int32((lc42)), 0, 99)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2902, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc49)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2905, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc42)))
	const (
		lc52 int32 = 6
	)
	func() {
		if lua_gettop(L) == int32((lc52)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc52)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2910, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+3)
	lua_rawseti(L, int32((lc52)), 100)
	lua_rawseti(L, int32((lc52)), 101)
	lua_rawseti(L, int32((lc52)), 102)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2915, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc52)))
	lua_pushcclosure(L, lcf1_do_rewrite, 1)
	lc_setupvalue(L, int32((lc52)), 0, 101)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2931, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc52)))
	lua_pushcclosure(L, lcf1_do_rewrite_force_all, 1)
	lc_setupvalue(L, int32((lc52)), 0, 100)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2944, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc52)))
	const (
		lc59 int32 = 7
	)
	func() {
		if lua_gettop(L) == int32((lc59)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc59)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2949, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	lua_rawseti(L, int32((lc59)), 103)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2952, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lc_setupvalue(L, int32((lc59)), 1, 102)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2957, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2961, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc59)))
	lua_pushcclosure(L, lcf1_replace_this_with_stopped, 1)
	lua_replace(L, 8)
	func() {
		if lua_gettop(L) == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2970, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2974, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc59)))
	lua_pushcclosure(L, lcf1_make_history, 1)
	lua_replace(L, 9)
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 2989, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	const (
		lc63 int32 = 9
	)
	for 1 != 0 {
		lc_getupvalue(L, int32((lc59)), 3, 19)
		lc_getupvalue(L, int32((lc59)), 1, 102)
		lua_call(L, 1, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc59)), 3, 2)
		lc_getupvalue(L, int32((lc59)), 1, 102)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3006, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		const (
			lc64 int32 = 10
		)
		lc_getupvalue(L, int32((lc59)), 2, 97)
		lua_pushvalue(L, 10)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushboolean(L, 1)
		var lc65 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc65)
		var lc66 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc66 != 0 {
			var lc67 int32 = lua_gettop(L)
			lua_pushvalue(L, 8)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc67
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3027, []byte("int lcf1_force_all(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc64)))
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3030, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		const (
			lc68 int32 = 10
		)
		lc_getupvalue(L, int32((lc59)), 0, 103)
		lua_pushvalue(L, 10)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushboolean(L, 1)
		var lc69 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc69)
		var lc70 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc70 != 0 {
			lua_pushboolean(L, 1)
			lc_getupvalue(L, int32((lc59)), 2, 98)
			lua_insert(L, -2)
			lua_pushnumber(L, 1)
			lua_insert(L, -2)
			lua_settable(L, -3)
			lua_settop(L, -(1)-1)
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3054, []byte("int lcf1_force_all(lua_State *)\x00"))
				}
			}()
			const (
				lc71 int32 = 10
			)
			lc_getupvalue(L, int32((lc59)), 3, 65)
			lc_getupvalue(L, int32((lc59)), 1, 102)
			lua_call(L, 1, 1)
			var lc72 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc72 != 0 {
				var lc73 int32 = lua_gettop(L)
				lua_pushvalue(L, 8)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc73
				func() {
					if lua_gettop(L) == 10 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3070, []byte("int lcf1_force_all(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc74 int32 = 10
				)
				lc_getupvalue(L, int32((lc59)), 3, 56)
				lc_getupvalue(L, int32((lc59)), 1, 102)
				lua_call(L, 1, 1)
				var lc75 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc75 != 0 {
					lc_getupvalue(L, int32((lc59)), 3, 55)
					lc_getupvalue(L, int32((lc59)), 1, 102)
					lua_call(L, 1, 1)
					func() {
						if lua_gettop(L) == 11 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3086, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					lc_getupvalue(L, int32((lc59)), 3, 54)
					lc_getupvalue(L, int32((lc59)), 1, 102)
					lua_call(L, 1, 1)
					func() {
						if lua_gettop(L) == 12 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3092, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					lua_createtable(L, 11, 0)
					lc_getupvalue(L, int32((lc59)), 3, 43)
					lua_rawseti(L, -2, 1)
					lc_getupvalue(L, int32((lc59)), 3, 42)
					lua_rawseti(L, -2, 2)
					lc_getupvalue(L, int32((lc59)), 3, 41)
					lua_rawseti(L, -2, 3)
					lc_getupvalue(L, int32((lc59)), 3, 40)
					lua_rawseti(L, -2, 4)
					lc_getupvalue(L, int32((lc59)), 3, 39)
					lua_rawseti(L, -2, 5)
					lc_getupvalue(L, int32((lc59)), 3, 38)
					lua_rawseti(L, -2, 6)
					lc_getupvalue(L, int32((lc59)), 3, 37)
					lua_rawseti(L, -2, 7)
					lc_getupvalue(L, int32((lc59)), 3, 36)
					lua_rawseti(L, -2, 8)
					lc_getupvalue(L, int32((lc59)), 3, 35)
					lua_rawseti(L, -2, 9)
					lc_getupvalue(L, int32((lc59)), 3, 34)
					lua_rawseti(L, -2, 10)
					lc_getupvalue(L, int32((lc59)), 3, 33)
					lua_rawseti(L, -2, 11)
					func() {
						if lua_gettop(L) == 13 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3128, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					lua_pushboolean(L, 0)
					func() {
						if lua_gettop(L) == 14 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3132, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 0)
					func() {
						if lua_gettop(L) == 15 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3137, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					const (
						lc76 int32 = 15
					)
					for 1 != 0 {
						var lc77 float64 = float64(lua_objlen(L, 13))
						lua_pushnumber(L, lua_Number((lc77)))
						var lc78 int32 = lua_lessthan(L, 15, -1)
						lua_settop(L, -(1)-1)
						lua_pushboolean(L, lc78)
						if noarch.Not(lua_toboolean(L, -1)) {
							break
						}
						lua_settop(L, -(1)-1)
						const (
							lc79 int32 = 15
						)
						lc_getupvalue(L, int32((lc59)), 3, 3)
						lua_pushnumber(L, 1)
						lc_add(L, 15, -1)
						lua_remove(L, -2)
						lua_gettable(L, 13)
						lua_pushvalue(L, 11)
						lua_call(L, 2, 1)
						var lc80 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc80 != 0 {
							lua_pushboolean(L, 1)
							lua_replace(L, 14)
							func() {
								if lua_gettop(L) == 15 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3168, []byte("int lcf1_force_all(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc79)))
						func() {
							if lua_gettop(L) == 15 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3171, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
						lua_pushnumber(L, 1)
						lc_add(L, 15, -1)
						lua_remove(L, -2)
						lua_replace(L, 15)
						func() {
							if lua_gettop(L) == 15 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3178, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc76)))
					func() {
						if lua_gettop(L) == 15 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3181, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					lua_settop(L, -(1)-1)
					func() {
						if lua_gettop(L) == 14 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3185, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					const (
						lc81 int32 = 14
					)
					if lua_toboolean(L, 14) != 0 {
						lc_getupvalue(L, int32((lc59)), 3, 95)
						var lc82 float64 = float64(lua_objlen(L, 12))
						lua_pushnumber(L, lua_Number((lc82)))
						lua_pushnumber(L, 1)
						var lc83 int32 = lua_equal(L, -2, -1)
						lua_settop(L, -(2)-1)
						lua_pushboolean(L, lc83)
						lua_call(L, 1, 0)
						func() {
							if lua_gettop(L) == 14 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3200, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
						lc_getupvalue(L, int32((lc59)), 3, 95)
						lc_getupvalue(L, int32((lc59)), 2, 98)
						lua_pushnumber(L, 2)
						lua_gettable(L, -2)
						lua_remove(L, -2)
						lua_pushboolean(L, 0)
						var lc84 int32 = lua_equal(L, -2, -1)
						lua_settop(L, -(2)-1)
						lua_pushboolean(L, lc84)
						lua_call(L, 1, 0)
						func() {
							if lua_gettop(L) == 14 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3213, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
						lc_getupvalue(L, int32((lc59)), 3, 18)
						lua_pushnumber(L, 1)
						lua_gettable(L, 12)
						lua_pushvalue(L, 9)
						lua_call(L, 0, 1)
						lc_getupvalue(L, int32((lc59)), 2, 98)
						lua_call(L, 3, 1)
						func() {
							if lua_gettop(L) == 15 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3224, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
						const (
							lc85 int32 = 15
						)
						lc_getupvalue(L, int32((lc59)), 2, 98)
						lua_pushnumber(L, 2)
						lua_gettable(L, -2)
						lua_remove(L, -2)
						var lc86 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc86 != 0 {
							var lc87 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc59)), 1, 100)
							var lc88 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc59)), 3, 57)
							lua_pushvalue(L, 11)
							lua_createtable(L, 1, 0)
							lua_pushvalue(L, 15)
							lua_rawseti(L, -2, 1)
							lua_call(L, 2, -1)
							lua_call(L, lua_gettop(L)-lc88, -1)
							return lua_gettop(L) - lc87
							func() {
								if lua_gettop(L) == 15 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3248, []byte("int lcf1_force_all(lua_State *)\x00"))
								}
							}()
						} else {
							var lc89 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc59)), 3, 96)
							lua_call(L, 0, -1)
							return lua_gettop(L) - lc89
							func() {
								if lua_gettop(L) == 15 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3257, []byte("int lcf1_force_all(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc85)))
						func() {
							if lua_gettop(L) == 15 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3260, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc81)))
					func() {
						if lua_gettop(L) == 14 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3263, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					const (
						lc90 int32 = 14
					)
					lc_getupvalue(L, int32((lc59)), 3, 3)
					lua_pushvalue(L, 11)
					lc_getupvalue(L, int32((lc59)), 3, 32)
					lua_call(L, 2, 1)
					var lc91 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc91 != 0 {
						var lc92 int32 = lua_gettop(L)
						lua_pushvalue(L, 8)
						lua_call(L, 0, -1)
						return lua_gettop(L) - lc92
						func() {
							if lua_gettop(L) == 14 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3280, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc93 int32 = 14
						)
						lc_getupvalue(L, int32((lc59)), 3, 3)
						lua_pushvalue(L, 11)
						lc_getupvalue(L, int32((lc59)), 3, 31)
						lua_call(L, 2, 1)
						var lc94 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc94 != 0 {
							var lc95 int32 = lua_gettop(L)
							lua_pushvalue(L, 8)
							lua_call(L, 0, -1)
							return lua_gettop(L) - lc95
							func() {
								if lua_gettop(L) == 14 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3299, []byte("int lcf1_force_all(lua_State *)\x00"))
								}
							}()
						} else {
							const (
								lc96 int32 = 14
							)
							lc_getupvalue(L, int32((lc59)), 3, 3)
							lua_pushvalue(L, 11)
							lc_getupvalue(L, int32((lc59)), 3, 30)
							lua_call(L, 2, 1)
							var lc97 int32 = lua_toboolean(L, -1)
							lua_settop(L, -(1)-1)
							if lc97 != 0 {
								var lc98 int32 = lua_gettop(L)
								lua_pushvalue(L, 8)
								lua_call(L, 0, -1)
								return lua_gettop(L) - lc98
								func() {
									if lua_gettop(L) == 14 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3318, []byte("int lcf1_force_all(lua_State *)\x00"))
									}
								}()
							} else {
								const (
									lc99 int32 = 14
								)
								lc_getupvalue(L, int32((lc59)), 3, 3)
								lua_pushvalue(L, 11)
								lc_getupvalue(L, int32((lc59)), 3, 29)
								lua_call(L, 2, 1)
								var lc100 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc100 != 0 {
									lc_getupvalue(L, int32((lc59)), 3, 95)
									var lc101 float64 = float64(lua_objlen(L, 12))
									lua_pushnumber(L, lua_Number((lc101)))
									lua_pushnumber(L, 3)
									var lc102 int32 = lua_equal(L, -2, -1)
									lua_settop(L, -(2)-1)
									lua_pushboolean(L, lc102)
									lua_call(L, 1, 0)
									func() {
										if lua_gettop(L) == 14 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3341, []byte("int lcf1_force_all(lua_State *)\x00"))
										}
									}()
									lc_getupvalue(L, int32((lc59)), 3, 95)
									lc_getupvalue(L, int32((lc59)), 2, 98)
									lua_pushnumber(L, 2)
									lua_gettable(L, -2)
									lua_remove(L, -2)
									lua_pushboolean(L, 0)
									var lc103 int32 = lua_equal(L, -2, -1)
									lua_settop(L, -(2)-1)
									lua_pushboolean(L, lc103)
									lua_call(L, 1, 0)
									func() {
										if lua_gettop(L) == 14 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3354, []byte("int lcf1_force_all(lua_State *)\x00"))
										}
									}()
									lc_getupvalue(L, int32((lc59)), 3, 18)
									lua_pushnumber(L, 1)
									lua_gettable(L, 12)
									lua_pushvalue(L, 9)
									lua_call(L, 0, 1)
									lc_getupvalue(L, int32((lc59)), 2, 98)
									lua_call(L, 3, 1)
									func() {
										if lua_gettop(L) == 15 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3365, []byte("int lcf1_force_all(lua_State *)\x00"))
										}
									}()
									const (
										lc104 int32 = 15
									)
									lc_getupvalue(L, int32((lc59)), 2, 98)
									lua_pushnumber(L, 2)
									lua_gettable(L, -2)
									lua_remove(L, -2)
									var lc105 int32 = lua_toboolean(L, -1)
									lua_settop(L, -(1)-1)
									if lc105 != 0 {
										var lc106 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc59)), 1, 100)
										var lc107 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc59)), 3, 57)
										lc_getupvalue(L, int32((lc59)), 3, 29)
										lua_createtable(L, 3, 0)
										lua_pushvalue(L, 15)
										lua_rawseti(L, -2, 1)
										lua_pushnumber(L, 2)
										lua_gettable(L, 12)
										lua_rawseti(L, -2, 2)
										lua_pushnumber(L, 3)
										lua_gettable(L, 12)
										lua_rawseti(L, -2, 3)
										lua_call(L, 2, -1)
										lua_call(L, lua_gettop(L)-lc107, -1)
										return lua_gettop(L) - lc106
										func() {
											if lua_gettop(L) == 15 {
											} else {
												linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3397, []byte("int lcf1_force_all(lua_State *)\x00"))
											}
										}()
									} else {
										var lc108 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc59)), 3, 96)
										lua_call(L, 0, -1)
										return lua_gettop(L) - lc108
										func() {
											if lua_gettop(L) == 15 {
											} else {
												linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3406, []byte("int lcf1_force_all(lua_State *)\x00"))
											}
										}()
									}
									lua_settop(L, int32((lc104)))
									func() {
										if lua_gettop(L) == 15 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3409, []byte("int lcf1_force_all(lua_State *)\x00"))
										}
									}()
								}
								lua_settop(L, int32((lc99)))
							}
							lua_settop(L, int32((lc96)))
						}
						lua_settop(L, int32((lc93)))
					}
					lua_settop(L, int32((lc90)))
					func() {
						if lua_gettop(L) == 14 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3418, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
					var lc109 int32 = lua_gettop(L)
					lc_getupvalue(L, int32((lc59)), 3, 96)
					lua_call(L, 0, -1)
					return lua_gettop(L) - lc109
					func() {
						if lua_gettop(L) == 14 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3425, []byte("int lcf1_force_all(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc110 int32 = 10
					)
					lc_getupvalue(L, int32((lc59)), 3, 61)
					lc_getupvalue(L, int32((lc59)), 1, 102)
					lua_call(L, 1, 1)
					var lc111 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc111 != 0 {
						var lc112 int32 = lua_gettop(L)
						lua_pushvalue(L, 8)
						lua_call(L, 0, -1)
						return lua_gettop(L) - lc112
						func() {
							if lua_gettop(L) == 10 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3442, []byte("int lcf1_force_all(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc113 int32 = 10
						)
						lc_getupvalue(L, int32((lc59)), 3, 52)
						lc_getupvalue(L, int32((lc59)), 1, 102)
						lua_call(L, 1, 1)
						var lc114 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc114 != 0 {
							var lc115 int32 = lua_gettop(L)
							lua_pushvalue(L, 8)
							lua_call(L, 0, -1)
							return lua_gettop(L) - lc115
							func() {
								if lua_gettop(L) == 10 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3459, []byte("int lcf1_force_all(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc113)))
					}
					lua_settop(L, int32((lc110)))
				}
				lua_settop(L, int32((lc74)))
			}
			lua_settop(L, int32((lc71)))
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3468, []byte("int lcf1_force_all(lua_State *)\x00"))
				}
			}()
			var lc116 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc59)), 3, 96)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc116
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3475, []byte("int lcf1_force_all(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc68)))
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3478, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		lc_getupvalue(L, int32((lc59)), 0, 103)
		lua_insert(L, -2)
		lua_pushvalue(L, 10)
		lua_insert(L, -2)
		lua_settable(L, -3)
		lua_settop(L, -(1)-1)
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3488, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc59)), 4, 1)
		lc_getupvalue(L, int32((lc59)), 2, 99)
		lc_getupvalue(L, int32((lc59)), 1, 102)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3495, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc59)), 3, 17)
		lc_getupvalue(L, int32((lc59)), 1, 102)
		lua_call(L, 1, 1)
		lc_setupvalue(L, int32((lc59)), 1, 102)
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3502, []byte("int lcf1_force_all(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc63)))
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3508, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	var lc117 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc59)), 1, 101)
	lc_getupvalue(L, int32((lc59)), 1, 102)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc117
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3516, []byte("int lcf1_force_all(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_force1 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:3521
func lcf1_force1(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 20)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3529, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3533, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 95)
	lc_getupvalue(L, -10002-1, 0, 68)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3543, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	const (
		lc118 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 0, 65)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	var lc119 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc119 != 0 {
		lc_getupvalue(L, -10002-1, 0, 10)
		var lc120 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 64)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lc_getupvalue(L, -10002-1, 0, 63)
		lua_pushvalue(L, 2)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc120, 1)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3565, []byte("int lcf1_force1(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc121 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 0, 61)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		var lc122 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc122 != 0 {
			lc_getupvalue(L, -10002-1, 0, 5)
			var lc123 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 0, 60)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			lc_getupvalue(L, -10002-1, 0, 59)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			lc_getupvalue(L, -10002-1, 0, 58)
			lua_pushvalue(L, 2)
			lua_call(L, 1, -1)
			lua_call(L, lua_gettop(L)-lc123, 1)
			lua_replace(L, 3)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3592, []byte("int lcf1_force1(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc124 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 0, 56)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			var lc125 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc125 != 0 {
				lc_getupvalue(L, -10002-1, 0, 6)
				var lc126 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 55)
				lua_pushvalue(L, 2)
				lua_call(L, 1, 1)
				lc_getupvalue(L, -10002-1, 0, 54)
				lua_pushvalue(L, 2)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc126, 1)
				lua_replace(L, 3)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3616, []byte("int lcf1_force1(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc127 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 0, 52)
				lua_pushvalue(L, 2)
				lua_call(L, 1, 1)
				var lc128 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc128 != 0 {
					lc_getupvalue(L, -10002-1, 0, 7)
					var lc129 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 51)
					lua_pushvalue(L, 2)
					lua_call(L, 1, 1)
					lc_getupvalue(L, -10002-1, 0, 50)
					lua_pushvalue(L, 2)
					lua_call(L, 1, -1)
					lua_call(L, lua_gettop(L)-lc129, 1)
					lua_replace(L, 3)
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3639, []byte("int lcf1_force1(lua_State *)\x00"))
						}
					}()
				} else {
					lua_pushvalue(L, 2)
					lua_replace(L, 3)
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3646, []byte("int lcf1_force1(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc127)))
			}
			lua_settop(L, int32((lc124)))
		}
		lua_settop(L, int32((lc121)))
	}
	lua_settop(L, int32((lc118)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3655, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 20)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	lua_replace(L, 3)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3662, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 69)
	lua_pushvalue(L, 2)
	lua_pushvalue(L, 3)
	lua_call(L, 2, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3669, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3674, []byte("int lcf1_force1(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_env_set - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:3679
func lcf1_env_set(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3685, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3690, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	const (
		lc130 int32 = 5
	)
	for 1 != 0 {
		var lc131 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc131)))
		var lc132 int32 = lua_lessthan(L, 5, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc132)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc133 int32 = 5
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushnumber(L, 0)
		lc_add(L, 5, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 1)
		var lc134 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc134 != 0 {
			lua_pushvalue(L, 2)
			lua_pushnumber(L, 0)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_insert(L, -2)
			lua_settable(L, 4)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3733, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			lua_pushvalue(L, 3)
			lua_pushnumber(L, 1)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_insert(L, -2)
			lua_settable(L, 4)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3746, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 2)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_replace(L, 5)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3754, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			const (
				lc135 int32 = 5
			)
			for 1 != 0 {
				var lc136 float64 = float64(lua_objlen(L, 1))
				lua_pushnumber(L, lua_Number((lc136)))
				var lc137 int32 = lua_lessthan(L, 5, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc137)
				if noarch.Not(lua_toboolean(L, -1)) {
					break
				}
				lua_settop(L, -(1)-1)
				lua_pushnumber(L, 0)
				lc_add(L, 5, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_gettable(L, 1)
				lua_pushnumber(L, 0)
				lc_add(L, 5, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_insert(L, -2)
				lua_settable(L, 4)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3787, []byte("int lcf1_env_set(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 1)
				lc_add(L, 5, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_gettable(L, 1)
				lua_pushnumber(L, 1)
				lc_add(L, 5, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_insert(L, -2)
				lua_settable(L, 4)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3807, []byte("int lcf1_env_set(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 2)
				lc_add(L, 5, -1)
				lua_remove(L, -2)
				lua_replace(L, 5)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3814, []byte("int lcf1_env_set(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc135)))
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3817, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3818, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			lua_pushvalue(L, 4)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3823, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
		} else {
			lua_pushnumber(L, 0)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_gettable(L, 1)
			lua_pushnumber(L, 0)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_insert(L, -2)
			lua_settable(L, 4)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3845, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 1)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_gettable(L, 1)
			lua_pushnumber(L, 1)
			lc_add(L, 5, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_insert(L, -2)
			lua_settable(L, 4)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3865, []byte("int lcf1_env_set(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc133)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3868, []byte("int lcf1_env_set(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 2)
		lc_add(L, 5, -1)
		lua_remove(L, -2)
		lua_replace(L, 5)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3875, []byte("int lcf1_env_set(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc130)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3878, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3882, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	var lc138 float64 = float64(lua_objlen(L, 1))
	lua_pushnumber(L, lua_Number((lc138)))
	lua_pushnumber(L, 0)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_insert(L, -2)
	lua_settable(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3898, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	var lc139 float64 = float64(lua_objlen(L, 1))
	lua_pushnumber(L, lua_Number((lc139)))
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_insert(L, -2)
	lua_settable(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3914, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 4)
	return 1
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3919, []byte("int lcf1_env_set(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_env_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:3924
func lcf1_env_get(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3931, []byte("int lcf1_env_get(lua_State *)\x00"))
		}
	}()
	const (
		lc140 int32 = 4
	)
	for 1 != 0 {
		var lc141 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc141)))
		var lc142 int32 = lua_lessthan(L, 4, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc142)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc143 int32 = 4
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushnumber(L, 0)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 1)
		var lc144 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc144 != 0 {
			lua_pushnumber(L, 1)
			lc_add(L, 4, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_gettable(L, 1)
			return 1
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3973, []byte("int lcf1_env_get(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc143)))
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3976, []byte("int lcf1_env_get(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 2)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_replace(L, 4)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3983, []byte("int lcf1_env_get(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc140)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3986, []byte("int lcf1_env_get(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3990, []byte("int lcf1_env_get(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 3995, []byte("int lcf1_env_get(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_must_env_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:4000
func lcf1_must_env_get(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4007, []byte("int lcf1_must_env_get(lua_State *)\x00"))
		}
	}()
	const (
		lc145 int32 = 3
	)
	for 1 != 0 {
		var lc146 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc146)))
		var lc147 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc147)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc148 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushnumber(L, 0)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 1)
		var lc149 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc149 != 0 {
			lua_pushnumber(L, 1)
			lc_add(L, 3, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_gettable(L, 1)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4049, []byte("int lcf1_must_env_get(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc148)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4052, []byte("int lcf1_must_env_get(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 2)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4059, []byte("int lcf1_must_env_get(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc145)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4062, []byte("int lcf1_must_env_get(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4066, []byte("int lcf1_must_env_get(lua_State *)\x00"))
		}
	}()
	var lc150 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc150
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4073, []byte("int lcf1_must_env_get(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_env2val - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:4078
func lcf1_env2val(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 79)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4084, []byte("int lcf1_env2val(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4089, []byte("int lcf1_env2val(lua_State *)\x00"))
		}
	}()
	const (
		lc151 int32 = 3
	)
	for 1 != 0 {
		var lc152 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc152)))
		var lc153 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc153)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 83)
		lc_getupvalue(L, -10002-1, 0, 21)
		lua_pushnumber(L, 0)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_call(L, 2, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 1)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4128, []byte("int lcf1_env2val(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 2)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4135, []byte("int lcf1_env2val(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc151)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4138, []byte("int lcf1_env2val(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4142, []byte("int lcf1_env2val(lua_State *)\x00"))
		}
	}()
	var lc154 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 77)
	var lc155 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 45)
	lc_getupvalue(L, -10002-1, 0, 21)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc155, -1)
	return lua_gettop(L) - lc154
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4154, []byte("int lcf1_env2val(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_env_foreach - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:4159
func lcf1_env_foreach(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4166, []byte("int lcf1_env_foreach(lua_State *)\x00"))
		}
	}()
	const (
		lc156 int32 = 3
	)
	for 1 != 0 {
		var lc157 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc157)))
		var lc158 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc158)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 2)
		lua_pushnumber(L, 0)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lc_add(L, -2, -1)
		lua_remove(L, -2)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4200, []byte("int lcf1_env_foreach(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 2)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4207, []byte("int lcf1_env_foreach(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc156)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4210, []byte("int lcf1_env_foreach(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4214, []byte("int lcf1_env_foreach(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_real_evaluate - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:4220
func lcf1_real_evaluate(L []lua_State) (c4goDefaultReturn int32) {
	lua_checkstack(L, 23)
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 0, 17)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4229, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
		}
	}()
	const (
		lc159 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 0, 19)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	var lc160 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc160 != 0 {
		var lc161 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 66)
		lua_pushvalue(L, 1)
		lua_pushvalue(L, 3)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc161
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4247, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc159)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4250, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 73)
	var lc162 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 48)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc163 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 26)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc164 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 30)
	lc_getupvalue(L, -10002-1, 0, 21)
	lc_getupvalue(L, -10002-1, 0, 12)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushvalue(L, 3)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc164, -1)
	lua_call(L, lua_gettop(L)-lc163, -1)
	lua_call(L, lua_gettop(L)-lc162, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4274, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
		}
	}()
	const (
		lc165 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 0, 82)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	var lc166 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc166 != 0 {
		lua_createtable(L, 0, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4287, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
			}
		}()
		lua_pushvalue(L, 3)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4291, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
			}
		}()
		const (
			lc167 int32 = 6
		)
		for 1 != 0 {
			lc_getupvalue(L, -10002-1, 0, 78)
			lua_pushvalue(L, 6)
			lua_call(L, 1, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			if noarch.Not(lua_toboolean(L, -1)) {
				break
			}
			lua_settop(L, -(1)-1)
			const (
				lc168 int32 = 6
			)
			lc_getupvalue(L, -10002-1, 0, 19)
			lua_pushvalue(L, 6)
			lua_call(L, 1, 1)
			var lc169 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc169 != 0 {
				var lc170 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 66)
				lua_pushvalue(L, 1)
				lua_pushvalue(L, 3)
				lua_call(L, 2, -1)
				return lua_gettop(L) - lc170
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4322, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc171 int32 = 6
				)
				lc_getupvalue(L, -10002-1, 0, 82)
				lua_pushvalue(L, 6)
				lua_call(L, 1, 1)
				var lc172 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc172 != 0 {
					lc_getupvalue(L, -10002-1, 1, 1)
					var lc173 int32 = lua_gettop(L)
					lua_pushvalue(L, 5)
					lc_getupvalue(L, -10002-1, 0, 81)
					lua_pushvalue(L, 6)
					lua_call(L, 1, -1)
					lua_call(L, lua_gettop(L)-lc173, 0)
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4342, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lc_getupvalue(L, -10002-1, 0, 17)
					var lc174 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 80)
					lua_pushvalue(L, 6)
					lua_call(L, 1, -1)
					lua_call(L, lua_gettop(L)-lc174, 1)
					lua_replace(L, 6)
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4352, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				} else {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4359, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc171)))
			}
			lua_settop(L, int32((lc168)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4364, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc167)))
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4367, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
			}
		}()
		const (
			lc175 int32 = 6
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushnumber(L, 1)
		lua_gettable(L, 5)
		lc_getupvalue(L, -10002-1, 0, 25)
		lua_call(L, 2, 1)
		var lc176 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc176 != 0 {
			const (
				lc177 int32 = 6
			)
			var lc178 float64 = float64(lua_objlen(L, 5))
			lua_pushnumber(L, lua_Number((lc178)))
			lua_pushnumber(L, 1)
			var lc179 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc179)
			var lc180 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc180 != 0 {
				lua_pushvalue(L, 4)
				return 1
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4395, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc177)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4398, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 2)
			lua_gettable(L, 5)
			func() {
				if lua_gettop(L) == 7 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4403, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			lua_createtable(L, 0, 0)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4407, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 2)
			func() {
				if lua_gettop(L) == 9 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4412, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			const (
				lc181 int32 = 9
			)
			for 1 != 0 {
				var lc182 float64 = float64(lua_objlen(L, 5))
				lua_pushnumber(L, lua_Number((lc182)))
				var lc183 int32 = lua_lessthan(L, 9, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc183)
				if noarch.Not(lua_toboolean(L, -1)) {
					break
				}
				lua_settop(L, -(1)-1)
				lua_pushnumber(L, 1)
				lc_add(L, 9, -1)
				lua_remove(L, -2)
				lua_gettable(L, 5)
				lua_pushnumber(L, 2)
				lc_sub(L, 9, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_insert(L, -2)
				lua_settable(L, 8)
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4441, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 1)
				lc_add(L, 9, -1)
				lua_remove(L, -2)
				lua_replace(L, 9)
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4448, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc181)))
			func() {
				if lua_gettop(L) == 9 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4451, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			lua_settop(L, -(1)-1)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4455, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
			var lc184 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 0, 62)
			lua_pushvalue(L, 1)
			lua_pushvalue(L, 7)
			lua_pushvalue(L, 8)
			lua_call(L, 3, -1)
			return lua_gettop(L) - lc184
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4465, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc185 int32 = 6
			)
			lc_getupvalue(L, -10002-1, 0, 3)
			lua_pushnumber(L, 1)
			lua_gettable(L, 5)
			lc_getupvalue(L, -10002-1, 0, 24)
			lua_call(L, 2, 1)
			var lc186 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc186 != 0 {
				const (
					lc187 int32 = 6
				)
				var lc188 float64 = float64(lua_objlen(L, 5))
				lua_pushnumber(L, lua_Number((lc188)))
				lua_pushnumber(L, 1)
				var lc189 int32 = lua_equal(L, -2, -1)
				lua_settop(L, -(2)-1)
				lua_pushboolean(L, lc189)
				var lc190 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc190 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4494, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc187)))
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4497, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 18)
				var lc191 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 66)
				lua_pushvalue(L, 1)
				lua_pushnumber(L, 2)
				lua_gettable(L, 5)
				lua_call(L, 2, -1)
				lua_call(L, lua_gettop(L)-lc191, 1)
				func() {
					if lua_gettop(L) == 7 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4508, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc192 int32 = 7
				)
				lc_getupvalue(L, -10002-1, 0, 76)
				lua_pushvalue(L, 7)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc193 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc193 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 7 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4524, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc192)))
				func() {
					if lua_gettop(L) == 7 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4527, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 17)
				var lc194 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 75)
				lua_pushvalue(L, 7)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc194, 1)
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4536, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc195 int32 = 8
				)
				lc_getupvalue(L, -10002-1, 0, 19)
				lua_pushvalue(L, 8)
				lua_call(L, 1, 1)
				var lc196 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc196 != 0 {
					var lc197 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 66)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 3)
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc197
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4554, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc195)))
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4557, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc198 int32 = 8
				)
				lc_getupvalue(L, -10002-1, 0, 85)
				lua_pushvalue(L, 8)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc199 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc199 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4573, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc198)))
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4576, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc200 int32 = 8
				)
				lc_getupvalue(L, -10002-1, 0, 23)
				lua_pushvalue(L, 8)
				lc_getupvalue(L, -10002-1, 0, 46)
				lua_call(L, 2, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc201 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc201 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4593, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc200)))
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4596, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 17)
				var lc202 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 74)
				lua_pushvalue(L, 7)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc202, 1)
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4605, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc203 int32 = 9
				)
				lc_getupvalue(L, -10002-1, 0, 19)
				lua_pushvalue(L, 9)
				lua_call(L, 1, 1)
				var lc204 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc204 != 0 {
					var lc205 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 66)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 3)
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc205
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4623, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc203)))
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4626, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc206 int32 = 9
				)
				lc_getupvalue(L, -10002-1, 0, 82)
				lua_pushvalue(L, 9)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc207 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc207 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4642, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc206)))
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4645, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 81)
				lua_pushvalue(L, 9)
				lua_call(L, 1, 1)
				func() {
					if lua_gettop(L) == 10 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4651, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 17)
				var lc208 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 80)
				lua_pushvalue(L, 9)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc208, 1)
				func() {
					if lua_gettop(L) == 11 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4660, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc209 int32 = 11
				)
				lc_getupvalue(L, -10002-1, 0, 19)
				lua_pushvalue(L, 11)
				lua_call(L, 1, 1)
				var lc210 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc210 != 0 {
					var lc211 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 66)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 3)
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc211
					func() {
						if lua_gettop(L) == 11 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4678, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc209)))
				func() {
					if lua_gettop(L) == 11 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4681, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc212 int32 = 11
				)
				lc_getupvalue(L, -10002-1, 0, 78)
				lua_pushvalue(L, 11)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc213 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc213 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 11 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4697, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc212)))
				func() {
					if lua_gettop(L) == 11 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4700, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lua_createtable(L, 1, 0)
				var lc214 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 12)
				lua_pushvalue(L, 1)
				lua_call(L, 1, -1)
				for lua_gettop(L) > lc214 {
					lua_rawseti(L, lc214, 0+(lua_gettop(L)-lc214))
				}
				func() {
					if lua_gettop(L) == 12 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4711, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 2)
				func() {
					if lua_gettop(L) == 13 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4716, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				const (
					lc215 int32 = 13
				)
				for 1 != 0 {
					var lc216 float64 = float64(lua_objlen(L, 5))
					lua_pushnumber(L, lua_Number((lc216)))
					var lc217 int32 = lua_lessthan(L, 13, -1)
					lua_settop(L, -(1)-1)
					lua_pushboolean(L, lc217)
					if noarch.Not(lua_toboolean(L, -1)) {
						break
					}
					lua_settop(L, -(1)-1)
					lua_pushnumber(L, 1)
					lc_add(L, 13, -1)
					lua_remove(L, -2)
					lua_gettable(L, 5)
					lua_pushnumber(L, 1)
					lc_sub(L, 13, -1)
					lua_remove(L, -2)
					lua_pushnumber(L, 1)
					lc_add(L, -2, -1)
					lua_remove(L, -2)
					lua_remove(L, -2)
					lua_insert(L, -2)
					lua_settable(L, 12)
					func() {
						if lua_gettop(L) == 13 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4745, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 1)
					lc_add(L, 13, -1)
					lua_remove(L, -2)
					lua_replace(L, 13)
					func() {
						if lua_gettop(L) == 13 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4752, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc215)))
				func() {
					if lua_gettop(L) == 13 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4755, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				lua_settop(L, -(1)-1)
				func() {
					if lua_gettop(L) == 12 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4759, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
				var lc218 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 53)
				lua_pushvalue(L, 10)
				lua_pushvalue(L, 12)
				lua_call(L, 2, -1)
				return lua_gettop(L) - lc218
				func() {
					if lua_gettop(L) == 12 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4768, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc219 int32 = 6
				)
				lc_getupvalue(L, -10002-1, 0, 3)
				lua_pushnumber(L, 1)
				lua_gettable(L, 5)
				lc_getupvalue(L, -10002-1, 0, 26)
				lua_call(L, 2, 1)
				var lc220 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc220 != 0 {
					const (
						lc221 int32 = 6
					)
					var lc222 float64 = float64(lua_objlen(L, 5))
					lua_pushnumber(L, lua_Number((lc222)))
					lua_pushnumber(L, 1)
					var lc223 int32 = lua_equal(L, -2, -1)
					lua_settop(L, -(2)-1)
					lua_pushboolean(L, lc223)
					var lc224 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc224 != 0 {
						lua_pushvalue(L, 4)
						return 1
						func() {
							if lua_gettop(L) == 6 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4798, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc221)))
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4801, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 2)
					lua_gettable(L, 5)
					func() {
						if lua_gettop(L) == 7 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4806, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_createtable(L, 0, 0)
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4810, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 2)
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4815, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					const (
						lc225 int32 = 9
					)
					for 1 != 0 {
						var lc226 float64 = float64(lua_objlen(L, 5))
						lua_pushnumber(L, lua_Number((lc226)))
						var lc227 int32 = lua_lessthan(L, 9, -1)
						lua_settop(L, -(1)-1)
						lua_pushboolean(L, lc227)
						if noarch.Not(lua_toboolean(L, -1)) {
							break
						}
						lua_settop(L, -(1)-1)
						lc_getupvalue(L, -10002-1, 0, 66)
						lua_pushvalue(L, 1)
						lua_pushnumber(L, 1)
						lc_add(L, 9, -1)
						lua_remove(L, -2)
						lua_gettable(L, 5)
						lua_call(L, 2, 1)
						lua_pushnumber(L, 2)
						lc_sub(L, 9, -1)
						lua_remove(L, -2)
						lua_pushnumber(L, 1)
						lc_add(L, -2, -1)
						lua_remove(L, -2)
						lua_remove(L, -2)
						lua_insert(L, -2)
						lua_settable(L, 8)
						func() {
							if lua_gettop(L) == 9 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4847, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
							}
						}()
						lua_pushnumber(L, 1)
						lc_add(L, 9, -1)
						lua_remove(L, -2)
						lua_replace(L, 9)
						func() {
							if lua_gettop(L) == 9 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4854, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc225)))
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4857, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_settop(L, -(1)-1)
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4861, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					var lc228 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 57)
					lua_pushvalue(L, 7)
					lua_pushvalue(L, 8)
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc228
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4870, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				} else {
					lc_getupvalue(L, -10002-1, 0, 66)
					lua_pushvalue(L, 1)
					lua_pushnumber(L, 1)
					lua_gettable(L, 5)
					lua_call(L, 2, 1)
					func() {
						if lua_gettop(L) == 7 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4880, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_createtable(L, 0, 0)
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4884, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 1)
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4889, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					const (
						lc229 int32 = 9
					)
					for 1 != 0 {
						var lc230 float64 = float64(lua_objlen(L, 5))
						lua_pushnumber(L, lua_Number((lc230)))
						var lc231 int32 = lua_lessthan(L, 9, -1)
						lua_settop(L, -(1)-1)
						lua_pushboolean(L, lc231)
						if noarch.Not(lua_toboolean(L, -1)) {
							break
						}
						lua_settop(L, -(1)-1)
						lc_getupvalue(L, -10002-1, 0, 66)
						lua_pushvalue(L, 1)
						lua_pushnumber(L, 1)
						lc_add(L, 9, -1)
						lua_remove(L, -2)
						lua_gettable(L, 5)
						lua_call(L, 2, 1)
						lua_pushnumber(L, 1)
						lc_sub(L, 9, -1)
						lua_remove(L, -2)
						lua_pushnumber(L, 1)
						lc_add(L, -2, -1)
						lua_remove(L, -2)
						lua_remove(L, -2)
						lua_insert(L, -2)
						lua_settable(L, 8)
						func() {
							if lua_gettop(L) == 9 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4921, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
							}
						}()
						lua_pushnumber(L, 1)
						lc_add(L, 9, -1)
						lua_remove(L, -2)
						lua_replace(L, 9)
						func() {
							if lua_gettop(L) == 9 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4928, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc229)))
					func() {
						if lua_gettop(L) == 9 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4931, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					lua_settop(L, -(1)-1)
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4935, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
					var lc232 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 53)
					lua_pushvalue(L, 7)
					lua_pushvalue(L, 8)
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc232
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4944, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc219)))
			}
			lua_settop(L, int32((lc185)))
		}
		lua_settop(L, int32((lc175)))
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4951, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc233 int32 = 4
		)
		lc_getupvalue(L, -10002-1, 0, 78)
		lua_pushvalue(L, 3)
		lua_call(L, 1, 1)
		var lc234 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc234 != 0 {
			lua_pushvalue(L, 3)
			return 1
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4966, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc235 int32 = 4
			)
			lc_getupvalue(L, -10002-1, 0, 9)
			lua_pushvalue(L, 3)
			lua_call(L, 1, 1)
			var lc236 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc236 != 0 {
				var lc237 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 14)
				lua_pushvalue(L, 1)
				lua_pushvalue(L, 3)
				lua_pushvalue(L, 4)
				lua_call(L, 3, -1)
				return lua_gettop(L) - lc237
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 4986, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc238 int32 = 4
				)
				lc_getupvalue(L, -10002-1, 0, 72)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				var lc239 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc239 != 0 {
					lua_pushvalue(L, 4)
					return 1
					func() {
						if lua_gettop(L) == 4 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5001, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc238)))
			}
			lua_settop(L, int32((lc235)))
		}
		lua_settop(L, int32((lc233)))
	}
	lua_settop(L, int32((lc165)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5010, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
		}
	}()
	var lc240 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc240
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5017, []byte("int lcf1_real_evaluate(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_name_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5022
func lcf1_name_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 85)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 76)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
	}
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5037, []byte("int lcf1_name_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_error_v - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5042
func lcf1_make_error_v(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	var lc242 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 73)
	var lc243 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 48)
	lc_getupvalue(L, -10002-1, 1, 21)
	var lc244 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 26)
	lc_getupvalue(L, -10002-1, 1, 21)
	var lc245 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 31)
	lc_getupvalue(L, -10002-1, 1, 21)
	var lc246 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 104)
	lc_getupvalue(L, -10002-1, 1, 22)
	lc_getupvalue(L, -10002-1, 0, 105)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc246, -1)
	lua_call(L, lua_gettop(L)-lc245, -1)
	lua_call(L, lua_gettop(L)-lc244, -1)
	lua_call(L, lua_gettop(L)-lc243, -1)
	return lua_gettop(L) - lc242
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5070, []byte("int lcf1_make_error_v(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_real_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5075
func lcf1_real_apply(L []lua_State) (c4goDefaultReturn int32) {
	lua_checkstack(L, 23)
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc241 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc241)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc241)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5081, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 104)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 105)
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5089, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc241)))
	lua_pushcclosure(L, lcf1_make_error_v, 1)
	lua_replace(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5100, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 17)
	lc_getupvalue(L, int32((lc241)), 0, 104)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc241)), 0, 104)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5107, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc247 int32 = 4
	)
	lc_getupvalue(L, int32((lc241)), 1, 19)
	lc_getupvalue(L, int32((lc241)), 0, 104)
	lua_call(L, 1, 1)
	var lc248 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc248 != 0 {
		var lc249 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc241)), 1, 53)
		lc_getupvalue(L, int32((lc241)), 0, 104)
		lc_getupvalue(L, int32((lc241)), 0, 105)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc249
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5125, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc247)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5128, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc250 int32 = 4
	)
	lc_getupvalue(L, int32((lc241)), 1, 76)
	lc_getupvalue(L, int32((lc241)), 0, 104)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc251 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc251 != 0 {
		var lc252 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc252
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5146, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc250)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5149, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 18)
	var lc253 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc241)), 1, 75)
	lc_getupvalue(L, int32((lc241)), 0, 104)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc253, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5158, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc254 int32 = 5
	)
	lc_getupvalue(L, int32((lc241)), 1, 85)
	lua_pushvalue(L, 5)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc241)), 1, 23)
		lua_pushvalue(L, 5)
		lc_getupvalue(L, int32((lc241)), 1, 47)
		lua_call(L, 2, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc255 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc255 != 0 {
		var lc256 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc256
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5184, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc254)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5187, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 18)
	var lc257 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc241)), 1, 74)
	lc_getupvalue(L, int32((lc241)), 0, 104)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc257, 1)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5196, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc258 int32 = 6
	)
	lc_getupvalue(L, int32((lc241)), 1, 82)
	lua_pushvalue(L, 6)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc259 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc259 != 0 {
		var lc260 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc260
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5214, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc258)))
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5217, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 49)
	var lc261 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc241)), 1, 81)
	lua_pushvalue(L, 6)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc261, 1)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5226, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 18)
	var lc262 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc241)), 1, 80)
	lua_pushvalue(L, 6)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc262, 1)
	func() {
		if lua_gettop(L) == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5235, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc263 int32 = 8
	)
	lc_getupvalue(L, int32((lc241)), 1, 82)
	lua_pushvalue(L, 8)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc241)), 1, 78)
		var lc264 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc241)), 1, 18)
		var lc265 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc241)), 1, 80)
		lua_pushvalue(L, 8)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc265, -1)
		lua_call(L, lua_gettop(L)-lc264, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc266 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc266 != 0 {
		var lc267 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc267
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5266, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc263)))
	func() {
		if lua_gettop(L) == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5269, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 81)
	lua_pushvalue(L, 8)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5275, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc241)), 1, 16)
	func() {
		if lua_gettop(L) == 10 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5279, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5283, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc268 int32 = 11
	)
	for 1 != 0 {
		lc_getupvalue(L, int32((lc241)), 1, 78)
		lua_pushvalue(L, 7)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc269 int32 = 11
		)
		lc_getupvalue(L, int32((lc241)), 1, 9)
		lua_pushvalue(L, 7)
		lua_call(L, 1, 1)
		var lc270 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc270 != 0 {
			lc_getupvalue(L, int32((lc241)), 1, 79)
			func() {
				if lua_gettop(L) == 12 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5309, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc241)), 0, 105)
			var lc271 float64 = float64(lua_objlen(L, -1))
			lua_settop(L, -(1)-1)
			lua_pushnumber(L, lua_Number((lc271)))
			lua_pushnumber(L, 1)
			lc_sub(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			func() {
				if lua_gettop(L) == 13 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5321, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			const (
				lc272 int32 = 13
			)
			for 1 != 0 {
				lua_pushboolean(L, lc_le(L, 11, 13))
				if noarch.Not(lua_toboolean(L, -1)) {
					break
				}
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc241)), 1, 83)
				lc_getupvalue(L, int32((lc241)), 0, 105)
				lua_pushnumber(L, 1)
				lc_add(L, 13, -1)
				lua_remove(L, -2)
				lua_gettable(L, -2)
				lua_remove(L, -2)
				lua_pushvalue(L, 12)
				lua_call(L, 2, 1)
				lua_replace(L, 12)
				func() {
					if lua_gettop(L) == 13 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5343, []byte("int lcf1_real_apply(lua_State *)\x00"))
					}
				}()
				lua_pushnumber(L, 1)
				lc_sub(L, 13, -1)
				lua_remove(L, -2)
				lua_replace(L, 13)
				func() {
					if lua_gettop(L) == 13 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5350, []byte("int lcf1_real_apply(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc272)))
			func() {
				if lua_gettop(L) == 13 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5353, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			lua_settop(L, -(1)-1)
			func() {
				if lua_gettop(L) == 12 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5357, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc241)), 1, 15)
			lua_pushvalue(L, 10)
			lua_pushvalue(L, 7)
			lua_pushvalue(L, 12)
			lua_call(L, 3, 1)
			lua_replace(L, 10)
			func() {
				if lua_gettop(L) == 12 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5366, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc241)), 0, 105)
			var lc273 float64 = float64(lua_objlen(L, -1))
			lua_settop(L, -(1)-1)
			lua_pushnumber(L, lua_Number((lc273)))
			lua_replace(L, 11)
			func() {
				if lua_gettop(L) == 12 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5374, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc241)), 1, 79)
			lua_replace(L, 7)
			func() {
				if lua_gettop(L) == 12 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5379, []byte("int lcf1_real_apply(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc274 int32 = 11
			)
			lc_getupvalue(L, int32((lc241)), 1, 82)
			lua_pushvalue(L, 7)
			lua_call(L, 1, 1)
			var lc275 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc275 != 0 {
				const (
					lc276 int32 = 11
				)
				lc_getupvalue(L, int32((lc241)), 0, 105)
				var lc277 float64 = float64(lua_objlen(L, -1))
				lua_settop(L, -(1)-1)
				lua_pushnumber(L, lua_Number((lc277)))
				var lc278 int32 = lua_lessthan(L, 11, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc278)
				var lc279 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc279 != 0 {
					lc_getupvalue(L, int32((lc241)), 0, 105)
					lua_pushnumber(L, 1)
					lc_add(L, 11, -1)
					lua_remove(L, -2)
					lua_gettable(L, -2)
					lua_remove(L, -2)
					func() {
						if lua_gettop(L) == 12 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5411, []byte("int lcf1_real_apply(lua_State *)\x00"))
						}
					}()
					lua_pushnumber(L, 1)
					lc_add(L, 11, -1)
					lua_remove(L, -2)
					lua_replace(L, 11)
					func() {
						if lua_gettop(L) == 12 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5418, []byte("int lcf1_real_apply(lua_State *)\x00"))
						}
					}()
					lc_getupvalue(L, int32((lc241)), 1, 15)
					lua_pushvalue(L, 10)
					lc_getupvalue(L, int32((lc241)), 1, 81)
					lua_pushvalue(L, 7)
					lua_call(L, 1, 1)
					lua_pushvalue(L, 12)
					lua_call(L, 3, 1)
					lua_replace(L, 10)
					func() {
						if lua_gettop(L) == 12 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5429, []byte("int lcf1_real_apply(lua_State *)\x00"))
						}
					}()
					lc_getupvalue(L, int32((lc241)), 1, 80)
					lua_pushvalue(L, 7)
					lua_call(L, 1, 1)
					lua_replace(L, 7)
					func() {
						if lua_gettop(L) == 12 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5436, []byte("int lcf1_real_apply(lua_State *)\x00"))
						}
					}()
				} else {
					var lc280 int32 = lua_gettop(L)
					lua_pushvalue(L, 4)
					lua_call(L, 0, -1)
					return lua_gettop(L) - lc280
					func() {
						if lua_gettop(L) == 11 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5445, []byte("int lcf1_real_apply(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc276)))
				func() {
					if lua_gettop(L) == 11 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5448, []byte("int lcf1_real_apply(lua_State *)\x00"))
					}
				}()
			} else {
				var lc281 int32 = lua_gettop(L)
				lua_pushvalue(L, 4)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc281
				func() {
					if lua_gettop(L) == 11 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5457, []byte("int lcf1_real_apply(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc274)))
		}
		lua_settop(L, int32((lc269)))
		func() {
			if lua_gettop(L) == 11 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5462, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc268)))
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5465, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc282 int32 = 11
	)
	lc_getupvalue(L, int32((lc241)), 0, 105)
	var lc283 float64 = float64(lua_objlen(L, -1))
	lua_settop(L, -(1)-1)
	lua_pushnumber(L, lua_Number((lc283)))
	var lc284 int32 = lua_equal(L, -1, 11)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc284)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc285 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc285 != 0 {
		var lc286 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc286
		func() {
			if lua_gettop(L) == 11 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5487, []byte("int lcf1_real_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc282)))
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5490, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	var lc287 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc241)), 1, 66)
	lua_pushvalue(L, 10)
	lua_pushvalue(L, 9)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc287
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5499, []byte("int lcf1_real_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_real_builtin_func_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5504
func lcf1_real_builtin_func_apply(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 0, 73)
	var lc288 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 48)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc289 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 26)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc290 int32 = lua_gettop(L)
	lua_pushvalue(L, 1)
	lc_getupvalue(L, -10002-1, 0, 22)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc290, -1)
	lua_call(L, lua_gettop(L)-lc289, -1)
	lua_call(L, lua_gettop(L)-lc288, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5526, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5531, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc291 int32 = 4
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 8)
		var lc292 float64 = float64(lua_objlen(L, -1))
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, lua_Number((lc292)))
		var lc293 int32 = lua_lessthan(L, 4, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc293)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc294 int32 = 4
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushvalue(L, 1)
		lc_getupvalue(L, -10002-1, 0, 8)
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushnumber(L, 1)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_call(L, 2, 1)
		var lc295 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc295 != 0 {
			lc_getupvalue(L, -10002-1, 0, 8)
			lua_pushnumber(L, 1)
			lc_add(L, 4, -1)
			lua_remove(L, -2)
			lua_gettable(L, -2)
			lua_remove(L, -2)
			lua_pushnumber(L, 2)
			lua_gettable(L, -2)
			lua_remove(L, -2)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5576, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
				}
			}()
			const (
				lc296 int32 = 5
			)
			var lc297 float64 = float64(lua_objlen(L, 2))
			lua_pushnumber(L, lua_Number((lc297)))
			var lc298 int32 = lua_equal(L, -1, 5)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc298)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc299 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc299 != 0 {
				lua_pushvalue(L, 3)
				return 1
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5594, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc296)))
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5597, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, -10002-1, 0, 8)
			lua_pushnumber(L, 1)
			lc_add(L, 4, -1)
			lua_remove(L, -2)
			lua_gettable(L, -2)
			lua_remove(L, -2)
			lua_pushnumber(L, 3)
			lua_gettable(L, -2)
			lua_remove(L, -2)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5609, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
				}
			}()
			const (
				lc300 int32 = 6
			)
			lua_pushnumber(L, 1)
			var lc301 int32 = lua_equal(L, 5, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc301)
			var lc302 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc302 != 0 {
				var lc303 int32 = lua_gettop(L)
				lua_pushvalue(L, 6)
				lua_pushnumber(L, 1)
				lua_gettable(L, 2)
				lua_pushvalue(L, 3)
				lua_call(L, 2, -1)
				return lua_gettop(L) - lc303
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5629, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc304 int32 = 6
				)
				lua_pushnumber(L, 2)
				var lc305 int32 = lua_equal(L, 5, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc305)
				var lc306 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc306 != 0 {
					var lc307 int32 = lua_gettop(L)
					lua_pushvalue(L, 6)
					lua_pushnumber(L, 1)
					lua_gettable(L, 2)
					lua_pushnumber(L, 2)
					lua_gettable(L, 2)
					lua_pushvalue(L, 3)
					lua_call(L, 3, -1)
					return lua_gettop(L) - lc307
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5652, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc308 int32 = 6
					)
					lua_pushnumber(L, 3)
					var lc309 int32 = lua_equal(L, 5, -1)
					lua_settop(L, -(1)-1)
					lua_pushboolean(L, lc309)
					var lc310 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc310 != 0 {
						var lc311 int32 = lua_gettop(L)
						lua_pushvalue(L, 6)
						lua_pushnumber(L, 1)
						lua_gettable(L, 2)
						lua_pushnumber(L, 2)
						lua_gettable(L, 2)
						lua_pushnumber(L, 3)
						lua_gettable(L, 2)
						lua_pushvalue(L, 3)
						lua_call(L, 4, -1)
						return lua_gettop(L) - lc311
						func() {
							if lua_gettop(L) == 6 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5677, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc308)))
				}
				lua_settop(L, int32((lc304)))
			}
			lua_settop(L, int32((lc300)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5684, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
				}
			}()
			var lc312 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 0, 96)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc312
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5691, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc294)))
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5694, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_replace(L, 4)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5701, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc291)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5704, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5708, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5713, []byte("int lcf1_real_builtin_func_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_real_builtin_form_apply - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5718
func lcf1_real_builtin_form_apply(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lc_getupvalue(L, -10002-1, 0, 73)
	var lc313 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 48)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc314 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 25)
	lc_getupvalue(L, -10002-1, 0, 21)
	var lc315 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 12)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushvalue(L, 2)
	lc_getupvalue(L, -10002-1, 0, 22)
	lua_pushvalue(L, 3)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc315, -1)
	lua_call(L, lua_gettop(L)-lc314, -1)
	lua_call(L, lua_gettop(L)-lc313, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5743, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
		}
	}()
	const (
		lc316 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 0, 3)
	lua_pushvalue(L, 2)
	lc_getupvalue(L, -10002-1, 0, 28)
	lua_call(L, 2, 1)
	var lc317 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc317 != 0 {
		const (
			lc318 int32 = 4
		)
		var lc319 float64 = float64(lua_objlen(L, 3))
		lua_pushnumber(L, lua_Number((lc319)))
		lua_pushnumber(L, 1)
		var lc320 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc320)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc321 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc321 != 0 {
			lua_pushvalue(L, 4)
			return 1
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5772, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc318)))
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5775, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lua_gettable(L, 3)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5781, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc322 int32 = 4
		)
		lc_getupvalue(L, -10002-1, 0, 3)
		lua_pushvalue(L, 2)
		lc_getupvalue(L, -10002-1, 0, 27)
		lua_call(L, 2, 1)
		var lc323 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc323 != 0 {
			const (
				lc324 int32 = 4
			)
			var lc325 float64 = float64(lua_objlen(L, 3))
			lua_pushnumber(L, lua_Number((lc325)))
			lua_pushnumber(L, 2)
			var lc326 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc326)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc327 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc327 != 0 {
				lua_pushvalue(L, 4)
				return 1
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5811, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc324)))
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5814, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
				}
			}()
			var lc328 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 0, 4)
			lua_pushvalue(L, 1)
			lua_pushnumber(L, 1)
			lua_gettable(L, 3)
			lua_pushnumber(L, 2)
			lua_gettable(L, 3)
			lua_pushvalue(L, 4)
			lua_call(L, 4, -1)
			return lua_gettop(L) - lc328
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5827, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc322)))
	}
	lua_settop(L, int32((lc316)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5832, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 4)
	return 1
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5837, []byte("int lcf1_real_builtin_form_apply(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_make_error_v - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5842
func lcf2_make_error_v(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc333 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 109)
	lua_pushboolean(L, 0)
	var lc334 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc334)
	var lc335 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc335 != 0 {
		var lc336 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 73)
		var lc337 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 48)
		lc_getupvalue(L, -10002-1, 1, 21)
		var lc338 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 25)
		lc_getupvalue(L, -10002-1, 1, 21)
		var lc339 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 12)
		lc_getupvalue(L, -10002-1, 0, 106)
		lua_call(L, 1, 1)
		lc_getupvalue(L, -10002-1, 1, 27)
		lc_getupvalue(L, -10002-1, 1, 22)
		lua_createtable(L, 2, 0)
		lc_getupvalue(L, -10002-1, 0, 107)
		lua_rawseti(L, -2, 1)
		lc_getupvalue(L, -10002-1, 0, 108)
		lua_rawseti(L, -2, 2)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc339, -1)
		lua_call(L, lua_gettop(L)-lc338, -1)
		lua_call(L, lua_gettop(L)-lc337, -1)
		return lua_gettop(L) - lc336
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5884, []byte("int lcf2_make_error_v(lua_State *)\x00"))
			}
		}()
	} else {
		lc_getupvalue(L, -10002-1, 0, 109)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5891, []byte("int lcf2_make_error_v(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc333)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5894, []byte("int lcf2_make_error_v(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_make_quote - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5900
func lcf1_make_quote(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc340 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 21)
	lc_getupvalue(L, -10002-1, 1, 25)
	lc_getupvalue(L, -10002-1, 1, 28)
	lua_pushvalue(L, 1)
	lua_call(L, 3, -1)
	return lua_gettop(L) - lc340
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5913, []byte("int lcf1_make_quote(lua_State *)\x00"))
		}
	}()
	return
}

// lcf356 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5917
func lcf356(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5924, []byte("int lcf356(lua_State *)\x00"))
		}
	}()
	const (
		lc351 int32 = 3
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 1, 110)
		var lc352 float64 = float64(lua_objlen(L, -1))
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, lua_Number((lc352)))
		var lc353 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc353)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc354 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 3, 3)
		lc_getupvalue(L, -10002-1, 1, 110)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushvalue(L, 1)
		lua_call(L, 2, 1)
		var lc355 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc355 != 0 {
			return 0
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5958, []byte("int lcf356(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc354)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5961, []byte("int lcf356(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5968, []byte("int lcf356(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc351)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5971, []byte("int lcf356(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5975, []byte("int lcf356(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 4, 1)
	lc_getupvalue(L, -10002-1, 0, 111)
	lua_pushvalue(L, 1)
	lua_call(L, 2, 0)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5982, []byte("int lcf356(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_new_lambda - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:5988
func lcf1_new_lambda(L []lua_State) (c4goDefaultReturn int32) {
	lua_checkstack(L, 25)
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	lc_newclosuretable(L, -10002-1)
	const (
		lc329 int32 = 5
	)
	func() {
		if lua_gettop(L) == int32((lc329)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc329)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 5994, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 106)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 107)
	lua_pushvalue(L, 3)
	lua_rawseti(L, -2, 108)
	lua_pushvalue(L, 4)
	lua_rawseti(L, -2, 109)
	const (
		lc330 int32 = 5
	)
	lc_getupvalue(L, int32((lc329)), 0, 109)
	lua_pushnil(L)
	var lc331 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc331)
	var lc332 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc332 != 0 {
		lua_pushboolean(L, 0)
		lc_setupvalue(L, int32((lc329)), 0, 109)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6018, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc330)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6021, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6025, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc329)))
	lua_pushcclosure(L, lcf2_make_error_v, 1)
	lua_replace(L, 6)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6039, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6043, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc329)))
	lua_pushcclosure(L, lcf1_make_quote, 1)
	lua_replace(L, 7)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6052, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc329)), 1, 49)
	lc_getupvalue(L, int32((lc329)), 0, 107)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc329)), 0, 107)
	func() {
		if lua_gettop(L) == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6059, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc329)))
	const (
		lc341 int32 = 8
	)
	func() {
		if lua_gettop(L) == int32((lc341)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc341)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6064, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	lua_rawseti(L, int32((lc341)), 110)
	func() {
		if lua_gettop(L) == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6067, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 0)
	func() {
		if lua_gettop(L) == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6071, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc341)), 1, 107)
	func() {
		if lua_gettop(L) == 10 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6075, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	const (
		lc342 int32 = 10
	)
	for 1 != 0 {
		lc_getupvalue(L, int32((lc341)), 2, 78)
		lua_pushvalue(L, 10)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc343 int32 = 10
		)
		lc_getupvalue(L, int32((lc341)), 2, 9)
		lua_pushvalue(L, 10)
		lua_call(L, 1, 1)
		var lc344 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc344 != 0 {
			lc_getupvalue(L, int32((lc341)), 3, 1)
			lc_getupvalue(L, int32((lc341)), 0, 110)
			lua_pushvalue(L, 10)
			lua_call(L, 2, 0)
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6104, []byte("int lcf1_new_lambda(lua_State *)\x00"))
				}
			}()
			lua_pushboolean(L, 1)
			lua_replace(L, 9)
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6109, []byte("int lcf1_new_lambda(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc341)), 2, 79)
			lua_replace(L, 10)
			func() {
				if lua_gettop(L) == 10 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6114, []byte("int lcf1_new_lambda(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc345 int32 = 10
			)
			lc_getupvalue(L, int32((lc341)), 2, 82)
			lua_pushvalue(L, 10)
			lua_call(L, 1, 1)
			var lc346 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc346 != 0 {
				lc_getupvalue(L, int32((lc341)), 3, 1)
				var lc347 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc341)), 0, 110)
				lc_getupvalue(L, int32((lc341)), 2, 81)
				lua_pushvalue(L, 10)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc347, 0)
				func() {
					if lua_gettop(L) == 10 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6134, []byte("int lcf1_new_lambda(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, int32((lc341)), 2, 80)
				lua_pushvalue(L, 10)
				lua_call(L, 1, 1)
				lua_replace(L, 10)
				func() {
					if lua_gettop(L) == 10 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6141, []byte("int lcf1_new_lambda(lua_State *)\x00"))
					}
				}()
			} else {
				var lc348 int32 = lua_gettop(L)
				lua_pushvalue(L, 6)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc348
				func() {
					if lua_gettop(L) == 10 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6150, []byte("int lcf1_new_lambda(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc345)))
		}
		lua_settop(L, int32((lc343)))
		func() {
			if lua_gettop(L) == 10 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6155, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc342)))
	func() {
		if lua_gettop(L) == 10 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6158, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc341)), 1, 107)
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6162, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	const (
		lc349 int32 = 11
	)
	if lua_toboolean(L, 9) != 0 {
		lc_getupvalue(L, int32((lc341)), 2, 22)
		lc_getupvalue(L, int32((lc341)), 0, 110)
		lua_call(L, 1, 1)
		lua_replace(L, 11)
		func() {
			if lua_gettop(L) == 11 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6173, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc349)))
	func() {
		if lua_gettop(L) == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6176, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc341)))
	const (
		lc350 int32 = 12
	)
	func() {
		if lua_gettop(L) == int32((lc350)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc350)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6181, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	lua_rawseti(L, int32((lc350)), 111)
	func() {
		if lua_gettop(L) == 12 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6184, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc350)), 3, 11)
	lc_getupvalue(L, int32((lc350)), 2, 106)
	lua_pushvalue(L, int32((lc350)))
	lua_pushcclosure(L, lcf356, 1)
	lua_call(L, 2, 0)
	func() {
		if lua_gettop(L) == 12 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6203, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 11)
	func() {
		if lua_gettop(L) == 13 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6207, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc350)), 0, 111)
	var lc357 float64 = float64(lua_objlen(L, -1))
	lua_settop(L, -(1)-1)
	lua_pushnumber(L, lua_Number((lc357)))
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	func() {
		if lua_gettop(L) == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6219, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	const (
		lc358 int32 = 14
	)
	for 1 != 0 {
		lua_pushnumber(L, 0)
		var lc359 int32 = lc_le(L, -1, 14)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc359)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc350)), 3, 83)
		lc_getupvalue(L, int32((lc350)), 0, 111)
		lua_pushnumber(L, 1)
		lc_add(L, 14, -1)
		lua_remove(L, -2)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_pushvalue(L, 13)
		lua_call(L, 2, 1)
		lua_replace(L, 13)
		func() {
			if lua_gettop(L) == 14 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6244, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_sub(L, 14, -1)
		lua_remove(L, -2)
		lua_replace(L, 14)
		func() {
			if lua_gettop(L) == 14 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6251, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc358)))
	func() {
		if lua_gettop(L) == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6254, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 13 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6258, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 11)
	func() {
		if lua_gettop(L) == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6262, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc350)), 0, 111)
	var lc360 float64 = float64(lua_objlen(L, -1))
	lua_settop(L, -(1)-1)
	lua_pushnumber(L, lua_Number((lc360)))
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	func() {
		if lua_gettop(L) == 15 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6274, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	const (
		lc361 int32 = 15
	)
	for 1 != 0 {
		lua_pushnumber(L, 0)
		var lc362 int32 = lc_le(L, -1, 15)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc362)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc350)), 3, 83)
		lua_pushvalue(L, 7)
		var lc363 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc350)), 3, 13)
		lc_getupvalue(L, int32((lc350)), 2, 106)
		lc_getupvalue(L, int32((lc350)), 0, 111)
		lua_pushnumber(L, 1)
		lc_add(L, 15, -1)
		lua_remove(L, -2)
		lua_gettable(L, -2)
		lua_remove(L, -2)
		lua_call(L, 2, -1)
		lua_call(L, lua_gettop(L)-lc363, 1)
		lua_pushvalue(L, 14)
		lua_call(L, 2, 1)
		lua_replace(L, 14)
		func() {
			if lua_gettop(L) == 15 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6306, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_sub(L, 15, -1)
		lua_remove(L, -2)
		lua_replace(L, 15)
		func() {
			if lua_gettop(L) == 15 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6313, []byte("int lcf1_new_lambda(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc361)))
	func() {
		if lua_gettop(L) == 15 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6316, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6320, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	var lc364 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc350)), 3, 77)
	var lc365 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc350)), 3, 47)
	lc_getupvalue(L, int32((lc350)), 3, 21)
	var lc366 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc350)), 2, 107)
	lc_getupvalue(L, int32((lc350)), 3, 83)
	lua_pushvalue(L, 7)
	var lc367 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc350)), 3, 77)
	var lc368 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc350)), 3, 47)
	lc_getupvalue(L, int32((lc350)), 3, 21)
	lua_pushvalue(L, 13)
	lc_getupvalue(L, int32((lc350)), 2, 108)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc368, -1)
	lua_call(L, lua_gettop(L)-lc367, 1)
	lua_pushvalue(L, 14)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc366, -1)
	lua_call(L, lua_gettop(L)-lc365, -1)
	return lua_gettop(L) - lc364
	func() {
		if lua_gettop(L) == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6349, []byte("int lcf1_new_lambda(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_end_2 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:6354
func lcf1_end_2(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	const (
		lc375 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 0, 3)
	var lc376 int32 = lua_gettop(L)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc376, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 3)
		var lc377 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		lua_pushvalue(L, 4)
		lua_pushvalue(L, 2)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc377, 1)
	}
	var lc378 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc378 != 0 {
		lc_getupvalue(L, -10002-1, 0, 69)
		lua_pushvalue(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6390, []byte("int lcf1_end_2(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6395, []byte("int lcf1_end_2(lua_State *)\x00"))
			}
		}()
	} else {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6402, []byte("int lcf1_end_2(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc375)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6405, []byte("int lcf1_end_2(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_jsbool_equal_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:6411
func lcf1_jsbool_equal_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	const (
		lc369 int32 = 2
	)
	var lc370 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc370)
	var lc371 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc371 != 0 {
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6426, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc369)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6429, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 18)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6436, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 18)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6443, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	const (
		lc372 int32 = 2
	)
	var lc373 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc373)
	var lc374 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc374 != 0 {
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6456, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc372)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6459, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6463, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf1_end_2, 1)
	lua_replace(L, 3)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6477, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	const (
		lc379 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 0, 78)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc380 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc380 != 0 {
		const (
			lc381 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 0, 78)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc382 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc382 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6502, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc381)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6505, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 69)
		lua_pushvalue(L, 1)
		lc_getupvalue(L, -10002-1, 0, 79)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6512, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 69)
		lua_pushvalue(L, 2)
		lc_getupvalue(L, -10002-1, 0, 79)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6519, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6524, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc383 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 0, 85)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		var lc384 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc384 != 0 {
			const (
				lc385 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 0, 85)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc386 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc386 != 0 {
				lua_pushboolean(L, 0)
				return 1
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6550, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc385)))
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6553, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
				}
			}()
			var lc387 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 0, 23)
			lua_pushvalue(L, 1)
			lua_pushvalue(L, 2)
			lua_call(L, 2, -1)
			return lua_gettop(L) - lc387
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6562, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc388 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 0, 82)
			lua_pushvalue(L, 1)
			lua_call(L, 1, 1)
			var lc389 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc389 != 0 {
				const (
					lc390 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 0, 82)
				lua_pushvalue(L, 2)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc391 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc391 != 0 {
					lua_pushboolean(L, 0)
					return 1
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6588, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc390)))
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6591, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
					}
				}()
				var lc392 int32 = lua_gettop(L)
				lua_pushvalue(L, 3)
				lua_pushvalue(L, 1)
				lua_pushvalue(L, 2)
				lc_getupvalue(L, -10002-1, 0, 81)
				lc_getupvalue(L, -10002-1, 0, 80)
				lua_call(L, 4, -1)
				return lua_gettop(L) - lc392
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6602, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc393 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 0, 72)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				var lc394 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc394 != 0 {
					const (
						lc395 int32 = 3
					)
					lc_getupvalue(L, -10002-1, 0, 72)
					lua_pushvalue(L, 2)
					lua_call(L, 1, 1)
					lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
					lua_remove(L, -2)
					var lc396 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc396 != 0 {
						lua_pushboolean(L, 0)
						return 1
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6628, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc395)))
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6631, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
						}
					}()
					var lc397 int32 = lua_gettop(L)
					lua_pushvalue(L, 3)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 2)
					lc_getupvalue(L, -10002-1, 0, 71)
					lc_getupvalue(L, -10002-1, 0, 70)
					lua_call(L, 4, -1)
					return lua_gettop(L) - lc397
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6642, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc398 int32 = 3
					)
					lc_getupvalue(L, -10002-1, 0, 76)
					lua_pushvalue(L, 1)
					lua_call(L, 1, 1)
					var lc399 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc399 != 0 {
						const (
							lc400 int32 = 3
						)
						lc_getupvalue(L, -10002-1, 0, 76)
						lua_pushvalue(L, 2)
						lua_call(L, 1, 1)
						lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
						lua_remove(L, -2)
						var lc401 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc401 != 0 {
							lua_pushboolean(L, 0)
							return 1
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6668, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc400)))
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6671, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
							}
						}()
						var lc402 int32 = lua_gettop(L)
						lua_pushvalue(L, 3)
						lua_pushvalue(L, 1)
						lua_pushvalue(L, 2)
						lc_getupvalue(L, -10002-1, 0, 75)
						lc_getupvalue(L, -10002-1, 0, 74)
						lua_call(L, 4, -1)
						return lua_gettop(L) - lc402
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6682, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc398)))
				}
				lua_settop(L, int32((lc393)))
			}
			lua_settop(L, int32((lc388)))
		}
		lua_settop(L, int32((lc383)))
	}
	lua_settop(L, int32((lc379)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6693, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	var lc403 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc403
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6700, []byte("int lcf1_jsbool_equal_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_simple_print - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:6705
func lcf1_simple_print(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 20)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6714, []byte("int lcf1_simple_print(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6718, []byte("int lcf1_simple_print(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6722, []byte("int lcf1_simple_print(lua_State *)\x00"))
		}
	}()
	const (
		lc404 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 0, 78)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc405 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc405 != 0 {
		lua_pushlstring(L, []byte("()\x00"), uint(3/1-1))
		return 1
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6736, []byte("int lcf1_simple_print(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc406 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 0, 82)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		var lc407 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc407 != 0 {
			lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
			lua_replace(L, 2)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6751, []byte("int lcf1_simple_print(lua_State *)\x00"))
				}
			}()
			lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
			lua_replace(L, 3)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6756, []byte("int lcf1_simple_print(lua_State *)\x00"))
				}
			}()
			const (
				lc408 int32 = 3
			)
			for 1 != 0 {
				lc_getupvalue(L, -10002-1, 0, 82)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				if noarch.Not(lua_toboolean(L, -1)) {
					break
				}
				lua_settop(L, -(1)-1)
				lua_pushvalue(L, 2)
				lua_pushvalue(L, 3)
				lc_getupvalue(L, -10002-1, 0, 2)
				var lc409 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 81)
				lua_pushvalue(L, 1)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc409, 1)
				lua_concat(L, 2)
				lua_concat(L, 2)
				lua_replace(L, 2)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6781, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
				lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
				lua_replace(L, 3)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6786, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, -10002-1, 0, 20)
				var lc410 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 80)
				lua_pushvalue(L, 1)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc410, 1)
				lua_replace(L, 1)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6796, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc408)))
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6799, []byte("int lcf1_simple_print(lua_State *)\x00"))
				}
			}()
			const (
				lc411 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 0, 78)
			lua_pushvalue(L, 1)
			lua_call(L, 1, 1)
			var lc412 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc412 != 0 {
				lua_pushvalue(L, 2)
				lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
				lua_concat(L, 2)
				lua_replace(L, 2)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6815, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
			} else {
				lua_pushvalue(L, 2)
				lua_pushlstring(L, []byte(" . \x00"), uint(4/1-1))
				lc_getupvalue(L, -10002-1, 0, 2)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				lua_concat(L, 2)
				lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
				lua_concat(L, 2)
				lua_concat(L, 2)
				lua_replace(L, 2)
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6830, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc411)))
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6833, []byte("int lcf1_simple_print(lua_State *)\x00"))
				}
			}()
			lua_pushvalue(L, 2)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6838, []byte("int lcf1_simple_print(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc413 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 0, 76)
			lua_pushvalue(L, 1)
			lua_call(L, 1, 1)
			var lc414 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc414 != 0 {
				lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
				lc_getupvalue(L, -10002-1, 0, 2)
				var lc415 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 83)
				var lc416 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 0, 75)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				lc_getupvalue(L, -10002-1, 0, 74)
				lua_pushvalue(L, 1)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc416, -1)
				lua_call(L, lua_gettop(L)-lc415, 1)
				lua_concat(L, 2)
				return 1
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6867, []byte("int lcf1_simple_print(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc417 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 0, 72)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				var lc418 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc418 != 0 {
					lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
					lc_getupvalue(L, -10002-1, 0, 2)
					var lc419 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 83)
					var lc420 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 0, 71)
					lua_pushvalue(L, 1)
					lua_call(L, 1, 1)
					lc_getupvalue(L, -10002-1, 0, 70)
					lua_pushvalue(L, 1)
					lua_call(L, 1, -1)
					lua_call(L, lua_gettop(L)-lc420, -1)
					lua_call(L, lua_gettop(L)-lc419, 1)
					lua_concat(L, 2)
					return 1
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6896, []byte("int lcf1_simple_print(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc421 int32 = 3
					)
					lc_getupvalue(L, -10002-1, 0, 85)
					lua_pushvalue(L, 1)
					lua_call(L, 1, 1)
					var lc422 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc422 != 0 {
						var lc423 int32 = lua_gettop(L)
						lc_getupvalue(L, -10002-1, 0, 84)
						lua_pushvalue(L, 1)
						lua_call(L, 1, -1)
						return lua_gettop(L) - lc423
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6914, []byte("int lcf1_simple_print(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc424 int32 = 3
						)
						lc_getupvalue(L, -10002-1, 0, 65)
						lua_pushvalue(L, 1)
						lua_call(L, 1, 1)
						var lc425 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc425 != 0 {
							lua_pushlstring(L, []byte("$(\x00"), uint(3/1-1))
							lc_getupvalue(L, -10002-1, 0, 2)
							var lc426 int32 = lua_gettop(L)
							lc_getupvalue(L, -10002-1, 0, 12)
							var lc427 int32 = lua_gettop(L)
							lc_getupvalue(L, -10002-1, 0, 64)
							lua_pushvalue(L, 1)
							lua_call(L, 1, -1)
							lua_call(L, lua_gettop(L)-lc427, -1)
							lua_call(L, lua_gettop(L)-lc426, 1)
							lua_concat(L, 2)
							lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
							lua_concat(L, 2)
							lc_getupvalue(L, -10002-1, 0, 2)
							var lc428 int32 = lua_gettop(L)
							lc_getupvalue(L, -10002-1, 0, 63)
							lua_pushvalue(L, 1)
							lua_call(L, 1, -1)
							lua_call(L, lua_gettop(L)-lc428, 1)
							lua_concat(L, 2)
							lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
							lua_concat(L, 2)
							return 1
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6951, []byte("int lcf1_simple_print(lua_State *)\x00"))
								}
							}()
						} else {
							const (
								lc429 int32 = 3
							)
							lc_getupvalue(L, -10002-1, 0, 56)
							lua_pushvalue(L, 1)
							lua_call(L, 1, 1)
							var lc430 int32 = lua_toboolean(L, -1)
							lua_settop(L, -(1)-1)
							if lc430 != 0 {
								lua_pushlstring(L, []byte("%(\x00"), uint(3/1-1))
								lc_getupvalue(L, -10002-1, 0, 2)
								var lc431 int32 = lua_gettop(L)
								lc_getupvalue(L, -10002-1, 0, 55)
								lua_pushvalue(L, 1)
								lua_call(L, 1, -1)
								lua_call(L, lua_gettop(L)-lc431, 1)
								lua_concat(L, 2)
								lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
								lua_concat(L, 2)
								lc_getupvalue(L, -10002-1, 0, 2)
								var lc432 int32 = lua_gettop(L)
								lc_getupvalue(L, -10002-1, 0, 22)
								var lc433 int32 = lua_gettop(L)
								lc_getupvalue(L, -10002-1, 0, 54)
								lua_pushvalue(L, 1)
								lua_call(L, 1, -1)
								lua_call(L, lua_gettop(L)-lc433, -1)
								lua_call(L, lua_gettop(L)-lc432, 1)
								lua_concat(L, 2)
								lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
								lua_concat(L, 2)
								return 1
								func() {
									if lua_gettop(L) == 3 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 6990, []byte("int lcf1_simple_print(lua_State *)\x00"))
									}
								}()
							} else {
								const (
									lc434 int32 = 3
								)
								lc_getupvalue(L, -10002-1, 0, 61)
								lua_pushvalue(L, 1)
								lua_call(L, 1, 1)
								var lc435 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc435 != 0 {
									lua_pushlstring(L, []byte("@(\x00"), uint(3/1-1))
									lc_getupvalue(L, -10002-1, 0, 2)
									var lc436 int32 = lua_gettop(L)
									lc_getupvalue(L, -10002-1, 0, 12)
									var lc437 int32 = lua_gettop(L)
									lc_getupvalue(L, -10002-1, 0, 60)
									lua_pushvalue(L, 1)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc437, -1)
									lua_call(L, lua_gettop(L)-lc436, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
									lua_concat(L, 2)
									lc_getupvalue(L, -10002-1, 0, 2)
									var lc438 int32 = lua_gettop(L)
									lc_getupvalue(L, -10002-1, 0, 59)
									lua_pushvalue(L, 1)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc438, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
									lua_concat(L, 2)
									lc_getupvalue(L, -10002-1, 0, 2)
									var lc439 int32 = lua_gettop(L)
									lc_getupvalue(L, -10002-1, 0, 22)
									var lc440 int32 = lua_gettop(L)
									lc_getupvalue(L, -10002-1, 0, 58)
									lua_pushvalue(L, 1)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc440, -1)
									lua_call(L, lua_gettop(L)-lc439, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
									lua_concat(L, 2)
									return 1
									func() {
										if lua_gettop(L) == 3 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7042, []byte("int lcf1_simple_print(lua_State *)\x00"))
										}
									}()
								} else {
									const (
										lc441 int32 = 3
									)
									lc_getupvalue(L, -10002-1, 0, 52)
									lua_pushvalue(L, 1)
									lua_call(L, 1, 1)
									var lc442 int32 = lua_toboolean(L, -1)
									lua_settop(L, -(1)-1)
									if lc442 != 0 {
										lua_pushlstring(L, []byte("^(\x00"), uint(3/1-1))
										lc_getupvalue(L, -10002-1, 0, 2)
										var lc443 int32 = lua_gettop(L)
										lc_getupvalue(L, -10002-1, 0, 51)
										lua_pushvalue(L, 1)
										lua_call(L, 1, -1)
										lua_call(L, lua_gettop(L)-lc443, 1)
										lua_concat(L, 2)
										lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
										lua_concat(L, 2)
										lc_getupvalue(L, -10002-1, 0, 2)
										var lc444 int32 = lua_gettop(L)
										lc_getupvalue(L, -10002-1, 0, 22)
										var lc445 int32 = lua_gettop(L)
										lc_getupvalue(L, -10002-1, 0, 50)
										lua_pushvalue(L, 1)
										lua_call(L, 1, -1)
										lua_call(L, lua_gettop(L)-lc445, -1)
										lua_call(L, lua_gettop(L)-lc444, 1)
										lua_concat(L, 2)
										lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
										lua_concat(L, 2)
										return 1
										func() {
											if lua_gettop(L) == 3 {
											} else {
												linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7080, []byte("int lcf1_simple_print(lua_State *)\x00"))
											}
										}()
									}
									lua_settop(L, int32((lc441)))
								}
								lua_settop(L, int32((lc434)))
							}
							lua_settop(L, int32((lc429)))
						}
						lua_settop(L, int32((lc424)))
					}
					lua_settop(L, int32((lc421)))
				}
				lua_settop(L, int32((lc417)))
			}
			lua_settop(L, int32((lc413)))
		}
		lua_settop(L, int32((lc406)))
	}
	lua_settop(L, int32((lc404)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7099, []byte("int lcf1_simple_print(lua_State *)\x00"))
		}
	}()
	var lc446 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc446
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7106, []byte("int lcf1_simple_print(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_new_symbol - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7111
func lcf1_new_symbol(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_createtable(L, 2, 0)
	lc_getupvalue(L, -10002-1, 1, 112)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 2)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7122, []byte("int lcf1_new_symbol(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_systemName_make - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7127
func lcf1_systemName_make(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc459 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 11, 77)
	var lc460 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 8, 114)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 11, 48)
	lua_pushvalue(L, 1)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc460, -1)
	return lua_gettop(L) - lc459
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7142, []byte("int lcf1_systemName_make(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_builtin_f_new_sym_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7147
func lcf1_make_builtin_f_new_sym_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc461 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 122)
	var lc462 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 5, 117)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 11, 47)
	lc_getupvalue(L, -10002-1, 6, 116)
	lua_pushvalue(L, 1)
	lua_call(L, 3, 1)
	lc_getupvalue(L, -10002-1, 7, 115)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc462, -1)
	return lua_gettop(L) - lc461
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7167, []byte("int lcf1_make_builtin_f_new_sym_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_builtin_f_get_sym_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7172
func lcf1_make_builtin_f_get_sym_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc463 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 122)
	var lc464 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 5, 117)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 11, 47)
	lc_getupvalue(L, -10002-1, 11, 21)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 6, 116)
	lua_call(L, 3, 1)
	lua_pushvalue(L, 2)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc464, -1)
	return lua_gettop(L) - lc463
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7194, []byte("int lcf1_make_builtin_f_get_sym_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_builtin_f_p_sym_f - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7199
func lcf1_make_builtin_f_p_sym_f(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc465 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 122)
	var lc466 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 11, 21)
	var lc467 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 5, 117)
	lc_getupvalue(L, -10002-1, 11, 47)
	lc_getupvalue(L, -10002-1, 11, 21)
	var lc468 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 4, 118)
	lc_getupvalue(L, -10002-1, 11, 21)
	lc_getupvalue(L, -10002-1, 5, 117)
	lua_pushvalue(L, 1)
	lc_getupvalue(L, -10002-1, 6, 116)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc468, -1)
	lua_call(L, lua_gettop(L)-lc467, -1)
	lua_call(L, lua_gettop(L)-lc466, -1)
	return lua_gettop(L) - lc465
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7225, []byte("int lcf1_make_builtin_f_p_sym_f(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_list_to_jsArray - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7230
func lcf1_list_to_jsArray(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7236, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
		}
	}()
	const (
		lc489 int32 = 4
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 15, 82)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 16, 1)
		var lc490 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lc_getupvalue(L, -10002-1, 15, 81)
		lua_pushvalue(L, 1)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc490, 0)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7257, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 15, 80)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7264, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc489)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7267, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
		}
	}()
	const (
		lc491 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 15, 78)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc492 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc492 != 0 {
		var lc493 int32 = lua_gettop(L)
		lua_pushvalue(L, 2)
		lua_pushvalue(L, 4)
		lua_call(L, 1, -1)
		return lua_gettop(L) - lc493
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7284, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc491)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7287, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
		}
	}()
	var lc494 int32 = lua_gettop(L)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 4)
	lua_pushvalue(L, 1)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc494
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7296, []byte("int lcf1_list_to_jsArray(lua_State *)\x00"))
		}
	}()
	return
}

// lcf497 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7300
func lcf497(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7307, []byte("int lcf497(lua_State *)\x00"))
		}
	}()
	return
}

// lcf498 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7311
func lcf498(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lua_pushboolean(L, 0)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7318, []byte("int lcf498(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_maybe_list_to_jsArray - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7323
func lcf1_maybe_list_to_jsArray(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc496 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 126)
	lua_pushvalue(L, 1)
	lua_pushcclosure(L, lcf497, 0)
	lua_pushcclosure(L, lcf498, 0)
	lua_call(L, 3, -1)
	return lua_gettop(L) - lc496
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7339, []byte("int lcf1_maybe_list_to_jsArray(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_val2env - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7344
func lcf1_val2env(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 17, 18)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7353, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc500 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 17, 76)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc501 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc501 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7369, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc500)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7372, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 18)
	var lc502 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 75)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc502, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7381, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc503 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 85)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc504 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc504 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7397, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc503)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7400, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc505 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 23)
	lua_pushvalue(L, 2)
	lc_getupvalue(L, -10002-1, 17, 45)
	lua_call(L, 2, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc506 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc506 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7417, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc505)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7420, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 18)
	var lc507 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 74)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc507, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7430, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc508 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc509 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc509 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7446, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc508)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7449, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc510 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 78)
	var lc511 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 18)
	var lc512 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc512, -1)
	lua_call(L, lua_gettop(L)-lc511, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc513 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc513 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7471, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc510)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7474, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7478, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 18)
	var lc514 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc514, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7487, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	const (
		lc515 int32 = 4
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 17, 78)
		lua_pushvalue(L, 4)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc516 int32 = 4
		)
		lc_getupvalue(L, -10002-1, 17, 82)
		lua_pushvalue(L, 4)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc517 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc517 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7516, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc516)))
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7519, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 18)
		var lc518 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 81)
		lua_pushvalue(L, 4)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc518, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7528, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 18)
		var lc519 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 80)
		lua_pushvalue(L, 4)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc519, 1)
		lua_replace(L, 4)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7538, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		const (
			lc520 int32 = 5
		)
		lc_getupvalue(L, -10002-1, 17, 82)
		lua_pushvalue(L, 5)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc521 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc521 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7554, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc520)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7557, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 81)
		lua_pushvalue(L, 5)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7563, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 18)
		var lc522 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 80)
		lua_pushvalue(L, 5)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc522, 1)
		lua_replace(L, 5)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7573, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		const (
			lc523 int32 = 6
		)
		lc_getupvalue(L, -10002-1, 17, 82)
		lua_pushvalue(L, 5)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc524 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc524 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7589, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc523)))
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7592, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 81)
		lua_pushvalue(L, 5)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 7 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7598, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		const (
			lc525 int32 = 7
		)
		lc_getupvalue(L, -10002-1, 17, 78)
		var lc526 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 18)
		var lc527 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 80)
		lua_pushvalue(L, 5)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc527, -1)
		lua_call(L, lua_gettop(L)-lc526, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc528 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc528 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 7 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7620, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc525)))
		func() {
			if lua_gettop(L) == 7 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7623, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7627, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 0)
		func() {
			if lua_gettop(L) == 9 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7632, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		const (
			lc529 int32 = 9
		)
		for 1 != 0 {
			var lc530 float64 = float64(lua_objlen(L, 3))
			lua_pushnumber(L, lua_Number((lc530)))
			var lc531 int32 = lua_lessthan(L, 9, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc531)
			if noarch.Not(lua_toboolean(L, -1)) {
				break
			}
			lua_settop(L, -(1)-1)
			const (
				lc532 int32 = 9
			)
			lc_getupvalue(L, -10002-1, 17, 3)
			lua_pushnumber(L, 0)
			lc_add(L, 9, -1)
			lua_remove(L, -2)
			lua_pushnumber(L, 1)
			lc_add(L, -2, -1)
			lua_remove(L, -2)
			lua_remove(L, -2)
			lua_gettable(L, 3)
			lua_pushvalue(L, 6)
			lua_call(L, 2, 1)
			var lc533 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc533 != 0 {
				lua_pushvalue(L, 7)
				lua_pushnumber(L, 1)
				lc_add(L, 9, -1)
				lua_remove(L, -2)
				lua_pushnumber(L, 1)
				lc_add(L, -2, -1)
				lua_remove(L, -2)
				lua_remove(L, -2)
				lua_insert(L, -2)
				lua_settable(L, 3)
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7675, []byte("int lcf1_val2env(lua_State *)\x00"))
					}
				}()
				lua_pushboolean(L, 0)
				lua_replace(L, 8)
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7680, []byte("int lcf1_val2env(lua_State *)\x00"))
					}
				}()
				break
				func() {
					if lua_gettop(L) == 9 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7684, []byte("int lcf1_val2env(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc532)))
			func() {
				if lua_gettop(L) == 9 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7687, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
			lua_pushnumber(L, 2)
			lc_add(L, 9, -1)
			lua_remove(L, -2)
			lua_replace(L, 9)
			func() {
				if lua_gettop(L) == 9 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7694, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc529)))
		func() {
			if lua_gettop(L) == 9 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7697, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7701, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		const (
			lc534 int32 = 8
		)
		if lua_toboolean(L, 8) != 0 {
			lc_getupvalue(L, -10002-1, 18, 1)
			lua_pushvalue(L, 3)
			lua_pushvalue(L, 6)
			lua_call(L, 2, 0)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7712, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, -10002-1, 18, 1)
			lua_pushvalue(L, 3)
			lua_pushvalue(L, 7)
			lua_call(L, 2, 0)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7719, []byte("int lcf1_val2env(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc534)))
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7722, []byte("int lcf1_val2env(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(4)-1)
	}
	lua_settop(L, int32((lc515)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7728, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	return 1
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7733, []byte("int lcf1_val2env(lua_State *)\x00"))
		}
	}()
	return
}

// lcf541 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7737
func lcf541(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 18, 17)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7746, []byte("int lcf541(lua_State *)\x00"))
		}
	}()
	const (
		lc536 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 18, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc537 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc537 != 0 {
		var lc538 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 18, 57)
		lc_getupvalue(L, -10002-1, 0, 129)
		lua_createtable(L, 1, 0)
		lua_pushvalue(L, 1)
		lua_rawseti(L, -2, 1)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc538
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7766, []byte("int lcf541(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc536)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7769, []byte("int lcf541(lua_State *)\x00"))
		}
	}()
	const (
		lc539 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 130)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc540 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc540 != 0 {
		lc_getupvalue(L, -10002-1, 4, 125)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7783, []byte("int lcf541(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc539)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7786, []byte("int lcf541(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 5, 124)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7791, []byte("int lcf541(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_builtin_p_func - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7796
func lcf1_make_builtin_p_func(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc535 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc535)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc535)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7801, []byte("int lcf1_make_builtin_p_func(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 129)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 130)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc535)), 0, 129)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc535)))
	lua_pushcclosure(L, lcf541, 1)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7826, []byte("int lcf1_make_builtin_p_func(lua_State *)\x00"))
		}
	}()
	return
}

// lcf549 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7830
func lcf549(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 18, 17)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7839, []byte("int lcf549(lua_State *)\x00"))
		}
	}()
	const (
		lc543 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 18, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc544 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc544 != 0 {
		var lc545 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 18, 57)
		lc_getupvalue(L, -10002-1, 0, 131)
		lua_createtable(L, 1, 0)
		lua_pushvalue(L, 1)
		lua_rawseti(L, -2, 1)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc545
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7859, []byte("int lcf549(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc543)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7862, []byte("int lcf549(lua_State *)\x00"))
		}
	}()
	const (
		lc546 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 132)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc547 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc547 != 0 {
		var lc548 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 133)
		lua_pushvalue(L, 1)
		lua_call(L, 1, -1)
		return lua_gettop(L) - lc548
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7879, []byte("int lcf549(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc546)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7882, []byte("int lcf549(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7887, []byte("int lcf549(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_builtin_get_func - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7892
func lcf1_make_builtin_get_func(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lc_newclosuretable(L, -10002-1)
	const (
		lc542 int32 = 4
	)
	func() {
		if lua_gettop(L) == int32((lc542)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc542)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7897, []byte("int lcf1_make_builtin_get_func(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 131)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 132)
	lua_pushvalue(L, 3)
	lua_rawseti(L, -2, 133)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc542)), 0, 131)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc542)))
	lua_pushcclosure(L, lcf549, 1)
	lua_rawseti(L, -2, 3)
	return 1
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7924, []byte("int lcf1_make_builtin_get_func(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_H_if - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7929
func lcf1_H_if(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	var lc560 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 57)
	lc_getupvalue(L, -10002-1, 18, 29)
	lua_createtable(L, 3, 0)
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 1)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 3)
	lua_rawseti(L, -2, 3)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc560
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7946, []byte("int lcf1_H_if(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_H_and - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7951
func lcf1_H_and(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc562 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 134)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 2)
	lc_getupvalue(L, -10002-1, 6, 124)
	lua_call(L, 3, -1)
	return lua_gettop(L) - lc562
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 7963, []byte("int lcf1_H_and(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_end_2 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:7968
func lcf2_end_2(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	var lc563 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 135)
	var lc564 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 19, 57)
	lc_getupvalue(L, -10002-1, 19, 32)
	lua_createtable(L, 2, 0)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_rawseti(L, -2, 1)
	var lc565 int32 = lua_gettop(L)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	for lua_gettop(L) > lc565 {
		lua_rawseti(L, lc565, 1+(lua_gettop(L)-lc565))
	}
	lua_call(L, 2, 1)
	lc_getupvalue(L, -10002-1, 19, 57)
	lc_getupvalue(L, -10002-1, 19, 32)
	lua_createtable(L, 2, 0)
	lua_pushvalue(L, 4)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_rawseti(L, -2, 1)
	var lc566 int32 = lua_gettop(L)
	lua_pushvalue(L, 4)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	for lua_gettop(L) > lc566 {
		lua_rawseti(L, lc566, 1+(lua_gettop(L)-lc566))
	}
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc564, -1)
	return lua_gettop(L) - lc563
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8010, []byte("int lcf2_end_2(lua_State *)\x00"))
		}
	}()
	return
}

// lcf591 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8014
func lcf591(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	const (
		lc550 int32 = 3
	)
	var lc551 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc551)
	var lc552 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc552 != 0 {
		lc_getupvalue(L, -10002-1, 3, 125)
		return 1
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8029, []byte("int lcf591(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc550)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8032, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 17)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8039, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 17)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8046, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	const (
		lc553 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 17, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 17, 19)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
	}
	var lc554 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc554 != 0 {
		var lc555 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 57)
		lc_getupvalue(L, -10002-1, 17, 32)
		lua_createtable(L, 2, 0)
		lua_pushvalue(L, 1)
		lua_rawseti(L, -2, 1)
		lua_pushvalue(L, 2)
		lua_rawseti(L, -2, 2)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc555
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8074, []byte("int lcf591(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc553)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8077, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	const (
		lc556 int32 = 3
	)
	var lc557 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc557)
	var lc558 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc558 != 0 {
		lc_getupvalue(L, -10002-1, 3, 125)
		return 1
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8090, []byte("int lcf591(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc556)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8093, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, -10002-1)
	const (
		lc559 int32 = 4
	)
	func() {
		if lua_gettop(L) == int32((lc559)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc559)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8098, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc559)), 134)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8101, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc559)))
	lua_pushcclosure(L, lcf1_H_if, 1)
	lc_setupvalue(L, int32((lc559)), 0, 134)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8110, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc559)))
	const (
		lc561 int32 = 5
	)
	func() {
		if lua_gettop(L) == int32((lc561)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc561)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8115, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc561)), 135)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8118, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc561)))
	lua_pushcclosure(L, lcf1_H_and, 1)
	lc_setupvalue(L, int32((lc561)), 0, 135)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8126, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc561)), 19, 95)
	lc_getupvalue(L, int32((lc561)), 19, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8136, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8140, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc561)))
	lua_pushcclosure(L, lcf2_end_2, 1)
	lua_replace(L, 6)
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8151, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	const (
		lc567 int32 = 6
	)
	lc_getupvalue(L, int32((lc561)), 19, 78)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc568 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc568 != 0 {
		const (
			lc569 int32 = 6
		)
		lc_getupvalue(L, int32((lc561)), 19, 78)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc570 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc570 != 0 {
			lc_getupvalue(L, int32((lc561)), 6, 124)
			return 1
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8176, []byte("int lcf591(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc569)))
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8179, []byte("int lcf591(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc561)), 5, 125)
		return 1
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8184, []byte("int lcf591(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc571 int32 = 6
		)
		lc_getupvalue(L, int32((lc561)), 19, 85)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		var lc572 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc572 != 0 {
			const (
				lc573 int32 = 6
			)
			lc_getupvalue(L, int32((lc561)), 19, 85)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc574 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc574 != 0 {
				lc_getupvalue(L, int32((lc561)), 6, 124)
				return 1
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8210, []byte("int lcf591(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc573)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8213, []byte("int lcf591(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc561)), 19, 23)
			lua_pushvalue(L, 1)
			lua_pushvalue(L, 2)
			lua_call(L, 2, 1)
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc561)), 5, 125)
			}
			if noarch.Not(lua_toboolean(L, -1)) {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc561)), 6, 124)
			}
			return 1
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8229, []byte("int lcf591(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc575 int32 = 6
			)
			lc_getupvalue(L, int32((lc561)), 19, 76)
			lua_pushvalue(L, 1)
			lua_call(L, 1, 1)
			var lc576 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc576 != 0 {
				const (
					lc577 int32 = 6
				)
				lc_getupvalue(L, int32((lc561)), 19, 76)
				lua_pushvalue(L, 2)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc578 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc578 != 0 {
					lc_getupvalue(L, int32((lc561)), 6, 124)
					return 1
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8255, []byte("int lcf591(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc577)))
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8258, []byte("int lcf591(lua_State *)\x00"))
					}
				}()
				var lc579 int32 = lua_gettop(L)
				lua_pushvalue(L, 6)
				lua_pushvalue(L, 1)
				lua_pushvalue(L, 2)
				lc_getupvalue(L, int32((lc561)), 19, 75)
				lc_getupvalue(L, int32((lc561)), 19, 74)
				lua_call(L, 4, -1)
				return lua_gettop(L) - lc579
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8269, []byte("int lcf591(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc580 int32 = 6
				)
				lc_getupvalue(L, int32((lc561)), 19, 82)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				var lc581 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc581 != 0 {
					const (
						lc582 int32 = 6
					)
					lc_getupvalue(L, int32((lc561)), 19, 82)
					lua_pushvalue(L, 2)
					lua_call(L, 1, 1)
					lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
					lua_remove(L, -2)
					var lc583 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc583 != 0 {
						lc_getupvalue(L, int32((lc561)), 6, 124)
						return 1
						func() {
							if lua_gettop(L) == 6 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8295, []byte("int lcf591(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc582)))
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8298, []byte("int lcf591(lua_State *)\x00"))
						}
					}()
					var lc584 int32 = lua_gettop(L)
					lua_pushvalue(L, 6)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 2)
					lc_getupvalue(L, int32((lc561)), 19, 81)
					lc_getupvalue(L, int32((lc561)), 19, 80)
					lua_call(L, 4, -1)
					return lua_gettop(L) - lc584
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8309, []byte("int lcf591(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc585 int32 = 6
					)
					lc_getupvalue(L, int32((lc561)), 19, 72)
					lua_pushvalue(L, 1)
					lua_call(L, 1, 1)
					var lc586 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc586 != 0 {
						const (
							lc587 int32 = 6
						)
						lc_getupvalue(L, int32((lc561)), 19, 72)
						lua_pushvalue(L, 2)
						lua_call(L, 1, 1)
						lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
						lua_remove(L, -2)
						var lc588 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc588 != 0 {
							lc_getupvalue(L, int32((lc561)), 6, 124)
							return 1
							func() {
								if lua_gettop(L) == 6 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8335, []byte("int lcf591(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc587)))
						func() {
							if lua_gettop(L) == 6 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8338, []byte("int lcf591(lua_State *)\x00"))
							}
						}()
						var lc589 int32 = lua_gettop(L)
						lua_pushvalue(L, 6)
						lua_pushvalue(L, 1)
						lua_pushvalue(L, 2)
						lc_getupvalue(L, int32((lc561)), 19, 71)
						lc_getupvalue(L, int32((lc561)), 19, 70)
						lua_call(L, 4, -1)
						return lua_gettop(L) - lc589
						func() {
							if lua_gettop(L) == 6 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8349, []byte("int lcf591(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc585)))
				}
				lua_settop(L, int32((lc580)))
			}
			lua_settop(L, int32((lc575)))
		}
		lua_settop(L, int32((lc571)))
	}
	lua_settop(L, int32((lc567)))
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8360, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	var lc590 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc561)), 19, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc590
	func() {
		if lua_gettop(L) == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8367, []byte("int lcf591(lua_State *)\x00"))
		}
	}()
	return
}

// lcf598 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8371
func lcf598(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8377, []byte("int lcf598(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 18)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8383, []byte("int lcf598(lua_State *)\x00"))
		}
	}()
	const (
		lc592 int32 = 5
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 17, 82)
		lua_pushvalue(L, 5)
		lua_call(L, 1, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 18, 1)
		var lc593 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lc_getupvalue(L, -10002-1, 17, 81)
		lua_pushvalue(L, 5)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc593, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8404, []byte("int lcf598(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 17, 18)
		var lc594 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 80)
		lua_pushvalue(L, 5)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc594, 1)
		lua_replace(L, 5)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8414, []byte("int lcf598(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc592)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8417, []byte("int lcf598(lua_State *)\x00"))
		}
	}()
	const (
		lc595 int32 = 5
	)
	lc_getupvalue(L, -10002-1, 17, 78)
	lua_pushvalue(L, 5)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc596 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc596 != 0 {
		lua_pushvalue(L, 3)
		return 1
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8433, []byte("int lcf598(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc595)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8436, []byte("int lcf598(lua_State *)\x00"))
		}
	}()
	var lc597 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 53)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 4)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc597
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8445, []byte("int lcf598(lua_State *)\x00"))
		}
	}()
	return
}

// lcf603 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8449
func lcf603(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lc_getupvalue(L, -10002-1, 0, 128)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8457, []byte("int lcf603(lua_State *)\x00"))
		}
	}()
	const (
		lc599 int32 = 4
	)
	lua_pushboolean(L, 0)
	var lc600 int32 = lua_equal(L, 4, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc600)
	var lc601 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc601 != 0 {
		lua_pushvalue(L, 3)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8472, []byte("int lcf603(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc599)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8475, []byte("int lcf603(lua_State *)\x00"))
		}
	}()
	var lc602 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 66)
	lua_pushvalue(L, 4)
	lua_pushvalue(L, 2)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc602
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8484, []byte("int lcf603(lua_State *)\x00"))
		}
	}()
	return
}

// lcf610 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8488
func lcf610(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 17, 17)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8497, []byte("int lcf610(lua_State *)\x00"))
		}
	}()
	const (
		lc604 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc605 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc605 != 0 {
		var lc606 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 57)
		lc_getupvalue(L, -10002-1, 5, 123)
		lua_createtable(L, 1, 0)
		lua_pushvalue(L, 1)
		lua_rawseti(L, -2, 1)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc606
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8518, []byte("int lcf610(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc604)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8521, []byte("int lcf610(lua_State *)\x00"))
		}
	}()
	const (
		lc607 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 17, 82)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc608 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc608 != 0 {
		lua_pushvalue(L, 2)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8537, []byte("int lcf610(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc607)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8540, []byte("int lcf610(lua_State *)\x00"))
		}
	}()
	var lc609 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 81)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc609
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8548, []byte("int lcf610(lua_State *)\x00"))
		}
	}()
	return
}

// lcf623 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8552
func lcf623(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	lc_getupvalue(L, -10002-1, 17, 17)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8561, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	const (
		lc611 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 17, 19)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc612 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc612 != 0 {
		var lc613 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 17, 57)
		lc_getupvalue(L, -10002-1, 17, 29)
		lua_createtable(L, 3, 0)
		lua_pushvalue(L, 1)
		lua_rawseti(L, -2, 1)
		lua_pushvalue(L, 2)
		lua_rawseti(L, -2, 2)
		lua_pushvalue(L, 3)
		lua_rawseti(L, -2, 3)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc613
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8585, []byte("int lcf623(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc611)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8588, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	const (
		lc614 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 17, 76)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc615 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc615 != 0 {
		lua_pushvalue(L, 4)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8604, []byte("int lcf623(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc614)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8607, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 17, 18)
	var lc616 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 17, 75)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc616, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8616, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	const (
		lc617 int32 = 5
	)
	lc_getupvalue(L, -10002-1, 17, 85)
	lua_pushvalue(L, 5)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc618 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc618 != 0 {
		lua_pushvalue(L, 4)
		return 1
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8632, []byte("int lcf623(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc617)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8635, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	const (
		lc619 int32 = 5
	)
	lc_getupvalue(L, -10002-1, 17, 23)
	lua_pushvalue(L, 5)
	lc_getupvalue(L, -10002-1, 8, 120)
	lua_call(L, 2, 1)
	var lc620 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc620 != 0 {
		lua_pushvalue(L, 2)
		return 1
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8650, []byte("int lcf623(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc619)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8653, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	const (
		lc621 int32 = 5
	)
	lc_getupvalue(L, -10002-1, 17, 23)
	lua_pushvalue(L, 5)
	lc_getupvalue(L, -10002-1, 7, 121)
	lua_call(L, 2, 1)
	var lc622 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc622 != 0 {
		lua_pushvalue(L, 3)
		return 1
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8668, []byte("int lcf623(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc621)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8671, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 4)
	return 1
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8676, []byte("int lcf623(lua_State *)\x00"))
		}
	}()
	return
}

// lcf3_end_2 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8681
func lcf3_end_2(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 4
	)
	lua_settop(L, 4)
	const (
		lc631 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 0, 136)
	var lc632 int32 = lua_gettop(L)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc632, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 136)
		var lc633 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		lua_pushvalue(L, 4)
		lua_pushvalue(L, 2)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc633, 1)
	}
	var lc634 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc634 != 0 {
		lc_getupvalue(L, -10002-1, 18, 69)
		lua_pushvalue(L, 1)
		lua_pushvalue(L, 2)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8718, []byte("int lcf3_end_2(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8723, []byte("int lcf3_end_2(lua_State *)\x00"))
			}
		}()
	} else {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8730, []byte("int lcf3_end_2(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc631)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8733, []byte("int lcf3_end_2(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_jsbool_no_force_equal_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:8739
func lcf1_jsbool_no_force_equal_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	const (
		lc625 int32 = 2
	)
	var lc626 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc626)
	var lc627 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc627 != 0 {
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8754, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc625)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8757, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 18, 20)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_replace(L, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8764, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 18, 20)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8771, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	const (
		lc628 int32 = 2
	)
	var lc629 int32 = lua_equal(L, 1, 2)
	lua_pushboolean(L, lc629)
	var lc630 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc630 != 0 {
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8784, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc628)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8787, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8791, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf3_end_2, 1)
	lua_replace(L, 3)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8805, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	const (
		lc635 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 18, 78)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc636 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc636 != 0 {
		const (
			lc637 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 18, 78)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc638 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc638 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8830, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc637)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8833, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 18, 69)
		lua_pushvalue(L, 1)
		lc_getupvalue(L, -10002-1, 18, 79)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8840, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 18, 69)
		lua_pushvalue(L, 2)
		lc_getupvalue(L, -10002-1, 18, 79)
		lua_call(L, 2, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8847, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8852, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc639 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 18, 85)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		var lc640 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc640 != 0 {
			const (
				lc641 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 18, 85)
			lua_pushvalue(L, 2)
			lua_call(L, 1, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc642 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc642 != 0 {
				lua_pushboolean(L, 0)
				return 1
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8878, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc641)))
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8881, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
				}
			}()
			var lc643 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 18, 23)
			lua_pushvalue(L, 1)
			lua_pushvalue(L, 2)
			lua_call(L, 2, -1)
			return lua_gettop(L) - lc643
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8890, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc644 int32 = 3
			)
			lc_getupvalue(L, -10002-1, 18, 82)
			lua_pushvalue(L, 1)
			lua_call(L, 1, 1)
			var lc645 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc645 != 0 {
				const (
					lc646 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 18, 82)
				lua_pushvalue(L, 2)
				lua_call(L, 1, 1)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				var lc647 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc647 != 0 {
					lua_pushboolean(L, 0)
					return 1
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8916, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc646)))
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8919, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
					}
				}()
				var lc648 int32 = lua_gettop(L)
				lua_pushvalue(L, 3)
				lua_pushvalue(L, 1)
				lua_pushvalue(L, 2)
				lc_getupvalue(L, -10002-1, 18, 81)
				lc_getupvalue(L, -10002-1, 18, 80)
				lua_call(L, 4, -1)
				return lua_gettop(L) - lc648
				func() {
					if lua_gettop(L) == 3 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8930, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc649 int32 = 3
				)
				lc_getupvalue(L, -10002-1, 18, 72)
				lua_pushvalue(L, 1)
				lua_call(L, 1, 1)
				var lc650 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc650 != 0 {
					const (
						lc651 int32 = 3
					)
					lc_getupvalue(L, -10002-1, 18, 72)
					lua_pushvalue(L, 2)
					lua_call(L, 1, 1)
					lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
					lua_remove(L, -2)
					var lc652 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc652 != 0 {
						lua_pushboolean(L, 0)
						return 1
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8956, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc651)))
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8959, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
						}
					}()
					var lc653 int32 = lua_gettop(L)
					lua_pushvalue(L, 3)
					lua_pushvalue(L, 1)
					lua_pushvalue(L, 2)
					lc_getupvalue(L, -10002-1, 18, 71)
					lc_getupvalue(L, -10002-1, 18, 70)
					lua_call(L, 4, -1)
					return lua_gettop(L) - lc653
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8970, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc654 int32 = 3
					)
					lc_getupvalue(L, -10002-1, 18, 76)
					lua_pushvalue(L, 1)
					lua_call(L, 1, 1)
					var lc655 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc655 != 0 {
						const (
							lc656 int32 = 3
						)
						lc_getupvalue(L, -10002-1, 18, 76)
						lua_pushvalue(L, 2)
						lua_call(L, 1, 1)
						lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
						lua_remove(L, -2)
						var lc657 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc657 != 0 {
							lua_pushboolean(L, 0)
							return 1
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8996, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc656)))
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 8999, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
							}
						}()
						var lc658 int32 = lua_gettop(L)
						lua_pushvalue(L, 3)
						lua_pushvalue(L, 1)
						lua_pushvalue(L, 2)
						lc_getupvalue(L, -10002-1, 18, 75)
						lc_getupvalue(L, -10002-1, 18, 74)
						lua_call(L, 4, -1)
						return lua_gettop(L) - lc658
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9010, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc659 int32 = 3
						)
						lc_getupvalue(L, -10002-1, 18, 65)
						lua_pushvalue(L, 1)
						lua_call(L, 1, 1)
						var lc660 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc660 != 0 {
							lua_pushboolean(L, 0)
							return 1
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9025, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
								}
							}()
						} else {
							const (
								lc661 int32 = 3
							)
							lc_getupvalue(L, -10002-1, 18, 56)
							lua_pushvalue(L, 1)
							lua_call(L, 1, 1)
							var lc662 int32 = lua_toboolean(L, -1)
							lua_settop(L, -(1)-1)
							if lc662 != 0 {
								lua_pushboolean(L, 0)
								return 1
								func() {
									if lua_gettop(L) == 3 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9040, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
									}
								}()
							} else {
								const (
									lc663 int32 = 3
								)
								lc_getupvalue(L, -10002-1, 18, 61)
								lua_pushvalue(L, 1)
								lua_call(L, 1, 1)
								var lc664 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc664 != 0 {
									lua_pushboolean(L, 0)
									return 1
									func() {
										if lua_gettop(L) == 3 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9055, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
										}
									}()
								} else {
									const (
										lc665 int32 = 3
									)
									lc_getupvalue(L, -10002-1, 18, 52)
									lua_pushvalue(L, 1)
									lua_call(L, 1, 1)
									var lc666 int32 = lua_toboolean(L, -1)
									lua_settop(L, -(1)-1)
									if lc666 != 0 {
										lua_pushboolean(L, 0)
										return 1
										func() {
											if lua_gettop(L) == 3 {
											} else {
												linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9070, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
											}
										}()
									}
									lua_settop(L, int32((lc665)))
								}
								lua_settop(L, int32((lc663)))
							}
							lua_settop(L, int32((lc661)))
						}
						lua_settop(L, int32((lc659)))
					}
					lua_settop(L, int32((lc654)))
				}
				lua_settop(L, int32((lc649)))
			}
			lua_settop(L, int32((lc644)))
		}
		lua_settop(L, int32((lc639)))
	}
	lua_settop(L, int32((lc635)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9089, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	var lc667 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc667
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9096, []byte("int lcf1_jsbool_no_force_equal_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_simple_print_force_all_rec - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9101
func lcf1_simple_print_force_all_rec(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	var lc668 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 2)
	var lc669 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 49)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc669, -1)
	return lua_gettop(L) - lc668
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9114, []byte("int lcf1_simple_print_force_all_rec(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_eof - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9119
func lcf1_eof(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 155)
	var lc672 float64 = float64(lua_objlen(L, -1))
	lua_settop(L, -(1)-1)
	lua_pushnumber(L, lua_Number((lc672)))
	lc_getupvalue(L, -10002-1, 0, 154)
	var lc673 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc673)
	return 1
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9133, []byte("int lcf1_eof(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9138
func lcf1_get(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 20, 95)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9149, []byte("int lcf1_get(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 155)
	lua_pushlstring(L, []byte("sub\x00"), uint(4/1-1))
	lua_gettable(L, -2)
	lua_insert(L, -2)
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9167, []byte("int lcf1_get(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_setupvalue(L, -10002-1, 0, 154)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9176, []byte("int lcf1_get(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9181, []byte("int lcf1_get(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_put - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9186
func lcf1_put(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 20, 95)
	lc_getupvalue(L, -10002-1, 0, 155)
	lua_pushlstring(L, []byte("sub\x00"), uint(4/1-1))
	lua_gettable(L, -2)
	lua_insert(L, -2)
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_call(L, 3, 1)
	lua_pushvalue(L, 1)
	var lc674 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc674)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9220, []byte("int lcf1_put(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 154)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_setupvalue(L, -10002-1, 0, 154)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9229, []byte("int lcf1_put(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_parse_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9235
func lcf1_parse_error(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lua_getfield(L, -10001, []byte("error\x00"))
	lua_pushlstring(L, []byte("TheLanguage parse ERROR!\x00"), uint(25/1-1))
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9243, []byte("int lcf1_parse_error(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_a_space_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9249
func lcf1_a_space_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
	var lc675 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc675)
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\n\x00"), uint(2/1-1))
		var lc676 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc676)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\t\x00"), uint(2/1-1))
		var lc677 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc677)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\r\x00"), uint(2/1-1))
		var lc678 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc678)
	}
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9284, []byte("int lcf1_a_space_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_space - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9289
func lcf1_space(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc679 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	var lc680 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc680 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9304, []byte("int lcf1_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc679)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9307, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9312, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	const (
		lc681 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 149)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc682 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc682 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9329, []byte("int lcf1_space(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9334, []byte("int lcf1_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc681)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9337, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	const (
		lc683 int32 = 1
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 149)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, -10002-1, 0, 153)
			lua_call(L, 0, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
		}
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 152)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9361, []byte("int lcf1_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc683)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9364, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	const (
		lc684 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 149)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc685 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc685 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9381, []byte("int lcf1_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc684)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9384, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9389, []byte("int lcf1_space(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_symbol - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9394
func lcf1_symbol(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc686 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	var lc687 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc687 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9409, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc686)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9412, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9417, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9421, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc688 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 139)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc689 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc689 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9438, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9443, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc688)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9446, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc690 int32 = 2
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 139)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, -10002-1, 0, 153)
			lua_call(L, 0, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
		}
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 2)
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9471, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 152)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9477, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc690)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9480, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc691 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 139)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc692 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc692 != 0 {
		lua_pushvalue(L, 2)
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9496, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
	} else {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9504, []byte("int lcf1_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc691)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9507, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	var lc693 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 113)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc693
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9515, []byte("int lcf1_symbol(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_set_last - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9520
func lcf1_set_last(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc702 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 1, 157)
	lc_getupvalue(L, -10002-1, 2, 156)
	var lc703 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc703)
	var lc704 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc704 != 0 {
		lua_pushvalue(L, 1)
		lc_setupvalue(L, -10002-1, 1, 157)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9538, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
		return 0
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9542, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc702)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9545, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 157)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9549, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc705 int32 = 2
	)
	for 1 != 0 {
		lua_pushboolean(L, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc706 int32 = 2
		)
		lc_getupvalue(L, -10002-1, 23, 82)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc707 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc707 != 0 {
			var lc708 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 23, 96)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc708
			func() {
				if lua_gettop(L) == 2 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9576, []byte("int lcf1_set_last(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc706)))
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9579, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 23, 80)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9585, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
		const (
			lc709 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 2, 156)
		var lc710 int32 = lua_equal(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc710)
		var lc711 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc711 != 0 {
			break
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9599, []byte("int lcf1_set_last(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc709)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9602, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 23, 80)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9609, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc705)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9615, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc712 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 23, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc713 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc713 != 0 {
		var lc714 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 23, 96)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc714
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9633, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc712)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9636, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc715 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 23, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 2, 156)
	var lc716 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc716)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc717 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc717 != 0 {
		var lc718 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 23, 96)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc718
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9658, []byte("int lcf1_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc715)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9661, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_pushnumber(L, 3)
	lua_insert(L, -2)
	lua_settable(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9668, []byte("int lcf1_set_last(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_last_add - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9674
func lcf1_last_add(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 158)
	var lc719 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 23, 83)
	lua_pushvalue(L, 1)
	lc_getupvalue(L, -10002-1, 2, 156)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc719, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9686, []byte("int lcf1_last_add(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9692
func lcf1_list(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc694 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	var lc695 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc695 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9707, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc694)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9710, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9715, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	const (
		lc696 int32 = 1
	)
	lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
	var lc697 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc697)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc698 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc698 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9733, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9738, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc696)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9741, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, -10002-1)
	const (
		lc699 int32 = 2
	)
	func() {
		if lua_gettop(L) == int32((lc699)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc699)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9746, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 18, 113)
	lua_pushlstring(L, []byte("!!@@READ||HOLE@@!!\x00"), uint(19/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc699)), 156)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9751, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc699)))
	const (
		lc700 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc700)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc700)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9756, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc699)), 0, 156)
	lua_rawseti(L, int32((lc700)), 157)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9759, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc700)))
	const (
		lc701 int32 = 4
	)
	func() {
		if lua_gettop(L) == int32((lc701)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc701)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9764, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc701)), 158)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9767, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc701)))
	lua_pushcclosure(L, lcf1_set_last, 1)
	lc_setupvalue(L, int32((lc701)), 0, 158)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9796, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9800, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc701)))
	lua_pushcclosure(L, lcf1_last_add, 1)
	lua_replace(L, 5)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9808, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	const (
		lc720 int32 = 5
	)
	for 1 != 0 {
		lua_pushboolean(L, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc701)), 3, 148)
		lua_call(L, 0, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9822, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		const (
			lc721 int32 = 5
		)
		lc_getupvalue(L, int32((lc701)), 3, 153)
		lua_call(L, 0, 1)
		var lc722 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc722 != 0 {
			var lc723 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc701)), 3, 150)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc723
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9837, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc721)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9840, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc701)), 3, 152)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9846, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		const (
			lc724 int32 = 5
		)
		lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
		var lc725 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc725)
		var lc726 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc726 != 0 {
			lc_getupvalue(L, int32((lc701)), 0, 158)
			lc_getupvalue(L, int32((lc701)), 23, 79)
			lua_call(L, 1, 0)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9862, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 1, 157)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9867, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc724)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9870, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		const (
			lc727 int32 = 5
		)
		lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
		var lc728 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc728)
		var lc729 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc729 != 0 {
			lc_getupvalue(L, int32((lc701)), 3, 148)
			lua_call(L, 0, 0)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9885, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 3, 138)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9890, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 0, 158)
			lua_pushvalue(L, 6)
			lua_call(L, 1, 0)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9896, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 3, 148)
			lua_call(L, 0, 0)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9901, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			const (
				lc730 int32 = 6
			)
			lc_getupvalue(L, int32((lc701)), 3, 153)
			lua_call(L, 0, 1)
			var lc731 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc731 != 0 {
				var lc732 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc701)), 3, 150)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc732
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9916, []byte("int lcf1_list(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc730)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9919, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 3, 152)
			lua_call(L, 0, 1)
			lua_replace(L, 1)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9925, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			const (
				lc733 int32 = 6
			)
			lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
			var lc734 int32 = lua_equal(L, 1, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc734)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc735 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc735 != 0 {
				var lc736 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc701)), 3, 150)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc736
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9944, []byte("int lcf1_list(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc733)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9947, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc701)), 1, 157)
			return 1
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9952, []byte("int lcf1_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc727)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9955, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc701)), 3, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9961, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc701)), 3, 138)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9966, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lua_pushvalue(L, 5)
		lua_pushvalue(L, 6)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9972, []byte("int lcf1_list(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc720)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9978, []byte("int lcf1_list(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_data - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:9984
func lcf1_data(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc737 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	var lc738 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc738 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 9999, []byte("int lcf1_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc737)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10002, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10007, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	const (
		lc739 int32 = 1
	)
	lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
	var lc740 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc740)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc741 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc741 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10025, []byte("int lcf1_data(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10030, []byte("int lcf1_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc739)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10033, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 146)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10038, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	const (
		lc742 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc743 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc743)
	var lc744 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc744 != 0 {
		var lc745 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc745
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10055, []byte("int lcf1_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc742)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10058, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	const (
		lc746 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 20, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc747 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc747 != 0 {
		var lc748 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc748
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10076, []byte("int lcf1_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc746)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10079, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	var lc749 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 77)
	var lc750 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 20, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc750, -1)
	return lua_gettop(L) - lc749
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10093, []byte("int lcf1_data(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_readerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10098
func lcf1_readerror(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc751 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 153)
	lua_call(L, 0, 1)
	var lc752 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc752 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10113, []byte("int lcf1_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc751)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10116, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10121, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc753 int32 = 1
	)
	lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
	var lc754 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc754)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc755 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc755 != 0 {
		lc_getupvalue(L, -10002-1, 0, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10139, []byte("int lcf1_readerror(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10144, []byte("int lcf1_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc753)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10147, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 146)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10152, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc756 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc757 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc757)
	var lc758 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc758 != 0 {
		var lc759 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc759
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10169, []byte("int lcf1_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc756)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10172, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc760 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 20, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc761 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc761 != 0 {
		var lc762 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc762
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10190, []byte("int lcf1_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc760)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10193, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	var lc763 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 73)
	var lc764 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 20, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc764, -1)
	return lua_gettop(L) - lc763
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10207, []byte("int lcf1_readerror(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_a_symbol_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10212
func lcf1_a_symbol_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc765 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 149)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc766 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc766 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10228, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc765)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10231, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 19, 0)
	lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 1)
	lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 2)
	lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 3)
	lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 4)
	lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 5)
	lua_pushlstring(L, []byte("$\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 6)
	lua_pushlstring(L, []byte("%\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 7)
	lua_pushlstring(L, []byte("^\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 8)
	lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 9)
	lua_pushlstring(L, []byte("~\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 10)
	lua_pushlstring(L, []byte("/\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 11)
	lua_pushlstring(L, []byte("-\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 12)
	lua_pushlstring(L, []byte(">\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 13)
	lua_pushlstring(L, []byte("_\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 14)
	lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 15)
	lua_pushlstring(L, []byte("?\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 16)
	lua_pushlstring(L, []byte("[\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 17)
	lua_pushlstring(L, []byte("]\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 18)
	lua_pushlstring(L, []byte("&\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 19)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10274, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10279, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	const (
		lc767 int32 = 3
	)
	for 1 != 0 {
		var lc768 float64 = float64(lua_objlen(L, 2))
		lua_pushnumber(L, lua_Number((lc768)))
		var lc769 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc769)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc770 int32 = 3
		)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_gettable(L, 2)
		var lc771 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc771)
		var lc772 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc772 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10310, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc770)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10313, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10320, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc767)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10323, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10327, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10332, []byte("int lcf1_a_symbol_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_val - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10337
func lcf1_val(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 148)
	lua_call(L, 0, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10344, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 8, 0)
	lc_getupvalue(L, -10002-1, 0, 146)
	lua_rawseti(L, -2, 1)
	lc_getupvalue(L, -10002-1, 0, 147)
	lua_rawseti(L, -2, 2)
	lc_getupvalue(L, -10002-1, 0, 145)
	lua_rawseti(L, -2, 3)
	lc_getupvalue(L, -10002-1, 0, 144)
	lua_rawseti(L, -2, 4)
	lc_getupvalue(L, -10002-1, 0, 143)
	lua_rawseti(L, -2, 5)
	lc_getupvalue(L, -10002-1, 0, 142)
	lua_rawseti(L, -2, 6)
	lc_getupvalue(L, -10002-1, 0, 141)
	lua_rawseti(L, -2, 7)
	lc_getupvalue(L, -10002-1, 0, 140)
	lua_rawseti(L, -2, 8)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10365, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10370, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	const (
		lc773 int32 = 2
	)
	for 1 != 0 {
		var lc774 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc774)))
		var lc775 int32 = lua_lessthan(L, 2, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc775)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10391, []byte("int lcf1_val(lua_State *)\x00"))
			}
		}()
		const (
			lc776 int32 = 3
		)
		lua_pushboolean(L, 0)
		var lc777 int32 = lua_equal(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc777)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc778 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc778 != 0 {
			lua_pushvalue(L, 3)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10408, []byte("int lcf1_val(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc776)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10411, []byte("int lcf1_val(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10418, []byte("int lcf1_val(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc773)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10424, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10428, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	var lc779 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 150)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc779
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10435, []byte("int lcf1_val(lua_State *)\x00"))
		}
	}()
	return
}

// lcf799 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10439
func lcf799(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc781 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 1, 153)
	lua_call(L, 0, 1)
	var lc782 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc782 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10454, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc781)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10457, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10462, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	const (
		lc783 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 159)
	var lc784 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc784)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc785 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc785 != 0 {
		lc_getupvalue(L, -10002-1, 1, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10480, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10485, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc783)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10488, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 146)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10493, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	const (
		lc786 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc787 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc787)
	var lc788 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc788 != 0 {
		var lc789 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc789
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10510, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc786)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10513, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	const (
		lc790 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc791 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc791 != 0 {
		var lc792 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc792
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10531, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc790)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10534, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10540, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	const (
		lc793 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 21, 78)
		var lc794 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 21, 80)
		lua_pushvalue(L, 3)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc794, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc795 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc795 != 0 {
		var lc796 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc796
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10567, []byte("int lcf799(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc793)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10570, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	var lc797 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 160)
	var lc798 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 3)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc798, -1)
	return lua_gettop(L) - lc797
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10584, []byte("int lcf799(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_read_two - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10589
func lcf1_make_read_two(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc780 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc780)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc780)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10594, []byte("int lcf1_make_read_two(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 159)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 160)
	lua_pushvalue(L, int32((lc780)))
	lua_pushcclosure(L, lcf799, 1)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10626, []byte("int lcf1_make_read_two(lua_State *)\x00"))
		}
	}()
	return
}

// lcf822 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10630
func lcf822(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc801 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 1, 153)
	lua_call(L, 0, 1)
	var lc802 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc802 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10645, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc801)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10648, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 152)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10653, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	const (
		lc803 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 161)
	var lc804 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc804)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc805 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc805 != 0 {
		lc_getupvalue(L, -10002-1, 1, 151)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10671, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10676, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc803)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10679, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 146)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10684, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	const (
		lc806 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc807 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc807)
	var lc808 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc808 != 0 {
		var lc809 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc809
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10701, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc806)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10704, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	const (
		lc810 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc811 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc811 != 0 {
		var lc812 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc812
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10722, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc810)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10725, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10731, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	const (
		lc813 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc814 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc814 != 0 {
		var lc815 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc815
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10749, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc813)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10752, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10758, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	const (
		lc816 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 4)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 21, 78)
		var lc817 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 21, 80)
		lua_pushvalue(L, 4)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc817, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc818 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc818 != 0 {
		var lc819 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc819
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10785, []byte("int lcf822(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc816)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10788, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	var lc820 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 162)
	var lc821 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 4)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc821, -1)
	return lua_gettop(L) - lc820
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10806, []byte("int lcf822(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_make_read_three - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10811
func lcf1_make_read_three(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc800 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc800)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc800)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10816, []byte("int lcf1_make_read_three(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 161)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 162)
	lua_pushvalue(L, int32((lc800)))
	lua_pushcclosure(L, lcf822, 1)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10853, []byte("int lcf1_make_read_three(lua_State *)\x00"))
		}
	}()
	return
}

// lcf828 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10857
func lcf828(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 3, 128)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10865, []byte("int lcf828(lua_State *)\x00"))
		}
	}()
	const (
		lc823 int32 = 3
	)
	lua_pushboolean(L, 0)
	var lc824 int32 = lua_equal(L, 3, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc824)
	var lc825 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc825 != 0 {
		var lc826 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc826
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10882, []byte("int lcf828(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc823)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10885, []byte("int lcf828(lua_State *)\x00"))
		}
	}()
	var lc827 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 66)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 2)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc827
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10894, []byte("int lcf828(lua_State *)\x00"))
		}
	}()
	return
}

// lcf829 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10898
func lcf829(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10905, []byte("int lcf829(lua_State *)\x00"))
		}
	}()
	return
}

// lcf831 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10909
func lcf831(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc830 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 150)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc830
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10918, []byte("int lcf831(lua_State *)\x00"))
		}
	}()
	return
}

// lcf833 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10922
func lcf833(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 2)
	lua_pushcclosure(L, lcf829, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf831, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10937, []byte("int lcf833(lua_State *)\x00"))
		}
	}()
	var lc832 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 57)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 3)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc832
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10946, []byte("int lcf833(lua_State *)\x00"))
		}
	}()
	return
}

// lcf834 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10950
func lcf834(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10957, []byte("int lcf834(lua_State *)\x00"))
		}
	}()
	return
}

// lcf836 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10961
func lcf836(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc835 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 150)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc835
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10970, []byte("int lcf836(lua_State *)\x00"))
		}
	}()
	return
}

// lcf842 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:10974
func lcf842(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 3)
	lua_pushcclosure(L, lcf834, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf836, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10989, []byte("int lcf842(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 3, 128)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 10995, []byte("int lcf842(lua_State *)\x00"))
		}
	}()
	const (
		lc837 int32 = 5
	)
	lua_pushboolean(L, 0)
	var lc838 int32 = lua_equal(L, 5, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc838)
	var lc839 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc839 != 0 {
		var lc840 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 150)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc840
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11012, []byte("int lcf842(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc837)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11015, []byte("int lcf842(lua_State *)\x00"))
		}
	}()
	var lc841 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 62)
	lua_pushvalue(L, 5)
	lua_pushvalue(L, 2)
	lua_pushvalue(L, 4)
	lua_call(L, 3, -1)
	return lua_gettop(L) - lc841
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11025, []byte("int lcf842(lua_State *)\x00"))
		}
	}()
	return
}

// lcf843 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11029
func lcf843(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11036, []byte("int lcf843(lua_State *)\x00"))
		}
	}()
	return
}

// lcf845 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11040
func lcf845(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc844 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 150)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc844
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11049, []byte("int lcf845(lua_State *)\x00"))
		}
	}()
	return
}

// lcf847 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11053
func lcf847(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 2)
	lua_pushcclosure(L, lcf843, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf845, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11068, []byte("int lcf847(lua_State *)\x00"))
		}
	}()
	var lc846 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 53)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 3)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc846
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11077, []byte("int lcf847(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_simple_parse - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11082
func lcf1_simple_parse(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_newclosuretable(L, -10002-1)
	const (
		lc671 int32 = 2
	)
	func() {
		if lua_gettop(L) == int32((lc671)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc671)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11091, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+18)
	lua_rawseti(L, int32((lc671)), 138)
	lua_rawseti(L, int32((lc671)), 139)
	lua_rawseti(L, int32((lc671)), 140)
	lua_rawseti(L, int32((lc671)), 141)
	lua_rawseti(L, int32((lc671)), 142)
	lua_rawseti(L, int32((lc671)), 143)
	lua_rawseti(L, int32((lc671)), 144)
	lua_rawseti(L, int32((lc671)), 145)
	lua_rawseti(L, int32((lc671)), 146)
	lua_rawseti(L, int32((lc671)), 147)
	lua_rawseti(L, int32((lc671)), 148)
	lua_rawseti(L, int32((lc671)), 149)
	lua_rawseti(L, int32((lc671)), 150)
	lua_rawseti(L, int32((lc671)), 151)
	lua_rawseti(L, int32((lc671)), 152)
	lua_rawseti(L, int32((lc671)), 153)
	lua_rawseti(L, int32((lc671)), 154)
	lua_rawseti(L, int32((lc671)), 155)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11111, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_eof, 1)
	lc_setupvalue(L, int32((lc671)), 0, 153)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11119, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_get, 1)
	lc_setupvalue(L, int32((lc671)), 0, 152)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11130, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_put, 1)
	lc_setupvalue(L, int32((lc671)), 0, 151)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11139, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_parse_error, 0)
	lc_setupvalue(L, int32((lc671)), 0, 150)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11146, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_a_space_p, 0)
	lc_setupvalue(L, int32((lc671)), 0, 149)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11153, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_space, 1)
	lc_setupvalue(L, int32((lc671)), 0, 148)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11175, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_symbol, 1)
	lc_setupvalue(L, int32((lc671)), 0, 147)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11201, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_list, 1)
	lc_setupvalue(L, int32((lc671)), 0, 146)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11275, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_data, 1)
	lc_setupvalue(L, int32((lc671)), 0, 145)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11298, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_readerror, 1)
	lc_setupvalue(L, int32((lc671)), 0, 144)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11321, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_a_symbol_p, 1)
	lc_setupvalue(L, int32((lc671)), 0, 139)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11343, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_val, 1)
	lc_setupvalue(L, int32((lc671)), 0, 138)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11364, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lc_setupvalue(L, int32((lc671)), 0, 155)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11369, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	lc_setupvalue(L, int32((lc671)), 0, 154)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11374, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11378, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_make_read_two, 1)
	lua_replace(L, 3)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11408, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11412, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf1_make_read_three, 1)
	lua_replace(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11447, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("$\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf828, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc671)), 0, 143)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11462, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("%\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf833, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc671)), 0, 142)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11478, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 4)
	lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf842, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc671)), 0, 141)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11498, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("^\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc671)))
	lua_pushcclosure(L, lcf847, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc671)), 0, 140)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11514, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	var lc848 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc671)), 0, 138)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc848
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11521, []byte("int lcf1_simple_parse(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_eof - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11526
func lcf2_eof(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 185)
	var lc850 float64 = float64(lua_objlen(L, -1))
	lua_settop(L, -(1)-1)
	lua_pushnumber(L, lua_Number((lc850)))
	lc_getupvalue(L, -10002-1, 0, 184)
	var lc851 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc851)
	return 1
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11540, []byte("int lcf2_eof(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11545
func lcf2_get(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 20, 95)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11556, []byte("int lcf2_get(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 185)
	lua_pushlstring(L, []byte("sub\x00"), uint(4/1-1))
	lua_gettable(L, -2)
	lua_insert(L, -2)
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11574, []byte("int lcf2_get(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_setupvalue(L, -10002-1, 0, 184)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11583, []byte("int lcf2_get(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11588, []byte("int lcf2_get(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_put - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11593
func lcf2_put(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 20, 95)
	lc_getupvalue(L, -10002-1, 0, 185)
	lua_pushlstring(L, []byte("sub\x00"), uint(4/1-1))
	lua_gettable(L, -2)
	lua_insert(L, -2)
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_pushnumber(L, 1)
	lc_add(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lua_call(L, 3, 1)
	lua_pushvalue(L, 1)
	var lc852 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc852)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11627, []byte("int lcf2_put(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 184)
	lua_pushnumber(L, 1)
	lc_sub(L, -2, -1)
	lua_remove(L, -2)
	lua_remove(L, -2)
	lc_setupvalue(L, -10002-1, 0, 184)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11636, []byte("int lcf2_put(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf2_parse_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11642
func lcf2_parse_error(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lua_getfield(L, -10001, []byte("error\x00"))
	lua_pushlstring(L, []byte("TheLanguage parse ERROR!\x00"), uint(25/1-1))
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11650, []byte("int lcf2_parse_error(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf2_a_space_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11656
func lcf2_a_space_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
	var lc853 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc853)
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\n\x00"), uint(2/1-1))
		var lc854 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc854)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\t\x00"), uint(2/1-1))
		var lc855 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc855)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 1)
		lua_pushlstring(L, []byte("\r\x00"), uint(2/1-1))
		var lc856 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc856)
	}
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11691, []byte("int lcf2_a_space_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_space - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11696
func lcf2_space(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc857 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	var lc858 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc858 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11711, []byte("int lcf2_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc857)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11714, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11719, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	const (
		lc859 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 179)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc860 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc860 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11736, []byte("int lcf2_space(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11741, []byte("int lcf2_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc859)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11744, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	const (
		lc861 int32 = 1
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 179)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, -10002-1, 0, 183)
			lua_call(L, 0, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
		}
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 0, 182)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11768, []byte("int lcf2_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc861)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11771, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	const (
		lc862 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 179)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc863 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc863 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11788, []byte("int lcf2_space(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc862)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11791, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11796, []byte("int lcf2_space(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_symbol - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11801
func lcf2_symbol(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc864 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	var lc865 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc865 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11816, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc864)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11819, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11824, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11828, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc866 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 169)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc867 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc867 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11845, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11850, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc866)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11853, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc868 int32 = 2
	)
	for 1 != 0 {
		lc_getupvalue(L, -10002-1, 0, 169)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, -10002-1, 0, 183)
			lua_call(L, 0, 1)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
		}
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushvalue(L, 2)
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11878, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 0, 182)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11884, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc868)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11887, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	const (
		lc869 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 0, 169)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc870 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc870 != 0 {
		lua_pushvalue(L, 2)
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11903, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
	} else {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11911, []byte("int lcf2_symbol(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc869)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11914, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	var lc871 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 18, 113)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc871
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11922, []byte("int lcf2_symbol(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_set_last - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:11927
func lcf2_set_last(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc880 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 1, 187)
	lc_getupvalue(L, -10002-1, 2, 186)
	var lc881 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc881)
	var lc882 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc882 != 0 {
		lua_pushvalue(L, 1)
		lc_setupvalue(L, -10002-1, 1, 187)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11945, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
		return 0
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11949, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc880)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11952, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 187)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11956, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc883 int32 = 2
	)
	for 1 != 0 {
		lua_pushboolean(L, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc884 int32 = 2
		)
		lc_getupvalue(L, -10002-1, 23, 82)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc885 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc885 != 0 {
			var lc886 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 23, 96)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc886
			func() {
				if lua_gettop(L) == 2 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11983, []byte("int lcf2_set_last(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc884)))
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11986, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 23, 80)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 11992, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
		const (
			lc887 int32 = 3
		)
		lc_getupvalue(L, -10002-1, 2, 186)
		var lc888 int32 = lua_equal(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc888)
		var lc889 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc889 != 0 {
			break
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12006, []byte("int lcf2_set_last(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc887)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12009, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, -10002-1, 23, 80)
		lua_pushvalue(L, 2)
		lua_call(L, 1, 1)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12016, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc883)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12022, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc890 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 23, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc891 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc891 != 0 {
		var lc892 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 23, 96)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc892
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12040, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc890)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12043, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	const (
		lc893 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 23, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 2, 186)
	var lc894 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc894)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc895 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc895 != 0 {
		var lc896 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 23, 96)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc896
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12065, []byte("int lcf2_set_last(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc893)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12068, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_pushnumber(L, 3)
	lua_insert(L, -2)
	lua_settable(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12075, []byte("int lcf2_set_last(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf2_last_add - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12081
func lcf2_last_add(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 188)
	var lc897 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 23, 83)
	lua_pushvalue(L, 1)
	lc_getupvalue(L, -10002-1, 2, 186)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc897, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12093, []byte("int lcf2_last_add(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf2_list - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12099
func lcf2_list(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc872 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	var lc873 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc873 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12114, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc872)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12117, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12122, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	const (
		lc874 int32 = 1
	)
	lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
	var lc875 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc875)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc876 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc876 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12140, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12145, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc874)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12148, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, -10002-1)
	const (
		lc877 int32 = 2
	)
	func() {
		if lua_gettop(L) == int32((lc877)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc877)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12153, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 18, 113)
	lua_pushlstring(L, []byte("!!@@READ||HOLE@@!!\x00"), uint(19/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc877)), 186)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12158, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc877)))
	const (
		lc878 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc878)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc878)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12163, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc877)), 0, 186)
	lua_rawseti(L, int32((lc878)), 187)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12166, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc878)))
	const (
		lc879 int32 = 4
	)
	func() {
		if lua_gettop(L) == int32((lc879)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc879)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12171, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc879)), 188)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12174, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc879)))
	lua_pushcclosure(L, lcf2_set_last, 1)
	lc_setupvalue(L, int32((lc879)), 0, 188)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12203, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12207, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc879)))
	lua_pushcclosure(L, lcf2_last_add, 1)
	lua_replace(L, 5)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12215, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	const (
		lc898 int32 = 5
	)
	for 1 != 0 {
		lua_pushboolean(L, 1)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc879)), 3, 178)
		lua_call(L, 0, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12229, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		const (
			lc899 int32 = 5
		)
		lc_getupvalue(L, int32((lc879)), 3, 183)
		lua_call(L, 0, 1)
		var lc900 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc900 != 0 {
			var lc901 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc879)), 3, 180)
			lua_call(L, 0, -1)
			return lua_gettop(L) - lc901
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12244, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc899)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12247, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc879)), 3, 182)
		lua_call(L, 0, 1)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12253, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		const (
			lc902 int32 = 5
		)
		lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
		var lc903 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc903)
		var lc904 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc904 != 0 {
			lc_getupvalue(L, int32((lc879)), 0, 188)
			lc_getupvalue(L, int32((lc879)), 23, 79)
			lua_call(L, 1, 0)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12269, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 1, 187)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12274, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc902)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12277, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		const (
			lc905 int32 = 5
		)
		lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
		var lc906 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc906)
		var lc907 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc907 != 0 {
			lc_getupvalue(L, int32((lc879)), 3, 178)
			lua_call(L, 0, 0)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12292, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 3, 168)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12297, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 0, 188)
			lua_pushvalue(L, 6)
			lua_call(L, 1, 0)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12303, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 3, 178)
			lua_call(L, 0, 0)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12308, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			const (
				lc908 int32 = 6
			)
			lc_getupvalue(L, int32((lc879)), 3, 183)
			lua_call(L, 0, 1)
			var lc909 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc909 != 0 {
				var lc910 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc879)), 3, 180)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc910
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12323, []byte("int lcf2_list(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc908)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12326, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 3, 182)
			lua_call(L, 0, 1)
			lua_replace(L, 1)
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12332, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			const (
				lc911 int32 = 6
			)
			lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
			var lc912 int32 = lua_equal(L, 1, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc912)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			var lc913 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc913 != 0 {
				var lc914 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc879)), 3, 180)
				lua_call(L, 0, -1)
				return lua_gettop(L) - lc914
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12351, []byte("int lcf2_list(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc911)))
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12354, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc879)), 1, 187)
			return 1
			func() {
				if lua_gettop(L) == 6 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12359, []byte("int lcf2_list(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc905)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12362, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc879)), 3, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12368, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc879)), 3, 168)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12373, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lua_pushvalue(L, 5)
		lua_pushvalue(L, 6)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12379, []byte("int lcf2_list(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc898)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12385, []byte("int lcf2_list(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf2_data - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12391
func lcf2_data(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc915 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	var lc916 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc916 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12406, []byte("int lcf2_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc915)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12409, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12414, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	const (
		lc917 int32 = 1
	)
	lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
	var lc918 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc918)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc919 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc919 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12432, []byte("int lcf2_data(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12437, []byte("int lcf2_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc917)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12440, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 176)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12445, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	const (
		lc920 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc921 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc921)
	var lc922 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc922 != 0 {
		var lc923 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc923
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12462, []byte("int lcf2_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc920)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12465, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	const (
		lc924 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 20, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc925 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc925 != 0 {
		var lc926 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc926
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12483, []byte("int lcf2_data(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc924)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12486, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	var lc927 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 77)
	var lc928 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 20, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc928, -1)
	return lua_gettop(L) - lc927
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12500, []byte("int lcf2_data(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_readerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12505
func lcf2_readerror(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc929 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	var lc930 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc930 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12520, []byte("int lcf2_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc929)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12523, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12528, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc931 int32 = 1
	)
	lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
	var lc932 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc932)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc933 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc933 != 0 {
		lc_getupvalue(L, -10002-1, 0, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12546, []byte("int lcf2_readerror(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12551, []byte("int lcf2_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc931)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12554, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 176)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12559, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc934 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc935 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc935)
	var lc936 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc936 != 0 {
		var lc937 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc937
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12576, []byte("int lcf2_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc934)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12579, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	const (
		lc938 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 20, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc939 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc939 != 0 {
		var lc940 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc940
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12597, []byte("int lcf2_readerror(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc938)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12600, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	var lc941 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 73)
	var lc942 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 20, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc942, -1)
	return lua_gettop(L) - lc941
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12614, []byte("int lcf2_readerror(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_a_symbol_p - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12619
func lcf2_a_symbol_p(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc943 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 179)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc944 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc944 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12635, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc943)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12638, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 19, 0)
	lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 1)
	lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 2)
	lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 3)
	lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 4)
	lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 5)
	lua_pushlstring(L, []byte("$\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 6)
	lua_pushlstring(L, []byte("%\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 7)
	lua_pushlstring(L, []byte("^\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 8)
	lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 9)
	lua_pushlstring(L, []byte("~\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 10)
	lua_pushlstring(L, []byte("/\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 11)
	lua_pushlstring(L, []byte("-\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 12)
	lua_pushlstring(L, []byte(">\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 13)
	lua_pushlstring(L, []byte("_\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 14)
	lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 15)
	lua_pushlstring(L, []byte("?\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 16)
	lua_pushlstring(L, []byte("[\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 17)
	lua_pushlstring(L, []byte("]\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 18)
	lua_pushlstring(L, []byte("&\x00"), uint(2/1-1))
	lua_rawseti(L, -2, 19)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12681, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12686, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	const (
		lc945 int32 = 3
	)
	for 1 != 0 {
		var lc946 float64 = float64(lua_objlen(L, 2))
		lua_pushnumber(L, lua_Number((lc946)))
		var lc947 int32 = lua_lessthan(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc947)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		const (
			lc948 int32 = 3
		)
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_gettable(L, 2)
		var lc949 int32 = lua_equal(L, 1, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc949)
		var lc950 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc950 != 0 {
			lua_pushboolean(L, 0)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12717, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc948)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12720, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 3, -1)
		lua_remove(L, -2)
		lua_replace(L, 3)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12727, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc945)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12730, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12734, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	lua_pushboolean(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12739, []byte("int lcf2_a_symbol_p(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_val - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12744
func lcf2_val(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 178)
	lua_call(L, 0, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12751, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 8, 0)
	lc_getupvalue(L, -10002-1, 0, 176)
	lua_rawseti(L, -2, 1)
	lc_getupvalue(L, -10002-1, 0, 163)
	lua_rawseti(L, -2, 2)
	lc_getupvalue(L, -10002-1, 0, 175)
	lua_rawseti(L, -2, 3)
	lc_getupvalue(L, -10002-1, 0, 174)
	lua_rawseti(L, -2, 4)
	lc_getupvalue(L, -10002-1, 0, 173)
	lua_rawseti(L, -2, 5)
	lc_getupvalue(L, -10002-1, 0, 172)
	lua_rawseti(L, -2, 6)
	lc_getupvalue(L, -10002-1, 0, 171)
	lua_rawseti(L, -2, 7)
	lc_getupvalue(L, -10002-1, 0, 170)
	lua_rawseti(L, -2, 8)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12772, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12777, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	const (
		lc951 int32 = 2
	)
	for 1 != 0 {
		var lc952 float64 = float64(lua_objlen(L, 1))
		lua_pushnumber(L, lua_Number((lc952)))
		var lc953 int32 = lua_lessthan(L, 2, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc953)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_gettable(L, 1)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12798, []byte("int lcf2_val(lua_State *)\x00"))
			}
		}()
		const (
			lc954 int32 = 3
		)
		lua_pushboolean(L, 0)
		var lc955 int32 = lua_equal(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc955)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc956 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc956 != 0 {
			lua_pushvalue(L, 3)
			return 1
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12815, []byte("int lcf2_val(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc954)))
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12818, []byte("int lcf2_val(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 2, -1)
		lua_remove(L, -2)
		lua_replace(L, 2)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12825, []byte("int lcf2_val(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc951)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12831, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12835, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	var lc957 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 180)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc957
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12842, []byte("int lcf2_val(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_un_maybe - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12847
func lcf1_un_maybe(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc958 int32 = 1
	)
	lua_pushboolean(L, 0)
	var lc959 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc959)
	var lc960 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc960 != 0 {
		var lc961 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc961
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12866, []byte("int lcf1_un_maybe(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc958)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12869, []byte("int lcf1_un_maybe(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12874, []byte("int lcf1_un_maybe(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_not_eof - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12879
func lcf1_not_eof(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 183)
	lua_call(L, 0, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	return 1
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12889, []byte("int lcf1_not_eof(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_assert_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12894
func lcf1_assert_get(L []lua_State) int32 {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_getupvalue(L, -10002-1, 0, 167)
	var lc962 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 166)
	lua_call(L, 0, -1)
	lua_call(L, lua_gettop(L)-lc962, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12904, []byte("int lcf1_assert_get(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 167)
	lc_getupvalue(L, -10002-1, 0, 182)
	lua_call(L, 0, 1)
	lua_pushvalue(L, 1)
	var lc963 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc963)
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12915, []byte("int lcf1_assert_get(lua_State *)\x00"))
		}
	}()
	return 0
}

// lcf1_readsysname_no_pack_bracket - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12921
func lcf1_readsysname_no_pack_bracket(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 1, 165)
	lua_pushlstring(L, []byte("[\x00"), uint(2/1-1))
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12929, []byte("int lcf1_readsysname_no_pack_bracket(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 0, 189)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12934, []byte("int lcf1_readsysname_no_pack_bracket(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 165)
	lua_pushlstring(L, []byte("]\x00"), uint(2/1-1))
	lua_call(L, 1, 0)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12940, []byte("int lcf1_readsysname_no_pack_bracket(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12945, []byte("int lcf1_readsysname_no_pack_bracket(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_readsysname_no_pack_inner_must - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:12950
func lcf1_readsysname_no_pack_inner_must(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc965 int32 = 1
	)
	lua_pushnil(L)
	var lc966 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc966)
	var lc967 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc967 != 0 {
		lua_pushboolean(L, 0)
		lua_replace(L, 1)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12967, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc965)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12970, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12974, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf1_readsysname_no_pack_bracket, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 12985, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lua_createtable(L, 9, 0)
		lc_getupvalue(L, -10002-1, 1, 176)
		lua_rawseti(L, -2, 1)
		lc_getupvalue(L, -10002-1, 1, 177)
		lua_rawseti(L, -2, 2)
		lua_pushvalue(L, 2)
		lua_rawseti(L, -2, 3)
		lc_getupvalue(L, -10002-1, 1, 175)
		lua_rawseti(L, -2, 4)
		lc_getupvalue(L, -10002-1, 1, 174)
		lua_rawseti(L, -2, 5)
		lc_getupvalue(L, -10002-1, 1, 173)
		lua_rawseti(L, -2, 6)
		lc_getupvalue(L, -10002-1, 1, 172)
		lua_rawseti(L, -2, 7)
		lc_getupvalue(L, -10002-1, 1, 171)
		lua_rawseti(L, -2, 8)
		lc_getupvalue(L, -10002-1, 1, 170)
		lua_rawseti(L, -2, 9)
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_createtable(L, 8, 0)
		lc_getupvalue(L, -10002-1, 1, 176)
		lua_rawseti(L, -2, 1)
		lc_getupvalue(L, -10002-1, 1, 164)
		lua_rawseti(L, -2, 2)
		lc_getupvalue(L, -10002-1, 1, 175)
		lua_rawseti(L, -2, 3)
		lc_getupvalue(L, -10002-1, 1, 174)
		lua_rawseti(L, -2, 4)
		lc_getupvalue(L, -10002-1, 1, 173)
		lua_rawseti(L, -2, 5)
		lc_getupvalue(L, -10002-1, 1, 172)
		lua_rawseti(L, -2, 6)
		lc_getupvalue(L, -10002-1, 1, 171)
		lua_rawseti(L, -2, 7)
		lc_getupvalue(L, -10002-1, 1, 170)
		lua_rawseti(L, -2, 8)
	}
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13034, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13039, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	const (
		lc968 int32 = 4
	)
	for 1 != 0 {
		var lc969 float64 = float64(lua_objlen(L, 3))
		lua_pushnumber(L, lua_Number((lc969)))
		var lc970 int32 = lua_lessthan(L, 4, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc970)
		if noarch.Not(lua_toboolean(L, -1)) {
			break
		}
		lua_settop(L, -(1)-1)
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_gettable(L, 3)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13060, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
			}
		}()
		const (
			lc971 int32 = 5
		)
		lua_pushboolean(L, 0)
		var lc972 int32 = lua_equal(L, 5, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc972)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		var lc973 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc973 != 0 {
			lua_pushvalue(L, 5)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13077, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc971)))
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13080, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
			}
		}()
		lua_pushnumber(L, 1)
		lc_add(L, 4, -1)
		lua_remove(L, -2)
		lua_replace(L, 4)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13087, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
			}
		}()
		lua_settop(L, -(1)-1)
	}
	lua_settop(L, int32((lc968)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13093, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	lua_settop(L, -(1)-1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13097, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	var lc974 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 1, 180)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc974
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13104, []byte("int lcf1_readsysname_no_pack_inner_must(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_may_xfx_xf - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:13109
func lcf1_may_xfx_xf(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc975 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 1, 183)
	lua_call(L, 0, 1)
	var lc976 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc976 != 0 {
		lua_pushvalue(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13124, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc975)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13127, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13132, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
		}
	}()
	const (
		lc977 int32 = 2
	)
	lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
	var lc978 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc978)
	var lc979 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc979 != 0 {
		lc_getupvalue(L, -10002-1, 0, 189)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13147, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
			}
		}()
		var lc980 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 21, 21)
		lc_getupvalue(L, -10002-1, 15, 117)
		lc_getupvalue(L, -10002-1, 21, 21)
		lc_getupvalue(L, -10002-1, 21, 47)
		lc_getupvalue(L, -10002-1, 21, 21)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 1)
		lc_getupvalue(L, -10002-1, 16, 116)
		lua_call(L, 3, 1)
		lua_pushvalue(L, 3)
		lua_call(L, 3, -1)
		return lua_gettop(L) - lc980
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13164, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc981 int32 = 2
		)
		lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
		var lc982 int32 = lua_equal(L, 2, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc982)
		var lc983 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc983 != 0 {
			lc_getupvalue(L, -10002-1, 0, 189)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13180, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
				}
			}()
			var lc984 int32 = lua_gettop(L)
			lc_getupvalue(L, -10002-1, 21, 21)
			lc_getupvalue(L, -10002-1, 15, 117)
			lua_pushvalue(L, 3)
			lua_pushvalue(L, 1)
			lua_call(L, 3, -1)
			return lua_gettop(L) - lc984
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13190, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc985 int32 = 2
			)
			lua_pushlstring(L, []byte("~\x00"), uint(2/1-1))
			var lc986 int32 = lua_equal(L, 2, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc986)
			var lc987 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc987 != 0 {
				var lc988 int32 = lua_gettop(L)
				lc_getupvalue(L, -10002-1, 21, 21)
				lc_getupvalue(L, -10002-1, 14, 118)
				lua_pushvalue(L, 1)
				lua_call(L, 2, -1)
				return lua_gettop(L) - lc988
				func() {
					if lua_gettop(L) == 2 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13210, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc989 int32 = 2
				)
				lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
				var lc990 int32 = lua_equal(L, 2, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc990)
				var lc991 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc991 != 0 {
					lc_getupvalue(L, -10002-1, 0, 189)
					lua_call(L, 0, 1)
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13226, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
						}
					}()
					var lc992 int32 = lua_gettop(L)
					lc_getupvalue(L, -10002-1, 21, 21)
					lc_getupvalue(L, -10002-1, 15, 117)
					lc_getupvalue(L, -10002-1, 21, 21)
					lc_getupvalue(L, -10002-1, 21, 47)
					lc_getupvalue(L, -10002-1, 21, 83)
					lua_pushvalue(L, 1)
					lc_getupvalue(L, -10002-1, 16, 116)
					lua_call(L, 2, 1)
					lc_getupvalue(L, -10002-1, 16, 116)
					lua_call(L, 3, 1)
					lua_pushvalue(L, 3)
					lua_call(L, 3, -1)
					return lua_gettop(L) - lc992
					func() {
						if lua_gettop(L) == 3 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13244, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc993 int32 = 2
					)
					lua_pushlstring(L, []byte("?\x00"), uint(2/1-1))
					var lc994 int32 = lua_equal(L, 2, -1)
					lua_settop(L, -(1)-1)
					lua_pushboolean(L, lc994)
					var lc995 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc995 != 0 {
						var lc996 int32 = lua_gettop(L)
						lc_getupvalue(L, -10002-1, 21, 21)
						var lc997 int32 = lua_gettop(L)
						lc_getupvalue(L, -10002-1, 15, 117)
						lc_getupvalue(L, -10002-1, 21, 47)
						lc_getupvalue(L, -10002-1, 21, 21)
						lc_getupvalue(L, -10002-1, 14, 118)
						lua_pushvalue(L, 1)
						lua_call(L, 2, -1)
						lua_call(L, lua_gettop(L)-lc997, -1)
						return lua_gettop(L) - lc996
						func() {
							if lua_gettop(L) == 2 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13270, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc998 int32 = 2
						)
						lua_pushlstring(L, []byte("/\x00"), uint(2/1-1))
						var lc999 int32 = lua_equal(L, 2, -1)
						lua_settop(L, -(1)-1)
						lua_pushboolean(L, lc999)
						var lc1000 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc1000 != 0 {
							lua_createtable(L, 1, 0)
							lua_pushvalue(L, 1)
							lua_rawseti(L, -2, 1)
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13287, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
								}
							}()
							const (
								lc1001 int32 = 3
							)
							for 1 != 0 {
								lua_pushboolean(L, 1)
								if noarch.Not(lua_toboolean(L, -1)) {
									break
								}
								lua_settop(L, -(1)-1)
								lc_getupvalue(L, -10002-1, 0, 189)
								lua_pushboolean(L, 1)
								lua_call(L, 1, 1)
								func() {
									if lua_gettop(L) == 4 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13302, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
									}
								}()
								lc_getupvalue(L, -10002-1, 22, 1)
								lua_pushvalue(L, 3)
								lua_pushvalue(L, 4)
								lua_call(L, 2, 0)
								func() {
									if lua_gettop(L) == 4 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13309, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
									}
								}()
								const (
									lc1002 int32 = 4
								)
								lc_getupvalue(L, -10002-1, 1, 183)
								lua_call(L, 0, 1)
								var lc1003 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc1003 != 0 {
									break
									func() {
										if lua_gettop(L) == 4 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13321, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
										}
									}()
								}
								lua_settop(L, int32((lc1002)))
								func() {
									if lua_gettop(L) == 4 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13324, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
									}
								}()
								lc_getupvalue(L, -10002-1, 1, 182)
								lua_call(L, 0, 1)
								func() {
									if lua_gettop(L) == 5 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13329, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
									}
								}()
								const (
									lc1004 int32 = 5
								)
								lua_pushlstring(L, []byte("/\x00"), uint(2/1-1))
								var lc1005 int32 = lua_equal(L, 5, -1)
								lua_settop(L, -(1)-1)
								lua_pushboolean(L, lc1005)
								lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
								lua_remove(L, -2)
								var lc1006 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc1006 != 0 {
									lc_getupvalue(L, -10002-1, 1, 181)
									lua_pushvalue(L, 5)
									lua_call(L, 1, 0)
									func() {
										if lua_gettop(L) == 5 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13347, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
										}
									}()
									break
									func() {
										if lua_gettop(L) == 5 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13351, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
										}
									}()
								}
								lua_settop(L, int32((lc1004)))
								func() {
									if lua_gettop(L) == 5 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13354, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
									}
								}()
								lua_settop(L, -(2)-1)
							}
							lua_settop(L, int32((lc1001)))
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13360, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
								}
							}()
							var lc1007 int32 = lua_gettop(L)
							lc_getupvalue(L, -10002-1, 21, 21)
							var lc1008 int32 = lua_gettop(L)
							lc_getupvalue(L, -10002-1, 13, 119)
							lc_getupvalue(L, -10002-1, 21, 22)
							lua_pushvalue(L, 3)
							lua_call(L, 1, -1)
							lua_call(L, lua_gettop(L)-lc1008, -1)
							return lua_gettop(L) - lc1007
							func() {
								if lua_gettop(L) == 3 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13372, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
								}
							}()
						} else {
							lc_getupvalue(L, -10002-1, 1, 181)
							lua_pushvalue(L, 2)
							lua_call(L, 1, 0)
							func() {
								if lua_gettop(L) == 2 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13380, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
								}
							}()
							lua_pushvalue(L, 1)
							return 1
							func() {
								if lua_gettop(L) == 2 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13385, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc998)))
					}
					lua_settop(L, int32((lc993)))
				}
				lua_settop(L, int32((lc989)))
			}
			lua_settop(L, int32((lc985)))
		}
		lua_settop(L, int32((lc981)))
	}
	lua_settop(L, int32((lc977)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13398, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
		}
	}()
	var lc1009 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 21, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1009
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13405, []byte("int lcf1_may_xfx_xf(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_readsysname_no_pack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:13410
func lcf1_readsysname_no_pack(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_newclosuretable(L, -10002-1)
	const (
		lc964 int32 = 1
	)
	func() {
		if lua_gettop(L) == int32((lc964)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc964)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13417, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+2)
	lua_rawseti(L, int32((lc964)), 189)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13420, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc964)))
	lua_pushcclosure(L, lcf1_readsysname_no_pack_inner_must, 1)
	lc_setupvalue(L, int32((lc964)), 0, 189)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13452, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc964)))
	lua_pushcclosure(L, lcf1_may_xfx_xf, 1)
	lua_replace(L, 2)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13500, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	const (
		lc1010 int32 = 2
	)
	lc_getupvalue(L, int32((lc964)), 1, 183)
	lua_call(L, 0, 1)
	var lc1011 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1011 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13513, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1010)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13516, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc964)), 1, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13521, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	const (
		lc1012 int32 = 3
	)
	lua_pushlstring(L, []byte("&\x00"), uint(2/1-1))
	var lc1013 int32 = lua_equal(L, 3, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1013)
	var lc1014 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1014 != 0 {
		lc_getupvalue(L, int32((lc964)), 1, 167)
		var lc1015 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc964)), 1, 166)
		lua_call(L, 0, -1)
		lua_call(L, lua_gettop(L)-lc1015, 0)
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13539, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc964)), 1, 182)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13544, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
		const (
			lc1016 int32 = 4
		)
		lua_pushlstring(L, []byte("+\x00"), uint(2/1-1))
		var lc1017 int32 = lua_equal(L, 4, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc1017)
		var lc1018 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1018 != 0 {
			lc_getupvalue(L, int32((lc964)), 0, 189)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13559, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
			var lc1019 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc964)), 21, 21)
			var lc1020 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc964)), 21, 46)
			lc_getupvalue(L, int32((lc964)), 21, 21)
			lc_getupvalue(L, int32((lc964)), 21, 48)
			lua_pushvalue(L, 5)
			lua_call(L, 2, -1)
			lua_call(L, lua_gettop(L)-lc1020, -1)
			return lua_gettop(L) - lc1019
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13572, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
		} else {
			lc_getupvalue(L, int32((lc964)), 1, 181)
			lua_pushvalue(L, 4)
			lua_call(L, 1, 0)
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13580, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1016)))
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13583, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc964)), 0, 189)
		lua_call(L, 0, 1)
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13588, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
		var lc1021 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc964)), 21, 21)
		lc_getupvalue(L, int32((lc964)), 21, 46)
		lua_pushvalue(L, 5)
		lua_call(L, 2, -1)
		return lua_gettop(L) - lc1021
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13597, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc1022 int32 = 3
		)
		lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
		var lc1023 int32 = lua_equal(L, 3, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc1023)
		var lc1024 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1024 != 0 {
			lc_getupvalue(L, int32((lc964)), 1, 167)
			var lc1025 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc964)), 1, 166)
			lua_call(L, 0, -1)
			lua_call(L, lua_gettop(L)-lc1025, 0)
			func() {
				if lua_gettop(L) == 3 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13616, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc964)), 1, 182)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13621, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
			const (
				lc1026 int32 = 4
			)
			lua_pushlstring(L, []byte("&\x00"), uint(2/1-1))
			var lc1027 int32 = lua_equal(L, 4, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc1027)
			var lc1028 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1028 != 0 {
				lc_getupvalue(L, int32((lc964)), 1, 165)
				lua_pushlstring(L, []byte(">\x00"), uint(2/1-1))
				lua_call(L, 1, 0)
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13637, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, int32((lc964)), 0, 189)
				lua_call(L, 0, 1)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13642, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
					}
				}()
				var lc1029 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc964)), 21, 21)
				lc_getupvalue(L, int32((lc964)), 15, 117)
				lc_getupvalue(L, int32((lc964)), 21, 21)
				var lc1030 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc964)), 21, 46)
				lc_getupvalue(L, int32((lc964)), 21, 21)
				lc_getupvalue(L, int32((lc964)), 21, 47)
				lc_getupvalue(L, int32((lc964)), 16, 116)
				lua_pushvalue(L, 5)
				lua_call(L, 3, -1)
				lua_call(L, lua_gettop(L)-lc1030, 1)
				lc_getupvalue(L, int32((lc964)), 17, 115)
				lua_call(L, 3, -1)
				return lua_gettop(L) - lc1029
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13661, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc1031 int32 = 4
				)
				lua_pushlstring(L, []byte(">\x00"), uint(2/1-1))
				var lc1032 int32 = lua_equal(L, 4, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc1032)
				var lc1033 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1033 != 0 {
					lc_getupvalue(L, int32((lc964)), 0, 189)
					lua_call(L, 0, 1)
					func() {
						if lua_gettop(L) == 5 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13677, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
					var lc1034 int32 = lua_gettop(L)
					lc_getupvalue(L, int32((lc964)), 21, 21)
					lc_getupvalue(L, int32((lc964)), 15, 117)
					lc_getupvalue(L, int32((lc964)), 21, 21)
					lc_getupvalue(L, int32((lc964)), 21, 47)
					lc_getupvalue(L, int32((lc964)), 16, 116)
					lua_pushvalue(L, 5)
					lua_call(L, 3, 1)
					lc_getupvalue(L, int32((lc964)), 17, 115)
					lua_call(L, 3, -1)
					return lua_gettop(L) - lc1034
					func() {
						if lua_gettop(L) == 5 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13692, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
				} else {
					lc_getupvalue(L, int32((lc964)), 1, 181)
					lua_pushvalue(L, 4)
					lua_call(L, 1, 0)
					func() {
						if lua_gettop(L) == 4 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13700, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc1031)))
			}
			lua_settop(L, int32((lc1026)))
			func() {
				if lua_gettop(L) == 4 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13705, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc964)), 0, 189)
			lua_call(L, 0, 1)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13710, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
			var lc1035 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc964)), 21, 21)
			lc_getupvalue(L, int32((lc964)), 15, 117)
			lua_pushvalue(L, 5)
			lc_getupvalue(L, int32((lc964)), 17, 115)
			lua_call(L, 3, -1)
			return lua_gettop(L) - lc1035
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13720, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc1036 int32 = 3
			)
			lua_pushlstring(L, []byte("+\x00"), uint(2/1-1))
			var lc1037 int32 = lua_equal(L, 3, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc1037)
			var lc1038 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1038 != 0 {
				lc_getupvalue(L, int32((lc964)), 0, 189)
				lua_call(L, 0, 1)
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13736, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
					}
				}()
				var lc1039 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc964)), 21, 21)
				lc_getupvalue(L, int32((lc964)), 21, 48)
				lua_pushvalue(L, 4)
				lua_call(L, 2, -1)
				return lua_gettop(L) - lc1039
				func() {
					if lua_gettop(L) == 4 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13745, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc1040 int32 = 3
				)
				lua_pushlstring(L, []byte("[\x00"), uint(2/1-1))
				var lc1041 int32 = lua_equal(L, 3, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc1041)
				var lc1042 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1042 != 0 {
					lc_getupvalue(L, int32((lc964)), 0, 189)
					lua_call(L, 0, 1)
					func() {
						if lua_gettop(L) == 4 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13761, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
					lc_getupvalue(L, int32((lc964)), 1, 165)
					lua_pushlstring(L, []byte("]\x00"), uint(2/1-1))
					lua_call(L, 1, 0)
					func() {
						if lua_gettop(L) == 4 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13767, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
					var lc1043 int32 = lua_gettop(L)
					lua_pushvalue(L, 2)
					lua_pushvalue(L, 4)
					lua_call(L, 1, -1)
					return lua_gettop(L) - lc1043
					func() {
						if lua_gettop(L) == 4 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13775, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc1044 int32 = 3
					)
					lua_pushlstring(L, []byte("_\x00"), uint(2/1-1))
					var lc1045 int32 = lua_equal(L, 3, -1)
					lua_settop(L, -(1)-1)
					lua_pushboolean(L, lc1045)
					var lc1046 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc1046 != 0 {
						lc_getupvalue(L, int32((lc964)), 1, 165)
						lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
						lua_call(L, 1, 0)
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13792, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
						lc_getupvalue(L, int32((lc964)), 0, 189)
						lua_call(L, 0, 1)
						func() {
							if lua_gettop(L) == 4 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13797, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
						var lc1047 int32 = lua_gettop(L)
						lc_getupvalue(L, int32((lc964)), 21, 21)
						lc_getupvalue(L, int32((lc964)), 15, 117)
						lua_pushvalue(L, 4)
						lc_getupvalue(L, int32((lc964)), 16, 116)
						lua_call(L, 3, -1)
						return lua_gettop(L) - lc1047
						func() {
							if lua_gettop(L) == 4 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13807, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
					} else {
						lc_getupvalue(L, int32((lc964)), 1, 181)
						lua_pushvalue(L, 3)
						lua_call(L, 1, 0)
						func() {
							if lua_gettop(L) == 3 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13815, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
						lc_getupvalue(L, int32((lc964)), 1, 177)
						lua_call(L, 0, 1)
						func() {
							if lua_gettop(L) == 4 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13820, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
						const (
							lc1048 int32 = 4
						)
						lua_pushboolean(L, 0)
						var lc1049 int32 = lua_equal(L, 4, -1)
						lua_settop(L, -(1)-1)
						lua_pushboolean(L, lc1049)
						var lc1050 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc1050 != 0 {
							lua_pushboolean(L, 0)
							return 1
							func() {
								if lua_gettop(L) == 4 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13835, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc1048)))
						func() {
							if lua_gettop(L) == 4 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13838, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
						var lc1051 int32 = lua_gettop(L)
						lua_pushvalue(L, 2)
						lua_pushvalue(L, 4)
						lua_call(L, 1, -1)
						return lua_gettop(L) - lc1051
						func() {
							if lua_gettop(L) == 4 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13846, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc1044)))
				}
				lua_settop(L, int32((lc1040)))
			}
			lua_settop(L, int32((lc1036)))
		}
		lua_settop(L, int32((lc1022)))
	}
	lua_settop(L, int32((lc1012)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13857, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	var lc1052 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc964)), 21, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1052
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13864, []byte("int lcf1_readsysname_no_pack(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_readsysname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:13869
func lcf1_readsysname(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	lc_getupvalue(L, -10002-1, 0, 164)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13876, []byte("int lcf1_readsysname(lua_State *)\x00"))
		}
	}()
	const (
		lc1053 int32 = 1
	)
	lua_pushboolean(L, 0)
	var lc1054 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1054)
	var lc1055 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1055 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13891, []byte("int lcf1_readsysname(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1053)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13894, []byte("int lcf1_readsysname(lua_State *)\x00"))
		}
	}()
	const (
		lc1056 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 20, 85)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc1057 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1057 != 0 {
		lua_pushvalue(L, 1)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13908, []byte("int lcf1_readsysname(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1056)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13911, []byte("int lcf1_readsysname(lua_State *)\x00"))
		}
	}()
	var lc1058 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 9, 122)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	return lua_gettop(L) - lc1058
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13919, []byte("int lcf1_readsysname(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1078 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:13923
func lcf1078(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc1060 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 1, 183)
	lua_call(L, 0, 1)
	var lc1061 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1061 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13938, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1060)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13941, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13946, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	const (
		lc1062 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 190)
	var lc1063 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1063)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1064 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1064 != 0 {
		lc_getupvalue(L, -10002-1, 1, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13964, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13969, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1062)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13972, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 176)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13977, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	const (
		lc1065 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc1066 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1066)
	var lc1067 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1067 != 0 {
		var lc1068 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1068
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13994, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1065)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 13997, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	const (
		lc1069 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1070 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1070 != 0 {
		var lc1071 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1071
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14015, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1069)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14018, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14024, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	const (
		lc1072 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 21, 78)
		var lc1073 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 21, 80)
		lua_pushvalue(L, 3)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc1073, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1074 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1074 != 0 {
		var lc1075 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1075
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14051, []byte("int lcf1078(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1072)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14054, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	var lc1076 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 191)
	var lc1077 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 3)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc1077, -1)
	return lua_gettop(L) - lc1076
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14068, []byte("int lcf1078(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_make_read_two - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14073
func lcf2_make_read_two(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc1059 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc1059)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc1059)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14078, []byte("int lcf2_make_read_two(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 190)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 191)
	lua_pushvalue(L, int32((lc1059)))
	lua_pushcclosure(L, lcf1078, 1)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14110, []byte("int lcf2_make_read_two(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1101 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14114
func lcf1101(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 0
	)
	lua_settop(L, 0)
	const (
		lc1080 int32 = 0
	)
	lc_getupvalue(L, -10002-1, 1, 183)
	lua_call(L, 0, 1)
	var lc1081 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1081 != 0 {
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14129, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1080)))
	func() {
		if lua_gettop(L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14132, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 182)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14137, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	const (
		lc1082 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 192)
	var lc1083 int32 = lua_equal(L, 1, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1083)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1084 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1084 != 0 {
		lc_getupvalue(L, -10002-1, 1, 181)
		lua_pushvalue(L, 1)
		lua_call(L, 1, 0)
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14155, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
		lua_pushboolean(L, 0)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14160, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1082)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14163, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 1, 176)
	lua_call(L, 0, 1)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14168, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	const (
		lc1085 int32 = 2
	)
	lua_pushboolean(L, 0)
	var lc1086 int32 = lua_equal(L, 2, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1086)
	var lc1087 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1087 != 0 {
		var lc1088 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1088
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14185, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1085)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14188, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	const (
		lc1089 int32 = 2
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1090 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1090 != 0 {
		var lc1091 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1091
		func() {
			if lua_gettop(L) == 2 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14206, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1089)))
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14209, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14215, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	const (
		lc1092 int32 = 3
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1093 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1093 != 0 {
		var lc1094 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1094
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14233, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1092)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14236, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 21, 80)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14242, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	const (
		lc1095 int32 = 4
	)
	lc_getupvalue(L, -10002-1, 21, 82)
	lua_pushvalue(L, 4)
	lua_call(L, 1, 1)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, -10002-1, 21, 78)
		var lc1096 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 21, 80)
		lua_pushvalue(L, 4)
		lua_call(L, 1, -1)
		lua_call(L, lua_gettop(L)-lc1096, 1)
	}
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	var lc1097 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1097 != 0 {
		var lc1098 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 1, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1098
		func() {
			if lua_gettop(L) == 4 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14269, []byte("int lcf1101(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1095)))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14272, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	var lc1099 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 193)
	var lc1100 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 2)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	lc_getupvalue(L, -10002-1, 21, 81)
	lua_pushvalue(L, 4)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc1100, -1)
	return lua_gettop(L) - lc1099
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14290, []byte("int lcf1101(lua_State *)\x00"))
		}
	}()
	return
}

// lcf2_make_read_three - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14295
func lcf2_make_read_three(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc1079 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc1079)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc1079)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14300, []byte("int lcf2_make_read_three(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lua_rawseti(L, -2, 192)
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 193)
	lua_pushvalue(L, int32((lc1079)))
	lua_pushcclosure(L, lcf1101, 1)
	return 1
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14337, []byte("int lcf2_make_read_three(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1107 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14341
func lcf1107(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 3, 128)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14349, []byte("int lcf1107(lua_State *)\x00"))
		}
	}()
	const (
		lc1102 int32 = 3
	)
	lua_pushboolean(L, 0)
	var lc1103 int32 = lua_equal(L, 3, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1103)
	var lc1104 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1104 != 0 {
		var lc1105 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1105
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14366, []byte("int lcf1107(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1102)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14369, []byte("int lcf1107(lua_State *)\x00"))
		}
	}()
	var lc1106 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 66)
	lua_pushvalue(L, 3)
	lua_pushvalue(L, 2)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc1106
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14378, []byte("int lcf1107(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1108 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14382
func lcf1108(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14389, []byte("int lcf1108(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1110 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14393
func lcf1110(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc1109 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 180)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1109
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14402, []byte("int lcf1110(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1112 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14406
func lcf1112(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 2)
	lua_pushcclosure(L, lcf1108, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf1110, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14421, []byte("int lcf1112(lua_State *)\x00"))
		}
	}()
	var lc1111 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 57)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 3)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc1111
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14430, []byte("int lcf1112(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1113 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14434
func lcf1113(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14441, []byte("int lcf1113(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1115 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14445
func lcf1115(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc1114 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 180)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1114
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14454, []byte("int lcf1115(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1121 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14458
func lcf1121(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 3
	)
	lua_settop(L, 3)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 3)
	lua_pushcclosure(L, lcf1113, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf1115, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14473, []byte("int lcf1121(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, -10002-1, 3, 128)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14479, []byte("int lcf1121(lua_State *)\x00"))
		}
	}()
	const (
		lc1116 int32 = 5
	)
	lua_pushboolean(L, 0)
	var lc1117 int32 = lua_equal(L, 5, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1117)
	var lc1118 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1118 != 0 {
		var lc1119 int32 = lua_gettop(L)
		lc_getupvalue(L, -10002-1, 0, 180)
		lua_call(L, 0, -1)
		return lua_gettop(L) - lc1119
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14496, []byte("int lcf1121(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1116)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14499, []byte("int lcf1121(lua_State *)\x00"))
		}
	}()
	var lc1120 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 62)
	lua_pushvalue(L, 5)
	lua_pushvalue(L, 2)
	lua_pushvalue(L, 4)
	lua_call(L, 3, -1)
	return lua_gettop(L) - lc1120
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14509, []byte("int lcf1121(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1122 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14513
func lcf1122(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lua_pushvalue(L, 1)
	return 1
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14520, []byte("int lcf1122(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1124 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14524
func lcf1124(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	var lc1123 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 0, 180)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1123
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14533, []byte("int lcf1124(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1126 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14537
func lcf1126(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_getupvalue(L, -10002-1, 5, 126)
	lua_pushvalue(L, 2)
	lua_pushcclosure(L, lcf1122, 0)
	lua_pushvalue(L, -10002-1)
	lua_pushcclosure(L, lcf1124, 1)
	lua_call(L, 3, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14552, []byte("int lcf1126(lua_State *)\x00"))
		}
	}()
	var lc1125 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 20, 53)
	lua_pushvalue(L, 1)
	lua_pushvalue(L, 3)
	lua_call(L, 2, -1)
	return lua_gettop(L) - lc1125
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14561, []byte("int lcf1126(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_complex_parse - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:14566
func lcf1_complex_parse(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_newclosuretable(L, -10002-1)
	const (
		lc849 int32 = 2
	)
	func() {
		if lua_gettop(L) == int32((lc849)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc849)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14576, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+23)
	lua_rawseti(L, int32((lc849)), 163)
	lua_rawseti(L, int32((lc849)), 164)
	lua_rawseti(L, int32((lc849)), 165)
	lua_rawseti(L, int32((lc849)), 166)
	lua_rawseti(L, int32((lc849)), 167)
	lua_rawseti(L, int32((lc849)), 168)
	lua_rawseti(L, int32((lc849)), 169)
	lua_rawseti(L, int32((lc849)), 170)
	lua_rawseti(L, int32((lc849)), 171)
	lua_rawseti(L, int32((lc849)), 172)
	lua_rawseti(L, int32((lc849)), 173)
	lua_rawseti(L, int32((lc849)), 174)
	lua_rawseti(L, int32((lc849)), 175)
	lua_rawseti(L, int32((lc849)), 176)
	lua_rawseti(L, int32((lc849)), 177)
	lua_rawseti(L, int32((lc849)), 178)
	lua_rawseti(L, int32((lc849)), 179)
	lua_rawseti(L, int32((lc849)), 180)
	lua_rawseti(L, int32((lc849)), 181)
	lua_rawseti(L, int32((lc849)), 182)
	lua_rawseti(L, int32((lc849)), 183)
	lua_rawseti(L, int32((lc849)), 184)
	lua_rawseti(L, int32((lc849)), 185)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14601, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_eof, 1)
	lc_setupvalue(L, int32((lc849)), 0, 183)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14609, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_get, 1)
	lc_setupvalue(L, int32((lc849)), 0, 182)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14620, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_put, 1)
	lc_setupvalue(L, int32((lc849)), 0, 181)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14629, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf2_parse_error, 0)
	lc_setupvalue(L, int32((lc849)), 0, 180)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14636, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf2_a_space_p, 0)
	lc_setupvalue(L, int32((lc849)), 0, 179)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14643, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_space, 1)
	lc_setupvalue(L, int32((lc849)), 0, 178)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14665, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_symbol, 1)
	lc_setupvalue(L, int32((lc849)), 0, 177)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14691, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_list, 1)
	lc_setupvalue(L, int32((lc849)), 0, 176)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14765, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_data, 1)
	lc_setupvalue(L, int32((lc849)), 0, 175)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14788, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_readerror, 1)
	lc_setupvalue(L, int32((lc849)), 0, 174)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14811, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_a_symbol_p, 1)
	lc_setupvalue(L, int32((lc849)), 0, 169)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14833, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_val, 1)
	lc_setupvalue(L, int32((lc849)), 0, 168)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14854, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1_un_maybe, 1)
	lc_setupvalue(L, int32((lc849)), 0, 167)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14865, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1_not_eof, 1)
	lc_setupvalue(L, int32((lc849)), 0, 166)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14873, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1_assert_get, 1)
	lc_setupvalue(L, int32((lc849)), 0, 165)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 14882, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1_readsysname_no_pack, 1)
	lc_setupvalue(L, int32((lc849)), 0, 164)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15013, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1_readsysname, 1)
	lc_setupvalue(L, int32((lc849)), 0, 163)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15028, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 1)
	lc_setupvalue(L, int32((lc849)), 0, 185)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15033, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	lc_setupvalue(L, int32((lc849)), 0, 184)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15038, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15042, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_make_read_two, 1)
	lua_replace(L, 3)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15072, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15076, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf2_make_read_three, 1)
	lua_replace(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15111, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("$\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1107, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc849)), 0, 173)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15126, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("%\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1112, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc849)), 0, 172)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15142, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 4)
	lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1121, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc849)), 0, 171)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15162, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 3)
	lua_pushlstring(L, []byte("^\x00"), uint(2/1-1))
	lua_pushvalue(L, int32((lc849)))
	lua_pushcclosure(L, lcf1126, 1)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc849)), 0, 170)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15178, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	var lc1127 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc849)), 0, 168)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1127
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15185, []byte("int lcf1_complex_parse(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_inner_bracket - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:15190
func lcf1_inner_bracket(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	const (
		lc1134 int32 = 1
	)
	lc_getupvalue(L, -10002-1, 0, 196)
	lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
	var lc1135 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc1135)
	var lc1136 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1136 != 0 {
		lua_pushlstring(L, []byte("[\x00"), uint(2/1-1))
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
		lua_pushlstring(L, []byte("]\x00"), uint(2/1-1))
		lua_concat(L, 2)
		return 1
		func() {
			if lua_gettop(L) == 1 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15212, []byte("int lcf1_inner_bracket(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc1137 int32 = 1
		)
		lc_getupvalue(L, -10002-1, 0, 196)
		lua_pushlstring(L, []byte("top\x00"), uint(4/1-1))
		var lc1138 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc1138)
		var lc1139 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1139 != 0 {
			lua_pushvalue(L, 1)
			return 1
			func() {
				if lua_gettop(L) == 1 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15229, []byte("int lcf1_inner_bracket(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1137)))
	}
	lua_settop(L, int32((lc1134)))
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15234, []byte("int lcf1_inner_bracket(lua_State *)\x00"))
		}
	}()
	var lc1140 int32 = lua_gettop(L)
	lc_getupvalue(L, -10002-1, 22, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1140
	func() {
		if lua_gettop(L) == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15241, []byte("int lcf1_inner_bracket(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_print_sys_name - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:15246
func lcf1_print_sys_name(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 2
	)
	lua_settop(L, 2)
	lc_newclosuretable(L, -10002-1)
	const (
		lc1130 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc1130)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc1130)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15251, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2)
	lua_rawseti(L, -2, 196)
	const (
		lc1131 int32 = 3
	)
	lc_getupvalue(L, int32((lc1130)), 22, 85)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	var lc1132 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1132 != 0 {
		var lc1133 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc1130)), 22, 84)
		lua_pushvalue(L, 1)
		lua_call(L, 1, -1)
		return lua_gettop(L) - lc1133
		func() {
			if lua_gettop(L) == 3 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15270, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
	}
	lua_settop(L, int32((lc1131)))
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15273, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15277, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc1130)))
	lua_pushcclosure(L, lcf1_inner_bracket, 1)
	lua_replace(L, 4)
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15290, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc1130)), 6, 127)
	lua_pushvalue(L, 1)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15296, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	const (
		lc1141 int32 = 5
	)
	lua_pushboolean(L, 0)
	var lc1142 int32 = lua_equal(L, 5, -1)
	lua_settop(L, -(1)-1)
	lua_pushboolean(L, lc1142)
	lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
	lua_remove(L, -2)
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		var lc1143 float64 = float64(lua_objlen(L, 5))
		lua_pushnumber(L, lua_Number((lc1143)))
		lua_pushnumber(L, 3)
		var lc1144 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc1144)
	}
	if lua_toboolean(L, -1) != 0 {
		lua_settop(L, -(1)-1)
		lc_getupvalue(L, int32((lc1130)), 4, 136)
		lua_pushnumber(L, 1)
		lua_gettable(L, 5)
		lc_getupvalue(L, int32((lc1130)), 16, 117)
		lua_call(L, 2, 1)
	}
	var lc1145 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1145 != 0 {
		lc_getupvalue(L, int32((lc1130)), 6, 127)
		lua_pushnumber(L, 2)
		lua_gettable(L, 5)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15333, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		const (
			lc1146 int32 = 6
		)
		lua_pushboolean(L, 0)
		var lc1147 int32 = lua_equal(L, 6, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc1147)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			var lc1148 float64 = float64(lua_objlen(L, 6))
			lua_pushnumber(L, lua_Number((lc1148)))
			lua_pushnumber(L, 3)
			var lc1149 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc1149)
		}
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 1)
			lua_gettable(L, 6)
			lc_getupvalue(L, int32((lc1130)), 22, 47)
			lua_call(L, 2, 1)
		}
		var lc1150 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1150 != 0 {
			lua_pushnumber(L, 2)
			lua_gettable(L, 6)
			func() {
				if lua_gettop(L) == 7 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15368, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
			lc_getupvalue(L, int32((lc1130)), 6, 127)
			lua_pushvalue(L, 7)
			lua_call(L, 1, 1)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15374, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
			const (
				lc1151 int32 = 8
			)
			lua_pushboolean(L, 0)
			var lc1152 int32 = lua_equal(L, 8, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc1152)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				var lc1153 float64 = float64(lua_objlen(L, 8))
				lua_pushnumber(L, lua_Number((lc1153)))
				lua_pushnumber(L, 1)
				var lc1154 int32 = lua_equal(L, -2, -1)
				lua_settop(L, -(2)-1)
				lua_pushboolean(L, lc1154)
			}
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc1130)), 4, 136)
				lua_pushnumber(L, 3)
				lua_gettable(L, 6)
				lc_getupvalue(L, int32((lc1130)), 17, 116)
				lua_call(L, 2, 1)
			}
			var lc1155 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1155 != 0 {
				var lc1156 int32 = lua_gettop(L)
				lua_pushvalue(L, 4)
				lc_getupvalue(L, int32((lc1130)), 1, 195)
				lua_pushnumber(L, 1)
				lua_gettable(L, 8)
				lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
				lua_call(L, 2, 1)
				lua_pushlstring(L, []byte(".\x00"), uint(2/1-1))
				lua_concat(L, 2)
				lc_getupvalue(L, int32((lc1130)), 1, 195)
				lua_pushnumber(L, 3)
				lua_gettable(L, 5)
				lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
				lua_call(L, 2, 1)
				lua_concat(L, 2)
				lua_call(L, 1, -1)
				return lua_gettop(L) - lc1156
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15425, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc1157 int32 = 8
				)
				lc_getupvalue(L, int32((lc1130)), 22, 82)
				lua_pushvalue(L, 7)
				lua_call(L, 1, 1)
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					lc_getupvalue(L, int32((lc1130)), 4, 136)
					lc_getupvalue(L, int32((lc1130)), 22, 80)
					lua_pushvalue(L, 7)
					lua_call(L, 1, 1)
					lc_getupvalue(L, int32((lc1130)), 17, 116)
					lua_call(L, 2, 1)
				}
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					lc_getupvalue(L, int32((lc1130)), 4, 136)
					lua_pushnumber(L, 3)
					lua_gettable(L, 6)
					lc_getupvalue(L, int32((lc1130)), 17, 116)
					lua_call(L, 2, 1)
				}
				var lc1158 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1158 != 0 {
					var lc1159 int32 = lua_gettop(L)
					lua_pushvalue(L, 4)
					lc_getupvalue(L, int32((lc1130)), 1, 195)
					lc_getupvalue(L, int32((lc1130)), 22, 81)
					lua_pushvalue(L, 7)
					lua_call(L, 1, 1)
					lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
					lua_call(L, 2, 1)
					lua_pushlstring(L, []byte("@\x00"), uint(2/1-1))
					lua_concat(L, 2)
					lc_getupvalue(L, int32((lc1130)), 1, 195)
					lua_pushnumber(L, 3)
					lua_gettable(L, 5)
					lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
					lua_call(L, 2, 1)
					lua_concat(L, 2)
					lua_call(L, 1, -1)
					return lua_gettop(L) - lc1159
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15477, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc1160 int32 = 8
					)
					lc_getupvalue(L, int32((lc1130)), 4, 136)
					lua_pushvalue(L, 7)
					lc_getupvalue(L, int32((lc1130)), 17, 116)
					lua_call(L, 2, 1)
					if lua_toboolean(L, -1) != 0 {
						lua_settop(L, -(1)-1)
						lc_getupvalue(L, int32((lc1130)), 4, 136)
						lua_pushnumber(L, 3)
						lua_gettable(L, 5)
						lc_getupvalue(L, int32((lc1130)), 18, 115)
						lua_call(L, 2, 1)
					}
					var lc1161 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc1161 != 0 {
						var lc1162 int32 = lua_gettop(L)
						lua_pushvalue(L, 4)
						lua_pushlstring(L, []byte(":>\x00"), uint(3/1-1))
						lc_getupvalue(L, int32((lc1130)), 1, 195)
						lua_pushnumber(L, 3)
						lua_gettable(L, 6)
						lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
						lua_call(L, 2, 1)
						lua_concat(L, 2)
						lua_call(L, 1, -1)
						return lua_gettop(L) - lc1162
						func() {
							if lua_gettop(L) == 8 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15512, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
							}
						}()
					}
					lua_settop(L, int32((lc1160)))
				}
				lua_settop(L, int32((lc1157)))
			}
			lua_settop(L, int32((lc1151)))
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15519, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1146)))
		func() {
			if lua_gettop(L) == 6 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15522, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc1130)), 6, 127)
		lua_pushnumber(L, 3)
		lua_gettable(L, 5)
		lua_call(L, 1, 1)
		func() {
			if lua_gettop(L) == 7 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15529, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		const (
			lc1163 int32 = 7
		)
		lc_getupvalue(L, int32((lc1130)), 4, 136)
		lua_pushnumber(L, 2)
		lua_gettable(L, 5)
		lc_getupvalue(L, int32((lc1130)), 22, 47)
		lua_call(L, 2, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, 0)
			var lc1164 int32 = lua_equal(L, 7, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc1164)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
		}
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			var lc1165 float64 = float64(lua_objlen(L, 7))
			lua_pushnumber(L, lua_Number((lc1165)))
			lua_pushnumber(L, 2)
			var lc1166 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc1166)
		}
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 1)
			lua_gettable(L, 7)
			lc_getupvalue(L, int32((lc1130)), 15, 118)
			lua_call(L, 2, 1)
		}
		var lc1167 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1167 != 0 {
			var lc1168 int32 = lua_gettop(L)
			lua_pushvalue(L, 4)
			lc_getupvalue(L, int32((lc1130)), 1, 195)
			lua_pushnumber(L, 2)
			lua_gettable(L, 7)
			lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
			lua_call(L, 2, 1)
			lua_pushlstring(L, []byte("?\x00"), uint(2/1-1))
			lua_concat(L, 2)
			lua_call(L, 1, -1)
			return lua_gettop(L) - lc1168
			func() {
				if lua_gettop(L) == 7 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15583, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1163)))
		func() {
			if lua_gettop(L) == 7 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15586, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		const (
			lc1169 int32 = 7
		)
		lua_pushboolean(L, 0)
		var lc1170 int32 = lua_equal(L, 6, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc1170)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			var lc1171 float64 = float64(lua_objlen(L, 6))
			lua_pushnumber(L, lua_Number((lc1171)))
			lua_pushnumber(L, 2)
			var lc1172 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc1172)
		}
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 3)
			lua_gettable(L, 5)
			lc_getupvalue(L, int32((lc1130)), 18, 115)
			lua_call(L, 2, 1)
		}
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 1)
			lua_gettable(L, 6)
			lc_getupvalue(L, int32((lc1130)), 22, 46)
			lua_call(L, 2, 1)
		}
		var lc1173 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1173 != 0 {
			lc_getupvalue(L, int32((lc1130)), 6, 127)
			lua_pushnumber(L, 2)
			lua_gettable(L, 6)
			lua_call(L, 1, 1)
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15632, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
			const (
				lc1174 int32 = 8
			)
			lua_pushboolean(L, 0)
			var lc1175 int32 = lua_equal(L, 8, -1)
			lua_settop(L, -(1)-1)
			lua_pushboolean(L, lc1175)
			lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
			lua_remove(L, -2)
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				var lc1176 float64 = float64(lua_objlen(L, 8))
				lua_pushnumber(L, lua_Number((lc1176)))
				lua_pushnumber(L, 3)
				var lc1177 int32 = lua_equal(L, -2, -1)
				lua_settop(L, -(2)-1)
				lua_pushboolean(L, lc1177)
			}
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc1130)), 4, 136)
				lua_pushnumber(L, 1)
				lua_gettable(L, 8)
				lc_getupvalue(L, int32((lc1130)), 22, 47)
				lua_call(L, 2, 1)
			}
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc1130)), 4, 136)
				lua_pushnumber(L, 2)
				lua_gettable(L, 8)
				lc_getupvalue(L, int32((lc1130)), 17, 116)
				lua_call(L, 2, 1)
			}
			var lc1178 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1178 != 0 {
				var lc1179 int32 = lua_gettop(L)
				lua_pushvalue(L, 4)
				lua_pushlstring(L, []byte(":&>\x00"), uint(4/1-1))
				lc_getupvalue(L, int32((lc1130)), 1, 195)
				lua_pushnumber(L, 3)
				lua_gettable(L, 8)
				lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
				lua_call(L, 2, 1)
				lua_concat(L, 2)
				lua_call(L, 1, -1)
				return lua_gettop(L) - lc1179
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15686, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc1174)))
			func() {
				if lua_gettop(L) == 8 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15689, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1169)))
		func() {
			if lua_gettop(L) == 7 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15692, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		lc_getupvalue(L, int32((lc1130)), 4, 136)
		lua_pushnumber(L, 3)
		lua_gettable(L, 5)
		lc_getupvalue(L, int32((lc1130)), 17, 116)
		lua_call(L, 2, 1)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			lua_pushlstring(L, []byte("_\x00"), uint(2/1-1))
		}
		if noarch.Not(lua_toboolean(L, -1)) {
			lua_settop(L, -(1)-1)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 3)
			lua_gettable(L, 5)
			lc_getupvalue(L, int32((lc1130)), 18, 115)
			lua_call(L, 2, 1)
			if lua_toboolean(L, -1) != 0 {
				lua_settop(L, -(1)-1)
				lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
			}
			if noarch.Not(lua_toboolean(L, -1)) {
				lua_settop(L, -(1)-1)
				lc_getupvalue(L, int32((lc1130)), 1, 195)
				lua_pushnumber(L, 3)
				lua_gettable(L, 5)
				lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
				lua_call(L, 2, 1)
			}
		}
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15726, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
		var lc1180 int32 = lua_gettop(L)
		lua_pushvalue(L, 4)
		lua_pushvalue(L, 8)
		lua_pushlstring(L, []byte(":\x00"), uint(2/1-1))
		lua_concat(L, 2)
		lc_getupvalue(L, int32((lc1130)), 1, 195)
		lua_pushnumber(L, 2)
		lua_gettable(L, 5)
		lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
		lua_call(L, 2, 1)
		lua_concat(L, 2)
		lua_call(L, 1, -1)
		return lua_gettop(L) - lc1180
		func() {
			if lua_gettop(L) == 8 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15743, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc1181 int32 = 5
		)
		lua_pushboolean(L, 0)
		var lc1182 int32 = lua_equal(L, 5, -1)
		lua_settop(L, -(1)-1)
		lua_pushboolean(L, lc1182)
		lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
		lua_remove(L, -2)
		if lua_toboolean(L, -1) != 0 {
			lua_settop(L, -(1)-1)
			var lc1183 float64 = float64(lua_objlen(L, 5))
			lua_pushnumber(L, lua_Number((lc1183)))
			lua_pushnumber(L, 2)
			var lc1184 int32 = lua_equal(L, -2, -1)
			lua_settop(L, -(2)-1)
			lua_pushboolean(L, lc1184)
		}
		var lc1185 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1185 != 0 {
			const (
				lc1186 int32 = 5
			)
			lc_getupvalue(L, int32((lc1130)), 4, 136)
			lua_pushnumber(L, 1)
			lua_gettable(L, 5)
			lc_getupvalue(L, int32((lc1130)), 22, 46)
			lua_call(L, 2, 1)
			var lc1187 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1187 != 0 {
				lc_getupvalue(L, int32((lc1130)), 6, 127)
				lua_pushnumber(L, 2)
				lua_gettable(L, 5)
				lua_call(L, 1, 1)
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15783, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
					}
				}()
				const (
					lc1188 int32 = 6
				)
				lua_pushboolean(L, 0)
				var lc1189 int32 = lua_equal(L, 6, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc1189)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					var lc1190 float64 = float64(lua_objlen(L, 6))
					lua_pushnumber(L, lua_Number((lc1190)))
					lua_pushnumber(L, 2)
					var lc1191 int32 = lua_equal(L, -2, -1)
					lua_settop(L, -(2)-1)
					lua_pushboolean(L, lc1191)
				}
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					lc_getupvalue(L, int32((lc1130)), 4, 136)
					lua_pushnumber(L, 1)
					lua_gettable(L, 6)
					lc_getupvalue(L, int32((lc1130)), 22, 48)
					lua_call(L, 2, 1)
				}
				var lc1192 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1192 != 0 {
					var lc1193 int32 = lua_gettop(L)
					lua_pushvalue(L, 4)
					lua_pushlstring(L, []byte("&+\x00"), uint(3/1-1))
					lc_getupvalue(L, int32((lc1130)), 1, 195)
					lua_pushnumber(L, 2)
					lua_gettable(L, 6)
					lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
					lua_call(L, 2, 1)
					lua_concat(L, 2)
					lua_call(L, 1, -1)
					return lua_gettop(L) - lc1193
					func() {
						if lua_gettop(L) == 6 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15828, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc1188)))
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15831, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
					}
				}()
				var lc1194 int32 = lua_gettop(L)
				lua_pushvalue(L, 4)
				lua_pushlstring(L, []byte("&\x00"), uint(2/1-1))
				lc_getupvalue(L, int32((lc1130)), 1, 195)
				lua_pushnumber(L, 2)
				lua_gettable(L, 5)
				lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
				lua_call(L, 2, 1)
				lua_concat(L, 2)
				lua_call(L, 1, -1)
				return lua_gettop(L) - lc1194
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15846, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc1195 int32 = 5
				)
				lc_getupvalue(L, int32((lc1130)), 4, 136)
				lua_pushnumber(L, 1)
				lua_gettable(L, 5)
				lc_getupvalue(L, int32((lc1130)), 15, 118)
				lua_call(L, 2, 1)
				var lc1196 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1196 != 0 {
					var lc1197 int32 = lua_gettop(L)
					lua_pushvalue(L, 4)
					lc_getupvalue(L, int32((lc1130)), 1, 195)
					lua_pushnumber(L, 2)
					lua_gettable(L, 5)
					lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
					lua_call(L, 2, 1)
					lua_pushlstring(L, []byte("~\x00"), uint(2/1-1))
					lua_concat(L, 2)
					lua_call(L, 1, -1)
					return lua_gettop(L) - lc1197
					func() {
						if lua_gettop(L) == 5 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15874, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc1198 int32 = 5
					)
					lc_getupvalue(L, int32((lc1130)), 4, 136)
					lua_pushnumber(L, 1)
					lua_gettable(L, 5)
					lc_getupvalue(L, int32((lc1130)), 22, 48)
					lua_call(L, 2, 1)
					var lc1199 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc1199 != 0 {
						var lc1200 int32 = lua_gettop(L)
						lua_pushvalue(L, 4)
						lua_pushlstring(L, []byte("+\x00"), uint(2/1-1))
						lc_getupvalue(L, int32((lc1130)), 1, 195)
						lua_pushnumber(L, 2)
						lua_gettable(L, 5)
						lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
						lua_call(L, 2, 1)
						lua_concat(L, 2)
						lua_call(L, 1, -1)
						return lua_gettop(L) - lc1200
						func() {
							if lua_gettop(L) == 5 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15902, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc1201 int32 = 5
						)
						lc_getupvalue(L, int32((lc1130)), 4, 136)
						lua_pushnumber(L, 1)
						lua_gettable(L, 5)
						lc_getupvalue(L, int32((lc1130)), 14, 119)
						lua_call(L, 2, 1)
						var lc1202 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc1202 != 0 {
							lc_getupvalue(L, int32((lc1130)), 6, 127)
							lua_pushnumber(L, 2)
							lua_gettable(L, 5)
							lua_call(L, 1, 1)
							func() {
								if lua_gettop(L) == 6 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15923, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
								}
							}()
							const (
								lc1203 int32 = 6
							)
							lua_pushboolean(L, 0)
							var lc1204 int32 = lua_equal(L, 6, -1)
							lua_settop(L, -(1)-1)
							lua_pushboolean(L, lc1204)
							lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
							lua_remove(L, -2)
							if lua_toboolean(L, -1) != 0 {
								lua_settop(L, -(1)-1)
								lua_pushnumber(L, 1)
								var lc1205 float64 = float64(lua_objlen(L, 6))
								lua_pushnumber(L, lua_Number((lc1205)))
								var lc1206 int32 = lua_lessthan(L, -2, -1)
								lua_settop(L, -(2)-1)
								lua_pushboolean(L, lc1206)
							}
							var lc1207 int32 = lua_toboolean(L, -1)
							lua_settop(L, -(1)-1)
							if lc1207 != 0 {
								lc_getupvalue(L, int32((lc1130)), 1, 195)
								lua_pushnumber(L, 1)
								lua_gettable(L, 6)
								lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
								lua_call(L, 2, 1)
								func() {
									if lua_gettop(L) == 7 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15953, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
									}
								}()
								lua_pushnumber(L, 1)
								func() {
									if lua_gettop(L) == 8 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15958, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
									}
								}()
								const (
									lc1208 int32 = 8
								)
								for 1 != 0 {
									var lc1209 float64 = float64(lua_objlen(L, 6))
									lua_pushnumber(L, lua_Number((lc1209)))
									var lc1210 int32 = lua_lessthan(L, 8, -1)
									lua_settop(L, -(1)-1)
									lua_pushboolean(L, lc1210)
									if noarch.Not(lua_toboolean(L, -1)) {
										break
									}
									lua_settop(L, -(1)-1)
									lua_pushvalue(L, 7)
									lua_pushlstring(L, []byte("/\x00"), uint(2/1-1))
									lc_getupvalue(L, int32((lc1130)), 1, 195)
									lua_pushnumber(L, 1)
									lc_add(L, 8, -1)
									lua_remove(L, -2)
									lua_gettable(L, 6)
									lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
									lua_call(L, 2, 1)
									lua_concat(L, 2)
									lua_concat(L, 2)
									lua_replace(L, 7)
									func() {
										if lua_gettop(L) == 8 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15987, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
										}
									}()
									lua_pushnumber(L, 1)
									lc_add(L, 8, -1)
									lua_remove(L, -2)
									lua_replace(L, 8)
									func() {
										if lua_gettop(L) == 8 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15994, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
										}
									}()
								}
								lua_settop(L, int32((lc1208)))
								func() {
									if lua_gettop(L) == 8 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 15997, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
									}
								}()
								lua_settop(L, -(1)-1)
								func() {
									if lua_gettop(L) == 7 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16001, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
									}
								}()
								var lc1211 int32 = lua_gettop(L)
								lua_pushvalue(L, 4)
								lua_pushvalue(L, 7)
								lua_call(L, 1, -1)
								return lua_gettop(L) - lc1211
								func() {
									if lua_gettop(L) == 7 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16009, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
									}
								}()
							}
							lua_settop(L, int32((lc1203)))
							func() {
								if lua_gettop(L) == 6 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16012, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
								}
							}()
						}
						lua_settop(L, int32((lc1201)))
					}
					lua_settop(L, int32((lc1198)))
				}
				lua_settop(L, int32((lc1195)))
			}
			lua_settop(L, int32((lc1186)))
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16021, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1181)))
	}
	lua_settop(L, int32((lc1141)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16026, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	const (
		lc1212 int32 = 5
	)
	lc_getupvalue(L, int32((lc1130)), 0, 196)
	lua_pushlstring(L, []byte("inner\x00"), uint(6/1-1))
	var lc1213 int32 = lua_equal(L, -2, -1)
	lua_settop(L, -(2)-1)
	lua_pushboolean(L, lc1213)
	var lc1214 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1214 != 0 {
		var lc1215 int32 = lua_gettop(L)
		lc_getupvalue(L, int32((lc1130)), 22, 2)
		lua_pushvalue(L, 1)
		lua_call(L, 1, -1)
		return lua_gettop(L) - lc1215
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16045, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc1216 int32 = 5
		)
		lc_getupvalue(L, int32((lc1130)), 0, 196)
		lua_pushlstring(L, []byte("top\x00"), uint(4/1-1))
		var lc1217 int32 = lua_equal(L, -2, -1)
		lua_settop(L, -(2)-1)
		lua_pushboolean(L, lc1217)
		var lc1218 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1218 != 0 {
			var lc1219 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc1130)), 22, 2)
			var lc1220 int32 = lua_gettop(L)
			lc_getupvalue(L, int32((lc1130)), 11, 122)
			lua_pushvalue(L, 1)
			lua_call(L, 1, -1)
			lua_call(L, lua_gettop(L)-lc1220, -1)
			return lua_gettop(L) - lc1219
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16068, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
				}
			}()
		}
		lua_settop(L, int32((lc1216)))
	}
	lua_settop(L, int32((lc1212)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16073, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	var lc1221 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc1130)), 22, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1221
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16080, []byte("int lcf1_print_sys_name(lua_State *)\x00"))
		}
	}()
	return
}

// lcf1_complex_print - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:16085
func lcf1_complex_print(L []lua_State) (c4goDefaultReturn int32) {
	const (
		lc_nformalargs int32 = 1
	)
	lua_settop(L, 1)
	lc_newclosuretable(L, -10002-1)
	const (
		lc1129 int32 = 2
	)
	func() {
		if lua_gettop(L) == int32((lc1129)) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == lc1129)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16092, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc1129)), 195)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16095, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc1129)))
	lua_pushcclosure(L, lcf1_print_sys_name, 1)
	lc_setupvalue(L, int32((lc1129)), 0, 195)
	func() {
		if lua_gettop(L) == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16207, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc1129)), 2, 137)
	var lc1222 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc1129)), 21, 2)
	lua_pushvalue(L, 1)
	lua_call(L, 1, -1)
	lua_call(L, lua_gettop(L)-lc1222, 1)
	func() {
		if lua_gettop(L) == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16216, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16220, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16224, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	const (
		lc1223 int32 = 5
	)
	lc_getupvalue(L, int32((lc1129)), 21, 78)
	lua_pushvalue(L, 3)
	lua_call(L, 1, 1)
	var lc1224 int32 = lua_toboolean(L, -1)
	lua_settop(L, -(1)-1)
	if lc1224 != 0 {
		lua_pushlstring(L, []byte("()\x00"), uint(3/1-1))
		return 1
		func() {
			if lua_gettop(L) == 5 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16238, []byte("int lcf1_complex_print(lua_State *)\x00"))
			}
		}()
	} else {
		const (
			lc1225 int32 = 5
		)
		lc_getupvalue(L, int32((lc1129)), 21, 82)
		lua_pushvalue(L, 3)
		lua_call(L, 1, 1)
		var lc1226 int32 = lua_toboolean(L, -1)
		lua_settop(L, -(1)-1)
		if lc1226 != 0 {
			lua_pushlstring(L, []byte("(\x00"), uint(2/1-1))
			lua_replace(L, 4)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16253, []byte("int lcf1_complex_print(lua_State *)\x00"))
				}
			}()
			lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
			lua_replace(L, 5)
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16258, []byte("int lcf1_complex_print(lua_State *)\x00"))
				}
			}()
			const (
				lc1227 int32 = 5
			)
			for 1 != 0 {
				lc_getupvalue(L, int32((lc1129)), 21, 82)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				if noarch.Not(lua_toboolean(L, -1)) {
					break
				}
				lua_settop(L, -(1)-1)
				lua_pushvalue(L, 4)
				lua_pushvalue(L, 5)
				lc_getupvalue(L, int32((lc1129)), 1, 194)
				var lc1228 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc1129)), 21, 81)
				lua_pushvalue(L, 3)
				lua_call(L, 1, -1)
				lua_call(L, lua_gettop(L)-lc1228, 1)
				lua_concat(L, 2)
				lua_concat(L, 2)
				lua_replace(L, 4)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16283, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
				lua_replace(L, 5)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16288, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, int32((lc1129)), 21, 80)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				lua_replace(L, 3)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16295, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc1227)))
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16298, []byte("int lcf1_complex_print(lua_State *)\x00"))
				}
			}()
			const (
				lc1229 int32 = 5
			)
			lc_getupvalue(L, int32((lc1129)), 21, 78)
			lua_pushvalue(L, 3)
			lua_call(L, 1, 1)
			var lc1230 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1230 != 0 {
				lua_pushvalue(L, 4)
				lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
				lua_concat(L, 2)
				lua_replace(L, 4)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16314, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
			} else {
				lua_pushvalue(L, 4)
				lua_pushlstring(L, []byte(" . \x00"), uint(4/1-1))
				lc_getupvalue(L, int32((lc1129)), 1, 194)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				lua_concat(L, 2)
				lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
				lua_concat(L, 2)
				lua_concat(L, 2)
				lua_replace(L, 4)
				func() {
					if lua_gettop(L) == 5 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16329, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
			}
			lua_settop(L, int32((lc1229)))
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16332, []byte("int lcf1_complex_print(lua_State *)\x00"))
				}
			}()
			lua_pushvalue(L, 4)
			return 1
			func() {
				if lua_gettop(L) == 5 {
				} else {
					linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16337, []byte("int lcf1_complex_print(lua_State *)\x00"))
				}
			}()
		} else {
			const (
				lc1231 int32 = 5
			)
			lc_getupvalue(L, int32((lc1129)), 21, 76)
			lua_pushvalue(L, 3)
			lua_call(L, 1, 1)
			var lc1232 int32 = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
			if lc1232 != 0 {
				lc_getupvalue(L, int32((lc1129)), 21, 75)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				func() {
					if lua_gettop(L) == 6 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16353, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, int32((lc1129)), 21, 74)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				func() {
					if lua_gettop(L) == 7 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16359, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				lc_getupvalue(L, int32((lc1129)), 5, 127)
				lua_pushvalue(L, 7)
				lua_call(L, 1, 1)
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16365, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				const (
					lc1233 int32 = 8
				)
				lua_pushboolean(L, 0)
				var lc1234 int32 = lua_equal(L, 8, -1)
				lua_settop(L, -(1)-1)
				lua_pushboolean(L, lc1234)
				lua_pushboolean(L, noarch.BoolToInt(noarch.Not(lua_toboolean(L, -1))))
				lua_remove(L, -2)
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					var lc1235 float64 = float64(lua_objlen(L, 8))
					lua_pushnumber(L, lua_Number((lc1235)))
					lua_pushnumber(L, 2)
					var lc1236 int32 = lua_equal(L, -2, -1)
					lua_settop(L, -(2)-1)
					lua_pushboolean(L, lc1236)
				}
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					lc_getupvalue(L, int32((lc1129)), 3, 136)
					lua_pushvalue(L, 6)
					lc_getupvalue(L, int32((lc1129)), 18, 114)
					lua_call(L, 2, 1)
				}
				if lua_toboolean(L, -1) != 0 {
					lua_settop(L, -(1)-1)
					lc_getupvalue(L, int32((lc1129)), 3, 136)
					lua_pushnumber(L, 1)
					lua_gettable(L, 8)
					lc_getupvalue(L, int32((lc1129)), 21, 48)
					lua_call(L, 2, 1)
				}
				var lc1237 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1237 != 0 {
					var lc1238 int32 = lua_gettop(L)
					lc_getupvalue(L, int32((lc1129)), 0, 195)
					lua_pushnumber(L, 2)
					lua_gettable(L, 8)
					lua_pushlstring(L, []byte("top\x00"), uint(4/1-1))
					lua_call(L, 2, -1)
					return lua_gettop(L) - lc1238
					func() {
						if lua_gettop(L) == 8 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16413, []byte("int lcf1_complex_print(lua_State *)\x00"))
						}
					}()
				}
				lua_settop(L, int32((lc1233)))
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16416, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
				lua_pushlstring(L, []byte("#\x00"), uint(2/1-1))
				lc_getupvalue(L, int32((lc1129)), 1, 194)
				var lc1239 int32 = lua_gettop(L)
				lc_getupvalue(L, int32((lc1129)), 21, 83)
				lua_pushvalue(L, 6)
				lua_pushvalue(L, 7)
				lua_call(L, 2, -1)
				lua_call(L, lua_gettop(L)-lc1239, 1)
				lua_concat(L, 2)
				return 1
				func() {
					if lua_gettop(L) == 8 {
					} else {
						linux.AssertFail([]byte("lua_gettop(L) == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16429, []byte("int lcf1_complex_print(lua_State *)\x00"))
					}
				}()
			} else {
				const (
					lc1240 int32 = 5
				)
				lc_getupvalue(L, int32((lc1129)), 21, 72)
				lua_pushvalue(L, 3)
				lua_call(L, 1, 1)
				var lc1241 int32 = lua_toboolean(L, -1)
				lua_settop(L, -(1)-1)
				if lc1241 != 0 {
					lua_pushlstring(L, []byte("!\x00"), uint(2/1-1))
					lc_getupvalue(L, int32((lc1129)), 1, 194)
					var lc1242 int32 = lua_gettop(L)
					lc_getupvalue(L, int32((lc1129)), 21, 83)
					var lc1243 int32 = lua_gettop(L)
					lc_getupvalue(L, int32((lc1129)), 21, 71)
					lua_pushvalue(L, 3)
					lua_call(L, 1, 1)
					lc_getupvalue(L, int32((lc1129)), 21, 70)
					lua_pushvalue(L, 3)
					lua_call(L, 1, -1)
					lua_call(L, lua_gettop(L)-lc1243, -1)
					lua_call(L, lua_gettop(L)-lc1242, 1)
					lua_concat(L, 2)
					return 1
					func() {
						if lua_gettop(L) == 5 {
						} else {
							linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16458, []byte("int lcf1_complex_print(lua_State *)\x00"))
						}
					}()
				} else {
					const (
						lc1244 int32 = 5
					)
					lc_getupvalue(L, int32((lc1129)), 21, 85)
					lua_pushvalue(L, 3)
					lua_call(L, 1, 1)
					var lc1245 int32 = lua_toboolean(L, -1)
					lua_settop(L, -(1)-1)
					if lc1245 != 0 {
						var lc1246 int32 = lua_gettop(L)
						lc_getupvalue(L, int32((lc1129)), 21, 84)
						lua_pushvalue(L, 3)
						lua_call(L, 1, -1)
						return lua_gettop(L) - lc1246
						func() {
							if lua_gettop(L) == 5 {
							} else {
								linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16476, []byte("int lcf1_complex_print(lua_State *)\x00"))
							}
						}()
					} else {
						const (
							lc1247 int32 = 5
						)
						lc_getupvalue(L, int32((lc1129)), 21, 65)
						lua_pushvalue(L, 3)
						lua_call(L, 1, 1)
						var lc1248 int32 = lua_toboolean(L, -1)
						lua_settop(L, -(1)-1)
						if lc1248 != 0 {
							lua_pushlstring(L, []byte("$(\x00"), uint(3/1-1))
							lc_getupvalue(L, int32((lc1129)), 1, 194)
							var lc1249 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc1129)), 21, 12)
							var lc1250 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc1129)), 21, 64)
							lua_pushvalue(L, 3)
							lua_call(L, 1, -1)
							lua_call(L, lua_gettop(L)-lc1250, -1)
							lua_call(L, lua_gettop(L)-lc1249, 1)
							lua_concat(L, 2)
							lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
							lua_concat(L, 2)
							lc_getupvalue(L, int32((lc1129)), 1, 194)
							var lc1251 int32 = lua_gettop(L)
							lc_getupvalue(L, int32((lc1129)), 21, 63)
							lua_pushvalue(L, 3)
							lua_call(L, 1, -1)
							lua_call(L, lua_gettop(L)-lc1251, 1)
							lua_concat(L, 2)
							lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
							lua_concat(L, 2)
							return 1
							func() {
								if lua_gettop(L) == 5 {
								} else {
									linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16514, []byte("int lcf1_complex_print(lua_State *)\x00"))
								}
							}()
						} else {
							const (
								lc1252 int32 = 5
							)
							lc_getupvalue(L, int32((lc1129)), 21, 56)
							lua_pushvalue(L, 3)
							lua_call(L, 1, 1)
							var lc1253 int32 = lua_toboolean(L, -1)
							lua_settop(L, -(1)-1)
							if lc1253 != 0 {
								lua_pushlstring(L, []byte("%(\x00"), uint(3/1-1))
								lc_getupvalue(L, int32((lc1129)), 1, 194)
								var lc1254 int32 = lua_gettop(L)
								lc_getupvalue(L, int32((lc1129)), 21, 55)
								lua_pushvalue(L, 3)
								lua_call(L, 1, -1)
								lua_call(L, lua_gettop(L)-lc1254, 1)
								lua_concat(L, 2)
								lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
								lua_concat(L, 2)
								lc_getupvalue(L, int32((lc1129)), 1, 194)
								var lc1255 int32 = lua_gettop(L)
								lc_getupvalue(L, int32((lc1129)), 21, 22)
								var lc1256 int32 = lua_gettop(L)
								lc_getupvalue(L, int32((lc1129)), 21, 54)
								lua_pushvalue(L, 3)
								lua_call(L, 1, -1)
								lua_call(L, lua_gettop(L)-lc1256, -1)
								lua_call(L, lua_gettop(L)-lc1255, 1)
								lua_concat(L, 2)
								lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
								lua_concat(L, 2)
								return 1
								func() {
									if lua_gettop(L) == 5 {
									} else {
										linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16553, []byte("int lcf1_complex_print(lua_State *)\x00"))
									}
								}()
							} else {
								const (
									lc1257 int32 = 5
								)
								lc_getupvalue(L, int32((lc1129)), 21, 61)
								lua_pushvalue(L, 3)
								lua_call(L, 1, 1)
								var lc1258 int32 = lua_toboolean(L, -1)
								lua_settop(L, -(1)-1)
								if lc1258 != 0 {
									lua_pushlstring(L, []byte("@(\x00"), uint(3/1-1))
									lc_getupvalue(L, int32((lc1129)), 1, 194)
									var lc1259 int32 = lua_gettop(L)
									lc_getupvalue(L, int32((lc1129)), 21, 12)
									var lc1260 int32 = lua_gettop(L)
									lc_getupvalue(L, int32((lc1129)), 21, 60)
									lua_pushvalue(L, 3)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc1260, -1)
									lua_call(L, lua_gettop(L)-lc1259, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
									lua_concat(L, 2)
									lc_getupvalue(L, int32((lc1129)), 1, 194)
									var lc1261 int32 = lua_gettop(L)
									lc_getupvalue(L, int32((lc1129)), 21, 59)
									lua_pushvalue(L, 3)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc1261, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
									lua_concat(L, 2)
									lc_getupvalue(L, int32((lc1129)), 1, 194)
									var lc1262 int32 = lua_gettop(L)
									lc_getupvalue(L, int32((lc1129)), 21, 22)
									var lc1263 int32 = lua_gettop(L)
									lc_getupvalue(L, int32((lc1129)), 21, 58)
									lua_pushvalue(L, 3)
									lua_call(L, 1, -1)
									lua_call(L, lua_gettop(L)-lc1263, -1)
									lua_call(L, lua_gettop(L)-lc1262, 1)
									lua_concat(L, 2)
									lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
									lua_concat(L, 2)
									return 1
									func() {
										if lua_gettop(L) == 5 {
										} else {
											linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16605, []byte("int lcf1_complex_print(lua_State *)\x00"))
										}
									}()
								} else {
									const (
										lc1264 int32 = 5
									)
									lc_getupvalue(L, int32((lc1129)), 21, 52)
									lua_pushvalue(L, 3)
									lua_call(L, 1, 1)
									var lc1265 int32 = lua_toboolean(L, -1)
									lua_settop(L, -(1)-1)
									if lc1265 != 0 {
										lua_pushlstring(L, []byte("^(\x00"), uint(3/1-1))
										lc_getupvalue(L, int32((lc1129)), 1, 194)
										var lc1266 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc1129)), 21, 51)
										lua_pushvalue(L, 3)
										lua_call(L, 1, -1)
										lua_call(L, lua_gettop(L)-lc1266, 1)
										lua_concat(L, 2)
										lua_pushlstring(L, []byte(" \x00"), uint(2/1-1))
										lua_concat(L, 2)
										lc_getupvalue(L, int32((lc1129)), 1, 194)
										var lc1267 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc1129)), 21, 22)
										var lc1268 int32 = lua_gettop(L)
										lc_getupvalue(L, int32((lc1129)), 21, 50)
										lua_pushvalue(L, 3)
										lua_call(L, 1, -1)
										lua_call(L, lua_gettop(L)-lc1268, -1)
										lua_call(L, lua_gettop(L)-lc1267, 1)
										lua_concat(L, 2)
										lua_pushlstring(L, []byte(")\x00"), uint(2/1-1))
										lua_concat(L, 2)
										return 1
										func() {
											if lua_gettop(L) == 5 {
											} else {
												linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16643, []byte("int lcf1_complex_print(lua_State *)\x00"))
											}
										}()
									}
									lua_settop(L, int32((lc1264)))
								}
								lua_settop(L, int32((lc1257)))
							}
							lua_settop(L, int32((lc1252)))
						}
						lua_settop(L, int32((lc1247)))
					}
					lua_settop(L, int32((lc1244)))
				}
				lua_settop(L, int32((lc1240)))
			}
			lua_settop(L, int32((lc1231)))
		}
		lua_settop(L, int32((lc1225)))
	}
	lua_settop(L, int32((lc1223)))
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16662, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	var lc1269 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc1129)), 21, 96)
	lua_call(L, 0, -1)
	return lua_gettop(L) - lc1269
	func() {
		if lua_gettop(L) == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16669, []byte("int lcf1_complex_print(lua_State *)\x00"))
		}
	}()
	return
}

// lcf_main - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:16674
func lcf_main(L []lua_State) (c4goDefaultReturn int32) {
	lua_checkstack(L, 61)
	const (
		lc_nformalargs int32 = 0
	)
	var lc_nactualargs int32 = lua_gettop(L)
	var lc_nextra int32 = lc_nactualargs - int32((lc_nformalargs))
	lc_newclosuretable(L, -10002-1)
	const (
		lc1 int32 = 1
	)
	func() {
		if lua_gettop(L) == int32((lc1 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc1 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16702, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1___TS__ArrayPush, 0)
	lua_rawseti(L, int32((lc1 + int32((int32((lc_nextra)))))), 1)
	func() {
		if lua_gettop(L)-lc_nextra == 1 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 1\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16705, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	func() {
		if lua_gettop(L)-lc_nextra == 2 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 2\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16709, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc1 + int32((int32((lc_nextra)))))))
	const (
		lc4 int32 = 3
	)
	func() {
		if lua_gettop(L) == int32((lc4 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc4 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16743, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+95)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 2)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 3)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 4)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 5)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 6)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 7)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 8)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 9)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 10)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 11)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 12)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 13)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 14)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 15)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 16)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 17)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 18)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 19)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 20)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 21)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 22)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 23)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 24)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 25)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 26)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 27)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 28)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 29)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 30)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 31)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 32)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 33)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 34)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 35)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 36)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 37)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 38)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 39)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 40)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 41)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 42)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 43)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 44)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 45)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 46)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 47)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 48)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 49)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 50)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 51)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 52)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 53)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 54)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 55)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 56)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 57)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 58)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 59)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 60)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 61)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 62)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 63)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 64)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 65)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 66)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 67)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 68)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 69)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 70)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 71)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 72)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 73)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 74)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 75)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 76)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 77)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 78)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 79)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 80)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 81)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 82)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 83)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 84)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 85)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 86)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 87)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 88)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 89)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 90)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 91)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 92)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 93)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 94)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 95)
	lua_rawseti(L, int32((lc4 + int32((int32((lc_nextra)))))), 96)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16840, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_ERROR, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 96)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16847, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_ASSERT, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 95)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16857, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_symbol_p, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 85)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16864, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_un_symbol, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 84)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16871, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_construction, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 83)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16879, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_construction_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 82)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16887, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_construction_head, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 81)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16894, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_construction_tail, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 80)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16901, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_null_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 78)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16909, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_data, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 77)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16917, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_data_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 76)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16925, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_data_name, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 75)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16932, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_data_list, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 74)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16939, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_error, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 73)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16947, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_error_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 72)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16955, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_error_name, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 71)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16962, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_error_list, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 70)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16969, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_lang_set_do, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 69)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16983, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_just_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 68)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16991, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_un_just, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 67)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 16998, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_evaluate, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 66)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17006, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_delay_evaluate_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 65)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17014, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_evaluate_env, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 64)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17021, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_evaluate_x, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 63)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17028, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_builtin_form_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 62)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17036, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_delay_builtin_form_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 61)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17044, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_builtin_form_env, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 60)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17051, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_builtin_form_f, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 59)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17058, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_builtin_form_xs, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 58)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17065, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_builtin_func_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 57)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17073, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_delay_builtin_func_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 56)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17081, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_builtin_func_f, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 55)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17088, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_builtin_func_xs, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 54)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17095, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 53)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17103, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_delay_apply_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 52)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17111, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_apply_f, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 51)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17118, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_delay_apply_xs, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 50)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17125, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_force_all_rec, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 49)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17153, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_symbol_equal_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 23)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17169, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_jsArray_to_list, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 22)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17185, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_list, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 21)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17194, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_un_just_all, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 20)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17215, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_any_delay_just_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 19)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17224, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_force_all, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 18)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17357, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_force1, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 17)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17383, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_env_set, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 15)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17416, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_env_get, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 14)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17433, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_must_env_get, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 13)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17450, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_env2val, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 12)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17467, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushcclosure(L, lcf1_env_foreach, 0)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 11)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17480, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_real_evaluate, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 10)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17599, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_name_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 9)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17607, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_real_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 7)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17676, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_real_builtin_func_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 6)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17710, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_real_builtin_form_apply, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 5)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17732, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_lambda, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 4)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17811, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_jsbool_equal_p, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 3)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17865, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc4 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_simple_print, 1)
	lc_setupvalue(L, int32((lc4 + int32((int32((lc_nextra)))))), 0, 2)
	func() {
		if lua_gettop(L)-lc_nextra == 3 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 3\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17915, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc4 + int32((int32((lc_nextra)))))))
	const (
		lc447 int32 = 4
	)
	func() {
		if lua_gettop(L) == int32((lc447 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc447 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17920, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 0)
	lua_rawseti(L, int32((lc447 + int32((int32((lc_nextra)))))), 112)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17923, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 1)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 94)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17928, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 2)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 93)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17933, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 3)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 92)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17938, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 4)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 91)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17943, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 5)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 90)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17948, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 6)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 89)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17953, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 7)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 88)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17958, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 8)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 87)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17963, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushnumber(L, 9)
	lc_setupvalue(L, int32((lc447 + int32((int32((lc_nextra)))))), 1, 86)
	func() {
		if lua_gettop(L)-lc_nextra == 4 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 4\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17968, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc447 + int32((int32((lc_nextra)))))))
	const (
		lc448 int32 = 5
	)
	func() {
		if lua_gettop(L) == int32((lc448 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc448 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17973, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc448 + int32((int32((lc_nextra)))))), 113)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17976, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc448 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_new_symbol, 1)
	lc_setupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 0, 113)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17984, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 0, 113)
	lua_pushlstring(L, []byte("new_symbol\x00"), uint(11/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17991, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 85)
	lua_pushlstring(L, []byte("symbol_p\x00"), uint(9/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 17998, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 84)
	lua_pushlstring(L, []byte("un_symbol\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18005, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 83)
	lua_pushlstring(L, []byte("new_construction\x00"), uint(17/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18012, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 82)
	lua_pushlstring(L, []byte("construction_p\x00"), uint(15/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18019, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 81)
	lua_pushlstring(L, []byte("construction_head\x00"), uint(18/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18026, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 80)
	lua_pushlstring(L, []byte("construction_tail\x00"), uint(18/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18033, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 1, 0)
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 93)
	lua_rawseti(L, -2, 1)
	lc_setupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 79)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18040, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 79)
	lua_pushlstring(L, []byte("null_v\x00"), uint(7/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18047, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 78)
	lua_pushlstring(L, []byte("null_p\x00"), uint(7/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18054, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 77)
	lua_pushlstring(L, []byte("new_data\x00"), uint(9/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18061, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 76)
	lua_pushlstring(L, []byte("data_p\x00"), uint(7/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18068, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 75)
	lua_pushlstring(L, []byte("data_name\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18075, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 74)
	lua_pushlstring(L, []byte("data_list\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18082, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 73)
	lua_pushlstring(L, []byte("new_error\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18089, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 72)
	lua_pushlstring(L, []byte("error_p\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18096, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 71)
	lua_pushlstring(L, []byte("error_name\x00"), uint(11/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18103, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 70)
	lua_pushlstring(L, []byte("error_list\x00"), uint(11/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18110, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 66)
	lua_pushlstring(L, []byte("evaluate\x00"), uint(9/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18117, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 53)
	lua_pushlstring(L, []byte("apply\x00"), uint(6/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18124, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 49)
	lua_pushlstring(L, []byte("force_all_rec\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18131, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 0, 113)
	lua_pushlstring(L, []byte("太始初核\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 2, 48)
	func() {
		if lua_gettop(L)-lc_nextra == 5 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 5\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18138, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc448 + int32((int32((lc_nextra)))))))
	const (
		lc449 int32 = 6
	)
	func() {
		if lua_gettop(L) == int32((lc449 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc449 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18143, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc448 + int32((int32((lc_nextra)))))), 0, 113)
	lua_pushlstring(L, []byte("符名\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc449 + int32((int32((lc_nextra)))))), 114)
	func() {
		if lua_gettop(L)-lc_nextra == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18148, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 1, 113)
	lua_pushlstring(L, []byte("化滅\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 3, 47)
	func() {
		if lua_gettop(L)-lc_nextra == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18155, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 1, 113)
	lua_pushlstring(L, []byte("式形\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 3, 46)
	func() {
		if lua_gettop(L)-lc_nextra == 6 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 6\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18162, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 1, 113)
	lua_pushlstring(L, []byte("等同\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 7 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 7\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18168, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 1, 113)
	lua_pushlstring(L, []byte("解算\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 8 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 8\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18174, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc449 + int32((int32((lc_nextra)))))))
	const (
		lc450 int32 = 9
	)
	func() {
		if lua_gettop(L) == int32((lc450 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc450 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18179, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc449 + int32((int32((lc_nextra)))))), 1, 113)
	lua_pushlstring(L, []byte("特定其物\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc450 + int32((int32((lc_nextra)))))), 115)
	func() {
		if lua_gettop(L)-lc_nextra == 9 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 9\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18184, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc450 + int32((int32((lc_nextra)))))))
	const (
		lc451 int32 = 10
	)
	func() {
		if lua_gettop(L) == int32((lc451 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc451 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18189, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc450 + int32((int32((lc_nextra)))))), 2, 113)
	lua_pushlstring(L, []byte("省略一物\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc451 + int32((int32((lc_nextra)))))), 116)
	func() {
		if lua_gettop(L)-lc_nextra == 10 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18194, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc451 + int32((int32((lc_nextra)))))), 3, 113)
	lua_pushlstring(L, []byte("映表\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc451 + int32((int32((lc_nextra)))))), 5, 45)
	func() {
		if lua_gettop(L)-lc_nextra == 10 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 10\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18201, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc451 + int32((int32((lc_nextra)))))), 3, 113)
	lua_pushlstring(L, []byte("若\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 11 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 11\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18207, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc451 + int32((int32((lc_nextra)))))))
	const (
		lc452 int32 = 12
	)
	func() {
		if lua_gettop(L) == int32((lc452 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc452 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18212, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc451 + int32((int32((lc_nextra)))))), 3, 113)
	lua_pushlstring(L, []byte("一類何物\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc452 + int32((int32((lc_nextra)))))), 117)
	func() {
		if lua_gettop(L)-lc_nextra == 12 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 12\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18217, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc452 + int32((int32((lc_nextra)))))))
	const (
		lc453 int32 = 13
	)
	func() {
		if lua_gettop(L) == int32((lc453 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc453 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18222, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc452 + int32((int32((lc_nextra)))))), 4, 113)
	lua_pushlstring(L, []byte("是非\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc453 + int32((int32((lc_nextra)))))), 118)
	func() {
		if lua_gettop(L)-lc_nextra == 13 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 13\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18227, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc453 + int32((int32((lc_nextra)))))))
	const (
		lc454 int32 = 14
	)
	func() {
		if lua_gettop(L) == int32((lc454 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc454 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18232, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc453 + int32((int32((lc_nextra)))))), 5, 113)
	lua_pushlstring(L, []byte("其子\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc454 + int32((int32((lc_nextra)))))), 119)
	func() {
		if lua_gettop(L)-lc_nextra == 14 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 14\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18237, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc454 + int32((int32((lc_nextra)))))))
	const (
		lc455 int32 = 15
	)
	func() {
		if lua_gettop(L) == int32((lc455 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc455 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18242, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc454 + int32((int32((lc_nextra)))))), 6, 113)
	lua_pushlstring(L, []byte("陽\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc455 + int32((int32((lc_nextra)))))), 120)
	func() {
		if lua_gettop(L)-lc_nextra == 15 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 15\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18247, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc455 + int32((int32((lc_nextra)))))))
	const (
		lc456 int32 = 16
	)
	func() {
		if lua_gettop(L) == int32((lc456 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc456 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18252, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc455 + int32((int32((lc_nextra)))))), 7, 113)
	lua_pushlstring(L, []byte("陰\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	lua_rawseti(L, int32((lc456 + int32((int32((lc_nextra)))))), 121)
	func() {
		if lua_gettop(L)-lc_nextra == 16 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 16\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18257, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("引用\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 17 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 17\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18263, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("應用\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 18 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 18\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18269, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("空\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 19 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 19\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18275, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("連\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 20 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 20\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18281, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("構\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 21 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 21\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18287, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("誤\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 22 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 22\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18293, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("詞素\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 23 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 23\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18299, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("列\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 24 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 24\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18305, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("首\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 25 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 25\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18311, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("尾\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 26 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 26\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18317, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("物\x00"), uint(4/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 27 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 27\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18323, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("宇宙亡矣\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 28 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 28\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18329, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("效應\x00"), uint(7/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 29 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 29\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18335, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("為符名連\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 30 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 30\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18341, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 8, 113)
	lua_pushlstring(L, []byte("出入改滅\x00"), uint(13/1-1))
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18347, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 48)
	lua_pushlstring(L, []byte("system_symbol\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18354, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 7, 114)
	lua_pushlstring(L, []byte("name_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18361, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 47)
	lua_pushlstring(L, []byte("function_symbol\x00"), uint(16/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18368, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 46)
	lua_pushlstring(L, []byte("form_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18375, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 7+lc_nextra)
	lua_pushlstring(L, []byte("equal_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18382, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 8+lc_nextra)
	lua_pushlstring(L, []byte("evaluate_sym\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18389, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 6, 115)
	lua_pushlstring(L, []byte("theThing_symbol\x00"), uint(16/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18396, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 5, 116)
	lua_pushlstring(L, []byte("something_symbol\x00"), uint(17/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18403, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 45)
	lua_pushlstring(L, []byte("mapping_symbol\x00"), uint(15/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18410, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 11+lc_nextra)
	lua_pushlstring(L, []byte("if_symbol\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18417, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 4, 117)
	lua_pushlstring(L, []byte("typeAnnotation_symbol\x00"), uint(22/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18424, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 3, 118)
	lua_pushlstring(L, []byte("isOrNot_symbol\x00"), uint(15/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18431, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 2, 119)
	lua_pushlstring(L, []byte("sub_symbol\x00"), uint(11/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18438, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 1, 120)
	lua_pushlstring(L, []byte("true_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18445, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 0, 121)
	lua_pushlstring(L, []byte("false_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18452, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 17+lc_nextra)
	lua_pushlstring(L, []byte("quote_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18459, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 18+lc_nextra)
	lua_pushlstring(L, []byte("apply_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18466, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 19+lc_nextra)
	lua_pushlstring(L, []byte("null_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18473, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 20+lc_nextra)
	lua_pushlstring(L, []byte("construction_symbol\x00"), uint(20/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18480, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 21+lc_nextra)
	lua_pushlstring(L, []byte("data_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18487, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 22+lc_nextra)
	lua_pushlstring(L, []byte("error_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18494, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 23+lc_nextra)
	lua_pushlstring(L, []byte("symbol_symbol\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18501, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 24+lc_nextra)
	lua_pushlstring(L, []byte("list_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18508, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 25+lc_nextra)
	lua_pushlstring(L, []byte("head_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18515, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 26+lc_nextra)
	lua_pushlstring(L, []byte("tail_symbol\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18522, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 27+lc_nextra)
	lua_pushlstring(L, []byte("thing_symbol\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18529, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 28+lc_nextra)
	lua_pushlstring(L, []byte("theWorldStopped_symbol\x00"), uint(23/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18536, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 29+lc_nextra)
	lua_pushlstring(L, []byte("effect_symbol\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18543, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 30+lc_nextra)
	lua_pushlstring(L, []byte("sequentialWordFormation_symbol\x00"), uint(31/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18550, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 31+lc_nextra)
	lua_pushlstring(L, []byte("inputOutput_symbol\x00"), uint(19/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18557, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 73)
	var lc457 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 48)
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 21)
	lua_pushvalue(L, 28+lc_nextra)
	lc_getupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 5, 116)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc457, 1)
	lc_setupvalue(L, int32((lc456 + int32((int32((lc_nextra)))))), 10, 44)
	func() {
		if lua_gettop(L)-lc_nextra == 31 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 31\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18570, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc456 + int32((int32((lc_nextra)))))))
	const (
		lc458 int32 = 32
	)
	func() {
		if lua_gettop(L) == int32((lc458 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc458 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18575, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc458 + int32((int32((lc_nextra)))))), 122)
	func() {
		if lua_gettop(L)-lc_nextra == 32 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 32\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18578, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc458 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_systemName_make, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 0, 122)
	func() {
		if lua_gettop(L)-lc_nextra == 32 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 32\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18586, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 33 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 33\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18590, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc458 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_make_builtin_f_new_sym_f, 1)
	lua_replace(L, 33+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 33 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 33\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18599, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 34 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 34\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18603, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc458 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_make_builtin_f_get_sym_f, 1)
	lua_replace(L, 34+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 34 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 34\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18612, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 35 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 35\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18616, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc458 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_make_builtin_f_p_sym_f, 1)
	lua_replace(L, 35+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 35 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 35\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18626, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 33+lc_nextra)
	lua_pushvalue(L, 21+lc_nextra)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 36 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 36\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18633, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 21+lc_nextra)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 8, 114)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 43)
	func() {
		if lua_gettop(L)-lc_nextra == 36 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 36\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18642, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 21+lc_nextra)
	lua_pushvalue(L, 24+lc_nextra)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 42)
	func() {
		if lua_gettop(L)-lc_nextra == 36 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 36\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18651, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 35+lc_nextra)
	lua_pushvalue(L, 21+lc_nextra)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 41)
	func() {
		if lua_gettop(L)-lc_nextra == 36 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 36\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18658, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 33+lc_nextra)
	lua_pushvalue(L, 22+lc_nextra)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 37 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 37\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18665, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 22+lc_nextra)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 8, 114)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 40)
	func() {
		if lua_gettop(L)-lc_nextra == 37 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 37\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18674, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 22+lc_nextra)
	lua_pushvalue(L, 24+lc_nextra)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 39)
	func() {
		if lua_gettop(L)-lc_nextra == 37 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 37\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18683, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 35+lc_nextra)
	lua_pushvalue(L, 22+lc_nextra)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 38)
	func() {
		if lua_gettop(L)-lc_nextra == 37 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 37\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18691, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 33+lc_nextra)
	lua_pushvalue(L, 20+lc_nextra)
	lua_call(L, 1, 1)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18698, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 35+lc_nextra)
	lua_pushvalue(L, 20+lc_nextra)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 37)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18706, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 20+lc_nextra)
	lua_pushvalue(L, 25+lc_nextra)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 36)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18715, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	lua_pushvalue(L, 20+lc_nextra)
	lua_pushvalue(L, 26+lc_nextra)
	lua_call(L, 2, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 35)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18724, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 35+lc_nextra)
	lua_pushvalue(L, 23+lc_nextra)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 34)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18732, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 35+lc_nextra)
	lua_pushvalue(L, 19+lc_nextra)
	lua_call(L, 1, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 33)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18739, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 0, 122)
	var lc469 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	var lc470 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 5, 117)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 47)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 4, 118)
	lua_pushvalue(L, 7+lc_nextra)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc470, -1)
	lua_call(L, lua_gettop(L)-lc469, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 32)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18757, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 0, 122)
	var lc471 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 5, 117)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 47)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 83)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 47)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 6, 116)
	lua_call(L, 2, 1)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 6, 116)
	lua_call(L, 3, 1)
	lua_pushvalue(L, 18+lc_nextra)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc471, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 31)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18779, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 0, 122)
	var lc472 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 5, 117)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 47)
	lua_pushvalue(L, 8+lc_nextra)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc472, 1)
	lc_setupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 30)
	func() {
		if lua_gettop(L)-lc_nextra == 38 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 38\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18793, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc458 + int32((int32((lc_nextra)))))))
	const (
		lc473 int32 = 39
	)
	func() {
		if lua_gettop(L) == int32((lc473 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc473 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18800, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 34+lc_nextra)
	var lc474 int32 = lua_gettop(L)
	lua_pushvalue(L, 24+lc_nextra)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 11, 21)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 5, 117)
	lua_pushvalue(L, 27+lc_nextra)
	lc_getupvalue(L, int32((lc458 + int32((int32((lc_nextra)))))), 6, 116)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc474, 1)
	lua_rawseti(L, int32((lc473 + int32((int32((lc_nextra)))))), 123)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18811, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc475 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 6, 117)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 47)
	lua_pushvalue(L, 11+lc_nextra)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc475, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 29)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18825, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc476 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 6, 117)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lua_pushvalue(L, 17+lc_nextra)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc476, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 28)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18839, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc477 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 6, 117)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	var lc478 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 47)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 7, 116)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 47)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc478, 1)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 8, 115)
	lua_call(L, 3, -1)
	lua_call(L, lua_gettop(L)-lc477, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 27)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18862, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc479 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	var lc480 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 48)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 47)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc480, -1)
	lua_call(L, lua_gettop(L)-lc479, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 26)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18878, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc481 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	var lc482 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 48)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc482, -1)
	lua_call(L, lua_gettop(L)-lc481, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 25)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18894, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 1, 122)
	var lc483 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 46)
	lua_call(L, 2, -1)
	lua_call(L, lua_gettop(L)-lc483, 1)
	lc_setupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 24)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18906, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 36+lc_nextra)
	lua_pushlstring(L, []byte("new_data_function_builtin_systemName\x00"), uint(37/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18914, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 43)
	lua_pushlstring(L, []byte("data_name_function_builtin_systemName\x00"), uint(38/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18922, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 42)
	lua_pushlstring(L, []byte("data_list_function_builtin_systemName\x00"), uint(38/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18930, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 41)
	lua_pushlstring(L, []byte("data_p_function_builtin_systemName\x00"), uint(35/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18938, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 37+lc_nextra)
	lua_pushlstring(L, []byte("new_error_function_builtin_systemName\x00"), uint(38/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18946, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 40)
	lua_pushlstring(L, []byte("error_name_function_builtin_systemName\x00"), uint(39/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18954, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 39)
	lua_pushlstring(L, []byte("error_list_function_builtin_systemName\x00"), uint(39/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18962, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 38)
	lua_pushlstring(L, []byte("error_p_function_builtin_systemName\x00"), uint(36/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18970, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 38+lc_nextra)
	lua_pushlstring(L, []byte("new_construction_function_builtin_systemName\x00"), uint(45/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18978, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 37)
	lua_pushlstring(L, []byte("construction_p_function_builtin_systemName\x00"), uint(43/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18986, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 36)
	lua_pushlstring(L, []byte("construction_head_function_builtin_systemName\x00"), uint(46/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 18994, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 35)
	lua_pushlstring(L, []byte("construction_tail_function_builtin_systemName\x00"), uint(46/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19002, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 34)
	lua_pushlstring(L, []byte("symbol_p_function_builtin_systemName\x00"), uint(37/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19010, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 33)
	lua_pushlstring(L, []byte("null_p_function_builtin_systemName\x00"), uint(35/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19018, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 32)
	lua_pushlstring(L, []byte("equal_p_function_builtin_systemName\x00"), uint(36/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19026, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 31)
	lua_pushlstring(L, []byte("apply_function_builtin_systemName\x00"), uint(34/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19034, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 30)
	lua_pushlstring(L, []byte("evaluate_function_builtin_systemName\x00"), uint(37/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19042, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 0, 123)
	lua_pushlstring(L, []byte("list_chooseOne_function_builtin_systemName\x00"), uint(43/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19050, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 29)
	lua_pushlstring(L, []byte("if_function_builtin_systemName\x00"), uint(31/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19057, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 28)
	lua_pushlstring(L, []byte("quote_form_builtin_systemName\x00"), uint(30/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19064, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 27)
	lua_pushlstring(L, []byte("lambda_form_builtin_systemName\x00"), uint(31/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19071, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 26)
	lua_pushlstring(L, []byte("function_builtin_use_systemName\x00"), uint(32/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19079, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 25)
	lua_pushlstring(L, []byte("form_builtin_use_systemName\x00"), uint(28/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19086, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 24)
	lua_pushlstring(L, []byte("form_use_systemName\x00"), uint(20/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 39 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 39\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19093, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc473 + int32((int32((lc_nextra)))))))
	const (
		lc484 int32 = 40
	)
	func() {
		if lua_gettop(L) == int32((lc484 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc484 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19098, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 77)
	var lc485 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 2, 121)
	lc_getupvalue(L, int32((lc473 + int32((int32((lc_nextra)))))), 12, 21)
	lua_call(L, 0, -1)
	lua_call(L, lua_gettop(L)-lc485, 1)
	lua_rawseti(L, int32((lc484 + int32((int32((lc_nextra)))))), 124)
	func() {
		if lua_gettop(L)-lc_nextra == 40 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 40\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19106, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc484 + int32((int32((lc_nextra)))))))
	const (
		lc486 int32 = 41
	)
	func() {
		if lua_gettop(L) == int32((lc486 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc486 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19111, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc484 + int32((int32((lc_nextra)))))), 13, 77)
	var lc487 int32 = lua_gettop(L)
	lc_getupvalue(L, int32((lc484 + int32((int32((lc_nextra)))))), 4, 120)
	lc_getupvalue(L, int32((lc484 + int32((int32((lc_nextra)))))), 13, 21)
	lua_call(L, 0, -1)
	lua_call(L, lua_gettop(L)-lc487, 1)
	lua_rawseti(L, int32((lc486 + int32((int32((lc_nextra)))))), 125)
	func() {
		if lua_gettop(L)-lc_nextra == 41 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 41\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19119, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc486 + int32((int32((lc_nextra)))))))
	const (
		lc488 int32 = 42
	)
	func() {
		if lua_gettop(L) == int32((lc488 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc488 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19124, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc488 + int32((int32((lc_nextra)))))), 126)
	func() {
		if lua_gettop(L)-lc_nextra == 42 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 42\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19127, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc488 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_list_to_jsArray, 1)
	lc_setupvalue(L, int32((lc488 + int32((int32((lc_nextra)))))), 0, 126)
	func() {
		if lua_gettop(L)-lc_nextra == 42 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 42\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19143, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc488 + int32((int32((lc_nextra)))))))
	const (
		lc495 int32 = 43
	)
	func() {
		if lua_gettop(L) == int32((lc495 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc495 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19148, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc495 + int32((int32((lc_nextra)))))), 127)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19151, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc495 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_maybe_list_to_jsArray, 1)
	lc_setupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 0, 127)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19163, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 22)
	lua_pushlstring(L, []byte("jsArray_to_list\x00"), uint(16/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19170, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 0, 127)
	lua_pushlstring(L, []byte("maybe_list_to_jsArray\x00"), uint(22/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19177, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 21)
	lua_pushlstring(L, []byte("new_list\x00"), uint(9/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19184, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 19)
	lua_pushlstring(L, []byte("delay_p\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19191, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 18)
	lua_pushlstring(L, []byte("force_all\x00"), uint(10/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19198, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 17)
	lua_pushlstring(L, []byte("force1\x00"), uint(7/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19205, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 0, 0)
	lc_setupvalue(L, int32((lc495 + int32((int32((lc_nextra)))))), 16, 16)
	func() {
		if lua_gettop(L)-lc_nextra == 43 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 43\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19210, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc495 + int32((int32((lc_nextra)))))))
	const (
		lc499 int32 = 44
	)
	func() {
		if lua_gettop(L) == int32((lc499 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc499 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19215, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc499 + int32((int32((lc_nextra)))))), 128)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19218, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_val2env, 1)
	lc_setupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 0, 128)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19281, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 16)
	lua_pushlstring(L, []byte("env_null_v\x00"), uint(11/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19288, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 15)
	lua_pushlstring(L, []byte("env_set\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19295, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 14)
	lua_pushlstring(L, []byte("env_get\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19302, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 12)
	lua_pushlstring(L, []byte("env2val\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19309, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 11)
	lua_pushlstring(L, []byte("env_foreach\x00"), uint(12/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19316, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 0, 128)
	lua_pushlstring(L, []byte("val2env\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 44 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 44\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19323, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 45 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 45\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19327, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_make_builtin_p_func, 1)
	lua_replace(L, 45+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 45 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 45\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19344, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 46 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 46\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19348, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_make_builtin_get_func, 1)
	lua_replace(L, 46+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 46 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 46\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19365, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_createtable(L, 19, 0)
	lua_pushvalue(L, 45+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 41)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 76)
	lua_call(L, 2, 1)
	lua_rawseti(L, -2, 1)
	lua_createtable(L, 3, 0)
	lua_pushvalue(L, 36+lc_nextra)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 77)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 43)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 76)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 75)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 3)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 42)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 76)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 74)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 4)
	lua_pushvalue(L, 45+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 38)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 72)
	lua_call(L, 2, 1)
	lua_rawseti(L, -2, 5)
	lua_createtable(L, 3, 0)
	lua_pushvalue(L, 37+lc_nextra)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 73)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 6)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 40)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 72)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 71)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 7)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 39)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 72)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 70)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 8)
	lua_pushvalue(L, 45+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 33)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 78)
	lua_call(L, 2, 1)
	lua_rawseti(L, -2, 9)
	lua_createtable(L, 3, 0)
	lua_pushvalue(L, 38+lc_nextra)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 83)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 10)
	lua_pushvalue(L, 45+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 37)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 82)
	lua_call(L, 2, 1)
	lua_rawseti(L, -2, 11)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 36)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 82)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 81)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 12)
	lua_pushvalue(L, 46+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 35)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 82)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 80)
	lua_call(L, 3, 1)
	lua_rawseti(L, -2, 13)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 32)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf591, 1)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 14)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 31)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf598, 1)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 15)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 30)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 2)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf603, 1)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 16)
	lua_pushvalue(L, 45+lc_nextra)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 34)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 85)
	lua_call(L, 2, 1)
	lua_rawseti(L, -2, 17)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 5, 123)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 1)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf610, 1)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 18)
	lua_createtable(L, 3, 0)
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 29)
	lua_rawseti(L, -2, 1)
	lua_pushnumber(L, 3)
	lua_rawseti(L, -2, 2)
	lua_pushvalue(L, int32((lc499 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf623, 1)
	lua_rawseti(L, -2, 3)
	lua_rawseti(L, -2, 19)
	lc_setupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 8)
	func() {
		if lua_gettop(L)-lc_nextra == 46 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 46\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19624, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc499 + int32((int32((lc_nextra)))))), 17, 3)
	lua_pushlstring(L, []byte("equal_p\x00"), uint(8/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 46 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 46\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19631, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc499 + int32((int32((lc_nextra)))))))
	const (
		lc624 int32 = 47
	)
	func() {
		if lua_gettop(L) == int32((lc624 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc624 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19636, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc624 + int32((int32((lc_nextra)))))), 136)
	func() {
		if lua_gettop(L)-lc_nextra == 47 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 47\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19639, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc624 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_jsbool_no_force_equal_p, 1)
	lc_setupvalue(L, int32((lc624 + int32((int32((lc_nextra)))))), 0, 136)
	func() {
		if lua_gettop(L)-lc_nextra == 47 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 47\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19701, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 48 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 48\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19705, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc624 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_simple_print_force_all_rec, 1)
	lua_replace(L, 48+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 48 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 48\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19713, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc624 + int32((int32((lc_nextra)))))), 18, 2)
	lua_pushlstring(L, []byte("simple_print\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 48 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 48\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19720, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 48+lc_nextra)
	lua_pushlstring(L, []byte("simple_print_force_all_rec\x00"), uint(27/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 48 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 48\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19727, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc624 + int32((int32((lc_nextra)))))))
	const (
		lc670 int32 = 49
	)
	func() {
		if lua_gettop(L) == int32((lc670 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc670 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19732, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc670 + int32((int32((lc_nextra)))))), 137)
	func() {
		if lua_gettop(L)-lc_nextra == 49 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 49\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 19735, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc670 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_simple_parse, 1)
	lc_setupvalue(L, int32((lc670 + int32((int32((lc_nextra)))))), 0, 137)
	func() {
		if lua_gettop(L)-lc_nextra == 49 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 49\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20035, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc670 + int32((int32((lc_nextra)))))), 0, 137)
	lua_pushlstring(L, []byte("simple_parse\x00"), uint(13/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 49 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 49\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20042, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	func() {
		if lua_gettop(L)-lc_nextra == 50 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 50\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20046, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc670 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_complex_parse, 1)
	lua_replace(L, 50+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 50 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 50\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20496, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 50+lc_nextra)
	lua_pushlstring(L, []byte("complex_parse\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 50 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 50\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20503, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_newclosuretable(L, int32((lc670 + int32((int32((lc_nextra)))))))
	const (
		lc1128 int32 = 51
	)
	func() {
		if lua_gettop(L) == int32((lc1128 + int32((int32((lc_nextra)))))) {
		} else {
			linux.AssertFail([]byte("(lua_gettop(L) == (lc1128 + lc_nextra))\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20508, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_settop(L, lua_gettop(L)+1)
	lua_rawseti(L, int32((lc1128 + int32((int32((lc_nextra)))))), 194)
	func() {
		if lua_gettop(L)-lc_nextra == 51 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 51\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20511, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, int32((lc1128 + int32((int32((lc_nextra)))))))
	lua_pushcclosure(L, lcf1_complex_print, 1)
	lc_setupvalue(L, int32((lc1128 + int32((int32((lc_nextra)))))), 0, 194)
	func() {
		if lua_gettop(L)-lc_nextra == 51 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 51\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20676, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lc_getupvalue(L, int32((lc1128 + int32((int32((lc_nextra)))))), 0, 194)
	lua_pushlstring(L, []byte("complex_print\x00"), uint(14/1-1))
	lua_insert(L, -2)
	lua_settable(L, 2+lc_nextra)
	func() {
		if lua_gettop(L)-lc_nextra == 51 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 51\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20683, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	lua_pushvalue(L, 2+lc_nextra)
	return 1
	func() {
		if lua_gettop(L)-lc_nextra == 51 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L) - lc_nextra == 51\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20688, []byte("int lcf_main(lua_State *)\x00"))
		}
	}()
	return
}

// traceback - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20692
func traceback(L []lua_State) int32 {
	if noarch.Not(lua_isstring(L, 1)) {
		return 1
	}
	lua_getfield(L, -10002, []byte("debug\x00"))
	if !(lua_type(L, -1) == 5) {
		lua_settop(L, -(1)-1)
		return 1
	}
	lua_getfield(L, -1, []byte("traceback\x00"))
	if !(lua_type(L, -1) == 6) {
		lua_settop(L, -(2)-1)
		return 1
	}
	lua_pushvalue(L, 1)
	lua_pushinteger(L, 2)
	lua_call(L, 2, 1)
	return 1
}

// lc_l_message - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20711
func lc_l_message(pname []byte, msg []byte) {
	if pname != nil {
		noarch.Fprintf(noarch.Stderr, []byte("%s: \x00"), pname)
	}
	noarch.Fprintf(noarch.Stderr, []byte("%s\n\x00"), msg)
	noarch.Fflush(noarch.Stderr)
}

// lc_report - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20718
func lc_report(L []lua_State, status int32) int32 {
	if status != 0 && !(lua_type(L, -1) == 0) {
		var msg []byte = lua_tolstring(L, -1, nil)
		if len(msg) == 0 {
			msg = []byte("(error object is not a string)\x00")
		}
		lc_l_message([]byte("lua\x00"), msg)
		lua_settop(L, -(1)-1)
	}
	return status
}

// lc_docall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20730
func lc_docall(L []lua_State, narg int32, clear int32) int32 {
	var status int32
	var base int32 = lua_gettop(L) - narg
	lua_pushcclosure(L, traceback, 0)
	lua_insert(L, base)
	status = lua_pcall(L, narg, func() int32 {
		if clear != 0 {
			return 0
		}
		return -1
	}(), base)
	lua_remove(L, base)
	if status != 0 {
		lua_gc(L, 2, 0)
	}
	return status
}

// lc_dofile - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20745
func lc_dofile(L []lua_State, name []byte) int32 {
	var status int32 = noarch.BoolToInt(luaL_loadfile(L, name) != 0 || lc_docall(L, 0, 1) != 0)
	return lc_report(L, status)
}

// lc_dostring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20750
func lc_dostring(L []lua_State, s []byte, name []byte) int32 {
	var status int32 = noarch.BoolToInt(luaL_loadbuffer(L, s, uint(noarch.Strlen(s)), name) != 0 || lc_docall(L, 0, 1) != 0)
	return lc_report(L, status)
}

// lc_handle_luainit - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20755
func lc_handle_luainit(L []lua_State) (c4goDefaultReturn int32) {
	var init_ []byte = noarch.Getenv([]byte("LUA_INIT\x00"))
	if len(init_) == 0 {
		return 0
	} else if int32(init_[0]) == int32('@') {
		return lc_dofile(L, init_[0+1:])
	} else {
		return lc_dostring(L, init_, []byte("=LUA_INIT\x00"))
	}
	return
}

// lc_createarg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20771
func lc_createarg(L []lua_State, args []lc_args_t) {
	var i int32
	lua_createtable(L, 0, 0)
	for i = 0; i < args[0].c; i++ {
		lua_pushstring(L, args[0].v[i])
		lua_rawseti(L, -2, i)
	}
	lua_setfield(L, -10002, ([]byte("arg\x00")))
}

// lang_state_new_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20813
func lang_state_new_orNULL() []lang_state {
	var L []lang_state = make([]lang_state, 1)
	if 0 != len(L) {
		L[0].L = luaL_newstate()
		if 0 == len(L[0].L) {
			_ = L
			return nil
		}
		luaL_openlibs(L[0].L)
		lua_createtable(L[0].L, 0, 0)
		lua_pushcclosure(L[0].L, lcf_main, 1)
		lua_call(L[0].L, 0, 1)
		func() {
			if lua_type(L[0].L, -1) == 5 {
			} else {
				linux.AssertFail([]byte("lua_istable(L->L, -1)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20825, []byte("lang_state *lang_state_new_orNULL()\x00"))
			}
		}()
		L[0].exports_ref = luaL_ref(L[0].L, -10000)
		func() {
			if lua_gettop(L[0].L) == 0 {
			} else {
				linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20827, []byte("lang_state *lang_state_new_orNULL()\x00"))
			}
		}()
	}
	return L
}

// lang_state_delete - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20831
func lang_state_delete(L []lang_state) {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20832, []byte("void lang_state_delete(lang_state *)\x00"))
		}
	}()
	lua_close(L[0].L)
	L[0].L = nil
	_ = L
}

// lang_value_delete - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20838
func lang_value_delete(L []lang_state, val []lang_value) {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20839, []byte("void lang_value_delete(lang_state *, lang_value *)\x00"))
		}
	}()
	luaL_unref(L[0].L, -10000, val[0].lua_ref)
	_ = val
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20842, []byte("void lang_value_delete(lang_state *, lang_value *)\x00"))
		}
	}()
}

// lang_value_copy_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20844
func lang_value_copy_orNULL(L []lang_state, val []lang_value) []lang_value {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20845, []byte("lang_value *lang_value_copy_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	var ret []lang_value = make([]lang_value, 1)
	if 0 == len(ret) {
		return nil
	}
	lua_rawgeti(L[0].L, -10000, val[0].lua_ref)
	ret[0].lua_ref = luaL_ref(L[0].L, -10000)
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20852, []byte("lang_value *lang_value_copy_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	return ret
}

// lang_value_from_lua_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20855
func lang_value_from_lua_orNULL(L []lang_state) []lang_value {
	var ret []lang_value = make([]lang_value, 1)
	if 0 == len(ret) {
		return nil
	}
	func() {
		if lua_type(L[0].L, -1) == 5 {
		} else {
			linux.AssertFail([]byte("lua_istable(L->L, -1)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20860, []byte("lang_value *lang_value_from_lua_orNULL(lang_state *)\x00"))
		}
	}()
	ret[0].lua_ref = luaL_ref(L[0].L, -10000)
	lua_rawgeti(L[0].L, -10000, ret[0].lua_ref)
	func() {
		if lua_type(L[0].L, -1) == 5 {
		} else {
			linux.AssertFail([]byte("lua_istable(L->L, -1)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20863, []byte("lang_value *lang_value_from_lua_orNULL(lang_state *)\x00"))
		}
	}()
	lua_remove(L[0].L, -1)
	return ret
}

// lang_complex_parse_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20867
func lang_complex_parse_orNULL(L []lang_state, str []byte) []lang_value {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20868, []byte("lang_value *lang_complex_parse_orNULL(lang_state *, const char *)\x00"))
		}
	}()
	lua_rawgeti(L[0].L, -10000, L[0].exports_ref)
	lua_getfield(L[0].L, -1, []byte("complex_parse\x00"))
	lua_remove(L[0].L, -2)
	lua_pushstring(L[0].L, str)
	lua_call(L[0].L, 1, 1)
	var ret []lang_value = lang_value_from_lua_orNULL(L)
	if 0 == len(ret) {
		lua_settop(L[0].L, 0)
		return nil
	}
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20879, []byte("lang_value *lang_complex_parse_orNULL(lang_state *, const char *)\x00"))
		}
	}()
	return ret
}

// lang_complex_print_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20882
func lang_complex_print_orNULL(L []lang_state, val []lang_value) []byte {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20883, []byte("const char *lang_complex_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	lua_rawgeti(L[0].L, -10000, L[0].exports_ref)
	lua_getfield(L[0].L, -1, []byte("complex_print\x00"))
	lua_remove(L[0].L, -2)
	lua_rawgeti(L[0].L, -10000, val[0].lua_ref)
	lua_call(L[0].L, 1, 1)
	func() {
		if lua_isstring(L[0].L, -1) != 0 {
		} else {
			linux.AssertFail([]byte("lua_isstring(L->L, -1)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20889, []byte("const char *lang_complex_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	var rawret []byte = lua_tolstring(L[0].L, -1, nil)
	lua_remove(L[0].L, -1)
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20892, []byte("const char *lang_complex_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	var len_ uint = uint(noarch.Strlen(rawret))
	var ret []byte = make([]byte, len_+uint(1))
	if 0 == len(ret) {
		return nil
	}
	noarch.Memcpy(ret, rawret, len_+uint(1))
	return ret
}

// lang_simple_parse_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20901
func lang_simple_parse_orNULL(L []lang_state, str []byte) []lang_value {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20902, []byte("lang_value *lang_simple_parse_orNULL(lang_state *, const char *)\x00"))
		}
	}()
	lua_rawgeti(L[0].L, -10000, L[0].exports_ref)
	lua_getfield(L[0].L, -1, []byte("simple_parse\x00"))
	lua_remove(L[0].L, -2)
	lua_pushstring(L[0].L, str)
	lua_call(L[0].L, 1, 1)
	var ret []lang_value = lang_value_from_lua_orNULL(L)
	if 0 == len(ret) {
		lua_settop(L[0].L, 0)
		return nil
	}
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20913, []byte("lang_value *lang_simple_parse_orNULL(lang_state *, const char *)\x00"))
		}
	}()
	return ret
}

// lang_simple_print_orNULL - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:20916
func lang_simple_print_orNULL(L []lang_state, val []lang_value) []byte {
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20917, []byte("const char *lang_simple_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	lua_rawgeti(L[0].L, -10000, L[0].exports_ref)
	lua_getfield(L[0].L, -1, []byte("simple_print\x00"))
	lua_remove(L[0].L, -2)
	lua_rawgeti(L[0].L, -10000, val[0].lua_ref)
	lua_call(L[0].L, 1, 1)
	func() {
		if lua_isstring(L[0].L, -1) != 0 {
		} else {
			linux.AssertFail([]byte("lua_isstring(L->L, -1)\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20923, []byte("const char *lang_simple_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	var rawret []byte = lua_tolstring(L[0].L, -1, nil)
	lua_remove(L[0].L, -1)
	func() {
		if lua_gettop(L[0].L) == 0 {
		} else {
			linux.AssertFail([]byte("lua_gettop(L->L) == 0\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/lang.c\x00"), 20926, []byte("const char *lang_simple_print_orNULL(lang_state *, lang_value *)\x00"))
		}
	}()
	var len_ uint = uint(noarch.Strlen(rawret))
	var ret []byte = make([]byte, len_+uint(1))
	if 0 == len(ret) {
		return nil
	}
	noarch.Memcpy(ret, rawret, len_+uint(1))
	return ret
}

// index2adr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22242
func index2adr(L []lua_State, idx int32) (c4goDefaultReturn []TValue) {
	if idx > 0 {
		var o []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].base)[0])) + (uintptr)(idx-1)*unsafe.Sizeof(StkId(L[0].base)[0]))))[:]
		_ = 0
		if (int64(uintptr(unsafe.Pointer(&o[0])))/int64(16) - func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) >= 0 {
			return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
		} else {
			return o
		}
	} else if idx > -10000 {
		_ = 0
		return []TValue((L[0].top[0+idx:]))
	} else {
		switch idx {
		case (-10000):
			return (*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:]
		case (-10001):
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22256 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			func_ []Closure = func() []Closure {
				(0)
				tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
				return *tempVar
			}()
			{
				var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&L[0].env))[:]
				(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0].c.env[0]))) / int64(1))))[:]
				i_o[0].tt = 5
				_ = 0
			}
			return (*[1000000]TValue)(unsafe.Pointer(&L[0].env))[:]
		case (-10002):
			return (*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:]
		default:
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22262 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			func_ []Closure = func() []Closure {
				(0)
				tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
				return *tempVar
			}()
			idx = -10002 - idx
			return func() []TValue {
				if idx <= int32(uint8((lu_byte(func_[0].c.nupvalues)))) {
					return func_[0].c.upvalue[:][idx-1:]
				}
				return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
			}()
		}
	}
	return
}

// getcurrenv - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22272
func getcurrenv(L []lua_State) (c4goDefaultReturn []Table) {
	if (int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)) == 0 {
		return func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*((*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:])[0].value.gc())[0].h))[:]
			return *tempVar
		}()
	} else {
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22276 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		func_ []Closure = func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}()
		return func_[0].c.env
	}
	return
}

// luaA_pushobject - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22282
func luaA_pushobject(L []lua_State, o []TValue) {
	{
		var o2 []TValue = o
		var o1 []TValue = []TValue((L[0].top))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
}

// lua_checkstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22288
func lua_checkstack(L []lua_State, size int32) int32 {
	var res int32 = 1
	_ = 0
	if size > 8000 || int32((func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()-func() int64 {
		c4go_temp_name := StkId(L[0].base)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()))+size > 8000 {
		res = 0
	} else if size > 0 {
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= size*int32(16) {
			luaD_growstack(L, size)
		} else {
			_ = (0)
		}
		if (func() int64 {
			c4go_temp_name := StkId(L[0].ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - int64(uintptr(unsafe.Pointer(&L[0].top[0+size])))/int64(8)) < 0 {
			L[0].ci[0].top = L[0].top[0+size:]
		}
	}
	_ = 0
	return res
}

// lua_xmove - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22303
func lua_xmove(from []lua_State, to []lua_State, n int32) {
	var i int32
	if (int64(uintptr(unsafe.Pointer(&from[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&to[0])))/int64(176)) == 0 {
		return
	}
	_ = 0
	_ = 0
	_ = 0
	_ = 0
	from[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&from[0].top[0])) - (uintptr)(n)*unsafe.Sizeof(from[0].top[0]))))[:]))
	for i = 0; i < n; i++ {
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&from[0].top[0+i]))) / int64(1))))[:]
			var o1 []TValue = []TValue((func() StkId {
				tempVar := to[0].top
				defer func() {
					to[0].top = to[0].top[1:]
				}()
				return tempVar
			}()))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
	}
	_ = 0
}

// lua_setlevel - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22318
func lua_setlevel(from []lua_State, to []lua_State) {
	to[0].nCcalls = from[0].nCcalls
}

// lua_atpanic - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22323
func lua_atpanic(L []lua_State, panicf lua_CFunction) lua_CFunction {
	var old lua_CFunction
	_ = 0
	old = lua_CFunction((L[0].l_G)[0].panic_)
	(L[0].l_G)[0].panic_ = panicf
	_ = 0
	return old
}

// lua_newthread - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22333
func lua_newthread(L []lua_State) []lua_State {
	var L1 []lua_State
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	L1 = luaE_newthread(L)
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L1[0]))) / int64(1))))[:]
		i_o[0].tt = 8
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
	_ = L
	return L1
}

// lua_gettop - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22352
func lua_gettop(L []lua_State) int32 {
	return int32((func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}() - func() int64 {
		c4go_temp_name := StkId(L[0].base)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()))
}

// lua_settop - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22357
func lua_settop(L []lua_State, idx int32) {
	_ = 0
	if idx >= 0 {
		_ = 0
		for (func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - int64(uintptr(unsafe.Pointer(&L[0].base[0+idx])))/int64(8)) < 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22362 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			(func() int32 {
				(func() StkId {
					tempVar := L[0].top
					defer func() {
						L[0].top = L[0].top[1:]
					}()
					return tempVar
				}())[0].tt = 0
				return (func() StkId {
					tempVar := L[0].top
					defer func() {
						L[0].top = L[0].top[1:]
					}()
					return tempVar
				}())[0].tt
			}())
		}
		L[0].top = L[0].base[0+idx:]
	} else {
		_ = 0
		L[0].top = L[0].top[0+(idx+1):]
	}
	_ = 0
}

// lua_remove - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22373
func lua_remove(L []lua_State, idx int32) {
	var p StkId
	_ = 0
	p = StkId((index2adr(L, idx)))
	_ = 0
	for (func() int64 {
		c4go_temp_name := func() StkId {
			func() StkId {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
			return p
		}()
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}() - func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()) < 0 {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId((p))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&p[0])) - (uintptr)(1)*unsafe.Sizeof(p[0]))))[:]
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
}

// lua_insert - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22384
func lua_insert(L []lua_State, idx int32) {
	var p StkId
	var q StkId
	_ = 0
	p = StkId((index2adr(L, idx)))
	_ = 0
	for q = StkId(L[0].top); (int64(uintptr(unsafe.Pointer(&q[0])))/int64(8) - int64(uintptr(unsafe.Pointer(&p[0])))/int64(8)) > 0; func() StkId {
		tempVarUnary := q
		defer func() {
			q = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&q[0])) - (uintptr)(1)*unsafe.Sizeof(q[0]))))[:]))
		}()
		return tempVarUnary
	}() {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&q[0])) - (uintptr)(1)*unsafe.Sizeof(q[0]))))[:]))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = []TValue((q))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId((L[0].top))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = []TValue((p))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	_ = 0
}

// lua_replace - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22396
func lua_replace(L []lua_State, idx int32) {
	var o StkId
	_ = 0
	if idx == -10001 && (int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)-int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)) == 0 {
		luaG_runerror(L, []byte("no calling environment\x00"))
	}
	_ = 0
	o = StkId((index2adr(L, idx)))
	_ = 0
	if idx == -10001 {
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22406 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		func_ []Closure = func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}()
		_ = 0
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22408 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		func_[0].c.env = func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
			return *tempVar
		}()
		{
			if (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22409 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0]))) / int64(1))))[:], func() []GCObject {
					(0)
					tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
					return *tempVar
				}())
			}
		}
	} else {
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = []TValue((o))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		if idx < -10002 {
			if (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() []Closure {
					(0)
					tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22414 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := func() []Closure {
						(0)
						tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
						return *tempVar
					}()
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:], func() []GCObject {
					(0)
					tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
					return *tempVar
				}())
			}
		}
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
}

// lua_pushvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22421
func lua_pushvalue(L []lua_State, idx int32) {
	_ = 0
	{
		var o2 []TValue = (index2adr(L, idx))
		var o1 []TValue = []TValue((L[0].top))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_type - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22435
func lua_type(L []lua_State, idx int32) int32 {
	var o StkId = StkId((index2adr(L, idx)))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22437 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	return func() int32 {
		if (int64(uintptr(unsafe.Pointer(&o[0])))/int64(8) - int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 {
			return -1
		}
		return StkId((o))[0].tt
	}()
}

// lua_typename - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22441
func lua_typename(L []lua_State, t int32) []byte {
	_ = L
	return func() []byte {
		if t == -1 {
			return []byte("no value\x00")
		}
		return luaT_typenames[t]
	}()
}

// lua_iscfunction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22447
func lua_iscfunction(L []lua_State, idx int32) int32 {
	var o StkId = StkId((index2adr(L, idx)))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22449 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return noarch.BoolToInt(StkId((o))[0].tt == 6 && int32(uint8((lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)))) != 0)
}

// lua_isnumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22453
func lua_isnumber(L []lua_State, idx int32) int32 {
	var n TValue
	var o []TValue = index2adr(L, idx)
	return noarch.BoolToInt((o)[0].tt == 3 || len((func() []TValue {
		o = luaV_tonumber(o, (*[1000000]TValue)(unsafe.Pointer(&n))[:])
		return o
	}())) != 0)
}

// lua_isstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22460
func lua_isstring(L []lua_State, idx int32) int32 {
	var t int32 = lua_type(L, idx)
	return noarch.BoolToInt(t == 4 || t == 3)
}

// lua_isuserdata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22466
func lua_isuserdata(L []lua_State, idx int32) int32 {
	var o []TValue = index2adr(L, idx)
	return noarch.BoolToInt((o)[0].tt == 7 || (o)[0].tt == 2)
}

// lua_rawequal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22472
func lua_rawequal(L []lua_State, index1 int32, index2 int32) int32 {
	var o1 StkId = StkId((index2adr(L, index1)))
	var o2 StkId = StkId((index2adr(L, index2)))
	return func() int32 {
		if (int64(uintptr(unsafe.Pointer(&o1[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 || (int64(uintptr(unsafe.Pointer(&o2[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 {
			return 0
		}
		return luaO_rawequalObj((*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o1)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:], (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o2)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])
	}()
}

// lua_equal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22480
func lua_equal(L []lua_State, index1 int32, index2 int32) int32 {
	var o1 StkId
	var o2 StkId
	var i int32
	_ = 0
	o1 = StkId((index2adr(L, index1)))
	o2 = StkId((index2adr(L, index2)))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22486 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	i = func() int32 {
		if (int64(uintptr(unsafe.Pointer(&o1[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 || (int64(uintptr(unsafe.Pointer(&o2[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 {
			return 0
		}
		return noarch.BoolToInt(StkId((o1))[0].tt == StkId((o2))[0].tt && luaV_equalval(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o1)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:], (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o2)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]) != 0)
	}()
	_ = 0
	return i
}

// lua_lessthan - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22492
func lua_lessthan(L []lua_State, index1 int32, index2 int32) int32 {
	var o1 StkId
	var o2 StkId
	var i int32
	_ = 0
	o1 = StkId((index2adr(L, index1)))
	o2 = StkId((index2adr(L, index2)))
	i = func() int32 {
		if (int64(uintptr(unsafe.Pointer(&o1[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 || (int64(uintptr(unsafe.Pointer(&o2[0])))/int64(8)-int64(uintptr(unsafe.Pointer(&(*StkId)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0]))) / int64(1))))[0])))/int64(8)) == 0 {
			return 0
		}
		return luaV_lessthan(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o1)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:], (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(o2)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])
	}()
	_ = 0
	return i
}

// lua_tonumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22506
func lua_tonumber(L []lua_State, idx int32) (c4goDefaultReturn lua_Number) {
	var n TValue
	var o []TValue = index2adr(L, idx)
	if (o)[0].tt == 3 || len((func() []TValue {
		o = luaV_tonumber(o, (*[1000000]TValue)(unsafe.Pointer(&n))[:])
		return o
	}())) != 0 {
		return func() lua_Number {
			(0)
			tempVar := &(*(o)[0].value.n())
			return *tempVar
		}()
	} else {
		return 0
	}
	return
}

// lua_tointeger - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22516
func lua_tointeger(L []lua_State, idx int32) (c4goDefaultReturn lua_Integer) {
	var n TValue
	var o []TValue = index2adr(L, idx)
	if (o)[0].tt == 3 || len((func() []TValue {
		o = luaV_tonumber(o, (*[1000000]TValue)(unsafe.Pointer(&n))[:])
		return o
	}())) != 0 {
		var res lua_Integer
		var num lua_Number = func() lua_Number {
			(0)
			tempVar := &(*(o)[0].value.n())
			return *tempVar
		}()
		res = lua_Integer(num)
		return res
	} else {
		return 0
	}
	return
}

// lua_toboolean - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22530
func lua_toboolean(L []lua_State, idx int32) int32 {
	var o []TValue = index2adr(L, idx)
	return noarch.BoolToInt(!((o)[0].tt == 0 || (o)[0].tt == 1 && func() int32 {
		(0)
		tempVar := &(*(o)[0].value.b())
		return *tempVar
	}() == 0))
}

// lua_tolstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22536
func lua_tolstring(L []lua_State, idx int32, len_ []uint) []byte {
	var o StkId = StkId((index2adr(L, idx)))
	if !(StkId((o))[0].tt == 4) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22538 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		_ = 0
		if noarch.Not(luaV_tostring(L, o)) {
			if len(len_) != 0 {
				len_[0] = 0
			}
			_ = 0
			return nil
		}
		{
			_ = 0
			if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
				luaC_step(L)
			}
		}
		o = StkId((index2adr(L, idx)))
		_ = 0
	}
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	if len(len_) != 0 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22549 :Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00767dec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	}
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22550 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]TString)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].ts))[:])[func() int32 {
		(0)
		tempVar := &0
		return *tempVar
	}()+1]))) / int64(1))))[:]
}

// lua_objlen - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22554
func lua_objlen(L []lua_State, idx int32) (c4goDefaultReturn uint) {
	var o StkId = StkId((index2adr(L, idx)))
	switch StkId((o))[0].tt {
	case 4:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22556 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		fallthrough
	case 7:
		// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22557 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008e75dc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		fallthrough
	case 5:
		// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22558 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc006b47bc0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22559 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return uint(luaH_getn(func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
			return *tempVar
		}()))
	case 3:
		var l uint
		_ = 0
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22563 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'size_t' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = parameter `b` : Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0074329c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		_ = 0
		return l
	default:
		return 0
	}
	return
}

// lua_tocfunction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22572
func lua_tocfunction(L []lua_State, idx int32) lua_CFunction {
	var o StkId = StkId((index2adr(L, idx)))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22574 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return func() lua_CFunction {
		if !(StkId((o))[0].tt == 6 && int32(uint8((lu_byte((*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).isC)))) != 0) {
			return nil
		}
		return lua_CFunction((*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).f)
	}()
}

// lua_touserdata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22578
func lua_touserdata(L []lua_State, idx int32) (c4goDefaultReturn interface{}) {
	var o StkId = StkId((index2adr(L, idx)))
	switch StkId((o))[0].tt {
	case 7:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22580 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22581 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return (((*[1000000]Udata)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].u))[:])[func() int32 {
			(0)
			tempVar := &0
			return *tempVar
		}()+1:])
	case 2:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22582 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return func() interface{} {
			(0)
			tempVar := &(*StkId((o))[0].value.p())
			return *tempVar
		}()
	default:
		return nil
	}
	return
}

// lua_tothread - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22588
func lua_tothread(L []lua_State, idx int32) []lua_State {
	var o StkId = StkId((index2adr(L, idx)))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22590 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22590 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return func() []lua_State {
		if !(StkId((o))[0].tt == 8) {
			return nil
		}
		return func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].th))[:]
			return *tempVar
		}()
	}()
}

// lua_topointer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22594
func lua_topointer(L []lua_State, idx int32) (c4goDefaultReturn interface{}) {
	var o StkId = StkId((index2adr(L, idx)))
	switch StkId((o))[0].tt {
	case 5:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22596 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22597 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return (func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
			return *tempVar
		}())
	case 6:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22598 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return (func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())
	case 8:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22599 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return (func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].th))[:]
			return *tempVar
		}())
	case 7:
		fallthrough
	case 2:
		return lua_touserdata(L, idx)
	default:
		return nil
	}
	return
}

// lua_pushnil - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22614
func lua_pushnil(L []lua_State) {
	_ = 0
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22616 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	StkId((L[0].top))[0].tt = 0
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushnumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22622
func lua_pushnumber(L []lua_State, n lua_Number) {
	_ = 0
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.n()) = n
		i_o[0].tt = 3
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushinteger - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22630
func lua_pushinteger(L []lua_State, n lua_Integer) {
	_ = 0
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.n()) = lua_Number(n)
		i_o[0].tt = 3
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushlstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22638
func lua_pushlstring(L []lua_State, s []byte, len_ uint) {
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, s, len_)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22647
func lua_pushstring(L []lua_State, s []byte) {
	if len(s) == 0 {
		lua_pushnil(L)
	} else {
		lua_pushlstring(L, s, uint(noarch.Strlen(s)))
	}
}

// lua_pushvfstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22655
func lua_pushvfstring(L []lua_State, fmt_ []byte, argp *va_list) []byte {
	var ret []byte
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	ret = luaO_pushvfstring(L, fmt_, argp)
	_ = 0
	return ret
}

// lua_pushfstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22666
func lua_pushfstring(L []lua_State, fmt_ []byte, c4goArgs ...interface{}) []byte {
	var ret []byte
	var argp = create_va_list(c4goArgs)
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	va_start(argp, fmt_)
	ret = luaO_pushvfstring(L, fmt_, argp)
	va_end(argp)
	_ = 0
	return ret
}

// lua_pushcclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22679
func lua_pushcclosure(L []lua_State, fn lua_CFunction, n int32) {
	var cl []Closure
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	_ = 0
	cl = luaF_newCclosure(L, n, getcurrenv(L))
	cl[0].c.f = fn
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(n)*unsafe.Sizeof(L[0].top[0]))))[:]))
	for func() int32 {
		defer func() {
			n--
		}()
		return n
	}() != 0 {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].top[0+n]))) / int64(1))))[:]
		var o1 []TValue = cl[0].c.upvalue[:][n:]
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0]))) / int64(1))))[:]
		i_o[0].tt = 6
		_ = 0
	}
	_ = 0
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushboolean - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22696
func lua_pushboolean(L []lua_State, b int32) {
	_ = 0
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.b()) = noarch.BoolToInt(b != 0)
		i_o[0].tt = 1
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushlightuserdata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22704
func lua_pushlightuserdata(L []lua_State, p interface{}) {
	_ = 0
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.p()) = p
		i_o[0].tt = 2
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_pushthread - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22712
func lua_pushthread(L []lua_State) int32 {
	_ = 0
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:]
		i_o[0].tt = 8
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
	return noarch.BoolToInt((int64(uintptr(unsafe.Pointer(&(L[0].l_G)[0].mainthread[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&L[0])))/int64(176)) == 0)
}

// lua_gettable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22727
func lua_gettable(L []lua_State, idx int32) {
	var t StkId
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	luaV_gettable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(t)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:], StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))
	_ = 0
}

// lua_getfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22737
func lua_getfield(L []lua_State, idx int32, k []byte) {
	var t StkId
	var key TValue
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&key))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, k, uint(noarch.Strlen(k)))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	}
	luaV_gettable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(t)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], (*[1000000]TValue)(unsafe.Pointer(&key))[:], StkId(L[0].top))
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_rawget - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22750
func lua_rawget(L []lua_State, idx int32) {
	var t StkId
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	{
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22755 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		o2 []TValue = luaH_get(func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((t))[0].value.gc())[0].h))[:]
			return *tempVar
		}(), (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])
		var o1 []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	_ = 0
}

// lua_rawgeti - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22760
func lua_rawgeti(L []lua_State, idx int32, n int32) {
	var o StkId
	_ = 0
	o = StkId((index2adr(L, idx)))
	_ = 0
	{
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22765 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		o2 []TValue = luaH_getnum(func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
			return *tempVar
		}(), n)
		var o1 []TValue = []TValue((L[0].top))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_createtable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22771
func lua_createtable(L []lua_State, narray int32, nrec int32) {
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaH_new(L, narray, nrec)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 5
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_getmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22780
func lua_getmetatable(L []lua_State, objindex int32) int32 {
	var obj []TValue
	var mt []Table
	var res int32
	_ = 0
	obj = index2adr(L, objindex)
	switch (obj)[0].tt {
	case 5:
		mt = (func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].h))[:]
			return *tempVar
		}())[0].metatable
	case 7:
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22791 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005b75640), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	default:
		mt = (L[0].l_G)[0].mt[:][(obj)[0].tt]
		break
	}
	if len(mt) == 0 {
		res = 0
	} else {
		{
			var i_o []TValue = []TValue((L[0].top))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:]
			i_o[0].tt = 5
			_ = 0
		}
		{
			_ = 0
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
		res = 1
	}
	_ = 0
	return res
}

// lua_getfenv - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22809
func lua_getfenv(L []lua_State, idx int32) {
	var o StkId
	_ = 0
	o = StkId((index2adr(L, idx)))
	_ = 0
	switch StkId((o))[0].tt {
	case 6:
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22814 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		i_o []TValue = []TValue((L[0].top))
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22816 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).env[0]))) / int64(1))))[:]
		i_o[0].tt = 5
		_ = 0
	case 7:
		var i_o []TValue = []TValue((L[0].top))
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpile BinaryOperator with type 'GCObject *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22819 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'GCObject *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0082e36c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		i_o[0].tt = 5
		_ = 0
	case 8:
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22822 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		o2 []TValue = ((*[1000000]TValue)(unsafe.Pointer(&(func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].th))[:]
			return *tempVar
		}())[0].l_gt))[:])
		var o1 []TValue = []TValue((L[0].top))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	default:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22824 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		(func() int32 {
			StkId((L[0].top))[0].tt = 0
			return StkId((L[0].top))[0].tt
		}())
		break
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
}

// lua_settable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22838
func lua_settable(L []lua_State, idx int32) {
	var t StkId
	_ = 0
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	luaV_settable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(t)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(2)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:], StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(2)*unsafe.Sizeof(L[0].top[0]))))[:]))
	_ = 0
}

// lua_setfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22850
func lua_setfield(L []lua_State, idx int32, k []byte) {
	var t StkId
	var key TValue
	_ = 0
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&key))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, k, uint(noarch.Strlen(k)))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	}
	luaV_settable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(t)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], (*[1000000]TValue)(unsafe.Pointer(&key))[:], StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
}

// lua_rawset - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22864
func lua_rawset(L []lua_State, idx int32) {
	var t StkId
	_ = 0
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	{
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22870 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		o1 []TValue = luaH_set(L, func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((t))[0].value.gc())[0].h))[:]
			return *tempVar
		}(), (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(2)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		if (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((t))[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22871 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			luaC_barrierback(L, func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((t))[0].value.gc())[0].h))[:]
				return *tempVar
			}())
		}
	}
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(2)*unsafe.Sizeof(L[0].top[0]))))[:]))
	_ = 0
}

// lua_rawseti - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22877
func lua_rawseti(L []lua_State, idx int32, n int32) {
	var o StkId
	_ = 0
	_ = 0
	o = StkId((index2adr(L, idx)))
	_ = 0
	{
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22883 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		o1 []TValue = luaH_setnum(L, func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
			return *tempVar
		}(), n)
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		if (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22884 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			luaC_barrierback(L, func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].h))[:]
				return *tempVar
			}())
		}
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
}

// lua_setmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22890
func lua_setmetatable(L []lua_State, objindex int32) int32 {
	var obj []TValue
	var mt []Table
	_ = 0
	_ = 0
	obj = index2adr(L, objindex)
	_ = 0
	if (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].tt == 0 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22897 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		mt = nil
	} else {
		_ = 0
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22901 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		mt = func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
			return *tempVar
		}()
	}
	switch (obj)[0].tt {
	case 5:
		(func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].h))[:]
			return *tempVar
		}())[0].metatable = mt
		if mt != nil {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() []Table {
					(0)
					tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].h))[:]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				luaC_barrierback(L, func() []Table {
					(0)
					tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].h))[:]
					return *tempVar
				}())
			}
		}
	case 7:
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		if mt != nil {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() []Udata {
					(0)
					tempVar := &(*[1000000]Udata)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].u))[:]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22911 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0068f2340), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := func() []Udata {
						(0)
						tempVar := &(*[1000000]Udata)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].u))[:]
						return *tempVar
					}()
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:], (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:])
			}
		}
	default:
		(L[0].l_G)[0].mt[:][(obj)[0].tt] = mt
		break
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
	return 1
}

// lua_setfenv - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22927
func lua_setfenv(L []lua_State, idx int32) int32 {
	var o StkId
	var res int32 = 1
	_ = 0
	_ = 0
	o = StkId((index2adr(L, idx)))
	_ = 0
	_ = 0
	switch StkId((o))[0].tt {
	case 6:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22935 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22937 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		(*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).env = func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
			return *tempVar
		}()
	case 7:
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22940 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'struct Table *' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc00587a740), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	case 8:
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22943 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&(func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&(*StkId((o))[0].value.gc())[0].th))[:]
			return *tempVar
		}())[0].l_gt))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 5
		_ = 0
	default:
		res = 0
		break
	}
	if res != 0 {
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*StkId((o))[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(2)) != 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22949 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			luaC_barrierf(L, func() []GCObject {
				(0)
				tempVar := &(*StkId((o))[0].value.gc())
				return *tempVar
			}(), (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() []Table {
					(0)
					tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].h))[:]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])
		}
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
	return res
}

// lua_call - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22969
func lua_call(L []lua_State, nargs int32, nresults int32) {
	var func_ StkId
	_ = 0
	_ = 0
	_ = 0
	func_ = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nargs+1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
	luaD_call(L, func_, nresults)
	{
		if nresults == -1 && (func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-func() int64 {
			c4go_temp_name := StkId(L[0].ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) >= 0 {
			L[0].ci[0].top = StkId(L[0].top)
		}
	}
	_ = 0
}

// f_call - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22991
func f_call(L []lua_State, ud interface{}) {
	var c []CallS = ud.([]CallS)
	luaD_call(L, StkId(c[0].func_), c[0].nresults)
}

// lua_pcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:22998
func lua_pcall(L []lua_State, nargs int32, nresults int32, errfunc int32) int32 {
	var c CallS
	var status int32
	var func_ noarch.PtrdiffT
	_ = 0
	_ = 0
	_ = 0
	if errfunc == 0 {
		func_ = 0
	} else {
		var o StkId = StkId((index2adr(L, errfunc)))
		_ = 0
		func_ = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&o[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))))
	}
	c.func_ = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nargs+1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
	c.nresults = nresults
	status = luaD_pcall(L, f_call, c4goUnsafeConvert_CallS(&c), noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&c.func_[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1)))), func_)
	{
		if nresults == -1 && (func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-func() int64 {
			c4go_temp_name := StkId(L[0].ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) >= 0 {
			L[0].ci[0].top = StkId(L[0].top)
		}
	}
	_ = 0
	return status
}

// f_Ccall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23030
func f_Ccall(L []lua_State, ud interface{}) {
	var c []CCallS = ud.([]CCallS)
	var cl []Closure
	cl = luaF_newCclosure(L, 0, getcurrenv(L))
	cl[0].c.f = lua_CFunction(c[0].func_)
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0]))) / int64(1))))[:]
		i_o[0].tt = 6
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.p()) = c[0].ud
		i_o[0].tt = 2
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	luaD_call(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(2)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])), 0)
}

// lua_cpcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23043
func lua_cpcall(L []lua_State, func_ lua_CFunction, ud interface{}) int32 {
	var c CCallS
	var status int32
	_ = 0
	c.func_ = func_
	c.ud = ud
	status = luaD_pcall(L, f_Ccall, c4goUnsafeConvert_CCallS(&c), noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].top[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1)))), 0)
	_ = 0
	return status
}

// lua_load - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23055
func lua_load(L []lua_State, reader lua_Reader, data interface{}, chunkname []byte) int32 {
	var z ZIO
	var status int32
	_ = 0
	if chunkname == nil {
		chunkname = []byte("?\x00")
	}
	luaZ_init(L, (*[1000000]ZIO)(unsafe.Pointer(&z))[:], reader, data)
	status = luaD_protectedparser(L, (*[1000000]ZIO)(unsafe.Pointer(&z))[:], chunkname)
	_ = 0
	return status
}

// lua_dump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23068
func lua_dump(L []lua_State, writer lua_Writer, data interface{}) int32 {
	var status int32
	var o []TValue
	_ = 0
	_ = 0
	o = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]
	if (o)[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*(o)[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)) {
		status = luaU_dump(L, (*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*(o)[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].l()).p, writer, data, 0)
	} else {
		status = 1
	}
	_ = 0
	return status
}

// lua_status - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23083
func lua_status(L []lua_State) int32 {
	return int32(uint8((lu_byte(L[0].status))))
}

// lua_gc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23092
func lua_gc(L []lua_State, what int32, data int32) int32 {
	var res int32
	var g []global_State
	_ = 0
	g = L[0].l_G
	switch what {
	case 0:
		g[0].GCthreshold = lu_mem(^lu_mem(0)) - lu_mem((uint(2)))
	case 1:
		g[0].GCthreshold = lu_mem(g[0].totalbytes)
	case 2:
		luaC_fullgc(L)
	case 3:
		res = int32(uint((lu_mem(g[0].totalbytes) >> uint64(10))))
	case 4:
		res = int32(uint((lu_mem(g[0].totalbytes) & lu_mem((uint(1023))))))
	case 5:
		var a lu_mem = lu_mem(data) << uint64(10)
		if a <= lu_mem(g[0].totalbytes) {
			g[0].GCthreshold = lu_mem(g[0].totalbytes) - a
		} else {
			g[0].GCthreshold = 0
		}
		for lu_mem(g[0].GCthreshold) <= lu_mem(g[0].totalbytes) {
			luaC_step(L)
			if int32(uint8((lu_byte(g[0].gcstate)))) == 0 {
				res = 1
				break
			}
		}
	case 6:
		res = g[0].gcpause
		g[0].gcpause = data
	case 7:
		res = g[0].gcstepmul
		g[0].gcstepmul = data
	default:
		res = -1
	}
	_ = 0
	return res
}

// lua_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23157
func lua_error(L []lua_State) int32 {
	_ = 0
	_ = 0
	luaG_errormsg(L)
	_ = 0
	return 0
}

// lua_next - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23166
func lua_next(L []lua_State, idx int32) int32 {
	var t StkId
	var more int32
	_ = 0
	t = StkId((index2adr(L, idx)))
	_ = 0
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23172 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	more = luaH_next(L, func() []Table {
		(0)
		tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((t))[0].value.gc())[0].h))[:]
		return *tempVar
	}(), StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))
	if more != 0 {
		{
			_ = 0
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
	} else {
		L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
	}
	_ = 0
	return more
}

// lua_concat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23183
func lua_concat(L []lua_State, n int32) {
	_ = 0
	_ = 0
	if n >= 2 {
		{
			_ = 0
			if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
				luaC_step(L)
			}
		}
		luaV_concat(L, n, int32((func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-func() int64 {
			c4go_temp_name := StkId(L[0].base)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()))-1)
		L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(n-1)*unsafe.Sizeof(L[0].top[0]))))[:]))
	} else if n == 0 {
		{
			var i_o []TValue = []TValue((L[0].top))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := luaS_newlstr(L, []byte("\x00"), 0)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			i_o[0].tt = 4
			_ = 0
		}
		{
			_ = 0
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
	}
	_ = 0
}

// lua_getallocf - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23200
func lua_getallocf(L []lua_State, ud []interface{}) lua_Alloc {
	var f lua_Alloc
	_ = 0
	if ud != nil {
		ud[0] = (L[0].l_G)[0].ud
	}
	f = lua_Alloc((L[0].l_G)[0].frealloc)
	_ = 0
	return f
}

// lua_setallocf - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23210
func lua_setallocf(L []lua_State, f lua_Alloc, ud interface{}) {
	_ = 0
	(L[0].l_G)[0].ud = ud
	(L[0].l_G)[0].frealloc = f
	_ = 0
}

// lua_newuserdata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23218
func lua_newuserdata(L []lua_State, size uint) interface{} {
	var u []Udata
	_ = 0
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	u = luaS_newudata(L, size, getcurrenv(L))
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&u[0]))) / int64(1))))[:]
		i_o[0].tt = 7
		_ = 0
	}
	{
		_ = 0
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
	return u[0+1:]
}

// aux_upvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23232
func aux_upvalue(fi StkId, n int32, val [][]TValue) (c4goDefaultReturn []byte) {
	var f []Closure
	if !(StkId((fi))[0].tt == 6) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23234 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		return nil
	}
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23235 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	f = func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((fi))[0].value.gc())[0].cl))[:]
		return *tempVar
	}()
	if uint8((lu_byte(f[0].c.isC))) != 0 {
		if !(1 <= n && n <= int32(uint8((lu_byte(f[0].c.nupvalues))))) {
			return nil
		}
		val[0] = f[0].c.upvalue[:][n-1:]
		return []byte("\x00")
	} else {
		var p []Proto = f[0].l.p
		if !(1 <= n && n <= p[0].sizeupvalues) {
			return nil
		}
		val[0] = f[0].l.upvals[:][n-1][0].v
		return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&p[0].upvalues[n-1][1]))) / int64(1))))[:]
	}
	return
}

// lua_getupvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23250
func lua_getupvalue(L []lua_State, funcindex int32, n int32) []byte {
	var name []byte
	var val []TValue
	_ = 0
	name = aux_upvalue(StkId((index2adr(L, funcindex))), n, (*[1000000][]TValue)(unsafe.Pointer(&val))[:])
	if name != nil {
		{
			var o2 []TValue = (val)
			var o1 []TValue = []TValue((L[0].top))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			_ = 0
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
	}
	_ = 0
	return name
}

// lua_setupvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23264
func lua_setupvalue(L []lua_State, funcindex int32, n int32) []byte {
	var name []byte
	var val []TValue
	var fi StkId
	_ = 0
	fi = StkId((index2adr(L, funcindex)))
	_ = 0
	name = aux_upvalue(fi, n, (*[1000000][]TValue)(unsafe.Pointer(&val))[:])
	if name != nil {
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
			}()
			return tempVarUnary
		}()
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId((L[0].top))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = val
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			if StkId((L[0].top))[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*StkId((L[0].top))[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() []Closure {
					(0)
					tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((fi))[0].value.gc())[0].cl))[:]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23275 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := func() []Closure {
						(0)
						tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((fi))[0].value.gc())[0].cl))[:]
						return *tempVar
					}()
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:], func() []GCObject {
					(0)
					tempVar := &(*StkId((L[0].top))[0].value.gc())
					return *tempVar
				}())
			}
		}
	}
	_ = 0
	return name
}

// luaL_argerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23327
func luaL_argerror(L []lua_State, narg int32, extramsg []byte) int32 {
	var ar lua_Debug
	if noarch.Not(lua_getstack(L, 0, c4goUnsafeConvert_lua_Debug(&ar))) {
		return luaL_error(L, []byte("bad argument #%d (%s)\x00"), narg, extramsg)
	}
	lua_getinfo(L, []byte("n\x00"), c4goUnsafeConvert_lua_Debug(&ar))
	if noarch.Strcmp(ar.namewhat, []byte("method\x00")) == 0 {
		narg--
		if narg == 0 {
			return luaL_error(L, []byte("calling '%s' on bad self (%s)\x00"), ar.name, extramsg)
		}
	}
	if len(ar.name) == 0 {
		ar.name = []byte("?\x00")
	}
	return luaL_error(L, []byte("bad argument #%d to '%s' (%s)\x00"), narg, ar.name, extramsg)
}

// luaL_typerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23345
func luaL_typerror(L []lua_State, narg int32, tname []byte) int32 {
	var msg []byte = lua_pushfstring(L, []byte("%s expected, got %s\x00"), tname, lua_typename(L, lua_type(L, narg)))
	return luaL_argerror(L, narg, msg)
}

// tag_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23352
func tag_error(L []lua_State, narg int32, tag int32) {
	luaL_typerror(L, narg, lua_typename(L, tag))
}

// luaL_where - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23357
func luaL_where(L []lua_State, level int32) {
	var ar lua_Debug
	if lua_getstack(L, level, c4goUnsafeConvert_lua_Debug(&ar)) != 0 {
		lua_getinfo(L, []byte("Sl\x00"), c4goUnsafeConvert_lua_Debug(&ar))
		if ar.currentline > 0 {
			lua_pushfstring(L, []byte("%s:%d: \x00"), ar.short_src[:], ar.currentline)
			return
		}
	}
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
}

// luaL_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23370
func luaL_error(L []lua_State, fmt_ []byte, c4goArgs ...interface{}) int32 {
	var argp = create_va_list(c4goArgs)
	va_start(argp, fmt_)
	luaL_where(L, 1)
	lua_pushvfstring(L, fmt_, argp)
	va_end(argp)
	lua_concat(L, 2)
	return lua_error(L)
}

// luaL_checkoption - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23383
func luaL_checkoption(L []lua_State, narg int32, def []byte, lst [][]byte) int32 {
	var name []byte = func() []byte {
		if def != nil {
			return luaL_optlstring(L, narg, def, nil)
		}
		return luaL_checklstring(L, narg, nil)
	}()
	var i int32
	for i = 0; lst[i] != nil; i++ {
		if noarch.Strcmp(lst[i], name) == 0 {
			return i
		}
	}
	return luaL_argerror(L, narg, lua_pushfstring(L, []byte("invalid option '%s'\x00"), name))
}

// luaL_newmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23396
func luaL_newmetatable(L []lua_State, tname []byte) int32 {
	lua_getfield(L, -10000, tname)
	if !(lua_type(L, -1) == 0) {
		return 0
	}
	lua_settop(L, -(1)-1)
	lua_createtable(L, 0, 0)
	lua_pushvalue(L, -1)
	lua_setfield(L, -10000, tname)
	return 1
}

// luaL_checkudata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23408
func luaL_checkudata(L []lua_State, ud int32, tname []byte) interface{} {
	var p interface{} = lua_touserdata(L, ud)
	if p != nil {
		if lua_getmetatable(L, ud) != 0 {
			lua_getfield(L, -10000, tname)
			if lua_rawequal(L, -1, -2) != 0 {
				lua_settop(L, -(2)-1)
				return p
			}
		}
	}
	luaL_typerror(L, ud, tname)
	return nil
}

// luaL_checkstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23424
func luaL_checkstack(L []lua_State, space int32, mes []byte) {
	if noarch.Not(lua_checkstack(L, space)) {
		luaL_error(L, []byte("stack overflow (%s)\x00"), mes)
	}
}

// luaL_checktype - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23430
func luaL_checktype(L []lua_State, narg int32, t int32) {
	if lua_type(L, narg) != t {
		tag_error(L, narg, t)
	}
}

// luaL_checkany - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23436
func luaL_checkany(L []lua_State, narg int32) {
	if lua_type(L, narg) == -1 {
		luaL_argerror(L, narg, []byte("value expected\x00"))
	}
}

// luaL_checklstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23442
func luaL_checklstring(L []lua_State, narg int32, len_ []uint) []byte {
	var s []byte = lua_tolstring(L, narg, len_)
	if s == nil {
		tag_error(L, narg, 4)
	}
	return s
}

// luaL_optlstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23449
func luaL_optlstring(L []lua_State, narg int32, def []byte, len_ []uint) (c4goDefaultReturn []byte) {
	if lua_type(L, narg) <= 0 {
		if len_ != nil {
			len_[0] = uint(func() uint32 {
				if def != nil {
					return uint32(noarch.Strlen(def))
				}
				return 0
			}())
		}
		return def
	} else {
		return luaL_checklstring(L, narg, len_)
	}
	return
}

// luaL_checknumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23460
func luaL_checknumber(L []lua_State, narg int32) lua_Number {
	var d lua_Number = lua_tonumber(L, narg)
	if d == lua_Number((0)) && noarch.Not(lua_isnumber(L, narg)) {
		tag_error(L, narg, 3)
	}
	return d
}

// luaL_optnumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23468
func luaL_optnumber(L []lua_State, narg int32, def lua_Number) lua_Number {
	return lua_Number((func() float64 {
		if lua_type(L, narg) <= 0 {
			return float64((def))
		}
		return float64((luaL_checknumber(L, narg)))
	}()))
}

// luaL_checkinteger - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23473
func luaL_checkinteger(L []lua_State, narg int32) lua_Integer {
	var d lua_Integer = lua_tointeger(L, narg)
	if d == lua_Integer((noarch.PtrdiffT(0))) && noarch.Not(lua_isnumber(L, narg)) {
		tag_error(L, narg, 3)
	}
	return d
}

// luaL_optinteger - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23481
func luaL_optinteger(L []lua_State, narg int32, def lua_Integer) lua_Integer {
	return lua_Integer((noarch.PtrdiffT(func() int32 {
		if lua_type(L, narg) <= 0 {
			return int32(noarch.PtrdiffT((def)))
		}
		return int32(noarch.PtrdiffT((luaL_checkinteger(L, narg))))
	}())))
}

// luaL_getmetafield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23487
func luaL_getmetafield(L []lua_State, obj int32, event []byte) (c4goDefaultReturn int32) {
	if noarch.Not(lua_getmetatable(L, obj)) {
		return 0
	}
	lua_pushstring(L, event)
	lua_rawget(L, -2)
	if lua_type(L, -1) == 0 {
		lua_settop(L, -(2)-1)
		return 0
	} else {
		lua_remove(L, -2)
		return 1
	}
	return
}

// luaL_callmeta - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23503
func luaL_callmeta(L []lua_State, obj int32, event []byte) int32 {
	obj = func() int32 {
		if obj > 0 || obj <= -10000 {
			return obj
		}
		return lua_gettop(L) + obj + 1
	}()
	if noarch.Not(luaL_getmetafield(L, obj, event)) {
		return 0
	}
	lua_pushvalue(L, obj)
	lua_call(L, 1, 1)
	return 1
}

// luaL_register - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23513
func luaL_register(L []lua_State, libname []byte, l []luaL_Reg) {
	luaL_openlib(L, libname, l, 0)
}

// libsize - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23519
func libsize(l []luaL_Reg) int32 {
	var size int32
	for ; l[0].name != nil; func() []luaL_Reg {
		tempVarUnary := l
		defer func() {
			l = l[0+1:]
		}()
		return tempVarUnary
	}() {
		size++
	}
	return size
}

// luaL_openlib - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23526
func luaL_openlib(L []lua_State, libname []byte, l []luaL_Reg, nup int32) {
	if libname != nil {
		var size int32 = libsize(l)
		luaL_findtable(L, -10000, []byte("_LOADED\x00"), 1)
		lua_getfield(L, -1, libname)
		if !(lua_type(L, -1) == 5) {
			lua_settop(L, -(1)-1)
			if len(luaL_findtable(L, -10002, libname, size)) != 0 {
				luaL_error(L, []byte("name conflict for module '%s'\x00"), libname)
			}
			lua_pushvalue(L, -1)
			lua_setfield(L, -3, libname)
		}
		lua_remove(L, -2)
		lua_insert(L, -(nup + 1))
	}
	for ; l[0].name != nil; func() []luaL_Reg {
		tempVarUnary := l
		defer func() {
			l = l[0+1:]
		}()
		return tempVarUnary
	}() {
		var i int32
		for i = 0; i < nup; i++ {
			lua_pushvalue(L, -nup)
		}
		lua_pushcclosure(L, lua_CFunction(l[0].func_), nup)
		lua_setfield(L, -(nup + 2), l[0].name)
	}
	lua_settop(L, -(nup)-1)
}

// luaL_gsub - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23624
func luaL_gsub(L []lua_State, s []byte, p []byte, r []byte) []byte {
	var wild []byte
	var l uint = uint(noarch.Strlen(p))
	var b luaL_Buffer
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for len((func() []byte {
		wild = noarch.Strstr(s, p)
		return wild
	}())) != 0 {
		luaL_addlstring(c4goUnsafeConvert_luaL_Buffer(&b), s, uint(int32((int64(uintptr(unsafe.Pointer(&wild[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))))
		luaL_addstring(c4goUnsafeConvert_luaL_Buffer(&b), r)
		s = wild[0+l:]
	}
	luaL_addstring(c4goUnsafeConvert_luaL_Buffer(&b), s)
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return lua_tolstring(L, -1, nil)
}

// luaL_findtable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23641
func luaL_findtable(L []lua_State, idx int32, fname []byte, szhint int32) []byte {
	var e []byte
	lua_pushvalue(L, idx)
	for {
		e = noarch.Strchr(fname, int32('.'))
		if len(e) == 0 {
			e = fname[0+noarch.Strlen(fname):]
		}
		lua_pushlstring(L, fname, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&fname[0])))/int64(1)))))
		lua_rawget(L, -2)
		if lua_type(L, -1) == 0 {
			lua_settop(L, -(1)-1)
			lua_createtable(L, 0, func() int32 {
				if int32(e[0]) == int32('.') {
					return 1
				}
				return szhint
			}())
			lua_pushlstring(L, fname, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&fname[0])))/int64(1)))))
			lua_pushvalue(L, -2)
			lua_settable(L, -4)
		} else if !(lua_type(L, -1) == 5) {
			lua_settop(L, -(2)-1)
			return fname
		}
		lua_remove(L, -2)
		fname = e[0+1:]
		if !(int32(e[0]) == int32('.')) {
			break
		}
	}
	return nil
}

// emptybuffer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23682
func emptybuffer(B []luaL_Buffer) (c4goDefaultReturn int32) {
	var l uint = uint(int32((int64(uintptr(unsafe.Pointer(&(B)[0].p[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(B)[0].buffer[0])))/int64(1))))
	if l == uint(0) {
		return 0
	} else {
		lua_pushlstring(B[0].L, B[0].buffer[:], l)
		B[0].p = B[0].buffer[:]
		B[0].lvl++
		return 1
	}
	return
}

// adjuststack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23694
func adjuststack(B []luaL_Buffer) {
	if B[0].lvl > 1 {
		var L []lua_State = B[0].L
		var toget int32 = 1
		var toplen uint = lua_objlen(L, -1)
		for {
			var l uint = lua_objlen(L, -(toget + 1))
			if B[0].lvl-toget+1 >= 20/2 || toplen > l {
				toplen += l
				toget++
			} else {
				break
			}
			if !(toget < B[0].lvl) {
				break
			}
		}
		lua_concat(L, toget)
		B[0].lvl = B[0].lvl - toget + 1
	}
}

// luaL_prepbuffer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23713
func luaL_prepbuffer(B []luaL_Buffer) []byte {
	if emptybuffer(B) != 0 {
		adjuststack(B)
	}
	return B[0].buffer[:]
}

// luaL_addlstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23720
func luaL_addlstring(B []luaL_Buffer, s []byte, l uint) {
	for bool(func() uint {
		defer func() {
			l--
		}()
		return l
	}()) {
		(func() byte {
			(int64(uintptr(unsafe.Pointer(&(B)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(B)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(B) != nil
			tempVar := &(func() byte {
				(func() []byte {
					tempVar := (B)[0].p
					defer func() {
						(B)[0].p = (B)[0].p[1:]
					}()
					return tempVar
				}())[0] = (func() []byte {
					defer func() {
						func() []byte {
							tempVarUnary := s
							defer func() {
								s = s[0+1:]
							}()
							return tempVarUnary
						}()
					}()
					return s
				}())[0]
				return (func() []byte {
					tempVar := (B)[0].p
					defer func() {
						(B)[0].p = (B)[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			return *tempVar
		}())
	}
}

// luaL_addstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23726
func luaL_addstring(B []luaL_Buffer, s []byte) {
	luaL_addlstring(B, s, uint(noarch.Strlen(s)))
}

// luaL_pushresult - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23731
func luaL_pushresult(B []luaL_Buffer) {
	emptybuffer(B)
	lua_concat(B[0].L, B[0].lvl)
	B[0].lvl = 1
}

// luaL_addvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23738
func luaL_addvalue(B []luaL_Buffer) {
	var L []lua_State = B[0].L
	var vl uint
	var s []byte = lua_tolstring(L, -1, c4goUnsafeConvert_uint(&vl))
	if vl <= uint(8192-int32((int64(uintptr(unsafe.Pointer(&(B)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(B)[0].buffer[0])))/int64(1)))) {
		noarch.Memcpy(B[0].p, s, vl)
		B[0].p = B[0].p[0+vl:]
		lua_settop(L, -(1)-1)
	} else {
		if emptybuffer(B) != 0 {
			lua_insert(L, -2)
		}
		B[0].lvl++
		adjuststack(B)
	}
}

// luaL_buffinit - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23756
func luaL_buffinit(L []lua_State, B []luaL_Buffer) {
	B[0].L = L
	B[0].p = B[0].buffer[:]
	B[0].lvl = 0
}

// luaL_ref - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23765
func luaL_ref(L []lua_State, t int32) int32 {
	var ref int32
	t = func() int32 {
		if t > 0 || t <= -10000 {
			return t
		}
		return lua_gettop(L) + t + 1
	}()
	if lua_type(L, -1) == 0 {
		lua_settop(L, -(1)-1)
		return -1
	}
	lua_rawgeti(L, t, 0)
	ref = int32(noarch.PtrdiffT((lua_tointeger(L, -1))))
	lua_settop(L, -(1)-1)
	if ref != 0 {
		lua_rawgeti(L, t, ref)
		lua_rawseti(L, t, 0)
	} else {
		ref = int32(lua_objlen(L, t))
		ref++
	}
	lua_rawseti(L, t, ref)
	return ref
}

// luaL_unref - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23788
func luaL_unref(L []lua_State, t int32, ref int32) {
	if ref >= 0 {
		t = func() int32 {
			if t > 0 || t <= -10000 {
				return t
			}
			return lua_gettop(L) + t + 1
		}()
		lua_rawgeti(L, t, 0)
		lua_rawseti(L, t, ref)
		lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(ref))))
		lua_rawseti(L, t, 0)
	}
}

// getF - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23813
func getF(L []lua_State, ud interface{}, size []uint) []byte {
	var lf []LoadF = ud.([]LoadF)
	_ = L
	if lf[0].extraline != 0 {
		lf[0].extraline = 0
		size[0] = 1
		return []byte("\n\x00")
	}
	if noarch.Feof(lf[0].f) != 0 {
		return nil
	}
	size[0] = uint(noarch.Fread(&lf[0].buff[:], 1, int32(8192), lf[0].f))
	return func() []byte {
		if size[0] > uint(0) {
			return lf[0].buff[:]
		}
		return nil
	}()
}

// errfile - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23827
func errfile(L []lua_State, what []byte, fnameindex int32) int32 {
	var serr []byte = noarch.Strerror((noarch.ErrnoLocation())[0])
	var filename []byte = (lua_tolstring(L, fnameindex, nil))[0+1:]
	lua_pushfstring(L, []byte("cannot %s %s: %s\x00"), what, filename, serr)
	lua_remove(L, fnameindex)
	return 5 + 1
}

// luaL_loadfile - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23836
func luaL_loadfile(L []lua_State, filename []byte) int32 {
	var lf LoadF
	var status int32
	var readstatus int32
	var c int32
	var fnameindex int32 = lua_gettop(L) + 1
	lf.extraline = 0
	if len(filename) == 0 {
		lua_pushlstring(L, []byte("=stdin\x00"), uint(7/1-1))
		lf.f = noarch.Stdin
	} else {
		lua_pushfstring(L, []byte("@%s\x00"), filename)
		lf.f = noarch.Fopen(filename, []byte("r\x00"))
		if lf.f == nil {
			return errfile(L, []byte("open\x00"), fnameindex)
		}
	}
	c = noarch.Fgetc(lf.f)
	if c == int32('#') {
		lf.extraline = 1
		for (func() int32 {
			c = noarch.Fgetc(lf.f)
			return c
		}()) != -1 && c != int32('\n') {
		}
		if c == int32('\n') {
			c = noarch.Fgetc(lf.f)
		}
	}
	if c == int32([]byte("\x1bLua\x00")[0]) && filename != nil {
		lf.f = freopen(filename, []byte("rb\x00"), lf.f)
		if lf.f == nil {
			return errfile(L, []byte("reopen\x00"), fnameindex)
		}
		for (func() int32 {
			c = noarch.Fgetc(lf.f)
			return c
		}()) != -1 && c != int32([]byte("\x1bLua\x00")[0]) {
		}
		lf.extraline = 0
	}
	ungetc(c, lf.f)
	status = lua_load(L, getF, c4goUnsafeConvert_LoadF(&lf), lua_tolstring(L, -1, nil))
	readstatus = ferror(lf.f)
	if filename != nil {
		noarch.Fclose(lf.f)
	}
	if readstatus != 0 {
		lua_settop(L, fnameindex)
		return errfile(L, []byte("read\x00"), fnameindex)
	}
	lua_remove(L, fnameindex)
	return status
}

// getS - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23883
func getS(L []lua_State, ud interface{}, size []uint) []byte {
	var ls []LoadS = ud.([]LoadS)
	_ = L
	if uint(ls[0].size) == uint(0) {
		return nil
	}
	size[0] = uint(ls[0].size)
	ls[0].size = 0
	return ls[0].s
}

// luaL_loadbuffer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23893
func luaL_loadbuffer(L []lua_State, buff []byte, size uint, name []byte) int32 {
	var ls LoadS
	ls.s = buff
	ls.size = size
	return lua_load(L, getS, c4goUnsafeConvert_LoadS(&ls), name)
}

// luaL_loadstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23902
func luaL_loadstring(L []lua_State, s []byte) int32 {
	return luaL_loadbuffer(L, s, uint(noarch.Strlen(s)), s)
}

// l_alloc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23911
func l_alloc(ud interface{}, ptr interface{}, osize uint, nsize uint) (c4goDefaultReturn interface{}) {
	_ = ud
	_ = osize
	if nsize == uint(0) {
		_ = ptr
		return nil
	} else {
		return make([]byte, nsize)
	}
	return
}

// panic_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23923
func panic_(L []lua_State) int32 {
	_ = L
	noarch.Fprintf(noarch.Stderr, []byte("PANIC: unprotected error in call to Lua API (%s)\n\x00"), lua_tolstring(L, -1, nil))
	return 0
}

// luaL_newstate - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23931
func luaL_newstate() []lua_State {
	var L []lua_State = lua_newstate(l_alloc, nil)
	if L != nil {
		lua_atpanic(L, panic_)
	}
	return L
}

// luaB_print - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23971
func luaB_print(L []lua_State) int32 {
	var n int32 = lua_gettop(L)
	var i int32
	lua_getfield(L, -10002, ([]byte("tostring\x00")))
	for i = 1; i <= n; i++ {
		var s []byte
		lua_pushvalue(L, -1)
		lua_pushvalue(L, i)
		lua_call(L, 1, 1)
		s = lua_tolstring(L, -1, nil)
		if len(s) == 0 {
			return luaL_error(L, []byte("'tostring' must return a string to 'print'\x00"))
		}
		if i > 1 {
			noarch.Fputs([]byte("\t\x00"), noarch.Stdout)
		}
		noarch.Fputs(s, noarch.Stdout)
		lua_settop(L, -(1)-1)
	}
	noarch.Fputs([]byte("\n\x00"), noarch.Stdout)
	return 0
}

// luaB_tonumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:23993
func luaB_tonumber(L []lua_State) int32 {
	var base int32 = int32(noarch.PtrdiffT((luaL_optinteger(L, 2, lua_Integer((noarch.PtrdiffT(10)))))))
	if base == 10 {
		luaL_checkany(L, 1)
		if lua_isnumber(L, 1) != 0 {
			lua_pushnumber(L, lua_tonumber(L, 1))
			return 1
		}
	} else {
		var s1 []byte = luaL_checklstring(L, 1, nil)
		var s2 []byte
		var n uint32
		_ = 2 <= base && base <= 36 || luaL_argerror(L, 2, ([]byte("base out of range\x00"))) != 0
		n = noarch.Strtoul(s1, (*[1000000][]byte)(unsafe.Pointer(&s2))[:], base)
		if (int64(uintptr(unsafe.Pointer(&s1[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s2[0])))/int64(1)) != 0 {
			for int32(((linux.CtypeLoc())[0])[int32(uint8(s2[0]))])&int32(uint16(noarch.ISspace)) != 0 {
				func() []byte {
					tempVarUnary := s2
					defer func() {
						s2 = s2[0+1:]
					}()
					return tempVarUnary
				}()
			}
			if int32(s2[0]) == int32('\x00') {
				lua_pushnumber(L, lua_Number(n))
				return 1
			}
		}
	}
	lua_pushnil(L)
	return 1
}

// luaB_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24021
func luaB_error(L []lua_State) int32 {
	var level int32 = int32(noarch.PtrdiffT((luaL_optinteger(L, 2, lua_Integer((noarch.PtrdiffT(1)))))))
	lua_settop(L, 1)
	if lua_isstring(L, 1) != 0 && level > 0 {
		luaL_where(L, level)
		lua_pushvalue(L, 1)
		lua_concat(L, 2)
	}
	return lua_error(L)
}

// luaB_getmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24033
func luaB_getmetatable(L []lua_State) int32 {
	luaL_checkany(L, 1)
	if noarch.Not(lua_getmetatable(L, 1)) {
		lua_pushnil(L)
		return 1
	}
	luaL_getmetafield(L, 1, []byte("__metatable\x00"))
	return 1
}

// luaB_setmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24044
func luaB_setmetatable(L []lua_State) int32 {
	var t int32 = lua_type(L, 2)
	luaL_checktype(L, 1, 5)
	_ = t == 0 || t == 5 || luaL_argerror(L, 2, ([]byte("nil or table expected\x00"))) != 0
	if luaL_getmetafield(L, 1, []byte("__metatable\x00")) != 0 {
		luaL_error(L, []byte("cannot change a protected metatable\x00"))
	}
	lua_settop(L, 2)
	lua_setmetatable(L, 1)
	return 1
}

// getfunc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24057
func getfunc(L []lua_State, opt int32) {
	if lua_type(L, 1) == 6 {
		lua_pushvalue(L, 1)
	} else {
		var ar lua_Debug
		var level int32 = func() int32 {
			if opt != 0 {
				return int32(noarch.PtrdiffT((luaL_optinteger(L, 1, lua_Integer((noarch.PtrdiffT(1)))))))
			}
			return int32(noarch.PtrdiffT((luaL_checkinteger(L, 1))))
		}()
		_ = level >= 0 || luaL_argerror(L, 1, ([]byte("level must be non-negative\x00"))) != 0
		if lua_getstack(L, level, c4goUnsafeConvert_lua_Debug(&ar)) == 0 {
			luaL_argerror(L, 1, []byte("invalid level\x00"))
		}
		lua_getinfo(L, []byte("f\x00"), c4goUnsafeConvert_lua_Debug(&ar))
		if lua_type(L, -1) == 0 {
			luaL_error(L, []byte("no function environment for tail call at level %d\x00"), level)
		}
	}
}

// luaB_getfenv - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24073
func luaB_getfenv(L []lua_State) int32 {
	getfunc(L, 1)
	if lua_iscfunction(L, -1) != 0 {
		lua_pushvalue(L, -10002)
	} else {
		lua_getfenv(L, -1)
	}
	return 1
}

// luaB_setfenv - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24083
func luaB_setfenv(L []lua_State) int32 {
	luaL_checktype(L, 2, 5)
	getfunc(L, 0)
	lua_pushvalue(L, 2)
	if lua_isnumber(L, 1) != 0 && lua_tonumber(L, 1) == lua_Number((0)) {
		lua_pushthread(L)
		lua_insert(L, -2)
		lua_setfenv(L, -2)
		return 0
	} else if lua_iscfunction(L, -2) != 0 || lua_setfenv(L, -2) == 0 {
		luaL_error(L, []byte("'setfenv' cannot change environment of given object\x00"))
	}
	return 1
}

// luaB_rawequal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24101
func luaB_rawequal(L []lua_State) int32 {
	luaL_checkany(L, 1)
	luaL_checkany(L, 2)
	lua_pushboolean(L, lua_rawequal(L, 1, 2))
	return 1
}

// luaB_rawget - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24109
func luaB_rawget(L []lua_State) int32 {
	luaL_checktype(L, 1, 5)
	luaL_checkany(L, 2)
	lua_settop(L, 2)
	lua_rawget(L, 1)
	return 1
}

// luaB_rawset - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24117
func luaB_rawset(L []lua_State) int32 {
	luaL_checktype(L, 1, 5)
	luaL_checkany(L, 2)
	luaL_checkany(L, 3)
	lua_settop(L, 3)
	lua_rawset(L, 1)
	return 1
}

// luaB_gcinfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24127
func luaB_gcinfo(L []lua_State) int32 {
	lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(lua_gc(L, 3, 0)))))
	return 1
}

// luaB_collectgarbage - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24133
func luaB_collectgarbage(L []lua_State) (c4goDefaultReturn int32) {
	var opts [][]byte = [][]byte{[]byte("stop\x00"), []byte("restart\x00"), []byte("collect\x00"), []byte("count\x00"), []byte("step\x00"), []byte("setpause\x00"), []byte("setstepmul\x00"), nil}
	var optsnum []int32 = []int32{0, 1, 2, 3, 5, 6, 7}
	var o int32 = luaL_checkoption(L, 1, []byte("collect\x00"), opts)
	var ex int32 = int32(noarch.PtrdiffT((luaL_optinteger(L, 2, lua_Integer((noarch.PtrdiffT(0)))))))
	var res int32 = lua_gc(L, optsnum[o], ex)
	switch optsnum[o] {
	case 3:
		var b int32 = lua_gc(L, 4, 0)
		lua_pushnumber(L, lua_Number((float64(res) + float64((lua_Number(b) / lua_Number((1024)))))))
		return 1
	case 5:
		lua_pushboolean(L, res)
		return 1
	default:
		lua_pushnumber(L, lua_Number((float64(res))))
		return 1
	}
	return
}

// luaB_type - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24159
func luaB_type(L []lua_State) int32 {
	luaL_checkany(L, 1)
	lua_pushstring(L, lua_typename(L, lua_type(L, 1)))
	return 1
}

// luaB_next - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24166
func luaB_next(L []lua_State) (c4goDefaultReturn int32) {
	luaL_checktype(L, 1, 5)
	lua_settop(L, 2)
	if lua_next(L, 1) != 0 {
		return 2
	} else {
		lua_pushnil(L)
		return 1
	}
	return
}

// luaB_pairs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24178
func luaB_pairs(L []lua_State) int32 {
	luaL_checktype(L, 1, 5)
	lua_pushvalue(L, -10002-1)
	lua_pushvalue(L, 1)
	lua_pushnil(L)
	return 3
}

// ipairsaux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24187
func ipairsaux(L []lua_State) int32 {
	var i int32 = int32(noarch.PtrdiffT((luaL_checkinteger(L, 2))))
	luaL_checktype(L, 1, 5)
	i++
	lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(i))))
	lua_rawgeti(L, 1, i)
	return func() int32 {
		if lua_type(L, -1) == 0 {
			return 0
		}
		return 2
	}()
}

// luaB_ipairs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24197
func luaB_ipairs(L []lua_State) int32 {
	luaL_checktype(L, 1, 5)
	lua_pushvalue(L, -10002-1)
	lua_pushvalue(L, 1)
	lua_pushinteger(L, 0)
	return 3
}

// load_aux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24206
func load_aux(L []lua_State, status int32) (c4goDefaultReturn int32) {
	if status == 0 {
		return 1
	} else {
		lua_pushnil(L)
		lua_insert(L, -2)
		return 2
	}
	return
}

// luaB_loadstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24217
func luaB_loadstring(L []lua_State) int32 {
	var l uint
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	var chunkname []byte = luaL_optlstring(L, 2, s, nil)
	return load_aux(L, luaL_loadbuffer(L, s, l, chunkname))
}

// luaB_loadfile - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24225
func luaB_loadfile(L []lua_State) int32 {
	var fname []byte = luaL_optlstring(L, 1, nil, nil)
	return load_aux(L, luaL_loadfile(L, fname))
}

// generic_reader - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24237
func generic_reader(L []lua_State, ud interface{}, size []uint) []byte {
	_ = ud
	luaL_checkstack(L, 2, []byte("too many nested functions\x00"))
	lua_pushvalue(L, 1)
	lua_call(L, 0, 1)
	if lua_type(L, -1) == 0 {
		size[0] = 0
		return nil
	} else if lua_isstring(L, -1) != 0 {
		lua_replace(L, 3)
		return lua_tolstring(L, 3, size)
	} else {
		luaL_error(L, []byte("reader function must return a string\x00"))
	}
	return nil
}

// luaB_load - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24255
func luaB_load(L []lua_State) int32 {
	var status int32
	var cname []byte = luaL_optlstring(L, 2, ([]byte("=(load)\x00")), nil)
	luaL_checktype(L, 1, 6)
	lua_settop(L, 3)
	status = lua_load(L, generic_reader, nil, cname)
	return load_aux(L, status)
}

// luaB_dofile - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24265
func luaB_dofile(L []lua_State) int32 {
	var fname []byte = luaL_optlstring(L, 1, nil, nil)
	var n int32 = lua_gettop(L)
	if luaL_loadfile(L, fname) != 0 {
		lua_error(L)
	}
	lua_call(L, 0, -1)
	return lua_gettop(L) - n
}

// luaB_assert - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24274
func luaB_assert(L []lua_State) int32 {
	luaL_checkany(L, 1)
	if noarch.Not(lua_toboolean(L, 1)) {
		return luaL_error(L, []byte("%s\x00"), luaL_optlstring(L, 2, ([]byte("assertion failed!\x00")), nil))
	}
	return lua_gettop(L)
}

// luaB_unpack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24282
func luaB_unpack(L []lua_State) int32 {
	var i int32
	var e int32
	var n int32
	luaL_checktype(L, 1, 5)
	i = int32(noarch.PtrdiffT((luaL_optinteger(L, 2, lua_Integer((noarch.PtrdiffT(1)))))))
	e = func() int32 {
		if lua_type(L, 3) <= 0 {
			return int32(lua_objlen(L, 1))
		}
		return int32(noarch.PtrdiffT((luaL_checkinteger(L, 3))))
	}()
	if i > e {
		return 0
	}
	n = e - i + 1
	if n <= 0 || noarch.Not(lua_checkstack(L, n)) {
		return luaL_error(L, []byte("too many results to unpack\x00"))
	}
	lua_rawgeti(L, 1, i)
	for func() int32 {
		defer func() {
			i++
		}()
		return i
	}() < e {
		lua_rawgeti(L, 1, i)
	}
	return n
}

// luaB_select - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24298
func luaB_select(L []lua_State) (c4goDefaultReturn int32) {
	var n int32 = lua_gettop(L)
	if lua_type(L, 1) == 4 && int32((lua_tolstring(L, 1, nil))[0]) == int32('#') {
		lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(n - 1))))
		return 1
	} else {
		var i int32 = int32(noarch.PtrdiffT((luaL_checkinteger(L, 1))))
		if i < 0 {
			i = n + i
		} else if i > n {
			i = n
		}
		_ = 1 <= i || luaL_argerror(L, 1, ([]byte("index out of range\x00"))) != 0
		return n - i
	}
	return
}

// luaB_pcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24314
func luaB_pcall(L []lua_State) int32 {
	var status int32
	luaL_checkany(L, 1)
	status = lua_pcall(L, lua_gettop(L)-1, -1, 0)
	lua_pushboolean(L, noarch.BoolToInt(status == 0))
	lua_insert(L, 1)
	return lua_gettop(L)
}

// luaB_xpcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24324
func luaB_xpcall(L []lua_State) int32 {
	var status int32
	luaL_checkany(L, 2)
	lua_settop(L, 2)
	lua_insert(L, 1)
	status = lua_pcall(L, 0, -1, 1)
	lua_pushboolean(L, noarch.BoolToInt(status == 0))
	lua_replace(L, 1)
	return lua_gettop(L)
}

// luaB_tostring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24336
func luaB_tostring(L []lua_State) int32 {
	luaL_checkany(L, 1)
	if luaL_callmeta(L, 1, []byte("__tostring\x00")) != 0 {
		return 1
	}
	switch lua_type(L, 1) {
	case 3:
		lua_pushstring(L, lua_tolstring(L, 1, nil))
	case 4:
		lua_pushvalue(L, 1)
	case 1:
		lua_pushstring(L, (func() []byte {
			if lua_toboolean(L, 1) != 0 {
				return []byte("true\x00")
			}
			return []byte("false\x00")
		}()))
	case 0:
		lua_pushlstring(L, []byte("nil\x00"), uint(4/1-1))
	default:
		lua_pushfstring(L, []byte("%s: %p\x00"), lua_typename(L, lua_type(L, 1)), lua_topointer(L, 1))
		break
	}
	return 1
}

// luaB_newproxy - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24361
func luaB_newproxy(L []lua_State) int32 {
	lua_settop(L, 1)
	lua_newuserdata(L, 0)
	if lua_toboolean(L, 1) == 0 {
		return 1
	} else if lua_type(L, 1) == 1 {
		lua_createtable(L, 0, 0)
		lua_pushvalue(L, -1)
		lua_pushboolean(L, 1)
		lua_rawset(L, -10002-1)
	} else {
		var validproxy int32
		if lua_getmetatable(L, 1) != 0 {
			lua_rawget(L, -10002-1)
			validproxy = lua_toboolean(L, -1)
			lua_settop(L, -(1)-1)
		}
		_ = validproxy != 0 || luaL_argerror(L, 1, ([]byte("boolean or proxy expected\x00"))) != 0
		lua_getmetatable(L, 1)
	}
	lua_setmetatable(L, 2)
	return 1
}

// costatus - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24430
func costatus(L []lua_State, co []lua_State) (c4goDefaultReturn int32) {
	if (int64(uintptr(unsafe.Pointer(&L[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&co[0])))/int64(176)) == 0 {
		return 0
	}
	switch lua_status(co) {
	case 1:
		return 1
	case 0:
		var ar lua_Debug
		if lua_getstack(co, 0, c4goUnsafeConvert_lua_Debug(&ar)) > 0 {
			return 2
		} else if lua_gettop(co) == 0 {
			return 3
		} else {
			return 1
		}
		fallthrough
	default:
		return 3
	}
	return
}

// luaB_costatus - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24450
func luaB_costatus(L []lua_State) int32 {
	var co []lua_State = lua_tothread(L, 1)
	_ = co != nil || luaL_argerror(L, 1, ([]byte("coroutine expected\x00"))) != 0
	lua_pushstring(L, statnames[costatus(L, co)])
	return 1
}

// auxresume - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24458
func auxresume(L []lua_State, co []lua_State, narg int32) (c4goDefaultReturn int32) {
	var status int32 = costatus(L, co)
	if noarch.Not(lua_checkstack(co, narg)) {
		luaL_error(L, []byte("too many arguments to resume\x00"))
	}
	if status != 1 {
		lua_pushfstring(L, []byte("cannot resume %s coroutine\x00"), statnames[status])
		return -1
	}
	lua_xmove(L, co, narg)
	lua_setlevel(L, co)
	status = lua_resume(co, narg)
	if status == 0 || status == 1 {
		var nres int32 = lua_gettop(co)
		if noarch.Not(lua_checkstack(L, nres+1)) {
			luaL_error(L, []byte("too many results to resume\x00"))
		}
		lua_xmove(co, L, nres)
		return nres
	} else {
		lua_xmove(co, L, 1)
		return -1
	}
	return
}

// luaB_coresume - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24483
func luaB_coresume(L []lua_State) (c4goDefaultReturn int32) {
	var co []lua_State = lua_tothread(L, 1)
	var r int32
	_ = co != nil || luaL_argerror(L, 1, ([]byte("coroutine expected\x00"))) != 0
	r = auxresume(L, co, lua_gettop(L)-1)
	if r < 0 {
		lua_pushboolean(L, 0)
		lua_insert(L, -2)
		return 2
	} else {
		lua_pushboolean(L, 1)
		lua_insert(L, -(r + 1))
		return r + 1
	}
	return
}

// luaB_auxwrap - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24501
func luaB_auxwrap(L []lua_State) int32 {
	var co []lua_State = lua_tothread(L, -10002-1)
	var r int32 = auxresume(L, co, lua_gettop(L))
	if r < 0 {
		if lua_isstring(L, -1) != 0 {
			luaL_where(L, 1)
			lua_insert(L, -2)
			lua_concat(L, 2)
		}
		lua_error(L)
	}
	return r
}

// luaB_cocreate - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24516
func luaB_cocreate(L []lua_State) int32 {
	var NL []lua_State = lua_newthread(L)
	_ = lua_type(L, 1) == 6 && noarch.Not(lua_iscfunction(L, 1)) || luaL_argerror(L, 1, ([]byte("Lua function expected\x00"))) != 0
	lua_pushvalue(L, 1)
	lua_xmove(L, NL, 1)
	return 1
}

// luaB_cowrap - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24526
func luaB_cowrap(L []lua_State) int32 {
	luaB_cocreate(L)
	lua_pushcclosure(L, luaB_auxwrap, 1)
	return 1
}

// luaB_yield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24533
func luaB_yield(L []lua_State) int32 {
	return lua_yield(L, lua_gettop(L))
}

// luaB_corunning - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24538
func luaB_corunning(L []lua_State) int32 {
	if lua_pushthread(L) != 0 {
		lua_pushnil(L)
	}
	return 1
}

// auxopen - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24558
func auxopen(L []lua_State, name []byte, f lua_CFunction, u lua_CFunction) {
	lua_pushcclosure(L, u, 0)
	lua_pushcclosure(L, f, 1)
	lua_setfield(L, -2, name)
}

// base_open - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24566
func base_open(L []lua_State) {
	lua_pushvalue(L, -10002)
	lua_setfield(L, -10002, ([]byte("_G\x00")))
	luaL_register(L, []byte("_G\x00"), base_funcs)
	lua_pushlstring(L, []byte("Lua 5.1\x00"), uint(8/1-1))
	lua_setfield(L, -10002, ([]byte("_VERSION\x00")))
	auxopen(L, []byte("ipairs\x00"), luaB_ipairs, ipairsaux)
	auxopen(L, []byte("pairs\x00"), luaB_pairs, luaB_next)
	lua_createtable(L, 0, 1)
	lua_pushvalue(L, -1)
	lua_setmetatable(L, -2)
	lua_pushlstring(L, []byte("kv\x00"), uint(3/1-1))
	lua_setfield(L, -2, []byte("__mode\x00"))
	lua_pushcclosure(L, luaB_newproxy, 1)
	lua_setfield(L, -10002, ([]byte("newproxy\x00")))
}

// luaopen_base - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:24588
func luaopen_base(L []lua_State) int32 {
	base_open(L)
	luaL_register(L, []byte("coroutine\x00"), co_funcs)
	return 2
}

// isnumeral - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25137
func isnumeral(e []expdesc) int32 {
	return noarch.BoolToInt(uint32(e[0].k) == uint32(int32((VKNUM))) && e[0].t == -1 && e[0].f == -1)
}

// luaK_nil - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25142
func luaK_nil(fs []FuncState, from int32, n int32) {
	var previous []Instruction
	if fs[0].pc > fs[0].lasttarget {
		if fs[0].pc == 0 {
			if from >= int32(uint8((lu_byte(fs[0].nactvar)))) {
				return
			}
		} else {
			previous = fs[0].f[0].code[fs[0].pc-1:]
			if uint32(int32(uint32((lu_int32((previous[0] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_LOADNIL))) {
				var pfrom int32 = int32(uint32((lu_int32((previous[0] >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))
				var pto int32 = int32(uint32((lu_int32((previous[0] >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
				if pfrom <= from && from <= pto+1 {
					if from+n-1 > pto {
						(func() Instruction {
							previous[0] = previous[0] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9)) | Instruction(from+n-1)<<uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9))
							return previous[0]
						}())
					}
					return
				}
			}
		}
	}
	luaK_codeABC(fs, int32((OP_LOADNIL)), from, from+n-1, 0)
}

// luaK_jump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25166
func luaK_jump(fs []FuncState) int32 {
	var jpc int32 = fs[0].jpc
	var j int32
	fs[0].jpc = -1
	j = luaK_codeABx(fs, int32((OP_JMP)), 0, uint32(-1+(1<<uint64(9+9)-1)>>uint64(1)))
	luaK_concat(fs, c4goUnsafeConvert_int32(&j), jpc)
	return j
}

// luaK_ret - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25176
func luaK_ret(fs []FuncState, first int32, nret int32) {
	luaK_codeABC(fs, int32((OP_RETURN)), first, nret+1, 0)
}

// condjump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25181
func condjump(fs []FuncState, op int32, A int32, B int32, C int32) int32 {
	luaK_codeABC(fs, op, A, B, C)
	return luaK_jump(fs)
}

// fixjump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25187
func fixjump(fs []FuncState, pc int32, dest int32) {
	var jmp []Instruction = fs[0].f[0].code[pc:]
	var offset int32 = dest - (pc + 1)
	_ = 0
	if noarch.Abs(offset) > (1<<uint64(9+9)-1)>>uint64(1) {
		luaX_syntaxerror(fs[0].ls, []byte("control structure too long\x00"))
	}
	jmp[0] = jmp[0] & ^(^(^Instruction(0)<<uint64(9+9))<<uint64(0+6+8)) | Instruction(uint32(offset+(1<<uint64(9+9)-1)>>uint64(1)))<<uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0+6+8))
}

// luaK_getlabel - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25201
func luaK_getlabel(fs []FuncState) int32 {
	fs[0].lasttarget = fs[0].pc
	return fs[0].pc
}

// getjump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25207
func getjump(fs []FuncState, pc int32) (c4goDefaultReturn int32) {
	var offset int32 = int32(uint32((lu_int32((fs[0].f[0].code[pc] >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0))))))) - (1<<uint64(9+9)-1)>>uint64(1)
	if offset == -1 {
		return -1
	} else {
		return pc + 1 + offset
	}
	return
}

// getjumpcontrol - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25216
func getjumpcontrol(fs []FuncState, pc int32) (c4goDefaultReturn []Instruction) {
	var pi []Instruction = fs[0].f[0].code[pc:]
	if pc >= 1 && int32(uint8((luaP_opmodes[int32(uint32((lu_int32((pi[0-1]>>uint64(0)&(^(^Instruction(0)<<uint64(6))<<uint64(0)))))))])))&(1<<uint64(7)) != 0 {
		return (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pi[0])) - (uintptr)(1)*unsafe.Sizeof(pi[0]))))[:]
	} else {
		return pi
	}
	return
}

// need_value - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25229
func need_value(fs []FuncState, list int32) int32 {
	for ; list != -1; list = getjump(fs, list) {
		var i Instruction = (getjumpcontrol(fs, list))[0]
		if uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) != uint32(int32((OP_TESTSET))) {
			return 1
		}
	}
	return 0
}

// patchtestreg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25238
func patchtestreg(fs []FuncState, node int32, reg int32) int32 {
	var i []Instruction = getjumpcontrol(fs, node)
	if uint32(int32(uint32((lu_int32((i[0] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) != uint32(int32((OP_TESTSET))) {
		return 0
	}
	if reg != 1<<uint64(8)-1 && reg != int32(uint32((lu_int32((i[0] >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) {
		(func() Instruction {
			i[0] = i[0] & ^(^(^Instruction(0)<<uint64(8))<<uint64(0+6)) | Instruction(reg)<<uint64(0+6)&(^(^Instruction(0)<<uint64(8))<<uint64(0+6))
			return i[0]
		}())
	} else {
		i[0] = Instruction(OP_TEST)<<uint64(0) | Instruction(int32(uint32((lu_int32((i[0] >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))))<<uint64(0+6) | Instruction(0)<<uint64(0+6+8+9) | Instruction(int32(uint32((lu_int32((i[0] >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))))<<uint64(0+6+8)
	}
	return 1
}

// removevalues - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25251
func removevalues(fs []FuncState, list int32) {
	for ; list != -1; list = getjump(fs, list) {
		patchtestreg(fs, list, 1<<uint64(8)-1)
	}
}

// patchlistaux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25257
func patchlistaux(fs []FuncState, list int32, vtarget int32, reg int32, dtarget int32) {
	for list != -1 {
		var next int32 = getjump(fs, list)
		if patchtestreg(fs, list, reg) != 0 {
			fixjump(fs, list, vtarget)
		} else {
			fixjump(fs, list, dtarget)
		}
		list = next
	}
}

// dischargejpc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25270
func dischargejpc(fs []FuncState) {
	patchlistaux(fs, fs[0].jpc, fs[0].pc, 1<<uint64(8)-1, fs[0].pc)
	fs[0].jpc = -1
}

// luaK_patchlist - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25276
func luaK_patchlist(fs []FuncState, list int32, target int32) {
	if target == fs[0].pc {
		luaK_patchtohere(fs, list)
	} else {
		_ = 0
		patchlistaux(fs, list, target, 1<<uint64(8)-1, target)
	}
}

// luaK_patchtohere - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25286
func luaK_patchtohere(fs []FuncState, list int32) {
	luaK_getlabel(fs)
	luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&fs[0].jpc))[:], list)
}

// luaK_concat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25292
func luaK_concat(fs []FuncState, l1 []int32, l2 int32) {
	if l2 == -1 {
		return
	} else if l1[0] == -1 {
		l1[0] = l2
	} else {
		var list int32 = l1[0]
		var next int32
		for (func() int32 {
			next = getjump(fs, list)
			return next
		}()) != -1 {
			list = next
		}
		fixjump(fs, list, l2)
	}
}

// luaK_checkstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25306
func luaK_checkstack(fs []FuncState, n int32) {
	var newstack int32 = fs[0].freereg + n
	if newstack > int32(uint8((lu_byte(fs[0].f[0].maxstacksize)))) {
		if newstack >= 250 {
			luaX_syntaxerror(fs[0].ls, []byte("function or expression too complex\x00"))
		}
		fs[0].f[0].maxstacksize = lu_byte(newstack)
	}
}

// luaK_reserveregs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25316
func luaK_reserveregs(fs []FuncState, n int32) {
	luaK_checkstack(fs, n)
	fs[0].freereg += n
}

// freereg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25322
func freereg(fs []FuncState, reg int32) {
	if noarch.Not(reg&(1<<uint64(9-1))) && reg >= int32(uint8((lu_byte(fs[0].nactvar)))) {
		fs[0].freereg--
		_ = 0
	}
}

// freeexp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25330
func freeexp(fs []FuncState, e []expdesc) {
	if uint32(e[0].k) == uint32(int32((VNONRELOC))) {
		freereg(fs, (*e[0].u.s()).info)
	}
}

// addk - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25336
func addk(fs []FuncState, k []TValue, v []TValue) (c4goDefaultReturn int32) {
	var L []lua_State = fs[0].L
	var idx []TValue = luaH_set(L, fs[0].h, k)
	var f []Proto = fs[0].f
	var oldsize int32 = f[0].sizek
	if (idx)[0].tt == 3 {
		_ = 0
		return int32(float64((func() lua_Number {
			(0)
			tempVar := &(*(idx)[0].value.n())
			return *tempVar
		}())))
	} else {
		{
			var i_o []TValue = idx
			(*i_o[0].value.n()) = lua_Number(fs[0].nk)
			i_o[0].tt = 3
		}
		if fs[0].nk+1 > f[0].sizek {
			(func() []TValue {
				f[0].k = luaM_growaux_(L, f[0].k, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizek)))[:], uint(16), 1<<uint64(9+9)-1, []byte("constant table overflow\x00")).([]TValue)
				return f[0].k
			}())
		}
		for oldsize < f[0].sizek {
			(func() int32 {
				(f[0].k[func() int32 {
					defer func() {
						oldsize++
					}()
					return oldsize
				}():])[0].tt = 0
				return (f[0].k[func() int32 {
					defer func() {
						oldsize++
					}()
					return oldsize
				}():])[0].tt
			}())
		}
		{
			var o2 []TValue = (v)
			var o1 []TValue = f[0].k[fs[0].nk:]
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			if (v)[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(v)[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
				luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:], func() []GCObject {
					(0)
					tempVar := &(*(v)[0].value.gc())
					return *tempVar
				}())
			}
		}
		return func() int32 {
			tempVar := &fs[0].nk
			defer func() {
				*tempVar++
			}()
			return *tempVar
		}()
	}
	return
}

// luaK_stringK - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25357
func luaK_stringK(fs []FuncState, s []TString) int32 {
	var o TValue
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&o))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&s[0]))) / int64(1))))[:]
		i_o[0].tt = 4
		_ = 0
	}
	return addk(fs, (*[1000000]TValue)(unsafe.Pointer(&o))[:], (*[1000000]TValue)(unsafe.Pointer(&o))[:])
}

// luaK_numberK - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25364
func luaK_numberK(fs []FuncState, r lua_Number) int32 {
	var o TValue
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&o))[:]
		(*i_o[0].value.n()) = r
		i_o[0].tt = 3
	}
	return addk(fs, (*[1000000]TValue)(unsafe.Pointer(&o))[:], (*[1000000]TValue)(unsafe.Pointer(&o))[:])
}

// boolK - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25371
func boolK(fs []FuncState, b int32) int32 {
	var o TValue
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&o))[:]
		(*i_o[0].value.b()) = b
		i_o[0].tt = 1
	}
	return addk(fs, (*[1000000]TValue)(unsafe.Pointer(&o))[:], (*[1000000]TValue)(unsafe.Pointer(&o))[:])
}

// nilK - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25378
func nilK(fs []FuncState) int32 {
	var k TValue
	var v TValue
	((*[1000000]TValue)(unsafe.Pointer(&v))[:])[0].tt = 0
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&k))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&fs[0].h[0]))) / int64(1))))[:]
		i_o[0].tt = 5
		_ = 0
	}
	return addk(fs, (*[1000000]TValue)(unsafe.Pointer(&k))[:], (*[1000000]TValue)(unsafe.Pointer(&v))[:])
}

// luaK_setreturns - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25387
func luaK_setreturns(fs []FuncState, e []expdesc, nresults int32) {
	if uint32(e[0].k) == uint32(int32((VCALL))) {
		(fs)[0].f[0].code[(*(e)[0].u.s()).info] = (fs)[0].f[0].code[(*(e)[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8)) | Instruction(nresults+1)<<uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8))
	} else if uint32(e[0].k) == uint32(int32((VVARARG))) {
		(fs)[0].f[0].code[(*(e)[0].u.s()).info] = (fs)[0].f[0].code[(*(e)[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9)) | Instruction(nresults+1)<<uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9))
		(fs)[0].f[0].code[(*(e)[0].u.s()).info] = (fs)[0].f[0].code[(*(e)[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(8))<<uint64(0+6)) | Instruction(fs[0].freereg)<<uint64(0+6)&(^(^Instruction(0)<<uint64(8))<<uint64(0+6))
		luaK_reserveregs(fs, 1)
	}
}

// luaK_setoneret - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25399
func luaK_setoneret(fs []FuncState, e []expdesc) {
	if uint32(e[0].k) == uint32(int32((VCALL))) {
		e[0].k = int32((VNONRELOC))
		(*e[0].u.s()).info = int32(uint32((lu_int32(((fs)[0].f[0].code[(*(e)[0].u.s()).info] >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))
	} else if uint32(e[0].k) == uint32(int32((VVARARG))) {
		(fs)[0].f[0].code[(*(e)[0].u.s()).info] = (fs)[0].f[0].code[(*(e)[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9)) | Instruction(2)<<uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9))
		e[0].k = int32((VRELOCABLE))
	}
}

// luaK_dischargevars - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25411
func luaK_dischargevars(fs []FuncState, e []expdesc) {
	switch uint32(e[0].k) {
	case uint32(int32((VLOCAL))):
		e[0].k = int32((VNONRELOC))
	case uint32(int32((VUPVAL))):
		(*e[0].u.s()).info = luaK_codeABC(fs, int32((OP_GETUPVAL)), 0, (*e[0].u.s()).info, 0)
		e[0].k = int32((VRELOCABLE))
	case uint32(int32((VGLOBAL))):
		(*e[0].u.s()).info = luaK_codeABx(fs, int32((OP_GETGLOBAL)), 0, uint32((*e[0].u.s()).info))
		e[0].k = int32((VRELOCABLE))
	case uint32(int32((VINDEXED))):
		freereg(fs, (*e[0].u.s()).aux)
		freereg(fs, (*e[0].u.s()).info)
		(*e[0].u.s()).info = luaK_codeABC(fs, int32((OP_GETTABLE)), 0, (*e[0].u.s()).info, (*e[0].u.s()).aux)
		e[0].k = int32((VRELOCABLE))
	case uint32(int32((VVARARG))):
		fallthrough
	case uint32(int32((VCALL))):
		luaK_setoneret(fs, e)
	default:
		break
	}
}

// code_label - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25444
func code_label(fs []FuncState, A int32, b int32, jump int32) int32 {
	luaK_getlabel(fs)
	return luaK_codeABC(fs, int32((OP_LOADBOOL)), A, b, jump)
}

// discharge2reg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25450
func discharge2reg(fs []FuncState, e []expdesc, reg int32) {
	luaK_dischargevars(fs, e)
	switch uint32(e[0].k) {
	case uint32(int32((VNIL))):
		luaK_nil(fs, reg, 1)
	case uint32(int32((VFALSE))):
		fallthrough
	case uint32(int32((VTRUE))):
		luaK_codeABC(fs, int32((OP_LOADBOOL)), reg, noarch.BoolToInt(uint32(e[0].k) == uint32(int32((VTRUE)))), 0)
	case uint32(int32((VK))):
		luaK_codeABx(fs, int32((OP_LOADK)), reg, uint32((*e[0].u.s()).info))
	case uint32(int32((VKNUM))):
		luaK_codeABx(fs, int32((OP_LOADK)), reg, uint32(luaK_numberK(fs, lua_Number((*e[0].u.nval())))))
	case uint32(int32((VRELOCABLE))):
		var pc []Instruction = (*[1000000]Instruction)(unsafe.Pointer(&((fs)[0].f[0].code[(*(e)[0].u.s()).info])))[:]
		pc[0] = pc[0] & ^(^(^Instruction(0)<<uint64(8))<<uint64(0+6)) | Instruction(reg)<<uint64(0+6)&(^(^Instruction(0)<<uint64(8))<<uint64(0+6))
	case uint32(int32((VNONRELOC))):
		if reg != (*e[0].u.s()).info {
			luaK_codeABC(fs, int32((OP_MOVE)), reg, (*e[0].u.s()).info, 0)
		}
	default:
		_ = 0
		return
	}
	(*e[0].u.s()).info = reg
	e[0].k = int32((VNONRELOC))
}

// discharge2anyreg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25489
func discharge2anyreg(fs []FuncState, e []expdesc) {
	if uint32(e[0].k) != uint32(int32((VNONRELOC))) {
		luaK_reserveregs(fs, 1)
		discharge2reg(fs, e, fs[0].freereg-1)
	}
}

// exp2reg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25497
func exp2reg(fs []FuncState, e []expdesc, reg int32) {
	discharge2reg(fs, e, reg)
	if uint32(e[0].k) == uint32(int32((VJMP))) {
		luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&e[0].t))[:], (*e[0].u.s()).info)
	}
	if (e)[0].t != (e)[0].f {
		var final int32
		var p_f int32 = -1
		var p_t int32 = -1
		if need_value(fs, e[0].t) != 0 || need_value(fs, e[0].f) != 0 {
			var fj int32 = func() int32 {
				if uint32(e[0].k) == uint32(int32((VJMP))) {
					return -1
				}
				return luaK_jump(fs)
			}()
			p_f = code_label(fs, reg, 0, 1)
			p_t = code_label(fs, reg, 1, 0)
			luaK_patchtohere(fs, fj)
		}
		final = luaK_getlabel(fs)
		patchlistaux(fs, e[0].f, final, reg, p_f)
		patchlistaux(fs, e[0].t, final, reg, p_t)
	}
	e[0].t = -1
	e[0].f = e[0].t
	(*e[0].u.s()).info = reg
	e[0].k = int32((VNONRELOC))
}

// luaK_exp2nextreg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25521
func luaK_exp2nextreg(fs []FuncState, e []expdesc) {
	luaK_dischargevars(fs, e)
	freeexp(fs, e)
	luaK_reserveregs(fs, 1)
	exp2reg(fs, e, fs[0].freereg-1)
}

// luaK_exp2anyreg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25529
func luaK_exp2anyreg(fs []FuncState, e []expdesc) int32 {
	luaK_dischargevars(fs, e)
	if uint32(e[0].k) == uint32(int32((VNONRELOC))) {
		if !((e)[0].t != (e)[0].f) {
			return (*e[0].u.s()).info
		}
		if (*e[0].u.s()).info >= int32(uint8((lu_byte(fs[0].nactvar)))) {
			exp2reg(fs, e, (*e[0].u.s()).info)
			return (*e[0].u.s()).info
		}
	}
	luaK_exp2nextreg(fs, e)
	return (*e[0].u.s()).info
}

// luaK_exp2val - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25543
func luaK_exp2val(fs []FuncState, e []expdesc) {
	if (e)[0].t != (e)[0].f {
		luaK_exp2anyreg(fs, e)
	} else {
		luaK_dischargevars(fs, e)
	}
}

// luaK_exp2RK - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25551
func luaK_exp2RK(fs []FuncState, e []expdesc) int32 {
	luaK_exp2val(fs, e)
	switch uint32(e[0].k) {
	case uint32(int32((VKNUM))):
		fallthrough
	case uint32(int32((VTRUE))):
		fallthrough
	case uint32(int32((VFALSE))):
		fallthrough
	case uint32(int32((VNIL))):
		if fs[0].nk <= 1<<uint64(9-1)-1 {
			(*e[0].u.s()).info = func() int32 {
				if uint32(e[0].k) == uint32(int32((VNIL))) {
					return nilK(fs)
				}
				return func() int32 {
					if uint32(e[0].k) == uint32(int32((VKNUM))) {
						return luaK_numberK(fs, lua_Number((*e[0].u.nval())))
					}
					return boolK(fs, noarch.BoolToInt(uint32(e[0].k) == uint32(int32((VTRUE)))))
				}()
			}()
			e[0].k = int32((VK))
			return (*e[0].u.s()).info | 1<<uint64(9-1)
		} else {
			break
		}
		fallthrough
	case uint32(int32((VK))):
		if (*e[0].u.s()).info <= 1<<uint64(9-1)-1 {
			return (*e[0].u.s()).info | 1<<uint64(9-1)
		} else {
			break
		}
		fallthrough
	default:
		break
	}
	return luaK_exp2anyreg(fs, e)
}

// luaK_storevar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25579
func luaK_storevar(fs []FuncState, var_ []expdesc, ex []expdesc) {
	switch uint32(var_[0].k) {
	case uint32(int32((VLOCAL))):
		freeexp(fs, ex)
		exp2reg(fs, ex, (*var_[0].u.s()).info)
		return
	case uint32(int32((VUPVAL))):
		var e int32 = luaK_exp2anyreg(fs, ex)
		luaK_codeABC(fs, int32((OP_SETUPVAL)), e, (*var_[0].u.s()).info, 0)
	case uint32(int32((VGLOBAL))):
		var e int32 = luaK_exp2anyreg(fs, ex)
		luaK_codeABx(fs, int32((OP_SETGLOBAL)), e, uint32((*var_[0].u.s()).info))
	case uint32(int32((VINDEXED))):
		var e int32 = luaK_exp2RK(fs, ex)
		luaK_codeABC(fs, int32((OP_SETTABLE)), (*var_[0].u.s()).info, (*var_[0].u.s()).aux, e)
	default:
		_ = 0
		break
	}
	freeexp(fs, ex)
}

// luaK_self - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25610
func luaK_self(fs []FuncState, e []expdesc, key []expdesc) {
	var func_ int32
	luaK_exp2anyreg(fs, e)
	freeexp(fs, e)
	func_ = fs[0].freereg
	luaK_reserveregs(fs, 2)
	luaK_codeABC(fs, int32((OP_SELF)), func_, (*e[0].u.s()).info, luaK_exp2RK(fs, key))
	freeexp(fs, key)
	(*e[0].u.s()).info = func_
	e[0].k = int32((VNONRELOC))
}

// invertjump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25623
func invertjump(fs []FuncState, e []expdesc) {
	var pc []Instruction = getjumpcontrol(fs, (*e[0].u.s()).info)
	_ = 0
	pc[0] = pc[0] & ^(^(^Instruction(0)<<uint64(8))<<uint64(0+6)) | Instruction(noarch.Not(int32(uint32((lu_int32((pc[0] >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))))<<uint64(0+6)&(^(^Instruction(0)<<uint64(8))<<uint64(0+6))
}

// jumponcond - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25631
func jumponcond(fs []FuncState, e []expdesc, cond int32) int32 {
	if uint32(e[0].k) == uint32(int32((VRELOCABLE))) {
		var ie Instruction = (fs)[0].f[0].code[(*(e)[0].u.s()).info]
		if uint32(int32(uint32((lu_int32((ie >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_NOT))) {
			fs[0].pc--
			return condjump(fs, int32((OP_TEST)), int32(uint32((lu_int32((ie >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))), 0, noarch.BoolToInt(noarch.Not(cond)))
		}
	}
	discharge2anyreg(fs, e)
	freeexp(fs, e)
	return condjump(fs, int32((OP_TESTSET)), 1<<uint64(8)-1, (*e[0].u.s()).info, cond)
}

// luaK_goiftrue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25646
func luaK_goiftrue(fs []FuncState, e []expdesc) {
	var pc int32
	luaK_dischargevars(fs, e)
	switch uint32(e[0].k) {
	case uint32(int32((VK))):
		fallthrough
	case uint32(int32((VKNUM))):
		fallthrough
	case uint32(int32((VTRUE))):
		pc = -1
	case uint32(int32((VJMP))):
		invertjump(fs, e)
		pc = (*e[0].u.s()).info
	default:
		pc = jumponcond(fs, e, 0)
		break
	}
	luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&e[0].f))[:], pc)
	luaK_patchtohere(fs, e[0].t)
	e[0].t = -1
}

// luaK_goiffalse - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25670
func luaK_goiffalse(fs []FuncState, e []expdesc) {
	var pc int32
	luaK_dischargevars(fs, e)
	switch uint32(e[0].k) {
	case uint32(int32((VNIL))):
		fallthrough
	case uint32(int32((VFALSE))):
		pc = -1
	case uint32(int32((VJMP))):
		pc = (*e[0].u.s()).info
	default:
		pc = jumponcond(fs, e, 1)
		break
	}
	luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&e[0].t))[:], pc)
	luaK_patchtohere(fs, e[0].f)
	e[0].f = -1
}

// codenot - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25693
func codenot(fs []FuncState, e []expdesc) {
	luaK_dischargevars(fs, e)
	switch uint32(e[0].k) {
	case uint32(int32((VNIL))):
		fallthrough
	case uint32(int32((VFALSE))):
		e[0].k = int32((VTRUE))
	case uint32(int32((VK))):
		fallthrough
	case uint32(int32((VKNUM))):
		fallthrough
	case uint32(int32((VTRUE))):
		e[0].k = int32((VFALSE))
	case uint32(int32((VJMP))):
		invertjump(fs, e)
	case uint32(int32((VRELOCABLE))):
		fallthrough
	case uint32(int32((VNONRELOC))):
		discharge2anyreg(fs, e)
		freeexp(fs, e)
		(*e[0].u.s()).info = luaK_codeABC(fs, int32((OP_NOT)), 0, (*e[0].u.s()).info, 0)
		e[0].k = int32((VRELOCABLE))
	default:
		_ = 0
		break
	}
	{
		var temp int32 = e[0].f
		e[0].f = e[0].t
		e[0].t = temp
	}
	removevalues(fs, e[0].f)
	removevalues(fs, e[0].t)
}

// luaK_indexed - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25728
func luaK_indexed(fs []FuncState, t []expdesc, k []expdesc) {
	(*t[0].u.s()).aux = luaK_exp2RK(fs, k)
	t[0].k = int32((VINDEXED))
}

// constfolding - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25734
func constfolding(op int32, e1 []expdesc, e2 []expdesc) int32 {
	var v1 lua_Number
	var v2 lua_Number
	var r lua_Number
	if noarch.Not(isnumeral(e1)) || noarch.Not(isnumeral(e2)) {
		return 0
	}
	v1 = lua_Number((*e1[0].u.nval()))
	v2 = lua_Number((*e2[0].u.nval()))
	switch uint32(op) {
	case uint32(int32((OP_ADD))):
		r = v1 + v2
	case uint32(int32((OP_SUB))):
		r = v1 - v2
	case uint32(int32((OP_MUL))):
		r = v1 * v2
	case uint32(int32((OP_DIV))):
		if v2 == lua_Number((0)) {
			return 0
		}
		r = v1 / v2
	case uint32(int32((OP_MOD))):
		if v2 == lua_Number((0)) {
			return 0
		}
		r = v1 - lua_Number((math.Floor(float64((v1 / v2))) * float64((v2))))
	case uint32(int32((OP_POW))):
		r = lua_Number((math.Pow(float64((v1)), float64((v2)))))
	case uint32(int32((OP_UNM))):
		r = -lua_Number((v1))
	case uint32(int32((OP_LEN))):
		return 0
	default:
		_ = (0)
		r = 0
		break
	}
	if !(r == r) {
		return 0
	}
	(*e1[0].u.nval()) = r
	return 1
}

// codearith - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25760
func codearith(fs []FuncState, op int32, e1 []expdesc, e2 []expdesc) {
	if constfolding(op, e1, e2) != 0 {
		return
	} else {
		var o2 int32 = func() int32 {
			if uint32(op) != uint32(int32((OP_UNM))) && uint32(op) != uint32(int32((OP_LEN))) {
				return luaK_exp2RK(fs, e2)
			}
			return 0
		}()
		var o1 int32 = luaK_exp2RK(fs, e1)
		if o1 > o2 {
			freeexp(fs, e1)
			freeexp(fs, e2)
		} else {
			freeexp(fs, e2)
			freeexp(fs, e1)
		}
		(*e1[0].u.s()).info = luaK_codeABC(fs, op, 0, o1, o2)
		e1[0].k = int32((VRELOCABLE))
	}
}

// codecomp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25780
func codecomp(fs []FuncState, op int32, cond int32, e1 []expdesc, e2 []expdesc) {
	var o1 int32 = luaK_exp2RK(fs, e1)
	var o2 int32 = luaK_exp2RK(fs, e2)
	freeexp(fs, e2)
	freeexp(fs, e1)
	if cond == 0 && uint32(op) != uint32(int32((OP_EQ))) {
		var temp int32
		temp = o1
		o1 = o2
		o2 = temp
		cond = 1
	}
	(*e1[0].u.s()).info = condjump(fs, op, cond, o1, o2)
	e1[0].k = int32((VJMP))
}

// luaK_prefix - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25796
func luaK_prefix(fs []FuncState, op UnOpr, e []expdesc) {
	var e2 expdesc
	e2.f = -1
	e2.t = e2.f
	e2.k = int32((VKNUM))
	(*e2.u.nval()) = 0
	switch op {
	case uint32(int32((OPR_MINUS))):
		if noarch.Not(isnumeral(e)) {
			luaK_exp2anyreg(fs, e)
		}
		codearith(fs, int32((OP_UNM)), e, c4goUnsafeConvert_expdesc(&e2))
	case uint32(int32((OPR_NOT))):
		codenot(fs, e)
	case uint32(int32((OPR_LEN))):
		luaK_exp2anyreg(fs, e)
		codearith(fs, int32((OP_LEN)), e, c4goUnsafeConvert_expdesc(&e2))
	default:
		_ = (0)
	}
}

// luaK_infix - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25817
func luaK_infix(fs []FuncState, op BinOpr, v []expdesc) {
	switch op {
	case uint32(int32((OPR_AND))):
		luaK_goiftrue(fs, v)
	case uint32(int32((OPR_OR))):
		luaK_goiffalse(fs, v)
	case uint32(int32((OPR_CONCAT))):
		luaK_exp2nextreg(fs, v)
	case uint32(int32((OPR_ADD))):
		fallthrough
	case uint32(int32((OPR_SUB))):
		fallthrough
	case uint32(int32((OPR_MUL))):
		fallthrough
	case uint32(int32((OPR_DIV))):
		fallthrough
	case uint32(int32((OPR_MOD))):
		fallthrough
	case uint32(int32((OPR_POW))):
		if noarch.Not(isnumeral(v)) {
			luaK_exp2RK(fs, v)
		}
	default:
		luaK_exp2RK(fs, v)
		break
	}
}

// luaK_posfix - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25844
func luaK_posfix(fs []FuncState, op BinOpr, e1 []expdesc, e2 []expdesc) {
	switch op {
	case uint32(int32((OPR_AND))):
		_ = 0
		luaK_dischargevars(fs, e2)
		luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&e2[0].f))[:], e1[0].f)
		e1[0] = e2[0]
	case uint32(int32((OPR_OR))):
		_ = 0
		luaK_dischargevars(fs, e2)
		luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&e2[0].t))[:], e1[0].t)
		e1[0] = e2[0]
	case uint32(int32((OPR_CONCAT))):
		luaK_exp2val(fs, e2)
		if uint32(e2[0].k) == uint32(int32((VRELOCABLE))) && uint32(int32(uint32((lu_int32(((fs)[0].f[0].code[(*(e2)[0].u.s()).info] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_CONCAT))) {
			_ = 0
			freeexp(fs, e1)
			(fs)[0].f[0].code[(*(e2)[0].u.s()).info] = (fs)[0].f[0].code[(*(e2)[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9)) | Instruction((*e1[0].u.s()).info)<<uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9))
			e1[0].k = int32((VRELOCABLE))
			(*e1[0].u.s()).info = (*e2[0].u.s()).info
		} else {
			luaK_exp2nextreg(fs, e2)
			codearith(fs, int32((OP_CONCAT)), e1, e2)
		}
	case uint32(int32((OPR_ADD))):
		codearith(fs, int32((OP_ADD)), e1, e2)
	case uint32(int32((OPR_SUB))):
		codearith(fs, int32((OP_SUB)), e1, e2)
	case uint32(int32((OPR_MUL))):
		codearith(fs, int32((OP_MUL)), e1, e2)
	case uint32(int32((OPR_DIV))):
		codearith(fs, int32((OP_DIV)), e1, e2)
	case uint32(int32((OPR_MOD))):
		codearith(fs, int32((OP_MOD)), e1, e2)
	case uint32(int32((OPR_POW))):
		codearith(fs, int32((OP_POW)), e1, e2)
	case uint32(int32((OPR_EQ))):
		codecomp(fs, int32((OP_EQ)), 1, e1, e2)
	case uint32(int32((OPR_NE))):
		codecomp(fs, int32((OP_EQ)), 0, e1, e2)
	case uint32(int32((OPR_LT))):
		codecomp(fs, int32((OP_LT)), 1, e1, e2)
	case uint32(int32((OPR_LE))):
		codecomp(fs, int32((OP_LE)), 1, e1, e2)
	case uint32(int32((OPR_GT))):
		codecomp(fs, int32((OP_LT)), 0, e1, e2)
	case uint32(int32((OPR_GE))):
		codecomp(fs, int32((OP_LE)), 0, e1, e2)
	default:
		_ = (0)
	}
}

// luaK_fixline - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25891
func luaK_fixline(fs []FuncState, line int32) {
	fs[0].f[0].lineinfo[fs[0].pc-1] = line
}

// luaK_code - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25896
func luaK_code(fs []FuncState, i Instruction, line int32) int32 {
	var f []Proto = fs[0].f
	dischargejpc(fs)
	if fs[0].pc+1 > f[0].sizecode {
		(func() []Instruction {
			f[0].code = luaM_growaux_(fs[0].L, f[0].code, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizecode)))[:], uint(4), 2147483647-2, []byte("code size overflow\x00")).([]Instruction)
			return f[0].code
		}())
	}
	f[0].code[fs[0].pc] = i
	if fs[0].pc+1 > f[0].sizelineinfo {
		(func() []int32 {
			f[0].lineinfo = luaM_growaux_(fs[0].L, f[0].lineinfo, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizelineinfo)))[:], uint(4), 2147483647-2, []byte("code size overflow\x00")).([]int32)
			return f[0].lineinfo
		}())
	}
	f[0].lineinfo[fs[0].pc] = line
	return func() int32 {
		tempVar := &fs[0].pc
		defer func() {
			*tempVar++
		}()
		return *tempVar
	}()
}

// luaK_codeABC - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25911
func luaK_codeABC(fs []FuncState, o int32, a int32, b int32, c int32) int32 {
	_ = 0
	_ = 0
	_ = 0
	return luaK_code(fs, Instruction(o)<<uint64(0)|Instruction(a)<<uint64(0+6)|Instruction(b)<<uint64(0+6+8+9)|Instruction(c)<<uint64(0+6+8), fs[0].ls[0].lastline)
}

// luaK_codeABx - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25919
func luaK_codeABx(fs []FuncState, o int32, a int32, bc uint32) int32 {
	_ = 0
	_ = 0
	return luaK_code(fs, Instruction(o)<<uint64(0)|Instruction(a)<<uint64(0+6)|Instruction(bc)<<uint64(0+6+8), fs[0].ls[0].lastline)
}

// luaK_setlist - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25926
func luaK_setlist(fs []FuncState, base int32, nelems int32, tostore int32) {
	var c int32 = (nelems-1)/50 + 1
	var b int32 = func() int32 {
		if tostore == -1 {
			return 0
		}
		return tostore
	}()
	_ = 0
	if c <= 1<<uint64(9)-1 {
		luaK_codeABC(fs, int32((OP_SETLIST)), base, b, c)
	} else {
		luaK_codeABC(fs, int32((OP_SETLIST)), base, b, 0)
		luaK_code(fs, Instruction(c), fs[0].ls[0].lastline)
	}
	fs[0].freereg = base + 1
}

// currentpc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25978
func currentpc(L []lua_State, ci []CallInfo) int32 {
	if !(StkId(((ci)[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC))) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25979 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return -1
	}
	if (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)) == 0 {
		ci[0].savedpc = L[0].savedpc
	}
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25982 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return int32((int64(uintptr(unsafe.Pointer(&ci[0].savedpc[0])))/int64(4) - int64(uintptr(unsafe.Pointer(&((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].l()).p)[0].code[0])))/int64(4))) - 1
}

// currentline - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25986
func currentline(L []lua_State, ci []CallInfo) (c4goDefaultReturn int32) {
	var pc int32 = currentpc(L, ci)
	if pc < 0 {
		return -1
	} else {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return func() int32 {
			if ((*(func() []Closure {
				(0)
				tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
				return *tempVar
			}())[0].l()).p)[0].lineinfo != nil {
				return ((*(func() []Closure {
					(0)
					tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
					return *tempVar
				}())[0].l()).p)[0].lineinfo[pc]
			}
			return 0
		}()
	}
	return
}

// lua_sethook - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:25998
func lua_sethook(L []lua_State, func_ lua_Hook, mask int32, count int32) int32 {
	if len(func_) == 0 || mask == 0 {
		mask = 0
		func_ = nil
	}
	L[0].hook = func_
	L[0].basehookcount = count
	L[0].hookcount = L[0].basehookcount
	L[0].hookmask = lu_byte(mask)
	return 1
}

// lua_gethook - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26011
func lua_gethook(L []lua_State) lua_Hook {
	return lua_Hook(L[0].hook)
}

// lua_gethookmask - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26016
func lua_gethookmask(L []lua_State) int32 {
	return int32(uint8((lu_byte(L[0].hookmask))))
}

// lua_gethookcount - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26021
func lua_gethookcount(L []lua_State) int32 {
	return L[0].basehookcount
}

// lua_getstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26026
func lua_getstack(L []lua_State, level int32, ar []lua_Debug) int32 {
	var status int32
	var ci []CallInfo
	_ = 0
	for ci = L[0].ci; level > 0 && (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40)-int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)) > 0; func() []CallInfo {
		tempVarUnary := ci
		defer func() {
			ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:]
		}()
		return tempVarUnary
	}() {
		level--
		if noarch.Not(lu_byte((*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).isC)) {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26032 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			level -= ci[0].tailcalls
		}
	}
	if level == 0 && (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40)-int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)) > 0 {
		status = 1
		ar[0].i_ci = int32((int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)))
	} else if level < 0 {
		status = 1
		ar[0].i_ci = 0
	} else {
		status = 0
	}
	_ = 0
	return status
}

// getluaproto - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26049
func getluaproto(ci []CallInfo) []Proto {
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26050 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return func() []Proto {
		if StkId(((ci)[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).isC)) {
			return (*(func() []Closure {
				(0)
				tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
				return *tempVar
			}())[0].l()).p
		}
		return nil
	}()
}

// findlocal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26054
func findlocal(L []lua_State, ci []CallInfo, n int32) (c4goDefaultReturn []byte) {
	var name []byte
	var fp []Proto = getluaproto(ci)
	if fp != nil && len((func() []byte {
		name = luaF_getlocalname(fp, n, currentpc(L, ci))
		return name
	}())) != 0 {
		return name
	} else {
		var limit StkId = func() StkId {
			if (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)) == 0 {
				return StkId(L[0].top)
			}
			return StkId((ci[0+1:])[0].func_)
		}()
		if int32((int64(uintptr(unsafe.Pointer(&limit[0])))/int64(8)-func() int64 {
			c4go_temp_name := StkId(ci[0].base)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())) >= n && n > 0 {
			return []byte("(*temporary)\x00")
		} else {
			return nil
		}
	}
	return
}

// lua_getlocal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26069
func lua_getlocal(L []lua_State, ar []lua_Debug, n int32) []byte {
	var ci []CallInfo = L[0].base_ci[0+ar[0].i_ci:]
	var name []byte = findlocal(L, ci, n)
	_ = 0
	if name != nil {
		luaA_pushobject(L, (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(ci[0].base)[0])) + (uintptr)(n-1)*unsafe.Sizeof(StkId(ci[0].base)[0]))))[:])
	}
	_ = 0
	return name
}

// lua_setlocal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26080
func lua_setlocal(L []lua_State, ar []lua_Debug, n int32) []byte {
	var ci []CallInfo = L[0].base_ci[0+ar[0].i_ci:]
	var name []byte = findlocal(L, ci, n)
	_ = 0
	if name != nil {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(ci[0].base)[0])) + (uintptr)(n-1)*unsafe.Sizeof(StkId(ci[0].base)[0]))))[:]
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	_ = 0
	return name
}

// funcinfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26092
func funcinfo(ar []lua_Debug, cl []Closure) {
	if uint8((lu_byte(cl[0].c.isC))) != 0 {
		ar[0].source = []byte("=[C]\x00")
		ar[0].linedefined = -1
		ar[0].lastlinedefined = -1
		ar[0].what = []byte("C\x00")
	} else {
		ar[0].source = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].l.p[0].source[0+1]))) / int64(1))))[:]
		ar[0].linedefined = cl[0].l.p[0].linedefined
		ar[0].lastlinedefined = cl[0].l.p[0].lastlinedefined
		ar[0].what = func() []byte {
			if ar[0].linedefined == 0 {
				return []byte("main\x00")
			}
			return []byte("Lua\x00")
		}()
	}
	luaO_chunkid(ar[0].short_src[:], ar[0].source, 60)
}

// info_tailcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26109
func info_tailcall(ar []lua_Debug) {
	ar[0].namewhat = []byte("\x00")
	ar[0].name = ar[0].namewhat
	ar[0].what = []byte("tail\x00")
	ar[0].currentline = -1
	ar[0].linedefined = ar[0].currentline
	ar[0].lastlinedefined = ar[0].linedefined
	ar[0].source = []byte("=(tail call)\x00")
	luaO_chunkid(ar[0].short_src[:], ar[0].source, 60)
	ar[0].nups = 0
}

// collectvalidlines - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26119
func collectvalidlines(L []lua_State, f []Closure) {
	if len(f) == 0 || int32(uint8((lu_byte(f[0].c.isC)))) != 0 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26121 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		StkId((L[0].top))[0].tt = 0
	} else {
		var t []Table = luaH_new(L, 0, 0)
		var lineinfo []int32 = f[0].l.p[0].lineinfo
		var i int32
		for i = 0; i < f[0].l.p[0].sizelineinfo; i++ {
			var i_o []TValue = luaH_setnum(L, t, lineinfo[i])
			(*i_o[0].value.b()) = 1
			i_o[0].tt = 1
		}
		{
			var i_o []TValue = []TValue((L[0].top))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&t[0]))) / int64(1))))[:]
			i_o[0].tt = 5
			_ = 0
		}
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
}

// auxgetinfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26135
func auxgetinfo(L []lua_State, what []byte, ar []lua_Debug, f []Closure, ci []CallInfo) int32 {
	var status int32 = 1
	if len(f) == 0 {
		info_tailcall(ar)
		return status
	}
	for ; what[0] != 0; func() []byte {
		tempVarUnary := what
		defer func() {
			what = what[0+1:]
		}()
		return tempVarUnary
	}() {
		switch int32(what[0]) {
		case 'S':
			funcinfo(ar, f)
		case 'l':
			ar[0].currentline = func() int32 {
				if ci != nil {
					return currentline(L, ci)
				}
				return -1
			}()
		case 'u':
			ar[0].nups = int32(uint8((lu_byte(f[0].c.nupvalues))))
		case 'n':
			ar[0].namewhat = func() []byte {
				if ci != nil {
					return getfuncname(L, ci, (*[1000000][]byte)(unsafe.Pointer(&ar[0].name))[:])
				}
				return nil
			}()
			if len(ar[0].namewhat) == 0 {
				ar[0].namewhat = []byte("\x00")
				ar[0].name = nil
			}
		case 'L':
			fallthrough
		case 'f':
		default:
			status = 0
		}
	}
	return status
}

// lua_getinfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26174
func lua_getinfo(L []lua_State, what []byte, ar []lua_Debug) int32 {
	var status int32
	var f []Closure
	var ci []CallInfo
	_ = 0
	if int32(what[0]) == int32('>') {
		var func_ StkId = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
		{
			_ = L
		}
		func() []byte {
			tempVarUnary := what
			defer func() {
				what = what[0+1:]
			}()
			return tempVarUnary
		}()
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26183 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		f = func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}()
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
			}()
			return tempVarUnary
		}()
	} else if ar[0].i_ci != 0 {
		ci = L[0].base_ci[0+ar[0].i_ci:]
		_ = 0
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26189 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		f = func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((ci[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}()
	}
	status = auxgetinfo(L, what, ar, f, ci)
	if noarch.Strchr(what, int32('f')) != nil {
		if len(f) == 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26193 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			(func() int32 {
				StkId((L[0].top))[0].tt = 0
				return StkId((L[0].top))[0].tt
			}())
		} else {
			var i_o []TValue = []TValue((L[0].top))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:]
			i_o[0].tt = 6
			_ = 0
		}
		{
			if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].stack_last)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].top)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1))) <= 1*int32(16) {
				luaD_growstack(L, 1)
			} else {
				_ = (0)
			}
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
	}
	if noarch.Strchr(what, int32('L')) != nil {
		collectvalidlines(L, f)
	}
	_ = 0
	return status
}

// precheck - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26218
func precheck(pt []Proto) int32 {
	if !(int32(uint8((lu_byte(pt[0].maxstacksize)))) <= 250) {
		return 0
	}
	if !(int32(uint8((lu_byte(pt[0].numparams))))+int32(uint8((lu_byte(pt[0].is_vararg))))&1 <= int32(uint8((lu_byte(pt[0].maxstacksize))))) {
		return 0
	}
	if !(noarch.Not(int32(uint8((lu_byte(pt[0].is_vararg))))&4) || int32(uint8((lu_byte(pt[0].is_vararg))))&1 != 0) {
		return 0
	}
	if !(pt[0].sizeupvalues <= int32(uint8((lu_byte(pt[0].nups))))) {
		return 0
	}
	if !(pt[0].sizelineinfo == pt[0].sizecode || pt[0].sizelineinfo == 0) {
		return 0
	}
	if !(pt[0].sizecode > 0 && uint32(int32(uint32((lu_int32((pt[0].code[pt[0].sizecode-1] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_RETURN)))) {
		return 0
	}
	return 1
}

// luaG_checkopenop - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26232
func luaG_checkopenop(i Instruction) (c4goDefaultReturn int32) {
	switch uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) {
	case uint32(int32((OP_CALL))):
		fallthrough
	case uint32(int32((OP_TAILCALL))):
		fallthrough
	case uint32(int32((OP_RETURN))):
		fallthrough
	case uint32(int32((OP_SETLIST))):
		if !(int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) == 0) {
			return 0
		}
		return 1
	default:
		return 0
	}
	return
}

// checkArgMode - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26246
func checkArgMode(pt []Proto, r int32, mode OpArgMask) int32 {
	switch uint32(int32((mode))) {
	case uint32(int32((OpArgN))):
		if !(r == 0) {
			return 0
		}
	case uint32(int32((OpArgU))):
	case uint32(int32((OpArgR))):
		if !(r < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
			return 0
		}
	case uint32(int32((OpArgK))):
		if noarch.Not(func() int32 {
			if r&(1<<uint64(9-1)) != 0 {
				return noarch.BoolToInt(r & ^(1<<uint64(9-1)) < pt[0].sizek)
			}
			return noarch.BoolToInt(r < int32(uint8((lu_byte(pt[0].maxstacksize)))))
		}()) {
			return 0
		}
		break
	}
	return 1
}

// symbexec - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26259
func symbexec(pt []Proto, lastpc int32, reg int32) Instruction {
	var pc int32
	var last int32
	last = pt[0].sizecode - 1
	if noarch.Not(precheck(pt)) {
		return 0
	}
	for pc = 0; pc < lastpc; pc++ {
		var i Instruction = pt[0].code[pc]
		var op int32 = int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))
		var a int32 = int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))
		var b int32
		var c int32
		if !(uint32(op) < uint32(int32((OP_VARARG))+1)) {
			return 0
		}
		if !(a < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
			return 0
		}
		switch uint32(int32((OpMode((int32(uint8((luaP_opmodes[op]))) & 3))))) {
		case uint32(int32((iABC))):
			b = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			c = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			if noarch.Not(checkArgMode(pt, b, OpArgMask((int32(uint8((luaP_opmodes[op]))) >> uint64(4) & 3)))) {
				return 0
			}
			if noarch.Not(checkArgMode(pt, c, OpArgMask((int32(uint8((luaP_opmodes[op]))) >> uint64(2) & 3)))) {
				return 0
			}
		case uint32(int32((iABx))):
			b = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0)))))))
			if uint32(int32((OpArgMask((int32(uint8((luaP_opmodes[op]))) >> uint64(4) & 3))))) == uint32(int32((OpArgK))) {
				if !(b < pt[0].sizek) {
					return 0
				}
			}
		case uint32(int32((iAsBx))):
			b = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0))))))) - (1<<uint64(9+9)-1)>>uint64(1)
			if uint32(int32((OpArgMask((int32(uint8((luaP_opmodes[op]))) >> uint64(4) & 3))))) == uint32(int32((OpArgR))) {
				var dest int32 = pc + 1 + b
				if !(0 <= dest && dest < pt[0].sizecode) {
					return 0
				}
				if dest > 0 {
					var j int32
					for j = 0; j < dest; j++ {
						var d Instruction = pt[0].code[dest-1-j]
						if !(uint32(int32(uint32((lu_int32((d >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_SETLIST))) && int32(uint32((lu_int32((d >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) == 0) {
							break
						}
					}
					if !(j&1 == 0) {
						return 0
					}
				}
			}
			break
		}
		if int32(uint8((luaP_opmodes[op])))&(1<<uint64(6)) != 0 {
			if a == reg {
				last = pc
			}
		}
		if int32(uint8((luaP_opmodes[op])))&(1<<uint64(7)) != 0 {
			if !(pc+2 < pt[0].sizecode) {
				return 0
			}
			if !(uint32(int32(uint32((lu_int32((pt[0].code[pc+1] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_JMP)))) {
				return 0
			}
		}
		switch uint32(op) {
		case uint32(int32((OP_LOADBOOL))):
			if c == 1 {
				if !(pc+2 < pt[0].sizecode) {
					return 0
				}
				if !(uint32(int32(uint32((lu_int32((pt[0].code[pc+1] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) != uint32(int32((OP_SETLIST))) || int32(uint32((lu_int32((pt[0].code[pc+1] >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) != 0) {
					return 0
				}
			}
		case uint32(int32((OP_LOADNIL))):
			if a <= reg && reg <= b {
				last = pc
			}
		case uint32(int32((OP_GETUPVAL))):
			fallthrough
		case uint32(int32((OP_SETUPVAL))):
			if !(b < int32(uint8((lu_byte(pt[0].nups))))) {
				return 0
			}
		case uint32(int32((OP_GETGLOBAL))):
			fallthrough
		case uint32(int32((OP_SETGLOBAL))):
			if !((pt[0].k[b:])[0].tt == 4) {
				return 0
			}
		case uint32(int32((OP_SELF))):
			if !(a+1 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
				return 0
			}
			if reg == a+1 {
				last = pc
			}
		case uint32(int32((OP_CONCAT))):
			if !(b < c) {
				return 0
			}
		case uint32(int32((OP_TFORLOOP))):
			if !(c >= 1) {
				return 0
			}
			if !(a+2+c < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
				return 0
			}
			if reg >= a+2 {
				last = pc
			}
		case uint32(int32((OP_FORLOOP))):
			fallthrough
		case uint32(int32((OP_FORPREP))):
			if !(a+3 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
				return 0
			}
			fallthrough
		case uint32(int32((OP_JMP))):
			var dest int32 = pc + 1 + b
			if reg != 1<<uint64(8)-1 && pc < dest && dest <= lastpc {
				pc += b
			}
		case uint32(int32((OP_CALL))):
			fallthrough
		case uint32(int32((OP_TAILCALL))):
			if b != 0 {
				if !(a+b-1 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
					return 0
				}
			}
			c--
			if c == -1 {
				if noarch.Not(luaG_checkopenop((pt)[0].code[pc+1])) {
					return 0
				}
			} else if c != 0 {
				if !(a+c-1 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
					return 0
				}
			}
			if reg >= a {
				last = pc
			}
		case uint32(int32((OP_RETURN))):
			b--
			if b > 0 {
				if !(a+b-1 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
					return 0
				}
			}
		case uint32(int32((OP_SETLIST))):
			if b > 0 {
				if !(a+b < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
					return 0
				}
			}
			if c == 0 {
				pc++
				if !(pc < pt[0].sizecode-1) {
					return 0
				}
			}
		case uint32(int32((OP_CLOSURE))):
			var nup int32
			var j int32
			if !(b < pt[0].sizep) {
				return 0
			}
			nup = int32(uint8((lu_byte(pt[0].p[b][0].nups))))
			if !(pc+nup < pt[0].sizecode) {
				return 0
			}
			for j = 1; j <= nup; j++ {
				var op1 int32 = int32(uint32((lu_int32((pt[0].code[pc+j] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))
				if !(uint32(op1) == uint32(int32((OP_GETUPVAL))) || uint32(op1) == uint32(int32((OP_MOVE)))) {
					return 0
				}
			}
			if reg != 1<<uint64(8)-1 {
				pc += nup
			}
		case uint32(int32((OP_VARARG))):
			if !(int32(uint8((lu_byte(pt[0].is_vararg))))&2 != 0 && noarch.Not(int32(uint8((lu_byte(pt[0].is_vararg))))&4)) {
				return 0
			}
			b--
			if b == -1 {
				if noarch.Not(luaG_checkopenop((pt)[0].code[pc+1])) {
					return 0
				}
			}
			if !(a+b-1 < int32(uint8((lu_byte((pt)[0].maxstacksize))))) {
				return 0
			}
		default:
			break
		}
	}
	return pt[0].code[last]
}

// luaG_checkcode - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26426
func luaG_checkcode(pt []Proto) int32 {
	return noarch.BoolToInt(symbexec(pt, pt[0].sizecode, 1<<uint64(8)-1) != Instruction((lu_int32((0)))))
}

// kname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26431
func kname(p []Proto, c int32) (c4goDefaultReturn []byte) {
	if c&(1<<uint64(9-1)) != 0 && (p[0].k[c & ^(1<<uint64(9-1)):])[0].tt == 4 {
		return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(p[0].k[c & ^(1<<uint64(9-1)):])[0].value.gc())[0].ts))[:]
			return *tempVar
		}()[1]))) / int64(1))))[:]
	} else {
		return []byte("?\x00")
	}
	return
}

// getobjname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26439
func getobjname(L []lua_State, ci []CallInfo, stackpos int32, name [][]byte) []byte {
	if StkId(((ci)[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)) {
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26441 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26442 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		p []Proto = (*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].l()).p
		var pc int32 = currentpc(L, ci)
		var i Instruction
		name[0] = luaF_getlocalname(p, stackpos+1, pc)
		if name[0] != nil {
			return []byte("local\x00")
		}
		i = symbexec(p, pc, stackpos)
		_ = 0
		switch uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) {
		case uint32(int32((OP_GETGLOBAL))):
			var g int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0)))))))
			_ = 0
			name[0] = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]TString)(unsafe.Pointer(&(*(p[0].k[g:])[0].value.gc())[0].ts))[:])[func() int32 {
				(0)
				tempVar := &0
				return *tempVar
			}()+1]))) / int64(1))))[:]
			return []byte("global\x00")
		case uint32(int32((OP_MOVE))):
			var a int32 = int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			if b < a {
				return getobjname(L, ci, b, name)
			}
		case uint32(int32((OP_GETTABLE))):
			var k int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			name[0] = kname(p, k)
			return []byte("field\x00")
		case uint32(int32((OP_GETUPVAL))):
			var u int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			name[0] = func() []byte {
				if p[0].upvalues != nil {
					return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(p[0].upvalues[u])[0+1]))) / int64(1))))[:]
				}
				return []byte("?\x00")
			}()
			return []byte("upvalue\x00")
		case uint32(int32((OP_SELF))):
			var k int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			name[0] = kname(p, k)
			return []byte("method\x00")
		default:
			break
		}
	}
	return nil
}

// getfuncname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26486
func getfuncname(L []lua_State, ci []CallInfo, name [][]byte) (c4goDefaultReturn []byte) {
	var i Instruction
	if StkId(((ci)[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)) && ci[0].tailcalls > 0 || !(StkId((((*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:])[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((((*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:])[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC))) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26488 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		return nil
	}
	func() []CallInfo {
		tempVarUnary := ci
		defer func() {
			ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:]
		}()
		return tempVarUnary
	}()
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26491 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	i = (*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].l()).p[0].code[currentpc(L, ci)]
	if uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_CALL))) || uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_TAILCALL))) || uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_TFORLOOP))) {
		return getobjname(L, ci, int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))), name)
	} else {
		return nil
	}
	return
}

// isinstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26501
func isinstack(ci []CallInfo, o []TValue) int32 {
	var p StkId
	for p = StkId(ci[0].base); (int64(uintptr(unsafe.Pointer(&p[0])))/int64(8) - func() int64 {
		c4go_temp_name := StkId(ci[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()) < 0; func() StkId {
		tempVarUnary := p
		defer func() {
			p = p[0+1:]
		}()
		return tempVarUnary
	}() {
		if (int64(uintptr(unsafe.Pointer(&o[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(p)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(16)) == 0 {
			return 1
		}
	}
	return 0
}

// luaG_typeerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26509
func luaG_typeerror(L []lua_State, o []TValue, op []byte) {
	var name []byte
	var t []byte = luaT_typenames[(o)[0].tt]
	var kind []byte = func() []byte {
		if isinstack(L[0].ci, o) != 0 {
			return getobjname(L, L[0].ci, int32((int64(uintptr(unsafe.Pointer(&o[0])))/int64(16) - func() int64 {
				c4go_temp_name := StkId(L[0].base)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())), (*[1000000][]byte)(unsafe.Pointer(&name))[:])
		}
		return nil
	}()
	if kind != nil {
		luaG_runerror(L, []byte("attempt to %s %s '%s' (a %s value)\x00"), op, kind, name, t)
	} else {
		luaG_runerror(L, []byte("attempt to %s a %s value\x00"), op, t)
	}
}

// luaG_concaterror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26523
func luaG_concaterror(L []lua_State, p1 StkId, p2 StkId) {
	if StkId((p1))[0].tt == 4 || StkId((p1))[0].tt == 3 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26524 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		p1 = p2
	}
	_ = 0
	luaG_typeerror(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(p1)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], []byte("concatenate\x00"))
}

// luaG_aritherror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26530
func luaG_aritherror(L []lua_State, p1 []TValue, p2 []TValue) {
	var temp TValue
	if len(luaV_tonumber(p1, (*[1000000]TValue)(unsafe.Pointer(&temp))[:])) == 0 {
		p2 = p1
	}
	luaG_typeerror(L, p2, []byte("perform arithmetic on\x00"))
}

// luaG_ordererror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26538
func luaG_ordererror(L []lua_State, p1 []TValue, p2 []TValue) int32 {
	var t1 []byte = luaT_typenames[(p1)[0].tt]
	var t2 []byte = luaT_typenames[(p2)[0].tt]
	if int32(t1[2]) == int32(t2[2]) {
		luaG_runerror(L, []byte("attempt to compare two %s values\x00"), t1)
	} else {
		luaG_runerror(L, []byte("attempt to compare %s with %s\x00"), t1, t2)
	}
	return 0
}

// addinfo - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26549
func addinfo(L []lua_State, msg []byte) {
	var ci []CallInfo = L[0].ci
	if StkId(((ci)[0].func_))[0].tt == 6 && noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)) {
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26551 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		buff []byte = make([]byte, 60)
		var line int32 = currentline(L, ci)
		luaO_chunkid(buff, (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&getluaproto(ci)[0].source[0+1]))) / int64(1))))[:], 60)
		luaO_pushfstring(L, []byte("%s:%d: %s\x00"), buff, line, msg)
	}
}

// luaG_errormsg - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26560
func luaG_errormsg(L []lua_State) {
	if noarch.PtrdiffT(L[0].errfunc) != noarch.PtrdiffT(0) {
		var errfunc StkId = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+L[0].errfunc]))) / int64(1))))[:]))
		if !(StkId((errfunc))[0].tt == 6) {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26563 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			luaD_throw(L, 5)
		}
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = []TValue((L[0].top))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId((errfunc))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].stack_last)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].top)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1))) <= 1*int32(16) {
				luaD_growstack(L, 1)
			} else {
				_ = (0)
			}
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
		luaD_call(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(2)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])), 1)
	}
	luaD_throw(L, 2)
}

// luaG_runerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26573
func luaG_runerror(L []lua_State, fmt_ []byte, c4goArgs ...interface{}) {
	var argp = create_va_list(c4goArgs)
	va_start(argp, fmt_)
	addinfo(L, luaO_pushvfstring(L, fmt_, argp))
	va_end(argp)
	luaG_errormsg(L)
}

// luaD_seterrorobj - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26637
func luaD_seterrorobj(L []lua_State, errcode int32, oldtop StkId) {
	switch errcode {
	case 4:
		var i_o []TValue = []TValue((oldtop))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, []byte("not enough memory\x00"), uint(18/1-1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	case 5:
		var i_o []TValue = []TValue((oldtop))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, []byte("error in error handling\x00"), uint(24/1-1))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	case 3:
		fallthrough
	case 2:
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = []TValue((oldtop))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		break
	}
	L[0].top = oldtop[0+1:]
}

// restore_stack_limit - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26657
func restore_stack_limit(L []lua_State) {
	_ = 0
	if L[0].size_ci > 20000 {
		var inuse int32 = int32((int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)))
		if inuse+1 < 20000 {
			luaD_reallocCI(L, 20000)
		}
	}
}

// resetstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26667
func resetstack(L []lua_State, status int32) {
	L[0].ci = L[0].base_ci
	L[0].base = StkId(L[0].ci[0].base)
	luaF_close(L, StkId(L[0].base))
	luaD_seterrorobj(L, status, StkId(L[0].base))
	L[0].nCcalls = L[0].baseCcalls
	L[0].allowhook = lu_byte(1)
	restore_stack_limit(L)
	L[0].errfunc = 0
	L[0].errorJmp = nil
}

// luaD_throw - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26680
func luaD_throw(L []lua_State, errcode int32) {
	if L[0].errorJmp != nil {
		L[0].errorJmp[0].status = errcode
		// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26683 :Cannot casting {jmp_buf -> struct __jmp_buf_tag *}. err = Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
		longjmp(nil, 1)
	} else {
		L[0].status = lu_byte(errcode)
		if (func([]lua_State) int32)((lua_CFunction((L[0].l_G)[0].panic_))) != nil {
			resetstack(L, errcode)
			_ = 0
			L.l_G.panic_(L)
		}
		noarch.Exit(1)
	}
}

// luaD_rawrunprotected - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26697
func luaD_rawrunprotected(L []lua_State, f Pfunc, ud interface{}) int32 {
	var lj lua_longjmp
	lj.status = 0
	lj.previous = L[0].errorJmp
	L[0].errorJmp = c4goUnsafeConvert_lua_longjmp(&lj)
	if _setjmp(nil) == 0 {
		// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26702 :Cannot casting {jmp_buf -> struct __jmp_buf_tag *}. err = Cannot resolve type 'jmp_buf' : I couldn't find an appropriate Go type for the C type 'jmp_buf'.
		f(L, ud)
	}
	L[0].errorJmp = lj.previous
	return lj.status
}

// correctstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26712
func correctstack(L []lua_State, oldstack []TValue) {
	var ci []CallInfo
	var up []GCObject
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(8))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]))
	for up = L[0].openupval; len(up) != 0; up = up[0].gch.next {
		(func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((up)[0].uv)))[:]
			return *tempVar
		}())[0].v = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((int64(uintptr(unsafe.Pointer(&(func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((up)[0].uv)))[:]
			return *tempVar
		}())[0].v[0])))/int64(16)-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(16))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]
	}
	for ci = L[0].base_ci; (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)) <= 0; func() []CallInfo {
		tempVarUnary := ci
		defer func() {
			ci = ci[0+1:]
		}()
		return tempVarUnary
	}() {
		ci[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((func() int64 {
			c4go_temp_name := StkId(ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(8))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]))
		ci[0].base = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((func() int64 {
			c4go_temp_name := StkId(ci[0].base)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(8))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]))
		ci[0].func_ = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((func() int64 {
			c4go_temp_name := StkId(ci[0].func_)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(8))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]))
	}
	L[0].base = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].stack)[0])) + (uintptr)(int32((func() int64 {
		c4go_temp_name := StkId(L[0].base)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()-int64(uintptr(unsafe.Pointer(&oldstack[0])))/int64(8))))*unsafe.Sizeof(StkId(L[0].stack)[0]))))[:]))
}

// luaD_reallocstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26727
func luaD_reallocstack(L []lua_State, newsize int32) {
	var oldstack []TValue = []TValue((StkId(L[0].stack)))
	var realsize int32 = newsize + 1 + 5
	_ = 0
	L[0].stack = StkId((func() interface{} {
		if uint(realsize+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, StkId((L[0].stack)), uint(uint32(L[0].stacksize)*16), uint(uint32(realsize)*16))
		}
		return luaM_toobig(L)
	}().([]TValue)))
	L[0].stacksize = realsize
	L[0].stack_last = L[0].stack[0+newsize:]
	correctstack(L, oldstack)
}

// luaD_reallocCI - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26738
func luaD_reallocCI(L []lua_State, newsize int32) {
	var oldci []CallInfo = L[0].base_ci
	L[0].base_ci = func() interface{} {
		if uint(newsize+1) <= (uint(^uint(0))-uint(2))/uint(40) {
			return luaM_realloc_(L, (L[0].base_ci), uint(uint32(L[0].size_ci)*40), uint(uint32(newsize)*40))
		}
		return luaM_toobig(L)
	}().([]CallInfo)
	L[0].size_ci = newsize
	L[0].ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].base_ci[0])) + (uintptr)(int32((int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)-int64(uintptr(unsafe.Pointer(&oldci[0])))/int64(40))))*unsafe.Sizeof(L[0].base_ci[0]))))[:]
	L[0].end_ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].base_ci[0+L[0].size_ci:][0])) - (uintptr)(1)*unsafe.Sizeof(L[0].base_ci[0+L[0].size_ci:][0]))))[:]
}

// luaD_growstack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26747
func luaD_growstack(L []lua_State, n int32) {
	if n <= L[0].stacksize {
		luaD_reallocstack(L, 2*L[0].stacksize)
	} else {
		luaD_reallocstack(L, L[0].stacksize+n)
	}
}

// growCI - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26755
func growCI(L []lua_State) []CallInfo {
	if L[0].size_ci > 20000 {
		luaD_throw(L, 5)
	} else {
		luaD_reallocCI(L, 2*L[0].size_ci)
		if L[0].size_ci > 20000 {
			luaG_runerror(L, []byte("stack overflow\x00"))
		}
	}
	return func() []CallInfo {
		tempVar := L[0].ci
		defer func() {
			L[0].ci = L[0].ci[1:]
		}()
		return tempVar
	}()
}

// luaD_callhook - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26767
func luaD_callhook(L []lua_State, event int32, line int32) {
	var hook lua_Hook = lua_Hook(L[0].hook)
	if (func([]lua_State, []lua_Debug))((hook)) != nil && int32(uint8((lu_byte(L[0].allowhook)))) != 0 {
		var top noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].top[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))))
		var ci_top noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].ci[0].top[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))))
		var ar lua_Debug
		ar.event = event
		ar.currentline = line
		if event == 4 {
			ar.i_ci = 0
		} else {
			ar.i_ci = int32((int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)))
		}
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 20*int32(16) {
			luaD_growstack(L, 20)
		} else {
			_ = (0)
		}
		L[0].ci[0].top = L[0].top[0+20:]
		_ = 0
		L[0].allowhook = lu_byte(0)
		_ = 0
		hook(L, c4goUnsafeConvert_lua_Debug(&ar))
		_ = 0
		_ = 0
		L[0].allowhook = lu_byte(1)
		L[0].ci[0].top = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+ci_top]))) / int64(1))))[:]))
		L[0].top = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+top]))) / int64(1))))[:]))
	}
}

// adjust_varargs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26794
func adjust_varargs(L []lua_State, p []Proto, actual int32) StkId {
	var i int32
	var nfixargs int32 = int32(uint8((lu_byte(p[0].numparams))))
	var htab []Table
	var base StkId
	var fixed StkId
	for ; actual < nfixargs; actual++ {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26800 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		(func() int32 {
			(func() StkId {
				tempVar := L[0].top
				defer func() {
					L[0].top = L[0].top[1:]
				}()
				return tempVar
			}())[0].tt = 0
			return (func() StkId {
				tempVar := L[0].top
				defer func() {
					L[0].top = L[0].top[1:]
				}()
				return tempVar
			}())[0].tt
		}())
	}
	if int32(uint8((lu_byte(p[0].is_vararg))))&4 != 0 {
		var nvar int32 = actual - nfixargs
		_ = 0
		{
			_ = 0
			if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
				luaC_step(L)
			}
		}
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= int32(uint8((p[0].maxstacksize)))*int32(16) {
			luaD_growstack(L, int32(uint8((lu_byte(p[0].maxstacksize)))))
		} else {
			_ = (0)
		}
		htab = luaH_new(L, nvar, 1)
		for i = 0; i < nvar; i++ {
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nvar)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:][0])) + (uintptr)(i)*unsafe.Sizeof((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nvar)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:][0]))))[:]))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var o1 []TValue = luaH_setnum(L, htab, i+1)
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			var i_o []TValue = luaH_setstr(L, htab, luaS_newlstr(L, []byte("n\x00"), uint(2/1-1)))
			(*i_o[0].value.n()) = lua_Number(nvar)
			i_o[0].tt = 3
		}
	}
	fixed = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(actual)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
	base = StkId(L[0].top)
	for i = 0; i < nfixargs; i++ {
		{
			var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&fixed[0+i]))) / int64(1))))[:]
			var o1 []TValue = []TValue((func() StkId {
				tempVar := L[0].top
				defer func() {
					L[0].top = L[0].top[1:]
				}()
				return tempVar
			}()))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26819 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		(fixed[0+i:])[0].tt = 0
	}
	if htab != nil {
		{
			var i_o []TValue = []TValue((func() StkId {
				tempVar := L[0].top
				defer func() {
					L[0].top = L[0].top[1:]
				}()
				return tempVar
			}()))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&htab[0]))) / int64(1))))[:]
			i_o[0].tt = 5
			_ = 0
		}
		_ = 0
	}
	return base
}

// tryfuncTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26830
func tryfuncTM(L []lua_State, func_ StkId) StkId {
	var tm []TValue = luaT_gettmbyobj(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(func_)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:], int32((TM_CALL)))
	var p StkId
	var funcr noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))))
	if !((tm)[0].tt == 6) {
		luaG_typeerror(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(func_)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:], []byte("call\x00"))
	}
	for p = StkId(L[0].top); (int64(uintptr(unsafe.Pointer(&p[0])))/int64(8) - int64(uintptr(unsafe.Pointer(&func_[0])))/int64(8)) > 0; func() StkId {
		tempVarUnary := p
		defer func() {
			p = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&p[0])) - (uintptr)(1)*unsafe.Sizeof(p[0]))))[:]))
		}()
		return tempVarUnary
	}() {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&p[0])) - (uintptr)(1)*unsafe.Sizeof(p[0]))))[:]))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = []TValue((p))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	func_ = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:])[0+funcr]))) / int64(1))))[:]))
	{
		var o2 []TValue = tm
		var o1 []TValue = []TValue((func_))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	return func_
}

// luaD_precall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26851
func luaD_precall(L []lua_State, func_ StkId, nresults int32) (c4goDefaultReturn int32) {
	var cl []LClosure
	var funcr noarch.PtrdiffT
	if !(StkId((func_))[0].tt == 6) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26854 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		func_ = tryfuncTM(L, func_)
	}
	funcr = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26857 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	cl = (*[1000000]LClosure)(unsafe.Pointer(&(*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].l())))[:]
	L[0].ci[0].savedpc = L[0].savedpc
	if noarch.Not(lu_byte(cl[0].isC)) {
		var ci []CallInfo
		var st StkId
		var base StkId
		var p []Proto = cl[0].p
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= int32(uint8((p[0].maxstacksize)))*int32(16) {
			luaD_growstack(L, int32(uint8((lu_byte(p[0].maxstacksize)))))
		} else {
			_ = (0)
		}
		func_ = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+funcr]))) / int64(1))))[:]))
		if noarch.Not(lu_byte(p[0].is_vararg)) {
			base = func_[0+1:]
			if (func() int64 {
				c4go_temp_name := StkId(L[0].top)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}() - int64(uintptr(unsafe.Pointer(&base[0+int32(p[0].numparams)])))/int64(8)) > 0 {
				L[0].top = base[0+int32(p[0].numparams):]
			}
		} else {
			var nargs int32 = int32((func() int64 {
				c4go_temp_name := StkId(L[0].top)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}() - int64(uintptr(unsafe.Pointer(&func_[0])))/int64(8))) - 1
			base = adjust_varargs(L, p, nargs)
			func_ = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].stack)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])[0+funcr]))) / int64(1))))[:]))
		}
		ci = func() []CallInfo {
			if (int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].end_ci[0])))/int64(40)) == 0 {
				return growCI(L)
			}
			return func() []CallInfo {
				(0)
				tempVar := L[0].ci
				defer func() {
					L[0].ci = L[0].ci[1:]
				}()
				return tempVar
			}()
		}()
		ci[0].func_ = func_
		ci[0].base = base
		L[0].base = ci[0].base
		ci[0].top = L[0].base[0+int32(p[0].maxstacksize):]
		_ = 0
		L[0].savedpc = p[0].code
		ci[0].tailcalls = 0
		ci[0].nresults = nresults
		for st = StkId(L[0].top); (int64(uintptr(unsafe.Pointer(&st[0])))/int64(8) - func() int64 {
			c4go_temp_name := StkId(ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) < 0; func() StkId {
			tempVarUnary := st
			defer func() {
				st = st[0+1:]
			}()
			return tempVarUnary
		}() {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26884 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			(func() int32 {
				StkId((st))[0].tt = 0
				return StkId((st))[0].tt
			}())
		}
		L[0].top = StkId(ci[0].top)
		if int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(0)) != 0 {
			func() []Instruction {
				tempVarUnary := L[0].savedpc
				defer func() {
					L[0].savedpc = L[0].savedpc[0+1:]
				}()
				return tempVarUnary
			}()
			luaD_callhook(L, 0, -1)
			func() []Instruction {
				tempVarUnary := L[0].savedpc
				defer func() {
					L[0].savedpc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].savedpc[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].savedpc[0]))))[:]
				}()
				return tempVarUnary
			}()
		}
		return 0
	} else {
		var ci []CallInfo
		var n int32
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 20*int32(16) {
			luaD_growstack(L, 20)
		} else {
			_ = (0)
		}
		ci = func() []CallInfo {
			if (int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].end_ci[0])))/int64(40)) == 0 {
				return growCI(L)
			}
			return func() []CallInfo {
				(0)
				tempVar := L[0].ci
				defer func() {
					L[0].ci = L[0].ci[1:]
				}()
				return tempVar
			}()
		}()
		ci[0].func_ = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+funcr]))) / int64(1))))[:]))
		ci[0].base = ci[0].func_[0+1:]
		L[0].base = ci[0].base
		ci[0].top = L[0].top[0+20:]
		_ = 0
		ci[0].nresults = nresults
		if int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(0)) != 0 {
			luaD_callhook(L, 0, -1)
		}
		_ = 0
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26906 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		n = (*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe_.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).f(L)
		_ = 0
		if n < 0 {
			return 2
		} else {
			luaD_poscall(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(n)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))
			return 1
		}
	}
	return
}

// callrethooks - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26918
func callrethooks(L []lua_State, firstResult StkId) StkId {
	var fr noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&firstResult[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))))
	luaD_callhook(L, 1, -1)
	if noarch.Not(lu_byte((*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((L[0].ci)[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].c()).isC)) {
		for int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(1)) != 0 && func() int32 {
			tempVar := &L[0].ci[0].tailcalls
			defer func() {
				*tempVar--
			}()
			return *tempVar
		}() != 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26921 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			luaD_callhook(L, 4, -1)
		}
	}
	return StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:])[0+fr]))) / int64(1))))[:]))
}

// luaD_poscall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26929
func luaD_poscall(L []lua_State, firstResult StkId) int32 {
	var res StkId
	var wanted int32
	var i int32
	var ci []CallInfo
	if int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(1)) != 0 {
		firstResult = callrethooks(L, firstResult)
	}
	ci = func() []CallInfo {
		tempVar := &L[0].ci
		defer func() {
			*tempVar--
		}()
		return *tempVar
	}()
	res = StkId(ci[0].func_)
	wanted = ci[0].nresults
	L[0].base = StkId(((*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:])[0].base)
	L[0].savedpc = ((*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&ci[0])) - (uintptr)(1)*unsafe.Sizeof(ci[0]))))[:])[0].savedpc
	for i = wanted; i != 0 && (int64(uintptr(unsafe.Pointer(&firstResult[0])))/int64(8)-func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()) < 0; i-- {
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := func() StkId {
				defer func() {
					func() StkId {
						tempVarUnary := firstResult
						defer func() {
							firstResult = firstResult[0+1:]
						}()
						return tempVarUnary
					}()
				}()
				return firstResult
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = []TValue((func() StkId {
			defer func() {
				func() StkId {
					tempVarUnary := res
					defer func() {
						res = res[0+1:]
					}()
					return tempVarUnary
				}()
			}()
			return res
		}()))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	for func() int32 {
		defer func() {
			i--
		}()
		return i
	}() > 0 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26944 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		(func() int32 {
			(func() StkId {
				defer func() {
					func() StkId {
						tempVarUnary := res
						defer func() {
							res = res[0+1:]
						}()
						return tempVarUnary
					}()
				}()
				return res
			}())[0].tt = 0
			return (func() StkId {
				defer func() {
					func() StkId {
						tempVarUnary := res
						defer func() {
							res = res[0+1:]
						}()
						return tempVarUnary
					}()
				}()
				return res
			}())[0].tt
		}())
	}
	L[0].top = res
	return wanted - -1
}

// luaD_call - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26956
func luaD_call(L []lua_State, func_ StkId, nResults int32) {
	if int32(func() uint16 {
		tempVar := &L[0].nCcalls
		*tempVar++
		return *tempVar
	}()) >= 200 {
		if int32(L[0].nCcalls) == 200 {
			luaG_runerror(L, []byte("C stack overflow\x00"))
		} else if int32(L[0].nCcalls) >= 200+200>>uint64(3) {
			luaD_throw(L, 5)
		}
	}
	if luaD_precall(L, func_, nResults) == 0 {
		luaV_execute(L, 1)
	}
	L[0].nCcalls -= uint16(1)
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
}

// resume - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26970
func resume(L []lua_State, ud interface{}) {
	var firstArg StkId = StkId((ud.([]TValue)))
	var ci []CallInfo = L[0].ci
	if int32(uint8((lu_byte(L[0].status)))) == 0 {
		_ = 0
		if luaD_precall(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&firstArg[0])) - (uintptr)(1)*unsafe.Sizeof(firstArg[0]))))[:])), -1) != 0 {
			return
		}
	} else {
		_ = 0
		L[0].status = lu_byte(0)
		if !noarch.Not(lu_byte((*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((ci)[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].c()).isC)) {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26981 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			_ = 0
			if luaD_poscall(L, firstArg) != 0 {
				L[0].top = StkId(L[0].ci[0].top)
			}
		} else {
			L[0].base = StkId(L[0].ci[0].base)
		}
	}
	luaV_execute(L, int32((int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40))))
}

// resume_error - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:26995
func resume_error(L []lua_State, msg []byte) int32 {
	L[0].top = StkId(L[0].ci[0].base)
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, msg, uint(noarch.Strlen(msg)))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = 0
	return 2
}

// lua_resume - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27004
func lua_resume(L []lua_State, nargs int32) int32 {
	var status int32
	_ = 0
	if int32(uint8((lu_byte(L[0].status)))) != 1 && (int32(uint8((lu_byte(L[0].status)))) != 0 || (int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40)-int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)) != 0) {
		return resume_error(L, []byte("cannot resume non-suspended coroutine\x00"))
	}
	if int32(L[0].nCcalls) >= 200 {
		return resume_error(L, []byte("C stack overflow\x00"))
	}
	_ = L
	_ = 0
	L[0].baseCcalls = func() uint16 {
		tempVar := &L[0].nCcalls
		*tempVar++
		return *tempVar
	}()
	status = luaD_rawrunprotected(L, resume, (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nargs)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])
	if status != 0 {
		L[0].status = lu_byte(status)
		luaD_seterrorobj(L, status, StkId(L[0].top))
		L[0].ci[0].top = StkId(L[0].top)
	} else {
		_ = 0
		status = int32(uint8((lu_byte(L[0].status))))
	}
	L[0].nCcalls -= uint16(1)
	_ = 0
	return status
}

// lua_yield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27030
func lua_yield(L []lua_State, nresults int32) int32 {
	_ = L
	_ = 0
	if int32(L[0].nCcalls) > int32(L[0].baseCcalls) {
		luaG_runerror(L, []byte("attempt to yield across metamethod/C-call boundary\x00"))
	}
	L[0].base = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(nresults)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:]))
	L[0].status = lu_byte(1)
	_ = 0
	return -1
}

// luaD_pcall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27042
func luaD_pcall(L []lua_State, func_ Pfunc, u interface{}, old_top noarch.PtrdiffT, ef noarch.PtrdiffT) int32 {
	var status int32
	var oldnCcalls uint16 = L[0].nCcalls
	var old_ci noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].ci[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].base_ci[0]))) / int64(1))))[0])))/int64(1))))
	var old_allowhooks lu_byte = lu_byte(L[0].allowhook)
	var old_errfunc noarch.PtrdiffT = noarch.PtrdiffT(L[0].errfunc)
	L[0].errfunc = ef
	status = luaD_rawrunprotected(L, func_, u)
	if status != 0 {
		var oldtop StkId = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])[0+old_top]))) / int64(1))))[:]))
		luaF_close(L, oldtop)
		luaD_seterrorobj(L, status, oldtop)
		L[0].nCcalls = oldnCcalls
		L[0].ci = (*[1000000]CallInfo)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].base_ci[0]))) / int64(1))))[:])[0+old_ci]))) / int64(1))))[:]
		L[0].base = StkId(L[0].ci[0].base)
		L[0].savedpc = L[0].ci[0].savedpc
		L[0].allowhook = old_allowhooks
		restore_stack_limit(L)
	}
	L[0].errfunc = old_errfunc
	return status
}

// f_parser - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27077
func f_parser(L []lua_State, ud interface{}) {
	var i int32
	var tf []Proto
	var cl []Closure
	var p []SParser = ud.([]SParser)
	var c int32 = luaZ_lookahead(p[0].z)
	{
		_ = 0
		if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
			luaC_step(L)
		}
	}
	// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27084 :cannot getName for: &ast.ConditionalOperator{Addr:0x55ad81049308, Pos:ast.Position{File:"/home/1828_sandbox/src/the-language/core/arch/c/lang.c", Line:27084, LineEnd:0, Column:9, ColumnEnd:45, StringValue:""}, Type:"Proto *(*)(lua_State *, ZIO *, Mbuffer *, const char *)", Type2:"", ChildNodes:[]ast.Node{(*ast.ParenExpr)(0xc003db06c0), (*ast.ImplicitCastExpr)(0xc003d5bcc0), (*ast.ImplicitCastExpr)(0xc003d5bd60)}}
	tf = C4GO_UNDEFINE_NAME(L, p[0].z, (*[1000000]Mbuffer)(unsafe.Pointer(&p[0].buff))[:], p[0].name)
	cl = luaF_newLclosure(L, int32(uint8((lu_byte(tf[0].nups)))), func() []Table {
		(0)
		tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*((*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:])[0].value.gc())[0].h))[:]
		return *tempVar
	}())
	cl[0].l.p = tf
	for i = 0; i < int32(uint8((lu_byte(tf[0].nups)))); i++ {
		cl[0].l.upvals[:][i] = luaF_newupval(L)
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0]))) / int64(1))))[:]
		i_o[0].tt = 6
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
}

// luaD_protectedparser - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27095
func luaD_protectedparser(L []lua_State, z []ZIO, name []byte) int32 {
	var p SParser
	var status int32
	p.z = z
	p.name = name
	((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffer = nil
	((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffsize = 0
	status = luaD_pcall(L, f_parser, c4goUnsafeConvert_SParser(&p), noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0].top[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1)))), noarch.PtrdiffT(L[0].errfunc))
	(func() []byte {
		((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffer = func() interface{} {
			if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(1) {
				return luaM_realloc_(L, (((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffer), ((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffsize*uint(1), uint(uint32(0)*1))
			}
			return luaM_toobig(L)
		}().([]byte)
		return ((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffer
	}())
	((*[1000000]Mbuffer)(unsafe.Pointer(&p.buff))[:])[0].buffsize = 0
	return status
}

// DumpBlock - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27138
func DumpBlock(b interface{}, size uint, D []DumpState) {
	if D[0].status == 0 {
		_ = 0
		D[0].status = D.writer(D[0].L, b, size, D[0].data)
		_ = 0
	}
}

// DumpChar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27148
func DumpChar(y int32, D []DumpState) {
	var x byte = byte(y)
	DumpBlock(c4goUnsafeConvert_byte(&x), uint(uint32(1)*1), D)
}

// DumpInt - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27154
func DumpInt(x int32, D []DumpState) {
	DumpBlock(c4goUnsafeConvert_int32(&x), uint(uint32(1)*4), D)
}

// DumpNumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27159
func DumpNumber(x lua_Number, D []DumpState) {
	DumpBlock(c4goUnsafeConvert_float64(&x), uint(uint32(1)*8), D)
}

// DumpVector - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27164
func DumpVector(b interface{}, n int32, size uint, D []DumpState) {
	DumpInt(n, D)
	DumpBlock(b, uint(uint32(n)*uint32(size)), D)
}

// DumpString - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27170
func DumpString(s []TString, D []DumpState) {
	if len(s) == 0 || len((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&s[0+1]))) / int64(1))))[:]) == 0 {
		var size uint
		DumpBlock(c4goUnsafeConvert_uint(&size), uint(uint32(1)*8), D)
	} else {
		var size uint = uint(s[0].tsv.len_) + uint(1)
		DumpBlock(c4goUnsafeConvert_uint(&size), uint(uint32(1)*8), D)
		DumpBlock(((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&s[0+1]))) / int64(1))))[:]), size, D)
	}
}

// DumpConstants - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27189
func DumpConstants(f []Proto, D []DumpState) {
	var i int32
	var n int32 = f[0].sizek
	DumpInt(n, D)
	for i = 0; i < n; i++ {
		var o []TValue = f[0].k[i:]
		DumpChar((o)[0].tt, D)
		switch (o)[0].tt {
		case 0:
		case 1:
			DumpChar(func() int32 {
				(0)
				tempVar := &(*(o)[0].value.b())
				return *tempVar
			}(), D)
		case 3:
			DumpNumber(func() lua_Number {
				(0)
				tempVar := &(*(o)[0].value.n())
				return *tempVar
			}(), D)
		case 4:
			DumpString((func() []TString {
				(0)
				tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(o)[0].value.gc())[0].ts))[:]
				return *tempVar
			}()), D)
		default:
			_ = (0)
			break
		}
	}
	n = f[0].sizep
	DumpInt(n, D)
	for i = 0; i < n; i++ {
		DumpFunction(f[0].p[i], f[0].source, D)
	}
}

// DumpDebug - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27220
func DumpDebug(f []Proto, D []DumpState) {
	var i int32
	var n int32
	n = func() int32 {
		if D[0].strip != 0 {
			return 0
		}
		return f[0].sizelineinfo
	}()
	DumpVector(f[0].lineinfo, n, uint(4), D)
	n = func() int32 {
		if D[0].strip != 0 {
			return 0
		}
		return f[0].sizelocvars
	}()
	DumpInt(n, D)
	for i = 0; i < n; i++ {
		DumpString(f[0].locvars[i].varname, D)
		DumpInt(f[0].locvars[i].startpc, D)
		DumpInt(f[0].locvars[i].endpc, D)
	}
	n = func() int32 {
		if D[0].strip != 0 {
			return 0
		}
		return f[0].sizeupvalues
	}()
	DumpInt(n, D)
	for i = 0; i < n; i++ {
		DumpString(f[0].upvalues[i], D)
	}
}

// DumpFunction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27238
func DumpFunction(f []Proto, p []TString, D []DumpState) {
	DumpString(func() []TString {
		if (int64(uintptr(unsafe.Pointer(&f[0].source[0])))/int64(24)-int64(uintptr(unsafe.Pointer(&p[0])))/int64(24)) == 0 || D[0].strip != 0 {
			return nil
		}
		return f[0].source
	}(), D)
	DumpInt(f[0].linedefined, D)
	DumpInt(f[0].lastlinedefined, D)
	DumpChar(int32(uint8((lu_byte(f[0].nups)))), D)
	DumpChar(int32(uint8((lu_byte(f[0].numparams)))), D)
	DumpChar(int32(uint8((lu_byte(f[0].is_vararg)))), D)
	DumpChar(int32(uint8((lu_byte(f[0].maxstacksize)))), D)
	DumpVector(f[0].code, f[0].sizecode, uint(4), D)
	DumpConstants(f, D)
	DumpDebug(f, D)
}

// DumpHeader - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27252
func DumpHeader(D []DumpState) {
	var h []byte = make([]byte, 12)
	luaU_header(h)
	DumpBlock(h, 12, D)
}

// luaU_dump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27262
func luaU_dump(L []lua_State, f []Proto, w lua_Writer, data interface{}, strip int32) int32 {
	var D DumpState
	D.L = L
	D.writer = w
	D.data = data
	D.strip = strip
	D.status = 0
	DumpHeader((*[1000000]DumpState)(unsafe.Pointer(&D))[:])
	DumpFunction(f, nil, (*[1000000]DumpState)(unsafe.Pointer(&D))[:])
	return D.status
}

// luaF_newCclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27299
func luaF_newCclosure(L []lua_State, nelems int32, e []Table) []Closure {
	var c []Closure = luaM_realloc_(L, nil, 0, uint(int32(48)+int32(16*uint32(nelems-1)))).([]Closure)
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&c[0]))) / int64(1))))[:], lu_byte(6))
	c[0].c.isC = lu_byte(1)
	c[0].c.env = e
	c[0].c.nupvalues = lu_byte(nelems)
	return c
}

// luaF_newLclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27309
func luaF_newLclosure(L []lua_State, nelems int32, e []Table) []Closure {
	var c []Closure = luaM_realloc_(L, nil, 0, uint(int32(48)+int32(8*uint32(nelems-1)))).([]Closure)
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&c[0]))) / int64(1))))[:], lu_byte(6))
	c[0].l.isC = lu_byte(0)
	c[0].l.env = e
	c[0].l.nupvalues = lu_byte(nelems)
	for func() int32 {
		defer func() {
			nelems--
		}()
		return nelems
	}() != 0 {
		c[0].l.upvals[:][nelems] = nil
	}
	return c
}

// luaF_newupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27320
func luaF_newupval(L []lua_State) []UpVal {
	var uv []UpVal = luaM_realloc_(L, nil, 0, uint(120)).([]UpVal)
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:], lu_byte((uint8(8 + 2))))
	uv[0].v = (*[1000000]TValue)(unsafe.Pointer(&(*uv[0].u.value())))[:]
	(uv[0].v)[0].tt = 0
	return uv
}

// luaF_findupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27329
func luaF_findupval(L []lua_State, level StkId) []UpVal {
	var g []global_State = L[0].l_G
	var pp [][]GCObject = (*[1000000][]GCObject)(unsafe.Pointer(&L[0].openupval))[:]
	var p []UpVal
	var uv []UpVal
	for len(pp[0]) != 0 && (int64(uintptr(unsafe.Pointer(&(func() []UpVal {
		p = func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((pp[0])[0].uv)))[:]
			return *tempVar
		}()
		return p
	}())[0].v[0])))/int64(16)-int64(uintptr(unsafe.Pointer(&level[0])))/int64(16)) >= 0 {
		_ = 0
		if (int64(uintptr(unsafe.Pointer(&p[0].v[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&level[0])))/int64(16)) == 0 {
			if int32(uint8((lu_byte(((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&p[0]))) / int64(1))))[:])[0].gch.marked))))&(int32(uint8((lu_byte(g[0].currentwhite))))^(1<<uint64(0)|1<<uint64(1)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				(lu_byte((uint8(func() lu_byte {
					tempVar := &((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&p[0]))) / int64(1))))[:])[0].gch.marked
					*tempVar ^= 1<<uint64(0) | 1<<uint64(1)
					return *tempVar
				}()))))
			}
			return p
		}
		pp = (*[1000000][]GCObject)(unsafe.Pointer(&p[0].next))[:]
	}
	uv = luaM_realloc_(L, nil, 0, uint(120)).([]UpVal)
	uv[0].tt = lu_byte((uint8(8 + 2)))
	uv[0].marked = lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))
	uv[0].v = []TValue((level))
	uv[0].next = pp[0]
	pp[0] = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:]
	(*uv[0].u.l()).prev = (*[1000000]UpVal)(unsafe.Pointer(&g[0].uvhead))[:]
	(*uv[0].u.l()).next = (*g[0].uvhead.u.l()).next
	(*(*uv[0].u.l()).next[0].u.l()).prev = uv
	(*g[0].uvhead.u.l()).next = uv
	_ = 0
	return uv
}

// unlinkupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27358
func unlinkupval(uv []UpVal) {
	_ = 0
	(*(*uv[0].u.l()).next[0].u.l()).prev = (*uv[0].u.l()).prev
	(*(*uv[0].u.l()).prev[0].u.l()).next = (*uv[0].u.l()).next
}

// luaF_freeupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27365
func luaF_freeupval(L []lua_State, uv []UpVal) {
	if (int64(uintptr(unsafe.Pointer(&uv[0].v[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&(*uv[0].u.value())))[0])))/int64(16)) != 0 {
		unlinkupval(uv)
	}
	luaM_realloc_(L, (uv), uint(120), 0)
}

// luaF_close - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27372
func luaF_close(L []lua_State, level StkId) {
	var uv []UpVal
	var g []global_State = L[0].l_G
	for len(L[0].openupval) != 0 && (int64(uintptr(unsafe.Pointer(&(func() []UpVal {
		uv = func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((L[0].openupval)[0].uv)))[:]
			return *tempVar
		}()
		return uv
	}())[0].v[0])))/int64(16)-int64(uintptr(unsafe.Pointer(&level[0])))/int64(16)) >= 0 {
		var o []GCObject = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:]
		_ = 0
		L[0].openupval = uv[0].next
		if int32(uint8((lu_byte((o)[0].gch.marked))))&(int32(uint8((lu_byte(g[0].currentwhite))))^(1<<uint64(0)|1<<uint64(1)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			luaF_freeupval(L, uv)
		} else {
			unlinkupval(uv)
			{
				var o2 []TValue = (uv[0].v)
				var o1 []TValue = (*[1000000]TValue)(unsafe.Pointer(&(*uv[0].u.value())))[:]
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			uv[0].v = (*[1000000]TValue)(unsafe.Pointer(&(*uv[0].u.value())))[:]
			luaC_linkupval(L, uv)
		}
	}
}

// luaF_newproto - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27391
func luaF_newproto(L []lua_State) []Proto {
	var f []Proto = luaM_realloc_(L, nil, 0, uint(128)).([]Proto)
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:], lu_byte((uint8(8 + 1))))
	f[0].k = nil
	f[0].sizek = 0
	f[0].p = nil
	f[0].sizep = 0
	f[0].code = nil
	f[0].sizecode = 0
	f[0].sizelineinfo = 0
	f[0].sizeupvalues = 0
	f[0].nups = lu_byte(0)
	f[0].upvalues = nil
	f[0].numparams = lu_byte(0)
	f[0].is_vararg = lu_byte(0)
	f[0].maxstacksize = lu_byte(0)
	f[0].lineinfo = nil
	f[0].sizelocvars = 0
	f[0].locvars = nil
	f[0].linedefined = 0
	f[0].lastlinedefined = 0
	f[0].source = nil
	return f
}

// luaF_freeproto - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27417
func luaF_freeproto(L []lua_State, f []Proto) {
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(L, (f[0].code), uint(uint32(f[0].sizecode)*4), uint(uint32(0)*4))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, (f[0].p), uint(uint32(f[0].sizep)*8), uint(uint32(0)*8))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (f[0].k), uint(uint32(f[0].sizek)*16), uint(uint32(0)*16))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(L, (f[0].lineinfo), uint(uint32(f[0].sizelineinfo)*4), uint(uint32(0)*4))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (f[0].locvars), uint(uint32(f[0].sizelocvars)*16), uint(uint32(0)*16))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, (f[0].upvalues), uint(uint32(f[0].sizeupvalues)*8), uint(uint32(0)*8))
		}
		return luaM_toobig(L)
	}()
	luaM_realloc_(L, (f), uint(128), 0)
}

// luaF_freeclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27428
func luaF_freeclosure(L []lua_State, c []Closure) {
	var size int32 = func() int32 {
		if int32(uint8((c[0].c.isC))) != 0 {
			return int32(48) + int32(16*uint32(int32(uint8((c[0].c.nupvalues)))-1))
		}
		return int32(48) + int32(8*uint32(int32(uint8((c[0].l.nupvalues)))-1))
	}()
	luaM_realloc_(L, (c), uint(size), 0)
}

// luaF_getlocalname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27439
func luaF_getlocalname(f []Proto, local_number int32, pc int32) []byte {
	var i int32
	for i = 0; i < f[0].sizelocvars && f[0].locvars[i].startpc <= pc; i++ {
		if pc < f[0].locvars[i].endpc {
			local_number--
			if local_number == 0 {
				return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0].locvars[i].varname[0+1]))) / int64(1))))[:]
			}
		}
	}
	return nil
}

// removeentry - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27516
func removeentry(n []Node) {
	// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	{
		_ = 0
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27518 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc003de8d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	}
}

// reallymarkobject - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27523
func reallymarkobject(g []global_State, o []GCObject) {
	_ = 0
	(o)[0].gch.marked &= lu_byte((uint8(int32(uint8((lu_byte(^(1<<uint64(0) | 1<<uint64(1)))))))))
	switch int32(uint8((lu_byte(o[0].gch.tt)))) {
	case 4:
		return
	case 7:
		var // Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27531 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0049070c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		mt []Table
		(o)[0].gch.marked |= lu_byte((uint8(1 << uint64(2))))
		if mt != nil {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&mt[0]))) / int64(1))))[:])
			}
		}
		// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		{
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27534 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0096a31c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		}
		return
	case (8 + 2):
		var uv []UpVal = func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((o)[0].uv)))[:]
			return *tempVar
		}()
		{
			_ = 0
			if (uv[0].v)[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(uv[0].v)[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, func() []GCObject {
					(0)
					tempVar := &(*(uv[0].v)[0].value.gc())
					return *tempVar
				}())
			}
		}
		if (int64(uintptr(unsafe.Pointer(&uv[0].v[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&(*uv[0].u.value())))[0])))/int64(16)) == 0 {
			(lu_byte((uint8(func() lu_byte {
				tempVar := &((o)[0].gch.marked)
				*tempVar |= 1 << uint64(2)
				return *tempVar
			}()))))
		}
		return
	case 6:
		(*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&((o)[0].cl)))[:]
			return *tempVar
		}())[0].c()).gclist = g[0].gray
		g[0].gray = o
	case 5:
		(func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&((o)[0].h)))[:]
			return *tempVar
		}())[0].gclist = g[0].gray
		g[0].gray = o
	case 8:
		(func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&((o)[0].th)))[:]
			return *tempVar
		}())[0].gclist = g[0].gray
		g[0].gray = o
	case (8 + 1):
		(func() []Proto {
			(0)
			tempVar := &(*[1000000]Proto)(unsafe.Pointer(&((o)[0].p)))[:]
			return *tempVar
		}())[0].gclist = g[0].gray
		g[0].gray = o
	default:
		_ = (0)
	}
}

// marktmu - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27569
func marktmu(g []global_State) {
	var u []GCObject = g[0].tmudata
	if u != nil {
		for {
			u = u[0].gch.next
			(u)[0].gch.marked = lu_byte(int32(uint8((lu_byte((u)[0].gch.marked))))&int32(uint8((lu_byte(^(1<<uint64(2) | (1<<uint64(0) | 1<<uint64(1))))))) | int32(uint8((lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))))))
			reallymarkobject(g, u)
			if !((int64(uintptr(unsafe.Pointer(&u[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&g[0].tmudata[0])))/int64(176)) != 0) {
				break
			}
		}
	}
}

// luaC_separateudata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27582
func luaC_separateudata(L []lua_State, all int32) uint {
	var g []global_State = L[0].l_G
	var deadmem uint
	var p [][]GCObject = (*[1000000][]GCObject)(unsafe.Pointer(&g[0].mainthread[0].next))[:]
	var curr []GCObject
	for len((func() []GCObject {
		curr = p[0]
		return curr
	}())) != 0 {
		// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		{
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27588 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0018d3980), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		}
	}
	return deadmem
}

// traversetable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27612
func traversetable(g []global_State, h []Table) int32 {
	var i int32
	var weakkey int32
	var weakvalue int32
	var mode []TValue
	if h[0].metatable != nil {
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&h[0].metatable[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&h[0].metatable[0]))) / int64(1))))[:])
		}
	}
	mode = func() []TValue {
		if len(h[0].metatable) == 0 {
			return nil
		}
		return func() []TValue {
			if uint32(uint8((lu_byte((h[0].metatable)[0].flags))))&uint32(1<<int32((uint64(int32((TM_MODE)))))) != 0 {
				return nil
			}
			return luaT_gettm(h[0].metatable, int32((TM_MODE)), (g)[0].tmname[:][TM_MODE])
		}()
	}()
	if mode != nil && (mode)[0].tt == 4 {
		weakkey = noarch.BoolToInt(len(noarch.Strchr((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]TString)(unsafe.Pointer(&(*(mode)[0].value.gc())[0].ts))[:])[func() int32 {
			(0)
			tempVar := &0
			return *tempVar
		}()+1]))) / int64(1))))[:], int32('k'))) != 0)
		weakvalue = noarch.BoolToInt(len(noarch.Strchr((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]TString)(unsafe.Pointer(&(*(mode)[0].value.gc())[0].ts))[:])[func() int32 {
			(0)
			tempVar := &0
			return *tempVar
		}()+1]))) / int64(1))))[:], int32('v'))) != 0)
		if weakkey != 0 || weakvalue != 0 {
			h[0].marked &= lu_byte((uint8(^(1<<uint64(3) | 1<<uint64(4)))))
			h[0].marked |= lu_byte((uint8(int32(uint8((lu_byte(weakkey<<uint64(3) | weakvalue<<uint64(4))))))))
			h[0].gclist = g[0].weak
			g[0].weak = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&h[0]))) / int64(1))))[:]
		}
	}
	if weakkey != 0 && weakvalue != 0 {
		return 1
	}
	if noarch.Not(weakvalue) {
		i = h[0].sizearray
		for func() int32 {
			defer func() {
				i--
			}()
			return i
		}() != 0 {
			_ = 0
			if (h[0].array[i:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(h[0].array[i:])[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, func() []GCObject {
					(0)
					tempVar := &(*(h[0].array[i:])[0].value.gc())
					return *tempVar
				}())
			}
		}
	}
	i = 1 << uint64(int32(uint8(((h)[0].lsizenode))))
	for func() int32 {
		defer func() {
			i--
		}()
		return i
	}() != 0 {
		var n []Node = (h)[0].node[i:]
		_ = 0
		if ((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt == 0 {
			removeentry(n)
		} else {
			_ = 0
			if noarch.Not(weakkey) {
				// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				{
					_ = 0
					// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
					// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27645 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `>=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc0059e4600), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				}
			}
			if noarch.Not(weakvalue) {
				_ = 0
				if ((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
					(0)
					tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].value.gc())
					return *tempVar
				}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
					reallymarkobject(g, func() []GCObject {
						(0)
						tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].value.gc())
						return *tempVar
					}())
				}
			}
		}
	}
	return noarch.BoolToInt(weakkey != 0 || weakvalue != 0)
}

// traverseproto - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27657
func traverseproto(g []global_State, f []Proto) {
	var i int32
	if f[0].source != nil {
		(lu_byte((uint8(func() lu_byte {
			tempVar := &((f[0].source)[0].tsv.marked)
			*tempVar &= int32(uint8((lu_byte(^(1<<uint64(0) | 1<<uint64(1))))))
			return *tempVar
		}()))))
	}
	for i = 0; i < f[0].sizek; i++ {
		_ = 0
		if (f[0].k[i:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*(f[0].k[i:])[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, func() []GCObject {
				(0)
				tempVar := &(*(f[0].k[i:])[0].value.gc())
				return *tempVar
			}())
		}
	}
	for i = 0; i < f[0].sizeupvalues; i++ {
		if f[0].upvalues[i] != nil {
			(lu_byte((uint8(func() lu_byte {
				tempVar := &((f[0].upvalues[i])[0].tsv.marked)
				*tempVar &= int32(uint8((lu_byte(^(1<<uint64(0) | 1<<uint64(1))))))
				return *tempVar
			}()))))
		}
	}
	for i = 0; i < f[0].sizep; i++ {
		if f[0].p[i] != nil {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0].p[i]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0].p[i]))) / int64(1))))[:])
			}
		}
	}
	for i = 0; i < f[0].sizelocvars; i++ {
		if f[0].locvars[i].varname != nil {
			(lu_byte((uint8(func() lu_byte {
				tempVar := &((f[0].locvars[i].varname)[0].tsv.marked)
				*tempVar &= int32(uint8((lu_byte(^(1<<uint64(0) | 1<<uint64(1))))))
				return *tempVar
			}()))))
		}
	}
}

// traverseclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27678
func traverseclosure(g []global_State, cl []Closure) {
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].c.env[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].c.env[0]))) / int64(1))))[:])
		}
	}
	if uint8((lu_byte(cl[0].c.isC))) != 0 {
		var i int32
		for i = 0; i < int32(uint8((lu_byte(cl[0].c.nupvalues)))); i++ {
			_ = 0
			if (cl[0].c.upvalue[:][i:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(cl[0].c.upvalue[:][i:])[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, func() []GCObject {
					(0)
					tempVar := &(*(cl[0].c.upvalue[:][i:])[0].value.gc())
					return *tempVar
				}())
			}
		}
	} else {
		var i int32
		_ = 0
		{
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].l.p[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].l.p[0]))) / int64(1))))[:])
			}
		}
		for i = 0; i < int32(uint8((lu_byte(cl[0].l.nupvalues)))); i++ {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].l.upvals[:][i]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].l.upvals[:][i]))) / int64(1))))[:])
			}
		}
	}
}

// checkstacksizes - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27695
func checkstacksizes(L []lua_State, max StkId) {
	var ci_used int32 = int32((int64(uintptr(unsafe.Pointer(&L[0].ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&L[0].base_ci[0])))/int64(40)))
	var s_used int32 = int32((int64(uintptr(unsafe.Pointer(&max[0])))/int64(8) - func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()))
	if L[0].size_ci > 20000 {
		return
	}
	if 4*ci_used < L[0].size_ci && 2*8 < L[0].size_ci {
		luaD_reallocCI(L, L[0].size_ci/2)
	}
	_ = 0
	if 4*s_used < L[0].stacksize && 2*(2*20+5) < L[0].stacksize {
		luaD_reallocstack(L, L[0].stacksize/2)
	}
	_ = 0
}

// traversestack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27710
func traversestack(g []global_State, l []lua_State) {
	var o StkId
	var lim StkId
	var ci []CallInfo
	{
		_ = 0
		if ((*[1000000]TValue)(unsafe.Pointer(&l[0].l_gt))[:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&l[0].l_gt))[:])[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, func() []GCObject {
				(0)
				tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&l[0].l_gt))[:])[0].value.gc())
				return *tempVar
			}())
		}
	}
	lim = StkId(l[0].top)
	for ci = l[0].base_ci; (int64(uintptr(unsafe.Pointer(&ci[0])))/int64(40) - int64(uintptr(unsafe.Pointer(&l[0].ci[0])))/int64(40)) <= 0; func() []CallInfo {
		tempVarUnary := ci
		defer func() {
			ci = ci[0+1:]
		}()
		return tempVarUnary
	}() {
		_ = 0
		if (int64(uintptr(unsafe.Pointer(&lim[0])))/int64(8) - func() int64 {
			c4go_temp_name := StkId(ci[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) < 0 {
			lim = StkId(ci[0].top)
		}
	}
	for o = StkId(l[0].stack); (int64(uintptr(unsafe.Pointer(&o[0])))/int64(8) - func() int64 {
		c4go_temp_name := StkId(l[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()) < 0; func() StkId {
		tempVarUnary := o
		defer func() {
			o = o[0+1:]
		}()
		return tempVarUnary
	}() {
		_ = 0
		if StkId((o))[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*StkId((o))[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27720 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27720 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			reallymarkobject(g, func() []GCObject {
				(0)
				tempVar := &(*StkId((o))[0].value.gc())
				return *tempVar
			}())
		}
	}
	for ; (int64(uintptr(unsafe.Pointer(&o[0])))/int64(8) - int64(uintptr(unsafe.Pointer(&lim[0])))/int64(8)) <= 0; func() StkId {
		tempVarUnary := o
		defer func() {
			o = o[0+1:]
		}()
		return tempVarUnary
	}() {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27722 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		(func() int32 {
			StkId((o))[0].tt = 0
			return StkId((o))[0].tt
		}())
	}
	checkstacksizes(l, lim)
}

// propagatemark - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27731
func propagatemark(g []global_State) (c4goDefaultReturn l_mem) {
	var o []GCObject = g[0].gray
	_ = 0
	(o)[0].gch.marked |= lu_byte((uint8(1 << uint64(2))))
	switch int32(uint8((lu_byte(o[0].gch.tt)))) {
	case 5:
		var h []Table = func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&((o)[0].h)))[:]
			return *tempVar
		}()
		g[0].gray = h[0].gclist
		if traversetable(g, h) != 0 {
			(lu_byte((uint8(func() lu_byte {
				tempVar := &((o)[0].gch.marked)
				*tempVar &= int32(uint8((lu_byte(^(1 << uint64(2))))))
				return *tempVar
			}()))))
		}
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27742 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		return l_mem((noarch.PtrdiffT(56 + 16*uint32(h[0].sizearray) + 0*uint32(1<<uint64(int32(uint8(((h)[0].lsizenode))))))))
	case 6:
		var cl []Closure = func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&((o)[0].cl)))[:]
			return *tempVar
		}()
		g[0].gray = cl[0].c.gclist
		traverseclosure(g, cl)
		return l_mem((noarch.PtrdiffT(func() int32 {
			if int32(uint8((cl[0].c.isC))) != 0 {
				return int32(48) + int32(16*uint32(int32(uint8((cl[0].c.nupvalues)))-1))
			}
			return int32(48) + int32(8*uint32(int32(uint8((cl[0].l.nupvalues)))-1))
		}())))
	case 8:
		var th []lua_State = func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&((o)[0].th)))[:]
			return *tempVar
		}()
		g[0].gray = th[0].gclist
		th[0].gclist = g[0].grayagain
		g[0].grayagain = o
		(o)[0].gch.marked &= lu_byte((uint8(int32(uint8((lu_byte(^(1 << uint64(2)))))))))
		traversestack(g, th)
		return l_mem((noarch.PtrdiffT(176 + 16*uint32(th[0].stacksize) + 40*uint32(th[0].size_ci))))
	case (8 + 1):
		var p []Proto = func() []Proto {
			(0)
			tempVar := &(*[1000000]Proto)(unsafe.Pointer(&((o)[0].p)))[:]
			return *tempVar
		}()
		g[0].gray = p[0].gclist
		traverseproto(g, p)
		return l_mem((noarch.PtrdiffT(128 + 4*uint32(p[0].sizecode) + 8*uint32(p[0].sizep) + 16*uint32(p[0].sizek) + 4*uint32(p[0].sizelineinfo) + 16*uint32(p[0].sizelocvars) + 8*uint32(p[0].sizeupvalues))))
	default:
		_ = (0)
		return 0
	}
	return
}

// propagateall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27777
func propagateall(g []global_State) uint {
	var m uint
	for g[0].gray != nil {
		m += uint(uint32(noarch.PtrdiffT((propagatemark(g)))))
	}
	return m
}

// iscleared - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27791
func iscleared(o []TValue, iskey int32) (c4goDefaultReturn int32) {
	// Warning (*ast.ReturnStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27797 :Cannot transpileToStmt : Cannot transpileReturnStmt. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	{
		if !((o)[0].tt >= 4) {
			return 0
		}
		if (o)[0].tt == 4 {
			(*(func() []TString {
				(0)
				tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(o)[0].value.gc())[0].ts))[:]
				return *tempVar
			}())[0].tsv()).marked &= lu_byte((uint8(int32(uint8((lu_byte(^(1<<uint64(0) | 1<<uint64(1)))))))))
			return 0
		}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27798 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27797 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `&&`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008af9840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	}
	return
}

// cleartable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27805
func cleartable(l []GCObject) {
	for l != nil {
		var h []Table = func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&((l)[0].h)))[:]
			return *tempVar
		}()
		var i int32 = h[0].sizearray
		_ = 0
		if int32(uint8((h[0].marked)))&(1<<uint64(4)) != 0 {
			for func() int32 {
				defer func() {
					i--
				}()
				return i
			}() != 0 {
				var o []TValue = h[0].array[i:]
				if iscleared(o, 0) != 0 {
					(func() int32 {
						(o)[0].tt = 0
						return (o)[0].tt
					}())
				}
			}
		}
		i = 1 << uint64(int32(uint8(((h)[0].lsizenode))))
		for func() int32 {
			defer func() {
				i--
			}()
			return i
		}() != 0 {
			var n []Node = (h)[0].node[i:]
			if !(((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt == 0) && (iscleared(((*[1000000]TValue)(unsafe.Pointer(&(*(n)[0].i_key.tvk())))[:]), 1) != 0 || iscleared(((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:]), 0) != 0) {
				((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt = 0
				removeentry(n)
			}
		}
		l = h[0].gclist
	}
}

// freeobj - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27832
func freeobj(L []lua_State, o []GCObject) {
	switch int32(uint8((lu_byte(o[0].gch.tt)))) {
	case (8 + 1):
		luaF_freeproto(L, func() []Proto {
			(0)
			tempVar := &(*[1000000]Proto)(unsafe.Pointer(&((o)[0].p)))[:]
			return *tempVar
		}())
	case 6:
		luaF_freeclosure(L, func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&((o)[0].cl)))[:]
			return *tempVar
		}())
	case (8 + 2):
		luaF_freeupval(L, func() []UpVal {
			(0)
			tempVar := &(*[1000000]UpVal)(unsafe.Pointer(&((o)[0].uv)))[:]
			return *tempVar
		}())
	case 5:
		luaH_free(L, func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&((o)[0].h)))[:]
			return *tempVar
		}())
	case 8:
		_ = 0
		luaE_freethread(L, func() []lua_State {
			(0)
			tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&((o)[0].th)))[:]
			return *tempVar
		}())
	case 4:
		(L[0].l_G)[0].strt.nuse -= lu_int32((uint32(1)))
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27845 :Cannot transpileToStmt : Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is luaM_realloc_. argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `*`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c00b40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	case 7:
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.CallExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27849 :Cannot transpileToStmt : Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is luaM_realloc_. argument position is 2. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'unsigned long' : result type = {unknown53}. Error: operator is `+`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005c01240), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	default:
		_ = (0)
	}
}

// sweeplist - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27861
func sweeplist(L []lua_State, p [][]GCObject, count lu_mem) [][]GCObject {
	var curr []GCObject
	var g []global_State = L[0].l_G
	var deadmask int32 = int32(uint8((lu_byte(g[0].currentwhite)))) ^ (1<<uint64(0) | 1<<uint64(1))
	for len((func() []GCObject {
		curr = p[0]
		return curr
	}())) != 0 && func() lu_mem {
		defer func() {
			count--
		}()
		return count
	}() > lu_mem((uint(0))) {
		if int32(uint8((lu_byte(curr[0].gch.tt)))) == 8 {
			sweeplist(L, (*[1000000][]GCObject)(unsafe.Pointer(&(func() []lua_State {
				(0)
				tempVar := &(*[1000000]lua_State)(unsafe.Pointer(&((curr)[0].th)))[:]
				return *tempVar
			}())[0].openupval))[:], lu_mem(^lu_mem(0))-lu_mem((uint(2))))
		}
		if (int32(uint8((lu_byte(curr[0].gch.marked))))^(1<<uint64(0)|1<<uint64(1)))&deadmask != 0 {
			_ = 0
			(curr)[0].gch.marked = lu_byte(int32(uint8((lu_byte((curr)[0].gch.marked))))&int32(uint8((lu_byte(^(1<<uint64(2) | (1<<uint64(0) | 1<<uint64(1))))))) | int32(uint8((lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))))))
			p = (*[1000000][]GCObject)(unsafe.Pointer(&curr[0].gch.next))[:]
		} else {
			_ = 0
			p[0] = curr[0].gch.next
			if (int64(uintptr(unsafe.Pointer(&curr[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&g[0].rootgc[0])))/int64(176)) == 0 {
				g[0].rootgc = curr[0].gch.next
			}
			freeobj(L, curr)
		}
	}
	return p
}

// checkSizes - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27885
func checkSizes(L []lua_State) {
	var g []global_State = L[0].l_G
	if lu_int32(g[0].strt.nuse) < lu_int32(g[0].strt.size/4) && g[0].strt.size > 32*2 {
		luaS_resize(L, g[0].strt.size/2)
	}
	if ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize > uint(uint32(32*2)) {
		var newsize uint = ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize / uint(2)
		(func() []byte {
			((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer = func() interface{} {
				if uint(newsize+uint(1)) <= (uint(^uint(0))-uint(2))/uint(1) {
					return luaM_realloc_(L, (((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer), ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize*uint(1), newsize*uint(1))
				}
				return luaM_toobig(L)
			}().([]byte)
			return ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer
		}())
		((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize = newsize
	}
}

// GCTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27899
func GCTM(L []lua_State) {
	var g []global_State = L[0].l_G
	var o []GCObject = g[0].tmudata[0].gch.next
	var udata []Udata = func() []Udata {
		(0)
		tempVar := &(*[1000000]Udata)(unsafe.Pointer(&((o)[0].u)))[:]
		return *tempVar
	}()
	var tm []TValue
	if (int64(uintptr(unsafe.Pointer(&o[0])))/int64(176) - int64(uintptr(unsafe.Pointer(&g[0].tmudata[0])))/int64(176)) == 0 {
		g[0].tmudata = nil
	} else {
		g[0].tmudata[0].gch.next = udata[0].uv.next
	}
	udata[0].uv.next = g[0].mainthread[0].next
	g[0].mainthread[0].next = o
	(o)[0].gch.marked = lu_byte(int32(uint8((lu_byte((o)[0].gch.marked))))&int32(uint8((lu_byte(^(1<<uint64(2) | (1<<uint64(0) | 1<<uint64(1))))))) | int32(uint8((lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))))))
	tm = func() []TValue {
		if len(udata[0].uv.metatable) == 0 {
			return nil
		}
		return func() []TValue {
			if uint32(uint8((lu_byte((udata[0].uv.metatable)[0].flags))))&uint32(1<<int32((uint64(int32((TM_GC)))))) != 0 {
				return nil
			}
			return luaT_gettm(udata[0].uv.metatable, int32((TM_GC)), (L[0].l_G)[0].tmname[:][TM_GC])
		}()
	}()
	if len(tm) != 0 {
		var oldah lu_byte = lu_byte(L[0].allowhook)
		var oldt lu_mem = lu_mem(g[0].GCthreshold)
		L[0].allowhook = lu_byte(0)
		g[0].GCthreshold = lu_mem((uint(2 * uint32(uint((lu_mem(g[0].totalbytes)))))))
		{
			var o2 []TValue = tm
			var o1 []TValue = []TValue((L[0].top))
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		{
			var i_o []TValue = []TValue((L[0].top[0+1:]))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&udata[0]))) / int64(1))))[:]
			i_o[0].tt = 7
			_ = 0
		}
		L[0].top = L[0].top[0+2:]
		luaD_call(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(2)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])), 0)
		L[0].allowhook = oldah
		g[0].GCthreshold = oldt
	}
}

// luaC_callGCTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27931
func luaC_callGCTM(L []lua_State) {
	for (L[0].l_G)[0].tmudata != nil {
		GCTM(L)
	}
}

// luaC_freeall - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27937
func luaC_freeall(L []lua_State) {
	var g []global_State = L[0].l_G
	var i int32
	g[0].currentwhite = lu_byte((uint8(1<<uint64(0) | 1<<uint64(1) | 1<<uint64(6))))
	sweeplist(L, (*[1000000][]GCObject)(unsafe.Pointer(&g[0].rootgc))[:], lu_mem(^lu_mem(0))-lu_mem((uint(2))))
	for i = 0; i < g[0].strt.size; i++ {
		sweeplist(L, g[0].strt.hash[i:], lu_mem(^lu_mem(0))-lu_mem((uint(2))))
	}
}

// markmt - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27947
func markmt(g []global_State) {
	var i int32
	for i = 0; i < 8+1; i++ {
		if g[0].mt[:][i] != nil {
			if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&g[0].mt[:][i]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&g[0].mt[:][i]))) / int64(1))))[:])
			}
		}
	}
}

// markroot - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27955
func markroot(L []lua_State) {
	var g []global_State = L[0].l_G
	g[0].gray = nil
	g[0].grayagain = nil
	g[0].weak = nil
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&g[0].mainthread[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&g[0].mainthread[0]))) / int64(1))))[:])
		}
	}
	{
		_ = 0
		if ((*[1000000]TValue)(unsafe.Pointer(&g[0].mainthread[0].l_gt))[:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&g[0].mainthread[0].l_gt))[:])[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, func() []GCObject {
				(0)
				tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&g[0].mainthread[0].l_gt))[:])[0].value.gc())
				return *tempVar
			}())
		}
	}
	{
		_ = 0
		if ((*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:])[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:])[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, func() []GCObject {
				(0)
				tempVar := &(*((*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:])[0].value.gc())
				return *tempVar
			}())
		}
	}
	markmt(g)
	g[0].gcstate = lu_byte(1)
}

// remarkupvals - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27969
func remarkupvals(g []global_State) {
	var uv []UpVal
	for uv = (*g[0].uvhead.u.l()).next; (int64(uintptr(unsafe.Pointer(&uv[0])))/int64(120) - int64(uintptr(unsafe.Pointer(&(*[1000000]UpVal)(unsafe.Pointer(&g[0].uvhead))[0])))/int64(120)) != 0; uv = (*uv[0].u.l()).next {
		_ = 0
		if noarch.Not(int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2))) && noarch.Not(int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1))) {
			_ = 0
			if (uv[0].v)[0].tt >= 4 && int32(uint8(((func() []GCObject {
				(0)
				tempVar := &(*(uv[0].v)[0].value.gc())
				return *tempVar
			}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				reallymarkobject(g, func() []GCObject {
					(0)
					tempVar := &(*(uv[0].v)[0].value.gc())
					return *tempVar
				}())
			}
		}
	}
}

// atomic - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:27979
func atomic(L []lua_State) {
	var g []global_State = L[0].l_G
	var udsize uint
	remarkupvals(g)
	propagateall(g)
	g[0].gray = g[0].weak
	g[0].weak = nil
	_ = 0
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
			reallymarkobject(g, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:])
		}
	}
	markmt(g)
	propagateall(g)
	g[0].gray = g[0].grayagain
	g[0].grayagain = nil
	propagateall(g)
	udsize = luaC_separateudata(L, 0)
	marktmu(g)
	udsize += propagateall(g)
	cleartable(g[0].weak)
	g[0].currentwhite = lu_byte(int32(uint8((lu_byte(g[0].currentwhite)))) ^ (1<<uint64(0) | 1<<uint64(1)))
	g[0].sweepstrgc = 0
	g[0].sweepgc = (*[1000000][]GCObject)(unsafe.Pointer(&g[0].rootgc))[:]
	g[0].gcstate = lu_byte(2)
	g[0].estimate = lu_mem(g[0].totalbytes) - lu_mem((udsize))
}

// singlestep - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28010
func singlestep(L []lua_State) (c4goDefaultReturn l_mem) {
	var g []global_State = L[0].l_G
	switch int32(uint8((lu_byte(g[0].gcstate)))) {
	case 0:
		markroot(L)
		return 0
	case 1:
		if g[0].gray != nil {
			return propagatemark(g)
		} else {
			atomic(L)
			return 0
		}
		fallthrough
	case 2:
		var old lu_mem = lu_mem(g[0].totalbytes)
		sweeplist(L, g[0].strt.hash[func() int32 {
			tempVar := &g[0].sweepstrgc
			defer func() {
				*tempVar++
			}()
			return *tempVar
		}():], lu_mem(^lu_mem(0))-lu_mem((uint(2))))
		if g[0].sweepstrgc >= g[0].strt.size {
			g[0].gcstate = lu_byte(3)
		}
		_ = 0
		g[0].estimate -= old - lu_mem(g[0].totalbytes)
		return 10
	case 3:
		var old lu_mem = lu_mem(g[0].totalbytes)
		g[0].sweepgc = sweeplist(L, g[0].sweepgc, 40)
		if len(g[0].sweepgc[0]) == 0 {
			checkSizes(L)
			g[0].gcstate = lu_byte(4)
		}
		_ = 0
		g[0].estimate -= old - lu_mem(g[0].totalbytes)
		return l_mem((noarch.PtrdiffT(40 * 10)))
	case 4:
		if g[0].tmudata != nil {
			GCTM(L)
			if lu_mem(g[0].estimate) > lu_mem((uint(100))) {
				g[0].estimate -= lu_mem((uint(100)))
			}
			return 100
		} else {
			g[0].gcstate = lu_byte(0)
			g[0].gcdept = 0
			return 0
		}
		fallthrough
	default:
		_ = (0)
		return 0
	}
	return
}

// luaC_step - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28064
func luaC_step(L []lua_State) {
	var g []global_State = L[0].l_G
	var lim l_mem = l_mem((noarch.PtrdiffT(1024 / int32(100) * int32(uint32(g[0].gcstepmul)))))
	if lim == l_mem((noarch.PtrdiffT(0))) {
		lim = l_mem((noarch.PtrdiffT(uint(((lu_mem(^lu_mem(0)) - lu_mem((uint(2))) - lu_mem((uint(1)))) / lu_mem((uint(2))))))))
	}
	g[0].gcdept += lu_mem(g[0].totalbytes) - lu_mem(g[0].GCthreshold)
	for {
		lim -= singlestep(L)
		if int32(uint8((lu_byte(g[0].gcstate)))) == 0 {
			break
		}
		if !(lim > l_mem((noarch.PtrdiffT(0)))) {
			break
		}
	}
	if int32(uint8((lu_byte(g[0].gcstate)))) != 0 {
		if lu_mem(g[0].gcdept) < lu_mem((uint(uint32(1024)))) {
			g[0].GCthreshold = lu_mem(g[0].totalbytes) + lu_mem((uint(uint32(1024))))
		} else {
			g[0].gcdept -= lu_mem((uint(uint32(1024))))
			g[0].GCthreshold = lu_mem(g[0].totalbytes)
		}
	} else {
		g[0].GCthreshold = lu_mem(g[0].estimate) / lu_mem((uint(100))) * lu_mem((uint(uint32(g[0].gcpause))))
	}
}

// luaC_fullgc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28089
func luaC_fullgc(L []lua_State) {
	var g []global_State = L[0].l_G
	if int32(uint8((lu_byte(g[0].gcstate)))) <= 1 {
		g[0].sweepstrgc = 0
		g[0].sweepgc = (*[1000000][]GCObject)(unsafe.Pointer(&g[0].rootgc))[:]
		g[0].gray = nil
		g[0].grayagain = nil
		g[0].weak = nil
		g[0].gcstate = lu_byte(2)
	}
	_ = 0
	for int32(uint8((lu_byte(g[0].gcstate)))) != 4 {
		_ = 0
		singlestep(L)
	}
	markroot(L)
	for int32(uint8((lu_byte(g[0].gcstate)))) != 0 {
		singlestep(L)
	}
	g[0].GCthreshold = lu_mem(g[0].estimate) / lu_mem((uint(100))) * lu_mem((uint(uint32(g[0].gcpause))))
}

// luaC_barrierf - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28115
func luaC_barrierf(L []lua_State, o []GCObject, v []GCObject) {
	var g []global_State = L[0].l_G
	_ = 0
	_ = 0
	_ = 0
	if int32(uint8((lu_byte(g[0].gcstate)))) == 1 {
		reallymarkobject(g, v)
	} else {
		(func() lu_byte {
			(o)[0].gch.marked = lu_byte(int32(uint8((lu_byte((o)[0].gch.marked))))&int32(uint8((lu_byte(^(1<<uint64(2) | (1<<uint64(0) | 1<<uint64(1))))))) | int32(uint8((lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))))))
			return (o)[0].gch.marked
		}())
	}
}

// luaC_barrierback - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28128
func luaC_barrierback(L []lua_State, t []Table) {
	var g []global_State = L[0].l_G
	var o []GCObject = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&t[0]))) / int64(1))))[:]
	_ = 0
	_ = 0
	(o)[0].gch.marked &= lu_byte((uint8(int32(uint8((lu_byte(^(1 << uint64(2)))))))))
	t[0].gclist = g[0].grayagain
	g[0].grayagain = o
}

// luaC_link - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28139
func luaC_link(L []lua_State, o []GCObject, tt lu_byte) {
	var g []global_State = L[0].l_G
	o[0].gch.next = g[0].rootgc
	g[0].rootgc = o
	o[0].gch.marked = lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))
	o[0].gch.tt = tt
}

// luaC_linkupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28148
func luaC_linkupval(L []lua_State, uv []UpVal) {
	var g []global_State = L[0].l_G
	var o []GCObject = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:]
	o[0].gch.next = g[0].rootgc
	g[0].rootgc = o
	if noarch.Not(int32(uint8(((o)[0].gch.marked)))&(1<<uint64(2))) && noarch.Not(int32(uint8(((o)[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1))) {
		if int32(uint8((lu_byte(g[0].gcstate)))) == 1 {
			(o)[0].gch.marked |= lu_byte((uint8(1 << uint64(2))))
			{
				if (uv[0].v)[0].tt >= 4 && int32(uint8(((func() []GCObject {
					(0)
					tempVar := &(*(uv[0].v)[0].value.gc())
					return *tempVar
				}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
					luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:], func() []GCObject {
						(0)
						tempVar := &(*(uv[0].v)[0].value.gc())
						return *tempVar
					}())
				}
			}
		} else {
			(o)[0].gch.marked = lu_byte(int32(uint8((lu_byte((o)[0].gch.marked))))&int32(uint8((lu_byte(^(1<<uint64(2) | (1<<uint64(0) | 1<<uint64(1))))))) | int32(uint8((lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))))))
			_ = 0
		}
	}
}

// luaL_openlibs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28187
func luaL_openlibs(L []lua_State) {
	var lib []luaL_Reg = lualibs
	for ; (func([]lua_State) int32)((lua_CFunction(lib[0].func_))) != nil; func() []luaL_Reg {
		tempVarUnary := lib
		defer func() {
			lib = lib[0+1:]
		}()
		return tempVarUnary
	}() {
		lua_pushcclosure(L, lib[0].func_, 0)
		lua_pushstring(L, lib[0].name)
		lua_call(L, 1, 0)
	}
}

// save - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28250
func save(ls []LexState, c int32) {
	var b []Mbuffer = ls[0].buff
	if uint(b[0].n)+uint(1) > uint(b[0].buffsize) {
		var newsize uint
		if uint(b[0].buffsize) >= (uint(^uint(0))-uint(2))/uint(2) {
			luaX_lexerror(ls, []byte("lexical element too long\x00"), 0)
		}
		newsize = uint(b[0].buffsize) * uint(2)
		(func() []byte {
			(b)[0].buffer = func() interface{} {
				if uint(newsize+uint(1)) <= (uint(^uint(0))-uint(2))/uint(1) {
					return luaM_realloc_(ls[0].L, ((b)[0].buffer), (b)[0].buffsize*uint(1), newsize*uint(1))
				}
				return luaM_toobig(ls[0].L)
			}().([]byte)
			return (b)[0].buffer
		}())
		(b)[0].buffsize = newsize
	}
	b[0].buffer[func() uint {
		tempVar := &b[0].n
		defer func() {
			*tempVar++
		}()
		return *tempVar
	}()] = byte(c)
}

// luaX_init - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28263
func luaX_init(L []lua_State) {
	var i int32
	for i = 0; i < int32((TK_WHILE - int32((RESERVED((257)))) + int32((RESERVED((1)))))); i++ {
		var ts []TString = luaS_newlstr(L, luaX_tokens[i], uint(noarch.Strlen(luaX_tokens[i])))
		(ts)[0].tsv.marked |= lu_byte((uint8(1 << uint64(5))))
		_ = 0
		ts[0].tsv.reserved = lu_byte(i + 1)
	}
}

// luaX_token2str - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28277
func luaX_token2str(ls []LexState, token int32) (c4goDefaultReturn []byte) {
	if token < 257 {
		_ = 0
		return func() []byte {
			if int32(((linux.CtypeLoc())[0])[token])&int32(uint16(noarch.IScntrl)) != 0 {
				return luaO_pushfstring(ls[0].L, []byte("char(%d)\x00"), token)
			}
			return luaO_pushfstring(ls[0].L, []byte("%c\x00"), token)
		}()
	} else {
		return luaX_tokens[token-257]
	}
	return
}

// txtToken - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28288
func txtToken(ls []LexState, token int32) (c4goDefaultReturn []byte) {
	switch token {
	case TK_NAME:
		fallthrough
	case TK_STRING:
		fallthrough
	case TK_NUMBER:
		save(ls, int32('\x00'))
		return ((ls[0].buff)[0].buffer)
	default:
		return luaX_token2str(ls, token)
	}
	return
}

// luaX_lexerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28301
func luaX_lexerror(ls []LexState, msg []byte, token int32) {
	var buff []byte = make([]byte, 80)
	luaO_chunkid(buff, (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ls[0].source[0+1]))) / int64(1))))[:], 80)
	msg = luaO_pushfstring(ls[0].L, []byte("%s:%d: %s\x00"), buff, ls[0].linenumber, msg)
	if token != 0 {
		luaO_pushfstring(ls[0].L, []byte("%s near '%s'\x00"), msg, txtToken(ls, token))
	}
	luaD_throw(ls[0].L, 3)
}

// luaX_syntaxerror - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28311
func luaX_syntaxerror(ls []LexState, msg []byte) {
	luaX_lexerror(ls, msg, ls[0].t.token)
}

// luaX_newstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28316
func luaX_newstring(ls []LexState, str []byte, l uint) []TString {
	var L []lua_State = ls[0].L
	var ts []TString = luaS_newlstr(L, str, l)
	var o []TValue = luaH_setstr(L, ls[0].fs[0].h, ts)
	if (o)[0].tt == 0 {
		{
			var i_o []TValue = o
			(*i_o[0].value.b()) = 1
			i_o[0].tt = 1
		}
		{
			_ = 0
			if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
				luaC_step(L)
			}
		}
	}
	return ts
}

// inclinenumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28328
func inclinenumber(ls []LexState) {
	var old int32 = ls[0].current
	_ = 0
	ls[0].current = func() int32 {
		if func() uint {
			tempVar := &(ls[0].z)[0].n
			defer func() {
				*tempVar--
			}()
			return *tempVar
		}() > uint(0) {
			return int32(uint8((func() []byte {
				tempVar := (ls[0].z)[0].p
				defer func() {
					(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
				}()
				return tempVar
			}())[0]))
		}
		return luaZ_fill(ls[0].z)
	}()
	if (ls[0].current == int32('\n') || ls[0].current == int32('\r')) && ls[0].current != old {
		(func() int32 {
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			return ls[0].current
		}())
	}
	if func() int32 {
		tempVar := &ls[0].linenumber
		*tempVar++
		return *tempVar
	}() >= 2147483647-2 {
		luaX_syntaxerror(ls, []byte("chunk has too many lines\x00"))
	}
}

// luaX_setinput - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28339
func luaX_setinput(L []lua_State, ls []LexState, z []ZIO, source []TString) {
	ls[0].decpoint = '.'
	ls[0].L = L
	ls[0].lookahead.token = int32((TK_EOS))
	ls[0].z = z
	ls[0].fs = nil
	ls[0].linenumber = 1
	ls[0].lastline = 1
	ls[0].source = source
	(func() []byte {
		(ls[0].buff)[0].buffer = func() interface{} {
			if uint(32+1) <= (uint(^uint(0))-uint(2))/uint(1) {
				return luaM_realloc_(ls[0].L, ((ls[0].buff)[0].buffer), (ls[0].buff)[0].buffsize*uint(1), uint(uint32(32)*1))
			}
			return luaM_toobig(ls[0].L)
		}().([]byte)
		return (ls[0].buff)[0].buffer
	}())
	(ls[0].buff)[0].buffsize = 32
	ls[0].current = func() int32 {
		if func() uint {
			tempVar := &(ls[0].z)[0].n
			defer func() {
				*tempVar--
			}()
			return *tempVar
		}() > uint(0) {
			return int32(uint8((func() []byte {
				tempVar := (ls[0].z)[0].p
				defer func() {
					(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
				}()
				return tempVar
			}())[0]))
		}
		return luaZ_fill(ls[0].z)
	}()
}

// check_next - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28362
func check_next(ls []LexState, set []byte) int32 {
	if noarch.Strchr(set, ls[0].current) == nil {
		return 0
	}
	save(ls, ls[0].current)
	(func() int32 {
		ls[0].current = func() int32 {
			if func() uint {
				tempVar := &(ls[0].z)[0].n
				defer func() {
					*tempVar--
				}()
				return *tempVar
			}() > uint(0) {
				return int32(uint8((func() []byte {
					tempVar := (ls[0].z)[0].p
					defer func() {
						(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
					}()
					return tempVar
				}())[0]))
			}
			return luaZ_fill(ls[0].z)
		}()
		return ls[0].current
	}())
	return 1
}

// buffreplace - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28370
func buffreplace(ls []LexState, from byte, to byte) {
	var n uint = (ls[0].buff)[0].n
	var p []byte = (ls[0].buff)[0].buffer
	for bool(func() uint {
		defer func() {
			n--
		}()
		return n
	}()) {
		if int32(p[n]) == int32(from) {
			p[n] = to
		}
	}
}

// trydecpoint - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28378
func trydecpoint(ls []LexState, seminfo []SemInfo) {
	var cv []noarch.Lconv = noarch.Localeconv()
	var old byte = ls[0].decpoint
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28382 :cannot determine type for RHS 'decimal_point', will use 'void *' for all fields. Is lvalue = true. n.Name = `decimal_point`
	ls[0].decpoint = byte(func() int32 {
		if cv != nil {
			return int32(cv[0].decimal_point[0])
		}
		return int32('.')
	}())
	buffreplace(ls, old, ls[0].decpoint)
	if noarch.Not(luaO_str2d(((ls[0].buff)[0].buffer), (*[1000000]lua_Number)(unsafe.Pointer(&seminfo[0].r))[:])) {
		buffreplace(ls, ls[0].decpoint, '.')
		luaX_lexerror(ls, []byte("malformed number\x00"), int32((TK_NUMBER)))
	}
}

// read_numeral - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28393
func read_numeral(ls []LexState, seminfo []SemInfo) {
	_ = 0
	for {
		save(ls, ls[0].current)
		(func() int32 {
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			return ls[0].current
		}())
		if !(int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISdigit)) != 0 || ls[0].current == int32('.')) {
			break
		}
	}
	if check_next(ls, []byte("Ee\x00")) != 0 {
		check_next(ls, []byte("+-\x00"))
	}
	for int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISalnum)) != 0 || ls[0].current == int32('_') {
		(func() int32 {
			save(ls, ls[0].current)
			tempVar := &(func() int32 {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return ls[0].current
			}())
			return *tempVar
		}())
	}
	save(ls, int32('\x00'))
	buffreplace(ls, '.', ls[0].decpoint)
	if noarch.Not(luaO_str2d(((ls[0].buff)[0].buffer), (*[1000000]lua_Number)(unsafe.Pointer(&seminfo[0].r))[:])) {
		trydecpoint(ls, seminfo)
	}
}

// skip_sep - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28409
func skip_sep(ls []LexState) int32 {
	var count int32
	var s int32 = ls[0].current
	_ = 0
	save(ls, ls[0].current)
	(func() int32 {
		ls[0].current = func() int32 {
			if func() uint {
				tempVar := &(ls[0].z)[0].n
				defer func() {
					*tempVar--
				}()
				return *tempVar
			}() > uint(0) {
				return int32(uint8((func() []byte {
					tempVar := (ls[0].z)[0].p
					defer func() {
						(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
					}()
					return tempVar
				}())[0]))
			}
			return luaZ_fill(ls[0].z)
		}()
		return ls[0].current
	}())
	for ls[0].current == int32('=') {
		save(ls, ls[0].current)
		(func() int32 {
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			return ls[0].current
		}())
		count++
	}
	return func() int32 {
		if ls[0].current == s {
			return count
		}
		return -count - 1
	}()
}

// read_long_string - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28422
func read_long_string(ls []LexState, seminfo []SemInfo, sep int32) {
	var cont int32
	_ = cont
	save(ls, ls[0].current)
	(func() int32 {
		ls[0].current = func() int32 {
			if func() uint {
				tempVar := &(ls[0].z)[0].n
				defer func() {
					*tempVar--
				}()
				return *tempVar
			}() > uint(0) {
				return int32(uint8((func() []byte {
					tempVar := (ls[0].z)[0].p
					defer func() {
						(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
					}()
					return tempVar
				}())[0]))
			}
			return luaZ_fill(ls[0].z)
		}()
		return ls[0].current
	}())
	if ls[0].current == int32('\n') || ls[0].current == int32('\r') {
		inclinenumber(ls)
	}
	for {
		switch ls[0].current {
		case (-1):
			luaX_lexerror(ls, func() []byte {
				if seminfo != nil {
					return []byte("unfinished long string\x00")
				}
				return []byte("unfinished long comment\x00")
			}(), int32((TK_EOS)))
		case '[':
			if skip_sep(ls) == sep {
				save(ls, ls[0].current)
				(func() int32 {
					ls[0].current = func() int32 {
						if func() uint {
							tempVar := &(ls[0].z)[0].n
							defer func() {
								*tempVar--
							}()
							return *tempVar
						}() > uint(0) {
							return int32(uint8((func() []byte {
								tempVar := (ls[0].z)[0].p
								defer func() {
									(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
								}()
								return tempVar
							}())[0]))
						}
						return luaZ_fill(ls[0].z)
					}()
					return ls[0].current
				}())
				cont++
				if sep == 0 {
					luaX_lexerror(ls, []byte("nesting of [[...]] is deprecated\x00"), int32('['))
				}
			}
		case ']':
			if skip_sep(ls) == sep {
				save(ls, ls[0].current)
				(func() int32 {
					ls[0].current = func() int32 {
						if func() uint {
							tempVar := &(ls[0].z)[0].n
							defer func() {
								*tempVar--
							}()
							return *tempVar
						}() > uint(0) {
							return int32(uint8((func() []byte {
								tempVar := (ls[0].z)[0].p
								defer func() {
									(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
								}()
								return tempVar
							}())[0]))
						}
						return luaZ_fill(ls[0].z)
					}()
					return ls[0].current
				}())
				goto endloop
			}
		case '\n':
			fallthrough
		case '\r':
			save(ls, int32('\n'))
			inclinenumber(ls)
			if seminfo == nil {
				(func() uint {
					(ls[0].buff)[0].n = 0
					return (ls[0].buff)[0].n
				}())
			}
		default:
			if seminfo != nil {
				(func() int32 {
					save(ls, ls[0].current)
					tempVar := &(func() int32 {
						ls[0].current = func() int32 {
							if func() uint {
								tempVar := &(ls[0].z)[0].n
								defer func() {
									*tempVar--
								}()
								return *tempVar
							}() > uint(0) {
								return int32(uint8((func() []byte {
									tempVar := (ls[0].z)[0].p
									defer func() {
										(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
									}()
									return tempVar
								}())[0]))
							}
							return luaZ_fill(ls[0].z)
						}()
						return ls[0].current
					}())
					return *tempVar
				}())
			} else {
				(func() int32 {
					ls[0].current = func() int32 {
						if func() uint {
							tempVar := &(ls[0].z)[0].n
							defer func() {
								*tempVar--
							}()
							return *tempVar
						}() > uint(0) {
							return int32(uint8((func() []byte {
								tempVar := (ls[0].z)[0].p
								defer func() {
									(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
								}()
								return tempVar
							}())[0]))
						}
						return luaZ_fill(ls[0].z)
					}()
					return ls[0].current
				}())
			}
		}
	}
endloop:
	;
	if seminfo != nil {
		seminfo[0].ts = luaX_newstring(ls, (ls[0].buff)[0].buffer[0+(2+sep):], (ls[0].buff)[0].n-uint(uint32(2*(2+sep))))
	}
}

// read_string - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28477
func read_string(ls []LexState, del int32, seminfo []SemInfo) {
	save(ls, ls[0].current)
	(func() int32 {
		ls[0].current = func() int32 {
			if func() uint {
				tempVar := &(ls[0].z)[0].n
				defer func() {
					*tempVar--
				}()
				return *tempVar
			}() > uint(0) {
				return int32(uint8((func() []byte {
					tempVar := (ls[0].z)[0].p
					defer func() {
						(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
					}()
					return tempVar
				}())[0]))
			}
			return luaZ_fill(ls[0].z)
		}()
		return ls[0].current
	}())
	for ls[0].current != del {
		switch ls[0].current {
		case (-1):
			luaX_lexerror(ls, []byte("unfinished string\x00"), int32((TK_EOS)))
			continue
			fallthrough
		case '\n':
			fallthrough
		case '\r':
			luaX_lexerror(ls, []byte("unfinished string\x00"), int32((TK_STRING)))
			continue
			fallthrough
		case '\\':
			var c int32
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			switch ls[0].current {
			case 'a':
				c = int32('\a')
			case 'b':
				c = int32('\b')
			case 'f':
				c = int32('\f')
			case 'n':
				c = int32('\n')
			case 'r':
				c = int32('\r')
			case 't':
				c = int32('\t')
			case 'v':
				c = int32('\v')
			case '\n':
				fallthrough
			case '\r':
				save(ls, int32('\n'))
				inclinenumber(ls)
				continue
				fallthrough
			case (-1):
				continue
				fallthrough
			default:
				if noarch.Not(int32(((linux.CtypeLoc())[0])[ls[0].current]) & int32(uint16(noarch.ISdigit))) {
					(func() int32 {
						save(ls, ls[0].current)
						tempVar := &(func() int32 {
							ls[0].current = func() int32 {
								if func() uint {
									tempVar := &(ls[0].z)[0].n
									defer func() {
										*tempVar--
									}()
									return *tempVar
								}() > uint(0) {
									return int32(uint8((func() []byte {
										tempVar := (ls[0].z)[0].p
										defer func() {
											(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
										}()
										return tempVar
									}())[0]))
								}
								return luaZ_fill(ls[0].z)
							}()
							return ls[0].current
						}())
						return *tempVar
					}())
				} else {
					var i int32
					c = 0
					for {
						c = 10*c + (ls[0].current - int32('0'))
						ls[0].current = func() int32 {
							if func() uint {
								tempVar := &(ls[0].z)[0].n
								defer func() {
									*tempVar--
								}()
								return *tempVar
							}() > uint(0) {
								return int32(uint8((func() []byte {
									tempVar := (ls[0].z)[0].p
									defer func() {
										(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
									}()
									return tempVar
								}())[0]))
							}
							return luaZ_fill(ls[0].z)
						}()
						if !(func() int32 {
							i++
							return i
						}() < 3 && int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISdigit)) != 0) {
							break
						}
					}
					if c > 127*2+1 {
						luaX_lexerror(ls, []byte("escape sequence too large\x00"), int32((TK_STRING)))
					}
					save(ls, c)
				}
				continue
			}
			save(ls, c)
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			continue
			fallthrough
		default:
			(func() int32 {
				save(ls, ls[0].current)
				tempVar := &(func() int32 {
					ls[0].current = func() int32 {
						if func() uint {
							tempVar := &(ls[0].z)[0].n
							defer func() {
								*tempVar--
							}()
							return *tempVar
						}() > uint(0) {
							return int32(uint8((func() []byte {
								tempVar := (ls[0].z)[0].p
								defer func() {
									(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
								}()
								return tempVar
							}())[0]))
						}
						return luaZ_fill(ls[0].z)
					}()
					return ls[0].current
				}())
				return *tempVar
			}())
		}
	}
	save(ls, ls[0].current)
	(func() int32 {
		ls[0].current = func() int32 {
			if func() uint {
				tempVar := &(ls[0].z)[0].n
				defer func() {
					*tempVar--
				}()
				return *tempVar
			}() > uint(0) {
				return int32(uint8((func() []byte {
					tempVar := (ls[0].z)[0].p
					defer func() {
						(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
					}()
					return tempVar
				}())[0]))
			}
			return luaZ_fill(ls[0].z)
		}()
		return ls[0].current
	}())
	seminfo[0].ts = luaX_newstring(ls, (ls[0].buff)[0].buffer[0+1:], (ls[0].buff)[0].n-uint(2))
}

// llex - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28533
func llex(ls []LexState, seminfo []SemInfo) (c4goDefaultReturn int32) {
	(ls[0].buff)[0].n = 0
	for {
		switch ls[0].current {
		case '\n':
			fallthrough
		case '\r':
			inclinenumber(ls)
			continue
			fallthrough
		case '-':
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current != int32('-') {
				return int32('-')
			}
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current == int32('[') {
				var sep int32 = skip_sep(ls)
				(ls[0].buff)[0].n = 0
				if sep >= 0 {
					read_long_string(ls, nil, sep)
					(ls[0].buff)[0].n = 0
					continue
				}
			}
			for !(ls[0].current == int32('\n') || ls[0].current == int32('\r')) && ls[0].current != -1 {
				(func() int32 {
					ls[0].current = func() int32 {
						if func() uint {
							tempVar := &(ls[0].z)[0].n
							defer func() {
								*tempVar--
							}()
							return *tempVar
						}() > uint(0) {
							return int32(uint8((func() []byte {
								tempVar := (ls[0].z)[0].p
								defer func() {
									(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
								}()
								return tempVar
							}())[0]))
						}
						return luaZ_fill(ls[0].z)
					}()
					return ls[0].current
				}())
			}
			continue
			fallthrough
		case '[':
			var sep int32 = skip_sep(ls)
			if sep >= 0 {
				read_long_string(ls, seminfo, sep)
				return int32((TK_STRING))
			} else if sep == -1 {
				return int32('[')
			} else {
				luaX_lexerror(ls, []byte("invalid long string delimiter\x00"), int32((TK_STRING)))
			}
			fallthrough
		case '=':
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current != int32('=') {
				return int32('=')
			} else {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return int32((TK_EQ))
			}
			fallthrough
		case '<':
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current != int32('=') {
				return int32('<')
			} else {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return int32((TK_LE))
			}
			fallthrough
		case '>':
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current != int32('=') {
				return int32('>')
			} else {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return int32((TK_GE))
			}
			fallthrough
		case '~':
			ls[0].current = func() int32 {
				if func() uint {
					tempVar := &(ls[0].z)[0].n
					defer func() {
						*tempVar--
					}()
					return *tempVar
				}() > uint(0) {
					return int32(uint8((func() []byte {
						tempVar := (ls[0].z)[0].p
						defer func() {
							(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
						}()
						return tempVar
					}())[0]))
				}
				return luaZ_fill(ls[0].z)
			}()
			if ls[0].current != int32('=') {
				return int32('~')
			} else {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return int32((TK_NE))
			}
			fallthrough
		case '"':
			fallthrough
		case '\'':
			read_string(ls, ls[0].current, seminfo)
			return int32((TK_STRING))
		case '.':
			save(ls, ls[0].current)
			(func() int32 {
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return ls[0].current
			}())
			if check_next(ls, []byte(".\x00")) != 0 {
				if check_next(ls, []byte(".\x00")) != 0 {
					return int32((TK_DOTS))
				} else {
					return int32((TK_CONCAT))
				}
			} else if noarch.Not(int32(((linux.CtypeLoc())[0])[ls[0].current]) & int32(uint16(noarch.ISdigit))) {
				return int32('.')
			} else {
				read_numeral(ls, seminfo)
				return int32((TK_NUMBER))
			}
			fallthrough
		case (-1):
			return int32((TK_EOS))
		default:
			if int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISspace)) != 0 {
				_ = 0
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				continue
			} else if int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISdigit)) != 0 {
				read_numeral(ls, seminfo)
				return int32((TK_NUMBER))
			} else if int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISalpha)) != 0 || ls[0].current == int32('_') {
				var ts []TString
				for {
					save(ls, ls[0].current)
					(func() int32 {
						ls[0].current = func() int32 {
							if func() uint {
								tempVar := &(ls[0].z)[0].n
								defer func() {
									*tempVar--
								}()
								return *tempVar
							}() > uint(0) {
								return int32(uint8((func() []byte {
									tempVar := (ls[0].z)[0].p
									defer func() {
										(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
									}()
									return tempVar
								}())[0]))
							}
							return luaZ_fill(ls[0].z)
						}()
						return ls[0].current
					}())
					if !(int32(((linux.CtypeLoc())[0])[ls[0].current])&int32(uint16(noarch.ISalnum)) != 0 || ls[0].current == int32('_')) {
						break
					}
				}
				ts = luaX_newstring(ls, ((ls[0].buff)[0].buffer), (ls[0].buff)[0].n)
				if int32(uint8((lu_byte(ts[0].tsv.reserved)))) > 0 {
					return int32(uint8((lu_byte(ts[0].tsv.reserved)))) - 1 + 257
				} else {
					seminfo[0].ts = ts
					return int32((TK_NAME))
				}
			} else {
				var c int32 = ls[0].current
				ls[0].current = func() int32 {
					if func() uint {
						tempVar := &(ls[0].z)[0].n
						defer func() {
							*tempVar--
						}()
						return *tempVar
					}() > uint(0) {
						return int32(uint8((func() []byte {
							tempVar := (ls[0].z)[0].p
							defer func() {
								(ls[0].z)[0].p = (ls[0].z)[0].p[1:]
							}()
							return tempVar
						}())[0]))
					}
					return luaZ_fill(ls[0].z)
				}()
				return c
			}
		}
	}
	return
}

// luaX_next - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28647
func luaX_next(ls []LexState) {
	ls[0].lastline = ls[0].linenumber
	if ls[0].lookahead.token != int32((TK_EOS)) {
		ls[0].t = Token(ls[0].lookahead)
		ls[0].lookahead.token = int32((TK_EOS))
	} else {
		ls[0].t.token = llex(ls, (*[1000000]SemInfo)(unsafe.Pointer(&ls[0].t.seminfo))[:])
	}
}

// luaX_lookahead - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28658
func luaX_lookahead(ls []LexState) {
	_ = 0
	ls[0].lookahead.token = llex(ls, (*[1000000]SemInfo)(unsafe.Pointer(&ls[0].lookahead.seminfo))[:])
}

// luaM_growaux_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28713
func luaM_growaux_(L []lua_State, block interface{}, size []int32, size_elems uint, limit int32, errormsg []byte) interface{} {
	var newblock interface{}
	var newsize int32
	if size[0] >= limit/2 {
		if size[0] >= limit {
			luaG_runerror(L, errormsg)
		}
		newsize = limit
	} else {
		newsize = size[0] * 2
		if newsize < 4 {
			newsize = 4
		}
	}
	newblock = func() interface{} {
		if uint(newsize+1) <= (uint(^uint(0))-uint(2))/size_elems {
			return luaM_realloc_(L, block, uint(uint32(size[0])*uint32(size_elems)), uint(uint32(newsize)*uint32(size_elems)))
		}
		return luaM_toobig(L)
	}()
	size[0] = newsize
	return newblock
}

// luaM_toobig - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28733
func luaM_toobig(L []lua_State) interface{} {
	luaG_runerror(L, []byte("memory allocation error: block too big\x00"))
	return nil
}

// luaM_realloc_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28743
func luaM_realloc_(L []lua_State, block interface{}, osize uint, nsize uint) interface{} {
	var g []global_State = L[0].l_G
	_ = 0
	block = g.frealloc(g[0].ud, block, osize, nsize)
	if block == nil && nsize > uint(0) {
		luaD_throw(L, 4)
	}
	_ = 0
	g[0].totalbytes = lu_mem(g[0].totalbytes) - lu_mem((osize)) + lu_mem((nsize))
	return block
}

// luaO_int2fb - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28792
func luaO_int2fb(x uint32) (c4goDefaultReturn int32) {
	var e int32
	for x >= 16 {
		x = (x + 1) >> uint64(1)
		e++
	}
	if x < 8 {
		return int32(x)
	} else {
		return (e+1)<<uint64(3) | (int32(x) - 8)
	}
	return
}

// luaO_fb2int - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28804
func luaO_fb2int(x int32) (c4goDefaultReturn int32) {
	var e int32 = x >> uint64(3) & 31
	if e == 0 {
		return x
	} else {
		return (x&7 + 8) << uint64(e-1)
	}
	return
}

// luaO_log2 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28811
func luaO_log2(x uint32) int32 {
	var log_2 []lu_byte = []lu_byte{lu_byte(0), lu_byte(1), lu_byte(2), lu_byte(2), lu_byte(3), lu_byte(3), lu_byte(3), lu_byte(3), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(4), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(5), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(6), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(7), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8), lu_byte(8)}
	var l int32 = -1
	for x >= 256 {
		l += 8
		x >>= uint32(uint64(8))
	}
	return l + int32(uint8((log_2[x])))
}

// luaO_rawequalObj - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28829
func luaO_rawequalObj(t1 []TValue, t2 []TValue) (c4goDefaultReturn int32) {
	if (t1)[0].tt != (t2)[0].tt {
		return 0
	} else {
		switch (t1)[0].tt {
		case 0:
			return 1
		case 3:
			return noarch.BoolToInt(func() lua_Number {
				(0)
				tempVar := &(*(t1)[0].value.n())
				return *tempVar
			}() == func() lua_Number {
				(0)
				tempVar := &(*(t2)[0].value.n())
				return *tempVar
			}())
		case 1:
			return noarch.BoolToInt(func() int32 {
				(0)
				tempVar := &(*(t1)[0].value.b())
				return *tempVar
			}() == func() int32 {
				(0)
				tempVar := &(*(t2)[0].value.b())
				return *tempVar
			}())
		case 2:
			return noarch.BoolToInt((func() int64 {
				c4go_temp_name := func() interface{} {
					(0)
					tempVar := &(*(t1)[0].value.p())
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}() - func() int64 {
				c4go_temp_name := func() interface{} {
					(0)
					tempVar := &(*(t2)[0].value.p())
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}()) == 0)
		default:
			_ = (0)
			return noarch.BoolToInt((func() int64 {
				c4go_temp_name := func() []GCObject {
					(0)
					tempVar := &(*(t1)[0].value.gc())
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}() - func() int64 {
				c4go_temp_name := func() []GCObject {
					(0)
					tempVar := &(*(t2)[0].value.gc())
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}()) == 0)
		}
	}
	return
}

// luaO_str2d - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28847
func luaO_str2d(s []byte, result []lua_Number) int32 {
	var endptr []byte
	result[0] = lua_Number((noarch.Strtod(s, (*[1000000][]byte)(unsafe.Pointer(&endptr))[:])))
	if (int64(uintptr(unsafe.Pointer(&endptr[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)) == 0 {
		return 0
	}
	if int32(endptr[0]) == int32('x') || int32(endptr[0]) == int32('X') {
		result[0] = lua_Number(noarch.Strtoul(s, (*[1000000][]byte)(unsafe.Pointer(&endptr))[:], 16))
	}
	if int32(endptr[0]) == int32('\x00') {
		return 1
	}
	for int32(((linux.CtypeLoc())[0])[int32(uint8(endptr[0]))])&int32(uint16(noarch.ISspace)) != 0 {
		func() []byte {
			tempVarUnary := endptr
			defer func() {
				endptr = endptr[0+1:]
			}()
			return tempVarUnary
		}()
	}
	if int32(endptr[0]) != int32('\x00') {
		return 0
	}
	return 1
}

// pushstr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28861
func pushstr(L []lua_State, str []byte) {
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaS_newlstr(L, str, uint(noarch.Strlen(str)))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 4
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
}

// luaO_pushvfstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28868
func luaO_pushvfstring(L []lua_State, fmt_ []byte, argp *va_list) []byte {
	var n int32 = 1
	pushstr(L, []byte("\x00"))
	for {
		var e []byte = noarch.Strchr(fmt_, int32('%'))
		if len(e) == 0 {
			break
		}
		{
			var i_o []TValue = []TValue((L[0].top))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := luaS_newlstr(L, fmt_, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&fmt_[0])))/int64(1)))))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			i_o[0].tt = 4
			_ = 0
		}
		{
			if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].stack_last)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(L[0].top)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[0])))/int64(1))) <= 1*int32(16) {
				luaD_growstack(L, 1)
			} else {
				_ = (0)
			}
			func() StkId {
				tempVarUnary := L[0].top
				defer func() {
					L[0].top = L[0].top[0+1:]
				}()
				return tempVarUnary
			}()
		}
		switch int32(e[0+1]) {
		case 's':
			var s []byte = va_arg(argp).([]byte)
			if len(s) == 0 {
				s = []byte("(null)\x00")
			}
			pushstr(L, s)
		case 'c':
			var buff []byte = make([]byte, 2)
			buff[0] = byte(va_arg(argp).(int32))
			buff[1] = '\x00'
			pushstr(L, buff)
		case 'd':
			{
				var i_o []TValue = []TValue((L[0].top))
				(*i_o[0].value.n()) = lua_Number(va_arg(argp).(int32))
				i_o[0].tt = 3
			}
			{
				if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId(L[0].stack_last)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId(L[0].top)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[0])))/int64(1))) <= 1*int32(16) {
					luaD_growstack(L, 1)
				} else {
					_ = (0)
				}
				func() StkId {
					tempVarUnary := L[0].top
					defer func() {
						L[0].top = L[0].top[0+1:]
					}()
					return tempVarUnary
				}()
			}
		case 'f':
			{
				var i_o []TValue = []TValue((L[0].top))
				(*i_o[0].value.n()) = lua_Number(va_arg(argp).(l_uacNumber))
				i_o[0].tt = 3
			}
			{
				if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId(L[0].stack_last)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId(L[0].top)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[0])))/int64(1))) <= 1*int32(16) {
					luaD_growstack(L, 1)
				} else {
					_ = (0)
				}
				func() StkId {
					tempVarUnary := L[0].top
					defer func() {
						L[0].top = L[0].top[0+1:]
					}()
					return tempVarUnary
				}()
			}
		case 'p':
			var buff []byte = make([]byte, 40)
			noarch.Sprintf(buff, []byte("%p\x00"), va_arg(argp).(interface{}))
			pushstr(L, buff)
		case '%':
			pushstr(L, []byte("%\x00"))
		default:
			var buff []byte = make([]byte, 3)
			buff[0] = '%'
			buff[1] = e[0+1]
			buff[2] = '\x00'
			pushstr(L, buff)
			break
		}
		n += 2
		fmt_ = e[0+2:]
	}
	pushstr(L, fmt_)
	luaV_concat(L, n+1, int32((func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()-func() int64 {
		c4go_temp_name := StkId(L[0].base)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}()))-1)
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(n)*unsafe.Sizeof(L[0].top[0]))))[:]))
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28925 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func() []TString {
		(0)
		tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(1)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])))[0].value.gc())[0].ts))[:]
		return *tempVar
	}()[1]))) / int64(1))))[:]
}

// luaO_pushfstring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28929
func luaO_pushfstring(L []lua_State, fmt_ []byte, c4goArgs ...interface{}) []byte {
	var msg []byte
	var argp = create_va_list(c4goArgs)
	va_start(argp, fmt_)
	msg = luaO_pushvfstring(L, fmt_, argp)
	va_end(argp)
	return msg
}

// luaO_chunkid - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:28939
func luaO_chunkid(out []byte, source []byte, bufflen uint) {
	if int32(source[0]) == int32('=') {
		noarch.Strncpy(out, source[0+1:], int32(bufflen))
		out[bufflen-uint(1)] = '\x00'
	} else {
		if int32(source[0]) == int32('@') {
			var l uint
			func() []byte {
				tempVarUnary := source
				defer func() {
					source = source[0+1:]
				}()
				return tempVarUnary
			}()
			bufflen -= uint(8)
			l = uint(noarch.Strlen(source))
			noarch.Strcpy(out, []byte("\x00"))
			if l > bufflen {
				source = (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&source[0])) + (uintptr)(int32(l-bufflen))*unsafe.Sizeof(source[0]))))[:]
				noarch.Strcat(out, []byte("...\x00"))
			}
			noarch.Strcat(out, source)
		} else {
			var len_ uint = uint(strcspn(source, []byte("\n\r\x00")))
			bufflen -= uint(17)
			if len_ > bufflen {
				len_ = bufflen
			}
			noarch.Strcpy(out, []byte("[string \"\x00"))
			if int32(source[len_]) != int32('\x00') {
				noarch.Strncat(out, source, int32(len_))
				noarch.Strcat(out, []byte("...\x00"))
			} else {
				noarch.Strcat(out, source)
			}
			noarch.Strcat(out, []byte("\"]\x00"))
		}
	}
}

// anchor_token - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29139
func anchor_token(ls []LexState) {
	if ls[0].t.token == int32((TK_NAME)) || ls[0].t.token == int32((TK_STRING)) {
		var ts []TString = (*ls[0].t.seminfo.ts())
		luaX_newstring(ls, (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ts[0+1]))) / int64(1))))[:], uint(ts[0].tsv.len_))
	}
}

// error_expected - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29147
func error_expected(ls []LexState, token int32) {
	luaX_syntaxerror(ls, luaO_pushfstring(ls[0].L, []byte("'%s' expected\x00"), luaX_token2str(ls, token)))
}

// errorlimit - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29153
func errorlimit(fs []FuncState, limit int32, what []byte) {
	var msg []byte = func() []byte {
		if fs[0].f[0].linedefined == 0 {
			return luaO_pushfstring(fs[0].L, []byte("main function has more than %d %s\x00"), limit, what)
		}
		return luaO_pushfstring(fs[0].L, []byte("function at line %d has more than %d %s\x00"), fs[0].f[0].linedefined, limit, what)
	}()
	luaX_lexerror(fs[0].ls, msg, 0)
}

// testnext - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29162
func testnext(ls []LexState, c int32) (c4goDefaultReturn int32) {
	if ls[0].t.token == c {
		luaX_next(ls)
		return 1
	} else {
		return 0
	}
	return
}

// check - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29171
func check(ls []LexState, c int32) {
	if ls[0].t.token != c {
		error_expected(ls, c)
	}
}

// checknext - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29176
func checknext(ls []LexState, c int32) {
	check(ls, c)
	luaX_next(ls)
}

// check_match - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29186
func check_match(ls []LexState, what int32, who int32, where int32) {
	if noarch.Not(testnext(ls, what)) {
		if where == ls[0].linenumber {
			error_expected(ls, what)
		} else {
			luaX_syntaxerror(ls, luaO_pushfstring(ls[0].L, []byte("'%s' expected (to close '%s' at line %d)\x00"), luaX_token2str(ls, what), luaX_token2str(ls, who), where))
		}
	}
}

// str_checkname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29199
func str_checkname(ls []LexState) []TString {
	var ts []TString
	check(ls, int32((TK_NAME)))
	ts = (*ls[0].t.seminfo.ts())
	luaX_next(ls)
	return ts
}

// init_exp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29208
func init_exp(e []expdesc, k int32, i int32) {
	e[0].t = -1
	e[0].f = e[0].t
	e[0].k = k
	(*e[0].u.s()).info = i
}

// codestring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29215
func codestring(ls []LexState, e []expdesc, s []TString) {
	init_exp(e, int32((VK)), luaK_stringK(ls[0].fs, s))
}

// checkname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29220
func checkname(ls []LexState, e []expdesc) {
	codestring(ls, e, str_checkname(ls))
}

// registerlocalvar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29225
func registerlocalvar(ls []LexState, varname []TString) int32 {
	var fs []FuncState = ls[0].fs
	var f []Proto = fs[0].f
	var oldsize int32 = f[0].sizelocvars
	if int32(fs[0].nlocvars)+1 > f[0].sizelocvars {
		(func() []LocVar {
			f[0].locvars = luaM_growaux_(ls[0].L, f[0].locvars, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizelocvars)))[:], uint(16), 32767, []byte("too many local variables\x00")).([]LocVar)
			return f[0].locvars
		}())
	}
	for oldsize < f[0].sizelocvars {
		f[0].locvars[func() int32 {
			defer func() {
				oldsize++
			}()
			return oldsize
		}()].varname = nil
	}
	f[0].locvars[fs[0].nlocvars].varname = varname
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&varname[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			luaC_barrierf(ls[0].L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:], (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&varname[0]))) / int64(1))))[:])
		}
	}
	return int32(func() int16 {
		tempVar := &fs[0].nlocvars
		defer func() {
			*tempVar++
		}()
		return *tempVar
	}())
}

// new_localvar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29242
func new_localvar(ls []LexState, name []TString, n int32) {
	var fs []FuncState = ls[0].fs
	if int32(uint8((lu_byte(fs[0].nactvar))))+n+1 > 200 {
		errorlimit(fs, 200, []byte("local variables\x00"))
	}
	fs[0].actvar[:][int32(uint8((lu_byte(fs[0].nactvar))))+n] = uint16(registerlocalvar(ls, name))
}

// adjustlocalvars - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29249
func adjustlocalvars(ls []LexState, nvars int32) {
	var fs []FuncState = ls[0].fs
	fs[0].nactvar = lu_byte(int32(uint8((lu_byte(fs[0].nactvar)))) + nvars)
	for ; nvars != 0; nvars-- {
		((fs)[0].f[0].locvars[(fs)[0].actvar[:][int32(uint8((lu_byte(fs[0].nactvar))))-nvars]]).startpc = fs[0].pc
	}
}

// removevars - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29258
func removevars(ls []LexState, tolevel int32) {
	var fs []FuncState = ls[0].fs
	for int32(uint8((lu_byte(fs[0].nactvar)))) > tolevel {
		((fs)[0].f[0].locvars[(fs)[0].actvar[:][func() lu_byte {
			tempVar := &fs[0].nactvar
			*tempVar--
			return *tempVar
		}()]]).endpc = fs[0].pc
	}
}

// indexupvalue - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29265
func indexupvalue(fs []FuncState, name []TString, v []expdesc) int32 {
	var i int32
	var f []Proto = fs[0].f
	var oldsize int32 = f[0].sizeupvalues
	for i = 0; i < int32(uint8((lu_byte(f[0].nups)))); i++ {
		if uint32(uint8((lu_byte(fs[0].upvalues[:][i].k)))) == uint32(v[0].k) && int32(uint8((lu_byte(fs[0].upvalues[:][i].info)))) == (*v[0].u.s()).info {
			_ = 0
			return i
		}
	}
	if int32(uint8((lu_byte(f[0].nups))))+1 > 60 {
		errorlimit(fs, 60, []byte("upvalues\x00"))
	}
	if int32(uint8((f[0].nups)))+1 > f[0].sizeupvalues {
		(func() [][]TString {
			f[0].upvalues = luaM_growaux_(fs[0].L, f[0].upvalues, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizeupvalues)))[:], uint(8), 2147483647-2, []byte("\x00"))
			return f[0].upvalues
		}())
	}
	for oldsize < f[0].sizeupvalues {
		f[0].upvalues[func() int32 {
			defer func() {
				oldsize++
			}()
			return oldsize
		}()] = nil
	}
	f[0].upvalues[lu_byte(f[0].nups)] = name
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&name[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			luaC_barrierf(fs[0].L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:], (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&name[0]))) / int64(1))))[:])
		}
	}
	_ = 0
	fs[0].upvalues[:][lu_byte(f[0].nups)].k = lu_byte(v[0].k)
	fs[0].upvalues[:][lu_byte(f[0].nups)].info = lu_byte((*v[0].u.s()).info)
	return int32(uint8((func() lu_byte {
		tempVar := &f[0].nups
		defer func() {
			*tempVar++
		}()
		return *tempVar
	}())))
}

// searchvar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29289
func searchvar(fs []FuncState, n []TString) int32 {
	var i int32
	for i = int32(uint8((lu_byte(fs[0].nactvar)))) - 1; i >= 0; i-- {
		if (int64(uintptr(unsafe.Pointer(&n[0])))/int64(24) - int64(uintptr(unsafe.Pointer(&((fs)[0].f[0].locvars[(fs)[0].actvar[:][i]]).varname[0])))/int64(24)) == 0 {
			return i
		}
	}
	return -1
}

// markupval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29299
func markupval(fs []FuncState, level int32) {
	var bl []BlockCnt = fs[0].bl
	for bl != nil && int32(uint8((lu_byte(bl[0].nactvar)))) > level {
		bl = bl[0].previous
	}
	if bl != nil {
		bl[0].upval = lu_byte(1)
	}
}

// singlevaraux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29306
func singlevaraux(fs []FuncState, n []TString, var_ []expdesc, base int32) (c4goDefaultReturn int32) {
	if len(fs) == 0 {
		init_exp(var_, int32((VGLOBAL)), 1<<uint64(8)-1)
		return int32((VGLOBAL))
	} else {
		var v int32 = searchvar(fs, n)
		if v >= 0 {
			init_exp(var_, int32((VLOCAL)), v)
			if noarch.Not(base) {
				markupval(fs, v)
			}
			return int32((VLOCAL))
		} else {
			if singlevaraux(fs[0].prev, n, var_, 0) == int32((VGLOBAL)) {
				return int32((VGLOBAL))
			}
			(*var_[0].u.s()).info = indexupvalue(fs, n, var_)
			var_[0].k = int32((VUPVAL))
			return int32((VUPVAL))
		}
	}
	return
}

// singlevar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29330
func singlevar(ls []LexState, var_ []expdesc) {
	var varname []TString = str_checkname(ls)
	var fs []FuncState = ls[0].fs
	if singlevaraux(fs, varname, var_, 1) == int32((VGLOBAL)) {
		(*var_[0].u.s()).info = luaK_stringK(fs, varname)
	}
}

// adjust_assign - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29338
func adjust_assign(ls []LexState, nvars int32, nexps int32, e []expdesc) {
	var fs []FuncState = ls[0].fs
	var extra int32 = nvars - nexps
	if uint32(e[0].k) == uint32(int32((VCALL))) || uint32(e[0].k) == uint32(int32((VVARARG))) {
		extra++
		if extra < 0 {
			extra = 0
		}
		luaK_setreturns(fs, e, extra)
		if extra > 1 {
			luaK_reserveregs(fs, extra-1)
		}
	} else {
		if uint32(e[0].k) != uint32(int32((VVOID))) {
			luaK_exp2nextreg(fs, e)
		}
		if extra > 0 {
			var reg int32 = fs[0].freereg
			luaK_reserveregs(fs, extra)
			luaK_nil(fs, reg, extra)
		}
	}
}

// enterlevel - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29358
func enterlevel(ls []LexState) {
	if int32(func() uint16 {
		tempVar := &ls[0].L[0].nCcalls
		*tempVar++
		return *tempVar
	}()) > 200 {
		luaX_lexerror(ls, []byte("chunk has too many syntax levels\x00"), 0)
	}
}

// enterblock - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29367
func enterblock(fs []FuncState, bl []BlockCnt, isbreakable lu_byte) {
	bl[0].breaklist = -1
	bl[0].isbreakable = isbreakable
	bl[0].nactvar = lu_byte(fs[0].nactvar)
	bl[0].upval = lu_byte(0)
	bl[0].previous = fs[0].bl
	fs[0].bl = bl
	_ = 0
}

// leaveblock - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29378
func leaveblock(fs []FuncState) {
	var bl []BlockCnt = fs[0].bl
	fs[0].bl = bl[0].previous
	removevars(fs[0].ls, int32(uint8((lu_byte(bl[0].nactvar)))))
	if uint8((lu_byte(bl[0].upval))) != 0 {
		luaK_codeABC(fs, int32((OP_CLOSE)), int32(uint8((lu_byte(bl[0].nactvar)))), 0, 0)
	}
	_ = 0
	_ = 0
	fs[0].freereg = int32(uint8((lu_byte(fs[0].nactvar))))
	luaK_patchtohere(fs, bl[0].breaklist)
}

// pushclosure - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29392
func pushclosure(ls []LexState, func_ []FuncState, v []expdesc) {
	var fs []FuncState = ls[0].fs
	var f []Proto = fs[0].f
	var oldsize int32 = f[0].sizep
	var i int32
	if fs[0].np+1 > f[0].sizep {
		(func() [][]Proto {
			f[0].p = luaM_growaux_(ls[0].L, f[0].p, (*[1000000]int32)(unsafe.Pointer(&(f[0].sizep)))[:], uint(8), 1<<uint64(9+9)-1, []byte("constant table overflow\x00"))
			return f[0].p
		}())
	}
	for oldsize < f[0].sizep {
		f[0].p[func() int32 {
			defer func() {
				oldsize++
			}()
			return oldsize
		}()] = nil
	}
	f[0].p[func() int32 {
		tempVar := &fs[0].np
		defer func() {
			*tempVar++
		}()
		return *tempVar
	}()] = func_[0].f
	{
		if int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0].f[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			luaC_barrierf(ls[0].L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:], (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&func_[0].f[0]))) / int64(1))))[:])
		}
	}
	init_exp(v, int32((VRELOCABLE)), luaK_codeABx(fs, int32((OP_CLOSURE)), 0, uint32(fs[0].np-1)))
	for i = 0; i < int32(uint8((lu_byte(func_[0].f[0].nups)))); i++ {
		var o int32 = func() int32 {
			if int32(uint8((lu_byte(func_[0].upvalues[:][i].k)))) == int32((VLOCAL)) {
				return int32((OP_MOVE))
			}
			return int32((OP_GETUPVAL))
		}()
		luaK_codeABC(fs, o, 0, int32(uint8((lu_byte(func_[0].upvalues[:][i].info)))), 0)
	}
}

// open_func - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29410
func open_func(ls []LexState, fs []FuncState) {
	var L []lua_State = ls[0].L
	var f []Proto = luaF_newproto(L)
	fs[0].f = f
	fs[0].prev = ls[0].fs
	fs[0].ls = ls
	fs[0].L = L
	ls[0].fs = fs
	fs[0].pc = 0
	fs[0].lasttarget = -1
	fs[0].jpc = -1
	fs[0].freereg = 0
	fs[0].nk = 0
	fs[0].np = 0
	fs[0].nlocvars = 0
	fs[0].nactvar = lu_byte(0)
	fs[0].bl = nil
	f[0].source = ls[0].source
	f[0].maxstacksize = lu_byte(2)
	fs[0].h = luaH_new(L, 0, 0)
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&fs[0].h[0]))) / int64(1))))[:]
		i_o[0].tt = 5
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	{
		var i_o []TValue = []TValue((L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:]
		i_o[0].tt = 8 + 1
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := L[0].top
			defer func() {
				L[0].top = L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
}

// close_func - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29438
func close_func(ls []LexState) {
	var L []lua_State = ls[0].L
	var fs []FuncState = ls[0].fs
	var f []Proto = fs[0].f
	removevars(ls, 0)
	luaK_ret(fs, 0, 0)
	f[0].code = func() interface{} {
		if uint(fs[0].pc+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(L, (f[0].code), uint(uint32(f[0].sizecode)*4), uint(uint32(fs[0].pc)*4))
		}
		return luaM_toobig(L)
	}().([]Instruction)
	f[0].sizecode = fs[0].pc
	f[0].lineinfo = func() interface{} {
		if uint(fs[0].pc+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(L, (f[0].lineinfo), uint(uint32(f[0].sizelineinfo)*4), uint(uint32(fs[0].pc)*4))
		}
		return luaM_toobig(L)
	}().([]int32)
	f[0].sizelineinfo = fs[0].pc
	f[0].k = func() interface{} {
		if uint(fs[0].nk+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (f[0].k), uint(uint32(f[0].sizek)*16), uint(uint32(fs[0].nk)*16))
		}
		return luaM_toobig(L)
	}().([]TValue)
	f[0].sizek = fs[0].nk
	f[0].p = func() interface{} {
		if uint(fs[0].np+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, (f[0].p), uint(uint32(f[0].sizep)*8), uint(uint32(fs[0].np)*8))
		}
		return luaM_toobig(L)
	}()
	f[0].sizep = fs[0].np
	f[0].locvars = func() interface{} {
		if uint(int32(fs[0].nlocvars)+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (f[0].locvars), uint(uint32(f[0].sizelocvars)*16), uint(uint32(fs[0].nlocvars)*16))
		}
		return luaM_toobig(L)
	}().([]LocVar)
	f[0].sizelocvars = int32(fs[0].nlocvars)
	f[0].upvalues = func() interface{} {
		if uint(int32(uint8((f[0].nups)))+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, (f[0].upvalues), uint(uint32(f[0].sizeupvalues)*8), uint(uint32(uint8((f[0].nups)))*8))
		}
		return luaM_toobig(L)
	}()
	f[0].sizeupvalues = int32(uint8((lu_byte(f[0].nups))))
	_ = 0
	_ = 0
	ls[0].fs = fs[0].prev
	if fs != nil {
		anchor_token(ls)
	}
	L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(2)*unsafe.Sizeof(L[0].top[0]))))[:]))
}

// luaY_parser - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29465
func luaY_parser(L []lua_State, z []ZIO, buff []Mbuffer, name []byte) []Proto {
	var lexstate LexState
	var funcstate FuncState
	lexstate.buff = buff
	luaX_setinput(L, c4goUnsafeConvert_LexState(&lexstate), z, luaS_newlstr(L, name, uint(noarch.Strlen(name))))
	open_func(c4goUnsafeConvert_LexState(&lexstate), c4goUnsafeConvert_FuncState(&funcstate))
	funcstate.f[0].is_vararg = lu_byte(2)
	luaX_next(c4goUnsafeConvert_LexState(&lexstate))
	chunk(c4goUnsafeConvert_LexState(&lexstate))
	check(c4goUnsafeConvert_LexState(&lexstate), int32((TK_EOS)))
	close_func(c4goUnsafeConvert_LexState(&lexstate))
	_ = 0
	_ = 0
	_ = 0
	return funcstate.f
}

// field - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29489
func field(ls []LexState, v []expdesc) {
	var fs []FuncState = ls[0].fs
	var key expdesc
	luaK_exp2anyreg(fs, v)
	luaX_next(ls)
	checkname(ls, c4goUnsafeConvert_expdesc(&key))
	luaK_indexed(fs, v, c4goUnsafeConvert_expdesc(&key))
}

// yindex - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29500
func yindex(ls []LexState, v []expdesc) {
	luaX_next(ls)
	expr(ls, v)
	luaK_exp2val(ls[0].fs, v)
	checknext(ls, int32(']'))
}

// recfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29525
func recfield(ls []LexState, cc []ConsControl) {
	var fs []FuncState = ls[0].fs
	var reg int32 = ls[0].fs[0].freereg
	var key expdesc
	var val expdesc
	var rkkey int32
	if ls[0].t.token == int32((TK_NAME)) {
		if cc[0].nh > 2147483647-2 {
			errorlimit(fs, 2147483647-2, []byte("items in a constructor\x00"))
		}
		checkname(ls, c4goUnsafeConvert_expdesc(&key))
	} else {
		yindex(ls, c4goUnsafeConvert_expdesc(&key))
	}
	cc[0].nh++
	checknext(ls, int32('='))
	rkkey = luaK_exp2RK(fs, c4goUnsafeConvert_expdesc(&key))
	expr(ls, c4goUnsafeConvert_expdesc(&val))
	luaK_codeABC(fs, int32((OP_SETTABLE)), (*cc[0].t[0].u.s()).info, rkkey, luaK_exp2RK(fs, c4goUnsafeConvert_expdesc(&val)))
	fs[0].freereg = reg
}

// closelistfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29546
func closelistfield(fs []FuncState, cc []ConsControl) {
	if uint32(cc[0].v.k) == uint32(int32((VVOID))) {
		return
	}
	luaK_exp2nextreg(fs, (*[1000000]expdesc)(unsafe.Pointer(&cc[0].v))[:])
	cc[0].v.k = int32((VVOID))
	if cc[0].tostore == 50 {
		luaK_setlist(fs, (*cc[0].t[0].u.s()).info, cc[0].na, cc[0].tostore)
		cc[0].tostore = 0
	}
}

// lastlistfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29557
func lastlistfield(fs []FuncState, cc []ConsControl) {
	if cc[0].tostore == 0 {
		return
	}
	if uint32(cc[0].v.k) == uint32(int32((VCALL))) || uint32(cc[0].v.k) == uint32(int32((VVARARG))) {
		luaK_setreturns(fs, (*[1000000]expdesc)(unsafe.Pointer(&cc[0].v))[:], -1)
		luaK_setlist(fs, (*cc[0].t[0].u.s()).info, cc[0].na, -1)
		cc[0].na--
	} else {
		if uint32(cc[0].v.k) != uint32(int32((VVOID))) {
			luaK_exp2nextreg(fs, (*[1000000]expdesc)(unsafe.Pointer(&cc[0].v))[:])
		}
		luaK_setlist(fs, (*cc[0].t[0].u.s()).info, cc[0].na, cc[0].tostore)
	}
}

// listfield - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29572
func listfield(ls []LexState, cc []ConsControl) {
	expr(ls, (*[1000000]expdesc)(unsafe.Pointer(&cc[0].v))[:])
	if cc[0].na > 2147483647-2 {
		errorlimit(ls[0].fs, 2147483647-2, []byte("items in a constructor\x00"))
	}
	cc[0].na++
	cc[0].tostore++
}

// constructor - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29580
func constructor(ls []LexState, t []expdesc) {
	var fs []FuncState = ls[0].fs
	var line int32 = ls[0].linenumber
	var pc int32 = luaK_codeABC(fs, int32((OP_NEWTABLE)), 0, 0, 0)
	var cc ConsControl
	cc.tostore = 0
	cc.nh = cc.tostore
	cc.na = cc.nh
	cc.t = t
	init_exp(t, int32((VRELOCABLE)), pc)
	init_exp((*[1000000]expdesc)(unsafe.Pointer(&cc.v))[:], int32((VVOID)), 0)
	luaK_exp2nextreg(ls[0].fs, t)
	checknext(ls, int32('{'))
	for {
		_ = 0
		if ls[0].t.token == int32('}') {
			break
		}
		closelistfield(fs, c4goUnsafeConvert_ConsControl(&cc))
		switch ls[0].t.token {
		case TK_NAME:
			luaX_lookahead(ls)
			if ls[0].lookahead.token != int32('=') {
				listfield(ls, c4goUnsafeConvert_ConsControl(&cc))
			} else {
				recfield(ls, c4goUnsafeConvert_ConsControl(&cc))
			}
		case '[':
			recfield(ls, c4goUnsafeConvert_ConsControl(&cc))
		default:
			listfield(ls, c4goUnsafeConvert_ConsControl(&cc))
			break
		}
		if !(testnext(ls, int32(',')) != 0 || testnext(ls, int32(';')) != 0) {
			break
		}
	}
	check_match(ls, int32('}'), int32('{'), line)
	lastlistfield(fs, c4goUnsafeConvert_ConsControl(&cc))
	fs[0].f[0].code[pc] = fs[0].f[0].code[pc] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9)) | Instruction(luaO_int2fb(uint32(cc.na)))<<uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8+9))
	fs[0].f[0].code[pc] = fs[0].f[0].code[pc] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8)) | Instruction(luaO_int2fb(uint32(cc.nh)))<<uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8))
}

// parlist - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29625
func parlist(ls []LexState) {
	var fs []FuncState = ls[0].fs
	var f []Proto = fs[0].f
	var nparams int32
	f[0].is_vararg = lu_byte(0)
	if ls[0].t.token != int32(')') {
		for {
			switch ls[0].t.token {
			case TK_NAME:
				new_localvar(ls, str_checkname(ls), func() int32 {
					defer func() {
						nparams++
					}()
					return nparams
				}())
			case TK_DOTS:
				luaX_next(ls)
				new_localvar(ls, luaX_newstring(ls, []byte("arg\x00"), uint(4/1-1)), func() int32 {
					defer func() {
						nparams++
					}()
					return nparams
				}())
				f[0].is_vararg = lu_byte((uint8(1 | 4)))
				f[0].is_vararg |= lu_byte((uint8(2)))
			default:
				luaX_syntaxerror(ls, []byte("<name> or '...' expected\x00"))
			}
			if !(noarch.Not(lu_byte(f[0].is_vararg)) && testnext(ls, int32(',')) != 0) {
				break
			}
		}
	}
	adjustlocalvars(ls, nparams)
	f[0].numparams = lu_byte(int32(uint8((lu_byte(fs[0].nactvar)))) - int32(uint8((lu_byte(f[0].is_vararg))))&1)
	luaK_reserveregs(fs, int32(uint8((lu_byte(fs[0].nactvar)))))
}

// body - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29658
func body(ls []LexState, e []expdesc, needself int32, line int32) {
	var new_fs FuncState
	open_func(ls, c4goUnsafeConvert_FuncState(&new_fs))
	new_fs.f[0].linedefined = line
	checknext(ls, int32('('))
	if needself != 0 {
		new_localvar(ls, luaX_newstring(ls, []byte("self\x00"), uint(5/1-1)), 0)
		adjustlocalvars(ls, 1)
	}
	parlist(ls)
	checknext(ls, int32(')'))
	chunk(ls)
	new_fs.f[0].lastlinedefined = ls[0].linenumber
	check_match(ls, int32((TK_END)), int32((TK_FUNCTION)), line)
	close_func(ls)
	pushclosure(ls, c4goUnsafeConvert_FuncState(&new_fs), e)
}

// explist1 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29678
func explist1(ls []LexState, v []expdesc) int32 {
	var n int32 = 1
	expr(ls, v)
	for testnext(ls, int32(',')) != 0 {
		luaK_exp2nextreg(ls[0].fs, v)
		expr(ls, v)
		n++
	}
	return n
}

// funcargs - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29691
func funcargs(ls []LexState, f []expdesc) {
	var fs []FuncState = ls[0].fs
	var args expdesc
	var base int32
	var nparams int32
	var line int32 = ls[0].linenumber
	switch ls[0].t.token {
	case '(':
		if line != ls[0].lastline {
			luaX_syntaxerror(ls, []byte("ambiguous syntax (function call x new statement)\x00"))
		}
		luaX_next(ls)
		if ls[0].t.token == int32(')') {
			args.k = int32((VVOID))
		} else {
			explist1(ls, c4goUnsafeConvert_expdesc(&args))
			luaK_setreturns(fs, c4goUnsafeConvert_expdesc(&args), -1)
		}
		check_match(ls, int32(')'), int32('('), line)
	case '{':
		constructor(ls, c4goUnsafeConvert_expdesc(&args))
	case TK_STRING:
		codestring(ls, c4goUnsafeConvert_expdesc(&args), (*ls[0].t.seminfo.ts()))
		luaX_next(ls)
	default:
		luaX_syntaxerror(ls, []byte("function arguments expected\x00"))
		return
	}
	_ = 0
	base = (*f[0].u.s()).info
	if uint32(args.k) == uint32(int32((VCALL))) || uint32(args.k) == uint32(int32((VVARARG))) {
		nparams = -1
	} else {
		if uint32(args.k) != uint32(int32((VVOID))) {
			luaK_exp2nextreg(fs, c4goUnsafeConvert_expdesc(&args))
		}
		nparams = fs[0].freereg - (base + 1)
	}
	init_exp(f, int32((VCALL)), luaK_codeABC(fs, int32((OP_CALL)), base, nparams+1, 2))
	luaK_fixline(fs, line)
	fs[0].freereg = base + 1
}

// prefixexp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29749
func prefixexp(ls []LexState, v []expdesc) {
	switch ls[0].t.token {
	case '(':
		var line int32 = ls[0].linenumber
		luaX_next(ls)
		expr(ls, v)
		check_match(ls, int32(')'), int32('('), line)
		luaK_dischargevars(ls[0].fs, v)
		return
	case TK_NAME:
		singlevar(ls, v)
		return
	default:
		luaX_syntaxerror(ls, []byte("unexpected symbol\x00"))
		return
	}
}

// primaryexp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29772
func primaryexp(ls []LexState, v []expdesc) {
	var fs []FuncState = ls[0].fs
	prefixexp(ls, v)
	for {
		switch ls[0].t.token {
		case '.':
			field(ls, v)
		case '[':
			var key expdesc
			luaK_exp2anyreg(fs, v)
			yindex(ls, c4goUnsafeConvert_expdesc(&key))
			luaK_indexed(fs, v, c4goUnsafeConvert_expdesc(&key))
		case ':':
			var key expdesc
			luaX_next(ls)
			checkname(ls, c4goUnsafeConvert_expdesc(&key))
			luaK_self(fs, v, c4goUnsafeConvert_expdesc(&key))
			funcargs(ls, v)
		case '(':
			fallthrough
		case TK_STRING:
			fallthrough
		case '{':
			luaK_exp2nextreg(fs, v)
			funcargs(ls, v)
		default:
			return
		}
	}
}

// simpleexp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29809
func simpleexp(ls []LexState, v []expdesc) {
	switch ls[0].t.token {
	case TK_NUMBER:
		init_exp(v, int32((VKNUM)), 0)
		(*v[0].u.nval()) = lua_Number((*ls[0].t.seminfo.r()))
	case TK_STRING:
		codestring(ls, v, (*ls[0].t.seminfo.ts()))
	case TK_NIL:
		init_exp(v, int32((VNIL)), 0)
	case TK_TRUE:
		init_exp(v, int32((VTRUE)), 0)
	case TK_FALSE:
		init_exp(v, int32((VFALSE)), 0)
	case TK_DOTS:
		var fs []FuncState = ls[0].fs
		{
			if noarch.Not(fs[0].f[0].is_vararg) {
				luaX_syntaxerror(ls, []byte("cannot use '...' outside a vararg function\x00"))
			}
		}
		fs[0].f[0].is_vararg &= lu_byte((uint8(^4)))
		init_exp(v, int32((VVARARG)), luaK_codeABC(fs, int32((OP_VARARG)), 0, 1, 0))
	case '{':
		constructor(ls, v)
		return
	case TK_FUNCTION:
		luaX_next(ls)
		body(ls, v, 0, ls[0].linenumber)
		return
	default:
		primaryexp(ls, v)
		return
	}
	luaX_next(ls)
}

// getunopr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29860
func getunopr(op int32) (c4goDefaultReturn UnOpr) {
	switch op {
	case TK_NOT:
		return int32((OPR_NOT))
	case '-':
		return int32((OPR_MINUS))
	case '#':
		return int32((OPR_LEN))
	default:
		return int32((OPR_NOUNOPR))
	}
	return
}

// getbinopr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29870
func getbinopr(op int32) (c4goDefaultReturn BinOpr) {
	switch op {
	case '+':
		return int32((OPR_ADD))
	case '-':
		return int32((OPR_SUB))
	case '*':
		return int32((OPR_MUL))
	case '/':
		return int32((OPR_DIV))
	case '%':
		return int32((OPR_MOD))
	case '^':
		return int32((OPR_POW))
	case TK_CONCAT:
		return int32((OPR_CONCAT))
	case TK_NE:
		return int32((OPR_NE))
	case TK_EQ:
		return int32((OPR_EQ))
	case '<':
		return int32((OPR_LT))
	case TK_LE:
		return int32((OPR_LE))
	case '>':
		return int32((OPR_GT))
	case TK_GE:
		return int32((OPR_GE))
	case TK_AND:
		return int32((OPR_AND))
	case TK_OR:
		return int32((OPR_OR))
	default:
		return int32((OPR_NOBINOPR))
	}
	return
}

// subexpr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29910
func subexpr(ls []LexState, v []expdesc, limit uint32) BinOpr {
	var op BinOpr
	var uop UnOpr
	enterlevel(ls)
	uop = getunopr(ls[0].t.token)
	if uop != uint32(int32((OPR_NOUNOPR))) {
		luaX_next(ls)
		subexpr(ls, v, 8)
		luaK_prefix(ls[0].fs, uop, v)
	} else {
		simpleexp(ls, v)
	}
	op = getbinopr(ls[0].t.token)
	for op != uint32(int32((OPR_NOBINOPR))) && uint32(uint8((lu_byte(priority[op].left)))) > limit {
		var v2 expdesc
		var nextop BinOpr
		luaX_next(ls)
		luaK_infix(ls[0].fs, op, v)
		nextop = subexpr(ls, c4goUnsafeConvert_expdesc(&v2), uint32(uint8((lu_byte(priority[op].right)))))
		luaK_posfix(ls[0].fs, op, v, c4goUnsafeConvert_expdesc(&v2))
		op = nextop
	}
	(ls)[0].L[0].nCcalls -= uint16(1)
	return op
}

// expr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29938
func expr(ls []LexState, v []expdesc) {
	subexpr(ls, v, 0)
}

// block_follow - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29953
func block_follow(token int32) (c4goDefaultReturn int32) {
	switch token {
	case TK_ELSE:
		fallthrough
	case TK_ELSEIF:
		fallthrough
	case TK_END:
		fallthrough
	case TK_UNTIL:
		fallthrough
	case TK_EOS:
		return 1
	default:
		return 0
	}
	return
}

// block - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29963
func block(ls []LexState) {
	var fs []FuncState = ls[0].fs
	var bl BlockCnt
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl), lu_byte(0))
	chunk(ls)
	_ = 0
	leaveblock(fs)
}

// check_conflict - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:29990
func check_conflict(ls []LexState, lh []LHS_assign, v []expdesc) {
	var fs []FuncState = ls[0].fs
	var extra int32 = fs[0].freereg
	var conflict int32
	for ; lh != nil; lh = lh[0].prev {
		if uint32(lh[0].v.k) == uint32(int32((VINDEXED))) {
			if (*lh[0].v.u.s()).info == (*v[0].u.s()).info {
				conflict = 1
				(*lh[0].v.u.s()).info = extra
			}
			if (*lh[0].v.u.s()).aux == (*v[0].u.s()).info {
				conflict = 1
				(*lh[0].v.u.s()).aux = extra
			}
		}
	}
	if conflict != 0 {
		luaK_codeABC(fs, int32((OP_MOVE)), fs[0].freereg, (*v[0].u.s()).info, 0)
		luaK_reserveregs(fs, 1)
	}
}

// assignment - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30013
func assignment(ls []LexState, lh []LHS_assign, nvars int32) {
	var e expdesc
	{
		if !(uint32(int32((VLOCAL))) <= uint32(lh[0].v.k) && uint32(lh[0].v.k) <= uint32(int32((VINDEXED)))) {
			luaX_syntaxerror(ls, []byte("syntax error\x00"))
		}
	}
	if testnext(ls, int32(',')) != 0 {
		var nv LHS_assign
		nv.prev = lh
		primaryexp(ls, (*[1000000]expdesc)(unsafe.Pointer(&nv.v))[:])
		if uint32(nv.v.k) == uint32(int32((VLOCAL))) {
			check_conflict(ls, lh, (*[1000000]expdesc)(unsafe.Pointer(&nv.v))[:])
		}
		if nvars > 200-int32(ls[0].L[0].nCcalls) {
			errorlimit(ls[0].fs, 200-int32(ls[0].L[0].nCcalls), []byte("variables in assignment\x00"))
		}
		assignment(ls, c4goUnsafeConvert_LHS_assign(&nv), nvars+1)
	} else {
		var nexps int32
		checknext(ls, int32('='))
		nexps = explist1(ls, c4goUnsafeConvert_expdesc(&e))
		if nexps != nvars {
			adjust_assign(ls, nvars, nexps, c4goUnsafeConvert_expdesc(&e))
			if nexps > nvars {
				ls[0].fs[0].freereg -= nexps - nvars
			}
		} else {
			luaK_setoneret(ls[0].fs, c4goUnsafeConvert_expdesc(&e))
			luaK_storevar(ls[0].fs, (*[1000000]expdesc)(unsafe.Pointer(&lh[0].v))[:], c4goUnsafeConvert_expdesc(&e))
			return
		}
	}
	init_exp(c4goUnsafeConvert_expdesc(&e), int32((VNONRELOC)), ls[0].fs[0].freereg-1)
	luaK_storevar(ls[0].fs, (*[1000000]expdesc)(unsafe.Pointer(&lh[0].v))[:], c4goUnsafeConvert_expdesc(&e))
}

// cond - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30047
func cond(ls []LexState) int32 {
	var v expdesc
	expr(ls, c4goUnsafeConvert_expdesc(&v))
	if uint32(v.k) == uint32(int32((VNIL))) {
		v.k = int32((VFALSE))
	}
	luaK_goiftrue(ls[0].fs, c4goUnsafeConvert_expdesc(&v))
	return v.f
}

// breakstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30057
func breakstat(ls []LexState) {
	var fs []FuncState = ls[0].fs
	var bl []BlockCnt = fs[0].bl
	var upval int32
	for bl != nil && noarch.Not(lu_byte(bl[0].isbreakable)) {
		upval |= int32(uint8((lu_byte(bl[0].upval))))
		bl = bl[0].previous
	}
	if bl == nil {
		luaX_syntaxerror(ls, []byte("no loop to break\x00"))
	}
	if upval != 0 {
		luaK_codeABC(fs, int32((OP_CLOSE)), int32(uint8((lu_byte(bl[0].nactvar)))), 0, 0)
	}
	luaK_concat(fs, (*[1000000]int32)(unsafe.Pointer(&bl[0].breaklist))[:], luaK_jump(fs))
}

// whilestat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30073
func whilestat(ls []LexState, line int32) {
	var fs []FuncState = ls[0].fs
	var whileinit int32
	var condexit int32
	var bl BlockCnt
	luaX_next(ls)
	whileinit = luaK_getlabel(fs)
	condexit = cond(ls)
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl), lu_byte(1))
	checknext(ls, int32((TK_DO)))
	block(ls)
	luaK_patchlist(fs, luaK_jump(fs), whileinit)
	check_match(ls, int32((TK_END)), int32((TK_WHILE)), line)
	leaveblock(fs)
	luaK_patchtohere(fs, condexit)
}

// repeatstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30092
func repeatstat(ls []LexState, line int32) {
	var condexit int32
	var fs []FuncState = ls[0].fs
	var repeat_init int32 = luaK_getlabel(fs)
	var bl1 BlockCnt
	var bl2 BlockCnt
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl1), lu_byte(1))
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl2), lu_byte(0))
	luaX_next(ls)
	chunk(ls)
	check_match(ls, int32((TK_UNTIL)), int32((TK_REPEAT)), line)
	condexit = cond(ls)
	if noarch.Not(lu_byte(bl2.upval)) {
		leaveblock(fs)
		luaK_patchlist(ls[0].fs, condexit, repeat_init)
	} else {
		breakstat(ls)
		luaK_patchtohere(ls[0].fs, condexit)
		leaveblock(fs)
		luaK_patchlist(ls[0].fs, luaK_jump(fs), repeat_init)
	}
	leaveblock(fs)
}

// exp1 - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30118
func exp1(ls []LexState) int32 {
	var e expdesc
	var k int32
	expr(ls, c4goUnsafeConvert_expdesc(&e))
	k = e.k
	luaK_exp2nextreg(ls[0].fs, c4goUnsafeConvert_expdesc(&e))
	return k
}

// forbody - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30128
func forbody(ls []LexState, base int32, line int32, nvars int32, isnum int32) {
	var bl BlockCnt
	var fs []FuncState = ls[0].fs
	var prep int32
	var endfor int32
	adjustlocalvars(ls, 3)
	checknext(ls, int32((TK_DO)))
	prep = func() int32 {
		if isnum != 0 {
			return luaK_codeABx(fs, int32((OP_FORPREP)), base, uint32(-1+(1<<uint64(9+9)-1)>>uint64(1)))
		}
		return luaK_jump(fs)
	}()
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl), lu_byte(0))
	adjustlocalvars(ls, nvars)
	luaK_reserveregs(fs, nvars)
	block(ls)
	leaveblock(fs)
	luaK_patchtohere(fs, prep)
	endfor = func() int32 {
		if isnum != 0 {
			return luaK_codeABx(fs, int32((OP_FORLOOP)), base, uint32(-1+(1<<uint64(9+9)-1)>>uint64(1)))
		}
		return luaK_codeABC(fs, int32((OP_TFORLOOP)), base, 0, nvars)
	}()
	luaK_fixline(fs, line)
	luaK_patchlist(fs, func() int32 {
		if isnum != 0 {
			return endfor
		}
		return luaK_jump(fs)
	}(), prep+1)
}

// fornum - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30149
func fornum(ls []LexState, varname []TString, line int32) {
	var fs []FuncState = ls[0].fs
	var base int32 = fs[0].freereg
	new_localvar(ls, luaX_newstring(ls, []byte("(for index)\x00"), uint(12/1-1)), 0)
	new_localvar(ls, luaX_newstring(ls, []byte("(for limit)\x00"), uint(12/1-1)), 1)
	new_localvar(ls, luaX_newstring(ls, []byte("(for step)\x00"), uint(11/1-1)), 2)
	new_localvar(ls, varname, 3)
	checknext(ls, int32('='))
	exp1(ls)
	checknext(ls, int32(','))
	exp1(ls)
	if testnext(ls, int32(',')) != 0 {
		exp1(ls)
	} else {
		luaK_codeABx(fs, int32((OP_LOADK)), fs[0].freereg, uint32(luaK_numberK(fs, 1)))
		luaK_reserveregs(fs, 1)
	}
	forbody(ls, base, line, 1, 1)
}

// forlist - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30171
func forlist(ls []LexState, indexname []TString) {
	var fs []FuncState = ls[0].fs
	var e expdesc
	var nvars int32
	var line int32
	var base int32 = fs[0].freereg
	new_localvar(ls, luaX_newstring(ls, []byte("(for generator)\x00"), uint(16/1-1)), func() int32 {
		defer func() {
			nvars++
		}()
		return nvars
	}())
	new_localvar(ls, luaX_newstring(ls, []byte("(for state)\x00"), uint(12/1-1)), func() int32 {
		defer func() {
			nvars++
		}()
		return nvars
	}())
	new_localvar(ls, luaX_newstring(ls, []byte("(for control)\x00"), uint(14/1-1)), func() int32 {
		defer func() {
			nvars++
		}()
		return nvars
	}())
	new_localvar(ls, indexname, func() int32 {
		defer func() {
			nvars++
		}()
		return nvars
	}())
	for testnext(ls, int32(',')) != 0 {
		new_localvar(ls, str_checkname(ls), func() int32 {
			defer func() {
				nvars++
			}()
			return nvars
		}())
	}
	checknext(ls, int32((TK_IN)))
	line = ls[0].linenumber
	adjust_assign(ls, 3, explist1(ls, c4goUnsafeConvert_expdesc(&e)), c4goUnsafeConvert_expdesc(&e))
	luaK_checkstack(fs, 3)
	forbody(ls, base, line, nvars-3, 0)
}

// forstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30194
func forstat(ls []LexState, line int32) {
	var fs []FuncState = ls[0].fs
	var varname []TString
	var bl BlockCnt
	enterblock(fs, c4goUnsafeConvert_BlockCnt(&bl), lu_byte(1))
	luaX_next(ls)
	varname = str_checkname(ls)
	switch ls[0].t.token {
	case '=':
		fornum(ls, varname, line)
	case ',':
		fallthrough
	case TK_IN:
		forlist(ls, varname)
	default:
		luaX_syntaxerror(ls, []byte("'=' or 'in' expected\x00"))
	}
	check_match(ls, int32((TK_END)), int32((TK_FOR)), line)
	leaveblock(fs)
}

// test_then_block - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30212
func test_then_block(ls []LexState) int32 {
	var condexit int32
	luaX_next(ls)
	condexit = cond(ls)
	checknext(ls, int32((TK_THEN)))
	block(ls)
	return condexit
}

// ifstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30223
func ifstat(ls []LexState, line int32) {
	var fs []FuncState = ls[0].fs
	var flist int32
	var escapelist int32 = -1
	flist = test_then_block(ls)
	for ls[0].t.token == int32((TK_ELSEIF)) {
		luaK_concat(fs, c4goUnsafeConvert_int32(&escapelist), luaK_jump(fs))
		luaK_patchtohere(fs, flist)
		flist = test_then_block(ls)
	}
	if ls[0].t.token == int32((TK_ELSE)) {
		luaK_concat(fs, c4goUnsafeConvert_int32(&escapelist), luaK_jump(fs))
		luaK_patchtohere(fs, flist)
		luaX_next(ls)
		block(ls)
	} else {
		luaK_concat(fs, c4goUnsafeConvert_int32(&escapelist), flist)
	}
	luaK_patchtohere(fs, escapelist)
	check_match(ls, int32((TK_END)), int32((TK_IF)), line)
}

// localfunc - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30247
func localfunc(ls []LexState) {
	var v expdesc
	var b expdesc
	var fs []FuncState = ls[0].fs
	new_localvar(ls, str_checkname(ls), 0)
	init_exp(c4goUnsafeConvert_expdesc(&v), int32((VLOCAL)), fs[0].freereg)
	luaK_reserveregs(fs, 1)
	adjustlocalvars(ls, 1)
	body(ls, c4goUnsafeConvert_expdesc(&b), 0, ls[0].linenumber)
	luaK_storevar(fs, c4goUnsafeConvert_expdesc(&v), c4goUnsafeConvert_expdesc(&b))
	((fs)[0].f[0].locvars[(fs)[0].actvar[:][int32(uint8((lu_byte(fs[0].nactvar))))-1]]).startpc = fs[0].pc
}

// localstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30261
func localstat(ls []LexState) {
	var nvars int32
	var nexps int32
	var e expdesc
	for {
		new_localvar(ls, str_checkname(ls), func() int32 {
			defer func() {
				nvars++
			}()
			return nvars
		}())
		if noarch.Not(testnext(ls, int32(','))) {
			break
		}
	}
	if testnext(ls, int32('=')) != 0 {
		nexps = explist1(ls, c4goUnsafeConvert_expdesc(&e))
	} else {
		e.k = int32((VVOID))
		nexps = 0
	}
	adjust_assign(ls, nvars, nexps, c4goUnsafeConvert_expdesc(&e))
	adjustlocalvars(ls, nvars)
}

// funcname - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30280
func funcname(ls []LexState, v []expdesc) int32 {
	var needself int32
	singlevar(ls, v)
	for ls[0].t.token == int32('.') {
		field(ls, v)
	}
	if ls[0].t.token == int32(':') {
		needself = 1
		field(ls, v)
	}
	return needself
}

// funcstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30294
func funcstat(ls []LexState, line int32) {
	var needself int32
	var v expdesc
	var b expdesc
	luaX_next(ls)
	needself = funcname(ls, c4goUnsafeConvert_expdesc(&v))
	body(ls, c4goUnsafeConvert_expdesc(&b), needself, line)
	luaK_storevar(ls[0].fs, c4goUnsafeConvert_expdesc(&v), c4goUnsafeConvert_expdesc(&b))
	luaK_fixline(ls[0].fs, line)
}

// exprstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30306
func exprstat(ls []LexState) {
	var fs []FuncState = ls[0].fs
	var v LHS_assign
	primaryexp(ls, (*[1000000]expdesc)(unsafe.Pointer(&v.v))[:])
	if uint32(v.v.k) == uint32(int32((VCALL))) {
		(func() Instruction {
			(fs)[0].f[0].code[(*((*[1000000]expdesc)(unsafe.Pointer(&v.v))[:])[0].u.s()).info] = (fs)[0].f[0].code[(*((*[1000000]expdesc)(unsafe.Pointer(&v.v))[:])[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8)) | Instruction(1)<<uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0+6+8))
			return (fs)[0].f[0].code[(*((*[1000000]expdesc)(unsafe.Pointer(&v.v))[:])[0].u.s()).info]
		}())
	} else {
		v.prev = nil
		assignment(ls, c4goUnsafeConvert_LHS_assign(&v), 1)
	}
}

// retstat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30320
func retstat(ls []LexState) {
	var fs []FuncState = ls[0].fs
	var e expdesc
	var first int32
	var nret int32
	luaX_next(ls)
	if block_follow(ls[0].t.token) != 0 || ls[0].t.token == int32(';') {
		nret = 0
		first = nret
	} else {
		nret = explist1(ls, c4goUnsafeConvert_expdesc(&e))
		if uint32(e.k) == uint32(int32((VCALL))) || uint32(e.k) == uint32(int32((VVARARG))) {
			luaK_setreturns(fs, c4goUnsafeConvert_expdesc(&e), -1)
			if uint32(e.k) == uint32(int32((VCALL))) && nret == 1 {
				(fs)[0].f[0].code[(*(c4goUnsafeConvert_expdesc(&e))[0].u.s()).info] = (fs)[0].f[0].code[(*(c4goUnsafeConvert_expdesc(&e))[0].u.s()).info] & ^(^(^Instruction(0)<<uint64(6))<<uint64(0)) | Instruction(OP_TAILCALL)<<uint64(0)&(^(^Instruction(0)<<uint64(6))<<uint64(0))
				_ = 0
			}
			first = int32(uint8((lu_byte(fs[0].nactvar))))
			nret = -1
		} else {
			if nret == 1 {
				first = luaK_exp2anyreg(fs, c4goUnsafeConvert_expdesc(&e))
			} else {
				luaK_exp2nextreg(fs, c4goUnsafeConvert_expdesc(&e))
				first = int32(uint8((lu_byte(fs[0].nactvar))))
				_ = 0
			}
		}
	}
	luaK_ret(fs, first, nret)
}

// statement - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30353
func statement(ls []LexState) (c4goDefaultReturn int32) {
	var line int32 = ls[0].linenumber
	switch ls[0].t.token {
	case TK_IF:
		ifstat(ls, line)
		return 0
	case TK_WHILE:
		whilestat(ls, line)
		return 0
	case TK_DO:
		luaX_next(ls)
		block(ls)
		check_match(ls, int32((TK_END)), int32((TK_DO)), line)
		return 0
	case TK_FOR:
		forstat(ls, line)
		return 0
	case TK_REPEAT:
		repeatstat(ls, line)
		return 0
	case TK_FUNCTION:
		funcstat(ls, line)
		return 0
	case TK_LOCAL:
		luaX_next(ls)
		if testnext(ls, int32((TK_FUNCTION))) != 0 {
			localfunc(ls)
		} else {
			localstat(ls)
		}
		return 0
	case TK_RETURN:
		retstat(ls)
		return 1
	case TK_BREAK:
		luaX_next(ls)
		breakstat(ls)
		return 1
	default:
		exprstat(ls)
		return 0
	}
	return
}

// chunk - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30407
func chunk(ls []LexState) {
	var islast int32
	enterlevel(ls)
	for noarch.Not(islast) && noarch.Not(block_follow(ls[0].t.token)) {
		islast = statement(ls)
		testnext(ls, int32(';'))
		_ = 0
		ls[0].fs[0].freereg = int32(uint8((lu_byte(ls[0].fs[0].nactvar))))
	}
	(ls)[0].L[0].nCcalls -= uint16(1)
}

// stack_init - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30467
func stack_init(L1 []lua_State, L []lua_State) {
	L1[0].base_ci = func() interface{} {
		if uint(8+1) <= (uint(^uint(0))-uint(2))/uint(40) {
			return luaM_realloc_(L, nil, uint(uint32(0)*40), uint(uint32(8)*40))
		}
		return luaM_toobig(L)
	}().([]CallInfo)
	L1[0].ci = L1[0].base_ci
	L1[0].size_ci = 8
	L1[0].end_ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&L1[0].base_ci[0+L1[0].size_ci:][0])) - (uintptr)(1)*unsafe.Sizeof(L1[0].base_ci[0+L1[0].size_ci:][0]))))[:]
	L1[0].stack = StkId((func() interface{} {
		if uint(2*20+5+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, nil, uint(uint32(0)*16), uint(uint32(2*20+5)*16))
		}
		return luaM_toobig(L)
	}().([]TValue)))
	L1[0].stacksize = 2*20 + 5
	L1[0].top = StkId(L1[0].stack)
	L1[0].stack_last = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L1[0].stack)[0])) + (uintptr)(L1[0].stacksize-5)*unsafe.Sizeof(StkId(L1[0].stack)[0]))))[:][0])) - (uintptr)(1)*unsafe.Sizeof((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L1[0].stack)[0])) + (uintptr)(L1[0].stacksize-5)*unsafe.Sizeof(StkId(L1[0].stack)[0]))))[:][0]))))[:]))
	L1[0].ci[0].func_ = StkId(L1[0].top)
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30480 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	(func() StkId {
		tempVar := L1[0].top
		defer func() {
			L1[0].top = L1[0].top[1:]
		}()
		return tempVar
	}())[0].tt = 0
	L1[0].ci[0].base = StkId(L1[0].top)
	L1[0].base = L1[0].ci[0].base
	L1[0].ci[0].top = L1[0].top[0+20:]
}

// freestack - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30486
func freestack(L []lua_State, L1 []lua_State) {
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(40) {
			return luaM_realloc_(L, (L1[0].base_ci), uint(uint32(L1[0].size_ci)*40), uint(uint32(0)*40))
		}
		return luaM_toobig(L)
	}()
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, StkId((L1[0].stack)), uint(uint32(L1[0].stacksize)*16), uint(uint32(0)*16))
		}
		return luaM_toobig(L)
	}()
}

// f_luaopen - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30495
func f_luaopen(L []lua_State, ud interface{}) {
	var g []global_State = L[0].l_G
	_ = ud
	stack_init(L, L)
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaH_new(L, 0, 2)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 5
		_ = 0
	}
	{
		var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:]
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := luaH_new(L, 0, 2)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		i_o[0].tt = 5
		_ = 0
	}
	luaS_resize(L, 32)
	luaT_init(L)
	luaX_init(L)
	(luaS_newlstr(L, []byte("not enough memory\x00"), uint(18/1-1)))[0].tsv.marked |= lu_byte((uint8(1 << uint64(5))))
	g[0].GCthreshold = lu_mem((uint(4 * uint32(uint((lu_mem(g[0].totalbytes)))))))
}

// preinit_state - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30509
func preinit_state(L []lua_State, g []global_State) {
	L[0].l_G = g
	L[0].stack = StkId((nil))
	L[0].stacksize = 0
	L[0].errorJmp = nil
	L[0].hook = nil
	L[0].hookmask = lu_byte(0)
	L[0].basehookcount = 0
	L[0].allowhook = lu_byte(1)
	L[0].hookcount = L[0].basehookcount
	L[0].openupval = nil
	L[0].size_ci = 0
	L[0].baseCcalls = 0
	L[0].nCcalls = L[0].baseCcalls
	L[0].status = lu_byte(0)
	L[0].ci = nil
	L[0].base_ci = L[0].ci
	L[0].savedpc = nil
	L[0].errfunc = 0
	((*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:])[0].tt = 0
}

// close_state - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30530
func close_state(L []lua_State) {
	var g []global_State = L[0].l_G
	luaF_close(L, StkId(L[0].stack))
	luaC_freeall(L)
	_ = 0
	_ = 0
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, ((L[0].l_G)[0].strt.hash), uint(uint32((L[0].l_G)[0].strt.size)*8), uint(uint32(0)*8))
		}
		return luaM_toobig(L)
	}()
	(func() []byte {
		((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer = func() interface{} {
			if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(1) {
				return luaM_realloc_(L, (((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer), ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize*uint(1), uint(uint32(0)*1))
			}
			return luaM_toobig(L)
		}().([]byte)
		return ((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer
	}())
	((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize = 0
	freestack(L, L)
	_ = 0
	g.frealloc(g[0].ud, ((*(*[1000000]lu_byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*[1000000]lu_byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:][0])) - (uintptr)(0)*unsafe.Sizeof((*[1000000]lu_byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:][0]))))[:]), uint(672+0), 0)
}

// luaE_newthread - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30544
func luaE_newthread(L []lua_State) []lua_State {
	var L1 []lua_State = (*[1000000]lua_State)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(luaM_realloc_(L, nil, 0, uint(176+0)).([]lu_byte))[0+0]))) / int64(1))))[:]
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L1[0]))) / int64(1))))[:], lu_byte(8))
	preinit_state(L1, L[0].l_G)
	stack_init(L1, L)
	{
		var o2 []TValue = ((*[1000000]TValue)(unsafe.Pointer(&L[0].l_gt))[:])
		var o1 []TValue = (*[1000000]TValue)(unsafe.Pointer(&L1[0].l_gt))[:]
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	L1[0].hookmask = lu_byte(L[0].hookmask)
	L1[0].basehookcount = L[0].basehookcount
	L1[0].hook = lua_Hook(L[0].hook)
	L1[0].hookcount = L1[0].basehookcount
	_ = 0
	return L1
}

// luaE_freethread - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30559
func luaE_freethread(L []lua_State, L1 []lua_State) {
	luaF_close(L1, StkId(L1[0].stack))
	_ = 0
	_ = L1
	freestack(L, L1)
	luaM_realloc_(L, ((*(*[1000000]lu_byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*[1000000]lu_byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L1[0]))) / int64(1))))[:][0])) - (uintptr)(0)*unsafe.Sizeof((*[1000000]lu_byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L1[0]))) / int64(1))))[:][0]))))[:]), uint(176+0), 0)
}

// lua_newstate - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30568
func lua_newstate(f lua_Alloc, ud interface{}) []lua_State {
	var i int32
	var L []lua_State
	var g []global_State
	var l interface{} = f(ud, nil, 0, uint(672+0))
	if l == nil {
		return nil
	}
	L = (*[1000000]lua_State)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(l.([]lu_byte))[0+0]))) / int64(1))))[:]
	g = (*[1000000]global_State)(unsafe.Pointer(&((*[1000000]LG)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:])[0].g))[:]
	L[0].next = nil
	L[0].tt = lu_byte(8)
	g[0].currentwhite = lu_byte((uint8(1<<uint64(0) | 1<<uint64(5))))
	L[0].marked = lu_byte(int32(uint8((lu_byte((g)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))
	L[0].marked |= lu_byte((uint8(1<<uint64(5) | 1<<uint64(6))))
	preinit_state(L, g)
	g[0].frealloc = f
	g[0].ud = ud
	g[0].mainthread = L
	(*g[0].uvhead.u.l()).prev = (*[1000000]UpVal)(unsafe.Pointer(&g[0].uvhead))[:]
	(*g[0].uvhead.u.l()).next = (*[1000000]UpVal)(unsafe.Pointer(&g[0].uvhead))[:]
	g[0].GCthreshold = 0
	g[0].strt.size = 0
	g[0].strt.nuse = 0
	g[0].strt.hash = nil
	((*[1000000]TValue)(unsafe.Pointer(&(L[0].l_G)[0].l_registry))[:])[0].tt = 0
	((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffer = nil
	((*[1000000]Mbuffer)(unsafe.Pointer(&g[0].buff))[:])[0].buffsize = 0
	g[0].panic_ = nil
	g[0].gcstate = lu_byte(0)
	g[0].rootgc = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&L[0]))) / int64(1))))[:]
	g[0].sweepstrgc = 0
	g[0].sweepgc = (*[1000000][]GCObject)(unsafe.Pointer(&g[0].rootgc))[:]
	g[0].gray = nil
	g[0].grayagain = nil
	g[0].weak = nil
	g[0].tmudata = nil
	g[0].totalbytes = lu_mem((uint(672)))
	g[0].gcpause = 200
	g[0].gcstepmul = 200
	g[0].gcdept = 0
	for i = 0; i < 8+1; i++ {
		g[0].mt[:][i] = nil
	}
	if luaD_rawrunprotected(L, f_luaopen, nil) != 0 {
		close_state(L)
		L = nil
	} else {
		_ = (L)
	}
	return L
}

// callallgcTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30618
func callallgcTM(L []lua_State, ud interface{}) {
	_ = ud
	luaC_callGCTM(L)
}

// lua_close - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30624
func lua_close(L []lua_State) {
	L = (L[0].l_G)[0].mainthread
	_ = 0
	luaF_close(L, StkId(L[0].stack))
	luaC_separateudata(L, 1)
	L[0].errfunc = 0
	for {
		L[0].ci = L[0].base_ci
		L[0].top = StkId(L[0].ci[0].base)
		L[0].base = L[0].top
		L[0].baseCcalls = 0
		L[0].nCcalls = L[0].baseCcalls
		if !(luaD_rawrunprotected(L, callallgcTM, nil) != 0) {
			break
		}
	}
	_ = 0
	_ = L
	close_state(L)
}

// luaS_resize - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30665
func luaS_resize(L []lua_State, newsize int32) {
	var newhash [][]GCObject
	var tb []stringtable
	var i int32
	if int32(uint8((lu_byte((L[0].l_G)[0].gcstate)))) == 2 {
		return
	}
	newhash = func() interface{} {
		if uint(newsize+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, nil, uint(uint32(0)*8), uint(uint32(newsize)*8))
		}
		return luaM_toobig(L)
	}()
	tb = (*[1000000]stringtable)(unsafe.Pointer(&(L[0].l_G)[0].strt))[:]
	for i = 0; i < newsize; i++ {
		newhash[i] = nil
	}
	for i = 0; i < tb[0].size; i++ {
		var p []GCObject = tb[0].hash[i]
		for p != nil {
			var next []GCObject = p[0].gch.next
			var // Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30679 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008257d40), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			h uint32
			var h1 int32 = func() int32 {
				(0)
				tempVar := &int32(h & uint32(newsize-1))
				return *tempVar
			}()
			_ = 0
			p[0].gch.next = newhash[h1]
			newhash[h1] = p
			p = next
		}
	}
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(L, (tb[0].hash), uint(uint32(tb[0].size)*8), uint(uint32(0)*8))
		}
		return luaM_toobig(L)
	}()
	tb[0].size = newsize
	tb[0].hash = newhash
}

// newlstr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30693
func newlstr(L []lua_State, str []byte, l uint, h uint32) []TString {
	var ts []TString
	var tb []stringtable
	if l+uint(1) > (uint(^uint(0))-uint(2)-uint(24))/uint(1) {
		luaM_toobig(L)
	}
	ts = luaM_realloc_(L, nil, 0, (l+uint(1))*uint(1)+uint(24)).([]TString)
	ts[0].tsv.len_ = l
	ts[0].tsv.hash = h
	ts[0].tsv.marked = lu_byte(int32(uint8((lu_byte((L[0].l_G)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))
	ts[0].tsv.tt = lu_byte(4)
	ts[0].tsv.reserved = lu_byte(0)
	noarch.Memcpy(ts[0+1:], str, l*uint(1))
	((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ts[0+1]))) / int64(1))))[:])[l] = '\x00'
	tb = (*[1000000]stringtable)(unsafe.Pointer(&(L[0].l_G)[0].strt))[:]
	h = uint32(func() int32 {
		(0)
		tempVar := &int32(h & uint32(tb[0].size-1))
		return *tempVar
	}())
	ts[0].tsv.next = tb[0].hash[h]
	tb[0].hash[h] = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ts[0]))) / int64(1))))[:]
	tb[0].nuse += lu_int32((uint32(1)))
	if lu_int32(tb[0].nuse) > lu_int32(tb[0].size) && tb[0].size <= (2147483647-2)/2 {
		luaS_resize(L, tb[0].size*2)
	}
	return ts
}

// luaS_newlstr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30718
func luaS_newlstr(L []lua_State, str []byte, l uint) []TString {
	var o []GCObject
	var h uint32 = uint32(l)
	var step uint = l>>uint64(5) + uint(1)
	var l1 uint
	for l1 = l; l1 >= step; l1 -= step {
		h = h ^ (h<<uint64(5) + h>>uint64(2) + uint32(uint8(str[l1-uint(1)])))
	}
	for o = (L[0].l_G)[0].strt.hash[func() int32 {
		(0)
		tempVar := &int32(h & uint32((L[0].l_G)[0].strt.size-1))
		return *tempVar
	}()]; len(o) != 0; o = o[0].gch.next {
		var ts []TString = func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&((o)[0].ts)))[:]
			return *tempVar
		}()
		if uint(ts[0].tsv.len_) == l && noarch.Memcmp(str, ((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ts[0+1]))) / int64(1))))[:]), uint32(l)) == 0 {
			if int32(uint8((lu_byte((o)[0].gch.marked))))&(int32(uint8((lu_byte((L[0].l_G)[0].currentwhite))))^(1<<uint64(0)|1<<uint64(1)))&(1<<uint64(0)|1<<uint64(1)) != 0 {
				(lu_byte((uint8(func() lu_byte {
					tempVar := &(o)[0].gch.marked
					*tempVar ^= 1<<uint64(0) | 1<<uint64(1)
					return *tempVar
				}()))))
			}
			return ts
		}
	}
	return newlstr(L, str, l, h)
}

// luaS_newudata - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30739
func luaS_newudata(L []lua_State, s uint, e []Table) []Udata {
	var u []Udata
	if s > uint(^uint(0))-uint(2)-uint(96) {
		luaM_toobig(L)
	}
	u = luaM_realloc_(L, nil, 0, s+uint(96)).([]Udata)
	u[0].uv.marked = lu_byte(int32(uint8((lu_byte((L[0].l_G)[0].currentwhite)))) & (1<<uint64(0) | 1<<uint64(1)))
	u[0].uv.tt = lu_byte(7)
	u[0].uv.len_ = s
	u[0].uv.metatable = nil
	u[0].uv.env = e
	u[0].uv.next = (L[0].l_G)[0].mainthread[0].next
	(L[0].l_G)[0].mainthread[0].next = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&u[0]))) / int64(1))))[:]
	return u
}

// str_len - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30786
func str_len(L []lua_State) int32 {
	var l uint
	luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(l))))
	return 1
}

// posrelat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30794
func posrelat(pos noarch.PtrdiffT, len_ uint) noarch.PtrdiffT {
	if pos < noarch.PtrdiffT(0) {
		pos += noarch.PtrdiffT(len_) + noarch.PtrdiffT(1)
	}
	return noarch.PtrdiffT(func() int32 {
		if pos >= noarch.PtrdiffT(0) {
			return int32(pos)
		}
		return 0
	}())
}

// str_sub - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30801
func str_sub(L []lua_State) int32 {
	var l uint
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	var start noarch.PtrdiffT = posrelat(noarch.PtrdiffT((luaL_checkinteger(L, 2))), l)
	var end noarch.PtrdiffT = posrelat(noarch.PtrdiffT((luaL_optinteger(L, 3, lua_Integer((noarch.PtrdiffT(-1)))))), l)
	if start < noarch.PtrdiffT(1) {
		start = 1
	}
	if end > noarch.PtrdiffT(l) {
		end = noarch.PtrdiffT(l)
	}
	if start <= end {
		lua_pushlstring(L, (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&s[0+start:][0])) - (uintptr)(1)*unsafe.Sizeof(s[0+start:][0]))))[:], uint(end-start+noarch.PtrdiffT(1)))
	} else {
		lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	}
	return 1
}

// str_reverse - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30815
func str_reverse(L []lua_State) int32 {
	var l uint
	var b luaL_Buffer
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for bool(func() uint {
		defer func() {
			l--
		}()
		return l
	}()) {
		(func() byte {
			(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
			tempVar := &(func() byte {
				(func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0] = s[l]
				return (func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			return *tempVar
		}())
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// str_lower - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30826
func str_lower(L []lua_State) int32 {
	var l uint
	var i uint
	var b luaL_Buffer
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for i = 0; i < l; i++ {
		(func() byte {
			(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
			tempVar := &(func() byte {
				(func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0] = byte(linux.ToLower(int32(uint8(s[i]))))
				return (func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			return *tempVar
		}())
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// str_upper - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30839
func str_upper(L []lua_State) int32 {
	var l uint
	var i uint
	var b luaL_Buffer
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for i = 0; i < l; i++ {
		(func() byte {
			(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
			tempVar := &(func() byte {
				(func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0] = byte(linux.ToUpper(int32(uint8(s[i]))))
				return (func() []byte {
					tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
					defer func() {
						(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			return *tempVar
		}())
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// str_rep - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30851
func str_rep(L []lua_State) int32 {
	var l uint
	var b luaL_Buffer
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	var n int32 = int32(noarch.PtrdiffT((luaL_checkinteger(L, 2))))
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for func() int32 {
		defer func() {
			n--
		}()
		return n
	}() > 0 {
		luaL_addlstring(c4goUnsafeConvert_luaL_Buffer(&b), s, l)
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// str_byte - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30864
func str_byte(L []lua_State) int32 {
	var l uint
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l))
	var posi noarch.PtrdiffT = posrelat(noarch.PtrdiffT((luaL_optinteger(L, 2, 1))), l)
	var pose noarch.PtrdiffT = posrelat(noarch.PtrdiffT((luaL_optinteger(L, 3, lua_Integer((posi))))), l)
	var n int32
	var i int32
	if posi <= noarch.PtrdiffT(0) {
		posi = 1
	}
	if uint(pose) > l {
		pose = noarch.PtrdiffT(l)
	}
	if posi > pose {
		return 0
	}
	n = int32(pose - posi + noarch.PtrdiffT(1))
	if posi+noarch.PtrdiffT(n) <= pose {
		luaL_error(L, []byte("string slice too long\x00"))
	}
	luaL_checkstack(L, n, []byte("string slice too long\x00"))
	for i = 0; i < n; i++ {
		lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(uint8(s[posi+noarch.PtrdiffT(i)-noarch.PtrdiffT(1)])))))
	}
	return n
}

// str_char - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30883
func str_char(L []lua_State) int32 {
	var n int32 = lua_gettop(L)
	var i int32
	var b luaL_Buffer
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for i = 1; i <= n; i++ {
		var c int32 = int32(noarch.PtrdiffT((luaL_checkinteger(L, i))))
		_ = int32(uint8(c)) == c || luaL_argerror(L, i, ([]byte("invalid value\x00"))) != 0
		_ = (int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
		(func() byte {
			(func() []byte {
				tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
				defer func() {
					(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
				}()
				return tempVar
			}())[0] = byte(uint8(c))
			return (func() []byte {
				tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
				defer func() {
					(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
				}()
				return tempVar
			}())[0]
		}())
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// writer - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30898
func writer(L []lua_State, b interface{}, size uint, B interface{}) int32 {
	_ = L
	luaL_addlstring(B.([]luaL_Buffer), b.([]byte), size)
	return 0
}

// str_dump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30905
func str_dump(L []lua_State) int32 {
	var b luaL_Buffer
	luaL_checktype(L, 1, 6)
	lua_settop(L, 1)
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	if lua_dump(L, writer, c4goUnsafeConvert_luaL_Buffer(&b)) != 0 {
		luaL_error(L, []byte("unable to dump given function\x00"))
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// check_capture - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30944
func check_capture(ms []MatchState, l int32) int32 {
	l -= int32('1')
	if l < 0 || l >= ms[0].level || noarch.PtrdiffT(ms[0].capture[:][l].len_) == noarch.PtrdiffT(-1) {
		return luaL_error(ms[0].L, []byte("invalid capture index\x00"))
	}
	return l
}

// capture_to_close - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30952
func capture_to_close(ms []MatchState) int32 {
	var level int32 = ms[0].level
	for level -= 1; level >= 0; level-- {
		if noarch.PtrdiffT(ms[0].capture[:][level].len_) == noarch.PtrdiffT(-1) {
			return level
		}
	}
	return luaL_error(ms[0].L, []byte("invalid pattern capture\x00"))
}

// classend - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30960
func classend(ms []MatchState, p []byte) (c4goDefaultReturn []byte) {
	switch int32((func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return p
	}())[0]) {
	case '%':
		if int32(p[0]) == int32('\x00') {
			luaL_error(ms[0].L, []byte("malformed pattern (ends with '%%')\x00"))
		}
		return p[0+1:]
	case '[':
		if int32(p[0]) == int32('^') {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
		}
		for {
			if int32(p[0]) == int32('\x00') {
				luaL_error(ms[0].L, []byte("malformed pattern (missing ']')\x00"))
			}
			if int32((func() []byte {
				defer func() {
					func() []byte {
						tempVarUnary := p
						defer func() {
							p = p[0+1:]
						}()
						return tempVarUnary
					}()
				}()
				return p
			}())[0]) == int32('%') && int32(p[0]) != int32('\x00') {
				func() []byte {
					tempVarUnary := p
					defer func() {
						p = p[0+1:]
					}()
					return tempVarUnary
				}()
			}
			if !(int32(p[0]) != int32(']')) {
				break
			}
		}
		return p[0+1:]
	default:
		return p
	}
	return
}

// match_class - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:30984
func match_class(c int32, cl int32) int32 {
	var res int32
	switch linux.ToLower(cl) {
	case 'a':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISalpha))
	case 'c':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.IScntrl))
	case 'd':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISdigit))
	case 'l':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISlower))
	case 'p':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISpunct))
	case 's':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISspace))
	case 'u':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISupper))
	case 'w':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISalnum))
	case 'x':
		res = int32(((linux.CtypeLoc())[0])[c]) & int32(uint16(noarch.ISxdigit))
	case 'z':
		res = noarch.BoolToInt(c == 0)
	default:
		return noarch.BoolToInt(cl == c)
	}
	return func() int32 {
		if int32(((linux.CtypeLoc())[0])[cl])&int32(uint16(noarch.ISlower)) != 0 {
			return res
		}
		return noarch.BoolToInt(noarch.Not(res))
	}()
}

// matchbracketclass - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31003
func matchbracketclass(c int32, p []byte, ec []byte) int32 {
	var sig int32 = 1
	if int32(p[0+1]) == int32('^') {
		sig = 0
		func() []byte {
			tempVarUnary := p
			defer func() {
				p = p[0+1:]
			}()
			return tempVarUnary
		}()
	}
	for (func() int64 {
		c4go_temp_name := func() []byte {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
			return p
		}()
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}() - int64(uintptr(unsafe.Pointer(&ec[0])))/int64(1)) < 0 {
		if int32(p[0]) == int32('%') {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
			if match_class(c, int32(uint8(p[0]))) != 0 {
				return sig
			}
		} else if int32(p[0+1]) == int32('-') && (int64(uintptr(unsafe.Pointer(&p[0+2])))/int64(1)-int64(uintptr(unsafe.Pointer(&ec[0])))/int64(1)) < 0 {
			p = p[0+2:]
			if int32(uint8(p[0-2])) <= c && c <= int32(uint8(p[0])) {
				return sig
			}
		} else if int32(uint8(p[0])) == c {
			return sig
		}
	}
	return noarch.BoolToInt(noarch.Not(sig))
}

// singlematch - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31026
func singlematch(c int32, p []byte, ep []byte) (c4goDefaultReturn int32) {
	switch int32(p[0]) {
	case '.':
		return 1
	case '%':
		return match_class(c, int32(uint8(p[0+1])))
	case '[':
		return matchbracketclass(c, p, (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&ep[0])) - (uintptr)(1)*unsafe.Sizeof(ep[0]))))[:])
	default:
		return noarch.BoolToInt(int32(uint8(p[0])) == c)
	}
	return
}

// matchbalance - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31039
func matchbalance(ms []MatchState, s []byte, p []byte) []byte {
	if int32(p[0]) == 0 || int32(p[0+1]) == 0 {
		luaL_error(ms[0].L, []byte("unbalanced pattern\x00"))
	}
	if int32(s[0]) != int32(p[0]) {
		return nil
	} else {
		var b int32 = int32(p[0])
		var e int32 = int32(p[0+1])
		var cont int32 = 1
		for (func() int64 {
			c4go_temp_name := func() []byte {
				func() []byte {
					tempVarUnary := s
					defer func() {
						s = s[0+1:]
					}()
					return tempVarUnary
				}()
				return s
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)) < 0 {
			if int32(s[0]) == e {
				if func() int32 {
					cont--
					return cont
				}() == 0 {
					return s[0+1:]
				}
			} else if int32(s[0]) == b {
				cont++
			}
		}
	}
	return nil
}

// max_expand - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31059
func max_expand(ms []MatchState, s []byte, p []byte, ep []byte) []byte {
	var i noarch.PtrdiffT
	for (int64(uintptr(unsafe.Pointer(&s[0+i])))/int64(1)-int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)) < 0 && singlematch(int32(uint8(s[0+i])), p, ep) != 0 {
		i++
	}
	for i >= noarch.PtrdiffT(0) {
		var res []byte = match(ms, s[0+i:], ep[0+1:])
		if res != nil {
			return res
		}
		i--
	}
	return nil
}

// min_expand - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31074
func min_expand(ms []MatchState, s []byte, p []byte, ep []byte) (c4goDefaultReturn []byte) {
	for {
		var res []byte = match(ms, s, ep[0+1:])
		if len(res) != 0 {
			return res
		} else if (int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)) < 0 && singlematch(int32(uint8(s[0])), p, ep) != 0 {
			func() []byte {
				tempVarUnary := s
				defer func() {
					s = s[0+1:]
				}()
				return tempVarUnary
			}()
		} else {
			return nil
		}
	}
	return
}

// start_capture - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31087
func start_capture(ms []MatchState, s []byte, p []byte, what int32) []byte {
	var res []byte
	var level int32 = ms[0].level
	if level >= 32 {
		luaL_error(ms[0].L, []byte("too many captures\x00"))
	}
	ms[0].capture[:][level].init_ = s
	ms[0].capture[:][level].len_ = noarch.PtrdiffT(what)
	ms[0].level = level + 1
	if len((func() []byte {
		res = match(ms, s, p)
		return res
	}())) == 0 {
		ms[0].level--
	}
	return res
}

// end_capture - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31101
func end_capture(ms []MatchState, s []byte, p []byte) []byte {
	var l int32 = capture_to_close(ms)
	var res []byte
	ms[0].capture[:][l].len_ = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&s[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms[0].capture[:][l].init_[0])))/int64(1))))
	if len((func() []byte {
		res = match(ms, s, p)
		return res
	}())) == 0 {
		ms[0].capture[:][l].len_ = noarch.PtrdiffT(-1)
	}
	return res
}

// match_capture - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31112
func match_capture(ms []MatchState, s []byte, l int32) (c4goDefaultReturn []byte) {
	var len_ uint
	l = check_capture(ms, l)
	len_ = uint(noarch.PtrdiffT(ms[0].capture[:][l].len_))
	if uint(int32((int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))) >= len_ && noarch.Memcmp(ms[0].capture[:][l].init_, s, uint32(len_)) == 0 {
		return s[0+len_:]
	} else {
		return nil
	}
	return
}

// match - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31123
func match(ms []MatchState, s []byte, p []byte) (c4goDefaultReturn []byte) {
init_:
	;
	switch int32(p[0]) {
	case '(':
		if int32(p[0+1]) == int32(')') {
			return start_capture(ms, s, p[0+2:], -2)
		} else {
			return start_capture(ms, s, p[0+1:], -1)
		}
		fallthrough
	case ')':
		return end_capture(ms, s, p[0+1:])
	case '%':
		switch int32(p[0+1]) {
		case 'b':
			s = matchbalance(ms, s, p[0+2:])
			if len(s) == 0 {
				return nil
			}
			p = p[0+4:]
			goto init_
			fallthrough
		case 'f':
			var ep []byte
			var previous byte
			p = p[0+2:]
			if int32(p[0]) != int32('[') {
				luaL_error(ms[0].L, []byte("missing '[' after '%%f' in pattern\x00"))
			}
			ep = classend(ms, p)
			previous = byte(func() int32 {
				if (int64(uintptr(unsafe.Pointer(&s[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms[0].src_init[0])))/int64(1)) == 0 {
					return int32('\x00')
				}
				return int32(s[0-1])
			}())
			if matchbracketclass(int32(uint8(previous)), p, (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&ep[0])) - (uintptr)(1)*unsafe.Sizeof(ep[0]))))[:]) != 0 || noarch.Not(matchbracketclass(int32(uint8(s[0])), p, (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&ep[0])) - (uintptr)(1)*unsafe.Sizeof(ep[0]))))[:])) {
				return nil
			}
			p = ep
			goto init_
			fallthrough
		default:
			if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0+1]))])&int32(uint16(noarch.ISdigit)) != 0 {
				s = match_capture(ms, s, int32(uint8(p[0+1])))
				if len(s) == 0 {
					return nil
				}
				p = p[0+2:]
				goto init_
			}
			goto dflt
		}
		fallthrough
	case '\x00':
		return s
	case '$':
		if int32(p[0+1]) == int32('\x00') {
			return func() []byte {
				if (int64(uintptr(unsafe.Pointer(&s[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)) == 0 {
					return s
				}
				return nil
			}()
		} else {
			goto dflt
		}
		fallthrough
	default:
	dflt:
		;
		{
			var ep []byte = classend(ms, p)
			var m int32 = noarch.BoolToInt((int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&ms[0].src_end[0])))/int64(1)) < 0 && singlematch(int32(uint8(s[0])), p, ep) != 0)
			switch int32(ep[0]) {
			case '?':
				var res []byte
				if m != 0 && len((func() []byte {
					res = match(ms, s[0+1:], ep[0+1:])
					return res
				}())) != 0 {
					return res
				}
				p = ep[0+1:]
				goto init_
				fallthrough
			case '*':
				return max_expand(ms, s, p, ep)
			case '+':
				return func() []byte {
					if m != 0 {
						return max_expand(ms, s[0+1:], p, ep)
					}
					return nil
				}()
			case '-':
				return min_expand(ms, s, p, ep)
			default:
				if noarch.Not(m) {
					return nil
				}
				func() []byte {
					tempVarUnary := s
					defer func() {
						s = s[0+1:]
					}()
					return tempVarUnary
				}()
				p = ep
				goto init_
			}
		}
	}
	return
}

// lmemfind - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31202
func lmemfind(s1 []byte, l1 uint, s2 []byte, l2 uint) (c4goDefaultReturn []byte) {
	if l2 == uint(0) {
		return s1
	} else if l2 > l1 {
		return nil
	} else {
		var init_ []byte
		l2--
		l1 = l1 - l2
		for l1 > uint(0) && len((func() []byte {
			init_ = memchr(s1, int32(s2[0]), uint32(l1)).([]byte)
			return init_
		}())) != 0 {
			func() []byte {
				tempVarUnary := init_
				defer func() {
					init_ = init_[0+1:]
				}()
				return tempVarUnary
			}()
			if noarch.Memcmp(init_, s2[0+1:], uint32(l2)) == 0 {
				return (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&init_[0])) - (uintptr)(1)*unsafe.Sizeof(init_[0]))))[:]
			} else {
				l1 -= uint(uint32(int32((int64(uintptr(unsafe.Pointer(&init_[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s1[0])))/int64(1)))))
				s1 = init_
			}
		}
		return nil
	}
	return
}

// push_onecapture - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31224
func push_onecapture(ms []MatchState, i int32, s []byte, e []byte) {
	if i >= ms[0].level {
		if i == 0 {
			lua_pushlstring(ms[0].L, s, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))))
		} else {
			luaL_error(ms[0].L, []byte("invalid capture index\x00"))
		}
	} else {
		var l noarch.PtrdiffT = noarch.PtrdiffT(ms[0].capture[:][i].len_)
		if l == noarch.PtrdiffT(-1) {
			luaL_error(ms[0].L, []byte("unfinished capture\x00"))
		}
		if l == noarch.PtrdiffT(-2) {
			lua_pushinteger(ms[0].L, lua_Integer((noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&ms[0].capture[:][i].init_[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms[0].src_init[0])))/int64(1))) + 1))))
		} else {
			lua_pushlstring(ms[0].L, ms[0].capture[:][i].init_, uint(l))
		}
	}
}

// push_captures - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31243
func push_captures(ms []MatchState, s []byte, e []byte) int32 {
	var i int32
	var nlevels int32 = func() int32 {
		if ms[0].level == 0 && s != nil {
			return 1
		}
		return ms[0].level
	}()
	luaL_checkstack(ms[0].L, nlevels, []byte("too many captures\x00"))
	for i = 0; i < nlevels; i++ {
		push_onecapture(ms, i, s, e)
	}
	return nlevels
}

// str_find_aux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31253
func str_find_aux(L []lua_State, find int32) int32 {
	var l1 uint
	var l2 uint
	var s []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&l1))
	var p []byte = luaL_checklstring(L, 2, c4goUnsafeConvert_uint(&l2))
	var init_ noarch.PtrdiffT = posrelat(noarch.PtrdiffT((luaL_optinteger(L, 3, 1))), l1) - noarch.PtrdiffT(1)
	if init_ < noarch.PtrdiffT(0) {
		init_ = 0
	} else if uint(init_) > l1 {
		init_ = noarch.PtrdiffT(l1)
	}
	if find != 0 && (lua_toboolean(L, 4) != 0 || len(strpbrk(p, []byte("^$*+?.([%-\x00"))) == 0) {
		var s2 []byte = lmemfind(s[0+init_:], l1-uint(uint32(init_)), p, l2)
		if s2 != nil {
			lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&s2[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1))) + 1))))
			lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(uint32(int32((int64(uintptr(unsafe.Pointer(&s2[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))) + uint32(l2)))))
			return 2
		}
	} else {
		var ms MatchState
		var anchor int32 = func() int32 {
			if int32(p[0]) == int32('^') {
				return func() int32 {
					func() []byte {
						tempVarUnary := p
						defer func() {
							p = p[0+1:]
						}()
						return tempVarUnary
					}()
					tempVar := &1
					return *tempVar
				}()
			}
			return 0
		}()
		var s1 []byte = s[0+init_:]
		ms.L = L
		ms.src_init = s
		ms.src_end = s[0+l1:]
		for {
			var res []byte
			ms.level = 0
			if len((func() []byte {
				res = match(c4goUnsafeConvert_MatchState(&ms), s1, p)
				return res
			}())) != 0 {
				if find != 0 {
					lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&s1[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1))) + 1))))
					lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&res[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))))))
					return push_captures(c4goUnsafeConvert_MatchState(&ms), nil, nil) + 2
				} else {
					return push_captures(c4goUnsafeConvert_MatchState(&ms), s1, res)
				}
			}
			if !((func() int64 {
				c4go_temp_name := func() []byte {
					defer func() {
						func() []byte {
							tempVarUnary := s1
							defer func() {
								s1 = s1[0+1:]
							}()
							return tempVarUnary
						}()
					}()
					return s1
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}()-int64(uintptr(unsafe.Pointer(&ms.src_end[0])))/int64(1)) < 0 && noarch.Not(anchor)) {
				break
			}
		}
	}
	lua_pushnil(L)
	return 1
}

// str_find - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31296
func str_find(L []lua_State) int32 {
	return str_find_aux(L, 1)
}

// str_match - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31301
func str_match(L []lua_State) int32 {
	return str_find_aux(L, 0)
}

// gmatch_aux - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31306
func gmatch_aux(L []lua_State) int32 {
	var ms MatchState
	var ls uint
	var s []byte = lua_tolstring(L, -10002-1, c4goUnsafeConvert_uint(&ls))
	var p []byte = lua_tolstring(L, -10002-2, nil)
	var src []byte
	ms.L = L
	ms.src_init = s
	ms.src_end = s[0+ls:]
	for src = (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&s[0])) + (uintptr)(int32(uint(lua_tointeger(L, -10002-3))))*unsafe.Sizeof(s[0]))))[:]; (int64(uintptr(unsafe.Pointer(&src[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms.src_end[0])))/int64(1)) <= 0; func() []byte {
		tempVarUnary := src
		defer func() {
			src = src[0+1:]
		}()
		return tempVarUnary
	}() {
		var e []byte
		ms.level = 0
		if len((func() []byte {
			e = match(c4goUnsafeConvert_MatchState(&ms), src, p)
			return e
		}())) != 0 {
			var newstart lua_Integer = lua_Integer((noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1))))))
			if (int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&src[0])))/int64(1)) == 0 {
				newstart++
			}
			lua_pushinteger(L, newstart)
			lua_replace(L, -10002-3)
			return push_captures(c4goUnsafeConvert_MatchState(&ms), src, e)
		}
	}
	return 0
}

// gmatch - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31332
func gmatch(L []lua_State) int32 {
	luaL_checklstring(L, 1, nil)
	luaL_checklstring(L, 2, nil)
	lua_settop(L, 2)
	lua_pushinteger(L, 0)
	lua_pushcclosure(L, gmatch_aux, 3)
	return 1
}

// gfind_nodef - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31342
func gfind_nodef(L []lua_State) int32 {
	return luaL_error(L, []byte("'string.gfind' was renamed to 'string.gmatch'\x00"))
}

// add_s - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31348
func add_s(ms []MatchState, b []luaL_Buffer, s []byte, e []byte) {
	var l uint
	var i uint
	var news []byte = lua_tolstring(ms[0].L, 3, c4goUnsafeConvert_uint(&l))
	for i = 0; i < l; i++ {
		if int32(news[i]) != int32('%') {
			(func() byte {
				(int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
				tempVar := &(func() byte {
					(func() []byte {
						tempVar := (b)[0].p
						defer func() {
							(b)[0].p = (b)[0].p[1:]
						}()
						return tempVar
					}())[0] = news[i]
					return (func() []byte {
						tempVar := (b)[0].p
						defer func() {
							(b)[0].p = (b)[0].p[1:]
						}()
						return tempVar
					}())[0]
				}())
				return *tempVar
			}())
		} else {
			i++
			if noarch.Not(int32(((linux.CtypeLoc())[0])[int32(uint8(news[i]))]) & int32(uint16(noarch.ISdigit))) {
				(func() byte {
					(int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
					tempVar := &(func() byte {
						(func() []byte {
							tempVar := (b)[0].p
							defer func() {
								(b)[0].p = (b)[0].p[1:]
							}()
							return tempVar
						}())[0] = news[i]
						return (func() []byte {
							tempVar := (b)[0].p
							defer func() {
								(b)[0].p = (b)[0].p[1:]
							}()
							return tempVar
						}())[0]
					}())
					return *tempVar
				}())
			} else if int32(news[i]) == int32('0') {
				luaL_addlstring(b, s, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))))
			} else {
				push_onecapture(ms, int32(news[i])-int32('1'), s, e)
				luaL_addvalue(b)
			}
		}
	}
}

// add_value - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31370
func add_value(ms []MatchState, b []luaL_Buffer, s []byte, e []byte) {
	var L []lua_State = ms[0].L
	switch lua_type(L, 3) {
	case 3:
		fallthrough
	case 4:
		add_s(ms, b, s, e)
		return
	case 6:
		var n int32
		lua_pushvalue(L, 3)
		n = push_captures(ms, s, e)
		lua_call(L, n, 1)
	case 5:
		push_onecapture(ms, 0, s, e)
		lua_gettable(L, 3)
		break
	}
	if noarch.Not(lua_toboolean(L, -1)) {
		lua_settop(L, -(1)-1)
		lua_pushlstring(L, s, uint(int32((int64(uintptr(unsafe.Pointer(&e[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&s[0])))/int64(1)))))
	} else if noarch.Not(lua_isstring(L, -1)) {
		luaL_error(L, []byte("invalid replacement value (a %s)\x00"), lua_typename(L, lua_type(L, -1)))
	}
	luaL_addvalue(b)
}

// str_gsub - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31402
func str_gsub(L []lua_State) int32 {
	var srcl uint
	var src []byte = luaL_checklstring(L, 1, c4goUnsafeConvert_uint(&srcl))
	var p []byte = luaL_checklstring(L, 2, nil)
	var tr int32 = lua_type(L, 3)
	var max_s int32 = int32(noarch.PtrdiffT((luaL_optinteger(L, 4, lua_Integer((noarch.PtrdiffT(srcl + uint(1))))))))
	var anchor int32 = func() int32 {
		if int32(p[0]) == int32('^') {
			return func() int32 {
				func() []byte {
					tempVarUnary := p
					defer func() {
						p = p[0+1:]
					}()
					return tempVarUnary
				}()
				tempVar := &1
				return *tempVar
			}()
		}
		return 0
	}()
	var n int32
	var ms MatchState
	var b luaL_Buffer
	_ = tr == 3 || tr == 4 || tr == 6 || tr == 5 || luaL_argerror(L, 3, ([]byte("string/function/table expected\x00"))) != 0
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	ms.L = L
	ms.src_init = src
	ms.src_end = src[0+srcl:]
	for n < max_s {
		var e []byte
		ms.level = 0
		e = match(c4goUnsafeConvert_MatchState(&ms), src, p)
		if e != nil {
			n++
			add_value(c4goUnsafeConvert_MatchState(&ms), c4goUnsafeConvert_luaL_Buffer(&b), src, e)
		}
		if e != nil && (int64(uintptr(unsafe.Pointer(&e[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&src[0])))/int64(1)) > 0 {
			src = e
		} else if (int64(uintptr(unsafe.Pointer(&src[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&ms.src_end[0])))/int64(1)) < 0 {
			(func() byte {
				(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
				tempVar := &(func() byte {
					(func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0] = (func() []byte {
						defer func() {
							func() []byte {
								tempVarUnary := src
								defer func() {
									src = src[0+1:]
								}()
								return tempVarUnary
							}()
						}()
						return src
					}())[0]
					return (func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0]
				}())
				return *tempVar
			}())
		} else {
			break
		}
		if anchor != 0 {
			break
		}
	}
	luaL_addlstring(c4goUnsafeConvert_luaL_Buffer(&b), src, uint(int32((int64(uintptr(unsafe.Pointer(&ms.src_end[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&src[0])))/int64(1)))))
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	lua_pushinteger(L, lua_Integer((noarch.PtrdiffT(n))))
	return 2
}

// addquoted - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31454
func addquoted(L []lua_State, b []luaL_Buffer, arg int32) {
	var l uint
	var s []byte = luaL_checklstring(L, arg, c4goUnsafeConvert_uint(&l))
	_ = (int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
	(func() byte {
		(func() []byte {
			tempVar := (b)[0].p
			defer func() {
				(b)[0].p = (b)[0].p[1:]
			}()
			return tempVar
		}())[0] = '"'
		return (func() []byte {
			tempVar := (b)[0].p
			defer func() {
				(b)[0].p = (b)[0].p[1:]
			}()
			return tempVar
		}())[0]
	}())
	for bool(func() uint {
		defer func() {
			l--
		}()
		return l
	}()) {
		switch int32(s[0]) {
		case '"':
			fallthrough
		case '\\':
			fallthrough
		case '\n':
			_ = (int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
			(func() byte {
				(func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0] = '\\'
				return (func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			_ = (int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
			(func() byte {
				(func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0] = s[0]
				return (func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
		case '\r':
			luaL_addlstring(b, []byte("\\r\x00"), 2)
		case '\x00':
			luaL_addlstring(b, []byte("\\000\x00"), 4)
		default:
			_ = (int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
			(func() byte {
				(func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0] = s[0]
				return (func() []byte {
					tempVar := (b)[0].p
					defer func() {
						(b)[0].p = (b)[0].p[1:]
					}()
					return tempVar
				}())[0]
			}())
			break
		}
		func() []byte {
			tempVarUnary := s
			defer func() {
				s = s[0+1:]
			}()
			return tempVarUnary
		}()
	}
	_ = (int64(uintptr(unsafe.Pointer(&(b)[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(b)[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(b) != nil
	(func() byte {
		(func() []byte {
			tempVar := (b)[0].p
			defer func() {
				(b)[0].p = (b)[0].p[1:]
			}()
			return tempVar
		}())[0] = '"'
		return (func() []byte {
			tempVar := (b)[0].p
			defer func() {
				(b)[0].p = (b)[0].p[1:]
			}()
			return tempVar
		}())[0]
	}())
}

// scanformat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31483
func scanformat(L []lua_State, strfrmt []byte, form []byte) []byte {
	var p []byte = strfrmt
	for int32(p[0]) != int32('\x00') && len(noarch.Strchr([]byte("-+ #0\x00"), int32(p[0]))) != 0 {
		func() []byte {
			tempVarUnary := p
			defer func() {
				p = p[0+1:]
			}()
			return tempVarUnary
		}()
	}
	if uint(int32((int64(uintptr(unsafe.Pointer(&p[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&strfrmt[0])))/int64(1)))) >= uint(6) {
		luaL_error(L, []byte("invalid format (repeated flags)\x00"))
	}
	if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0]))])&int32(uint16(noarch.ISdigit)) != 0 {
		func() []byte {
			tempVarUnary := p
			defer func() {
				p = p[0+1:]
			}()
			return tempVarUnary
		}()
	}
	if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0]))])&int32(uint16(noarch.ISdigit)) != 0 {
		func() []byte {
			tempVarUnary := p
			defer func() {
				p = p[0+1:]
			}()
			return tempVarUnary
		}()
	}
	if int32(p[0]) == int32('.') {
		func() []byte {
			tempVarUnary := p
			defer func() {
				p = p[0+1:]
			}()
			return tempVarUnary
		}()
		if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0]))])&int32(uint16(noarch.ISdigit)) != 0 {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
		}
		if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0]))])&int32(uint16(noarch.ISdigit)) != 0 {
			func() []byte {
				tempVarUnary := p
				defer func() {
					p = p[0+1:]
				}()
				return tempVarUnary
			}()
		}
	}
	if int32(((linux.CtypeLoc())[0])[int32(uint8(p[0]))])&int32(uint16(noarch.ISdigit)) != 0 {
		luaL_error(L, []byte("invalid format (width or precision too long)\x00"))
	}
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := form
				defer func() {
					form = form[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return form
	}())[0] = '%'
	noarch.Strncpy(form, strfrmt, int32(uint32(int32((int64(uintptr(unsafe.Pointer(&p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&strfrmt[0])))/int64(1)))+1)))
	form = (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&form[0])) + (uintptr)(int32((int64(uintptr(unsafe.Pointer(&p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&strfrmt[0])))/int64(1)))+1)*unsafe.Sizeof(form[0]))))[:]
	form[0] = '\x00'
	return p
}

// addintlen - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31505
func addintlen(form []byte) {
	var l uint = uint(noarch.Strlen(form))
	var spec byte = form[l-uint(1)]
	noarch.Strcpy((*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&form[0+l:][0])) - (uintptr)(1)*unsafe.Sizeof(form[0+l:][0]))))[:], []byte("l\x00"))
	form[l+uint(2)-uint(2)] = spec
	form[l+uint(2)-uint(1)] = '\x00'
}

// str_format - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31514
func str_format(L []lua_State) int32 {
	var top int32 = lua_gettop(L)
	var arg int32 = 1
	var sfl uint
	var strfrmt []byte = luaL_checklstring(L, arg, c4goUnsafeConvert_uint(&sfl))
	var strfrmt_end []byte = strfrmt[0+sfl:]
	var b luaL_Buffer
	luaL_buffinit(L, c4goUnsafeConvert_luaL_Buffer(&b))
	for (int64(uintptr(unsafe.Pointer(&strfrmt[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&strfrmt_end[0])))/int64(1)) < 0 {
		if int32(strfrmt[0]) != int32('%') {
			(func() byte {
				(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
				tempVar := &(func() byte {
					(func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0] = (func() []byte {
						defer func() {
							func() []byte {
								tempVarUnary := strfrmt
								defer func() {
									strfrmt = strfrmt[0+1:]
								}()
								return tempVarUnary
							}()
						}()
						return strfrmt
					}())[0]
					return (func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0]
				}())
				return *tempVar
			}())
		} else if int32((func() []byte {
			func() []byte {
				tempVarUnary := strfrmt
				defer func() {
					strfrmt = strfrmt[0+1:]
				}()
				return tempVarUnary
			}()
			return strfrmt
		}())[0]) == int32('%') {
			(func() byte {
				(int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].p[0])))/int64(1)-int64(uintptr(unsafe.Pointer(&(c4goUnsafeConvert_luaL_Buffer(&b))[0].buffer[0+8192])))/int64(1)) < 0 || luaL_prepbuffer(c4goUnsafeConvert_luaL_Buffer(&b)) != nil
				tempVar := &(func() byte {
					(func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0] = (func() []byte {
						defer func() {
							func() []byte {
								tempVarUnary := strfrmt
								defer func() {
									strfrmt = strfrmt[0+1:]
								}()
								return tempVarUnary
							}()
						}()
						return strfrmt
					}())[0]
					return (func() []byte {
						tempVar := (c4goUnsafeConvert_luaL_Buffer(&b))[0].p
						defer func() {
							(c4goUnsafeConvert_luaL_Buffer(&b))[0].p = (c4goUnsafeConvert_luaL_Buffer(&b))[0].p[1:]
						}()
						return tempVar
					}())[0]
				}())
				return *tempVar
			}())
		} else {
			var form []byte = make([]byte, 18)
			var buff []byte = make([]byte, 512)
			if func() int32 {
				arg++
				return arg
			}() > top {
				luaL_argerror(L, arg, []byte("no value\x00"))
			}
			strfrmt = scanformat(L, strfrmt, form)
			switch int32((func() []byte {
				defer func() {
					func() []byte {
						tempVarUnary := strfrmt
						defer func() {
							strfrmt = strfrmt[0+1:]
						}()
						return tempVarUnary
					}()
				}()
				return strfrmt
			}())[0]) {
			case 'c':
				noarch.Sprintf(buff, form, int32(float64((luaL_checknumber(L, arg)))))
			case 'd':
				fallthrough
			case 'i':
				addintlen(form)
				noarch.Sprintf(buff, form, int32(float64((luaL_checknumber(L, arg)))))
			case 'o':
				fallthrough
			case 'u':
				fallthrough
			case 'x':
				fallthrough
			case 'X':
				addintlen(form)
				noarch.Sprintf(buff, form, uint32(float64((luaL_checknumber(L, arg)))))
			case 'e':
				fallthrough
			case 'E':
				fallthrough
			case 'f':
				fallthrough
			case 'g':
				fallthrough
			case 'G':
				noarch.Sprintf(buff, form, float64((luaL_checknumber(L, arg))))
			case 'q':
				addquoted(L, c4goUnsafeConvert_luaL_Buffer(&b), arg)
				continue
				fallthrough
			case 's':
				var l uint
				var s []byte = luaL_checklstring(L, arg, c4goUnsafeConvert_uint(&l))
				if noarch.Strchr(form, int32('.')) == nil && l >= uint(100) {
					lua_pushvalue(L, arg)
					luaL_addvalue(c4goUnsafeConvert_luaL_Buffer(&b))
					continue
				} else {
					noarch.Sprintf(buff, form, s)
					break
				}
				fallthrough
			default:
				return luaL_error(L, []byte("invalid option '%%%c' to 'format'\x00"), int32(strfrmt[0-1]))
			}
			luaL_addlstring(c4goUnsafeConvert_luaL_Buffer(&b), buff, uint(noarch.Strlen(buff)))
		}
	}
	luaL_pushresult(c4goUnsafeConvert_luaL_Buffer(&b))
	return 1
}

// createmetatable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31605
func createmetatable(L []lua_State) {
	lua_createtable(L, 0, 1)
	lua_pushlstring(L, []byte("\x00"), uint(1/1-1))
	lua_pushvalue(L, -2)
	lua_setmetatable(L, -2)
	lua_settop(L, -(1)-1)
	lua_pushvalue(L, -2)
	lua_setfield(L, -2, []byte("__index\x00"))
	lua_settop(L, -(1)-1)
}

// luaopen_string - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31620
func luaopen_string(L []lua_State) int32 {
	luaL_register(L, []byte("string\x00"), strlib)
	lua_getfield(L, -1, []byte("gmatch\x00"))
	lua_setfield(L, -2, []byte("gfind\x00"))
	createmetatable(L)
	return 1
}

// hashnum - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31716
func hashnum(t []Table, n lua_Number) []Node {
	var a []uint32 = make([]uint32, 2)
	var i int32
	if n == lua_Number((float64(0))) {
		return (t)[0].node[0:]
	}
	noarch.Memcpy(a, c4goUnsafeConvert_float64(&n), uint(8))
	for i = 1; i < int32(8/4); i++ {
		a[0] += a[i]
	}
	return (t)[0].node[a[0]%uint32(1<<uint64(int32(uint8(((t)[0].lsizenode))))-1|1):]
}

// mainposition - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31732
func mainposition(t []Table, key []TValue) (c4goDefaultReturn []Node) {
	switch (key)[0].tt {
	case 3:
		return hashnum(t, func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}())
	case 4:
		return (t)[0].node[func() int32 {
			(0)
			tempVar := &int32((*(func() []TString {
				(0)
				tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(key)[0].value.gc())[0].ts))[:]
				return *tempVar
			}())[0].tsv()).hash & uint32(1<<uint64(int32(uint8(((t)[0].lsizenode))))-1))
			return *tempVar
		}():]
	case 1:
		return (t)[0].node[func() int32 {
			(0)
			tempVar := &(func() int32 {
				(0)
				tempVar := &(*(key)[0].value.b())
				return *tempVar
			}() & (1<<uint64(int32(uint8(((t)[0].lsizenode)))) - 1))
			return *tempVar
		}():]
	case 2:
		return (t)[0].node[uint32(uint((lu_mem(func() interface{} {
			(0)
			tempVar := &(*(key)[0].value.p())
			return *tempVar
		}()))))%uint32(1<<uint64(int32(uint8(((t)[0].lsizenode))))-1|1):]
	default:
		return (t)[0].node[uint32(uint((lu_mem(func() []GCObject {
			(0)
			tempVar := &(*(key)[0].value.gc())
			return *tempVar
		}()))))%uint32(1<<uint64(int32(uint8(((t)[0].lsizenode))))-1|1):]
	}
	return
}

// arrayindex - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31752
func arrayindex(key []TValue) int32 {
	if (key)[0].tt == 3 {
		var n lua_Number = func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}()
		var k int32
		k = int32(float64((n)))
		if lua_Number(k) == n {
			return k
		}
	}
	return -1
}

// findindex - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31769
func findindex(L []lua_State, t []Table, key StkId) (c4goDefaultReturn int32) {
	var i int32
	if StkId((key))[0].tt == 0 {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31771 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		return -1
	}
	i = arrayindex((*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(key)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:])
	if 0 < i && i <= t[0].sizearray {
		return i - 1
	} else {
		var n []Node = mainposition(t, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(key)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:])
		for {
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31780 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31779 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			if n == nil {
				// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31779 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc002252200), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				break
			}
		}
		luaG_runerror(L, []byte("invalid key to 'next'\x00"))
		return 0
	}
	return
}

// luaH_next - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31794
func luaH_next(L []lua_State, t []Table, key StkId) int32 {
	var i int32 = findindex(L, t, key)
	for i += 1; i < t[0].sizearray; i++ {
		if !((t[0].array[i:])[0].tt == 0) {
			{
				var i_o []TValue = []TValue((key))
				(*i_o[0].value.n()) = lua_Number(i + 1)
				i_o[0].tt = 3
			}
			{
				var o2 []TValue = (t[0].array[i:])
				var o1 []TValue = []TValue((key[0+1:]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			return 1
		}
	}
	for i -= t[0].sizearray; i < 1<<uint64(int32(uint8(((t)[0].lsizenode)))); i++ {
		if !(((*[1000000]TValue)(unsafe.Pointer(&((t)[0].node[i:])[0].i_val))[:])[0].tt == 0) {
			{
				var o2 []TValue = ((*[1000000]TValue)(unsafe.Pointer(&(*((t)[0].node[i:])[0].i_key.tvk())))[:])
				var o1 []TValue = []TValue((key))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			{
				var o2 []TValue = ((*[1000000]TValue)(unsafe.Pointer(&((t)[0].node[i:])[0].i_val))[:])
				var o1 []TValue = []TValue((key[0+1:]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			return 1
		}
	}
	return 0
}

// computesizes - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31821
func computesizes(nums []int32, narray []int32) int32 {
	var i int32
	var twotoi int32
	var a int32
	var na int32
	var n int32
	{
		i = 0
		twotoi = 1
		for twotoi = 1; twotoi/2 < narray[0]; {
			if nums[i] > 0 {
				a += nums[i]
				if a > twotoi/2 {
					n = twotoi
					na = a
				}
			}
			if a == narray[0] {
				break
			}
			i++
			twotoi *= 2
		}
	}
	narray[0] = n
	_ = 0
	return na
}

// countint - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31843
func countint(key []TValue, nums []int32) (c4goDefaultReturn int32) {
	var k int32 = arrayindex(key)
	if 0 < k && k <= 1<<uint64(26) {
		nums[luaO_log2(uint32(k-1))+1]++
		return 1
	} else {
		return 0
	}
	return
}

// numusearray - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31854
func numusearray(t []Table, nums []int32) int32 {
	var lg int32
	var ttlg int32
	var ause int32
	var i int32 = 1
	{
		lg = 0
		ttlg = 1
		for ttlg = 1; lg <= 26; {
			var lc int32
			var lim int32 = ttlg
			if lim > t[0].sizearray {
				lim = t[0].sizearray
				if i > lim {
					break
				}
			}
			for ; i <= lim; i++ {
				if !((t[0].array[i-1:])[0].tt == 0) {
					lc++
				}
			}
			nums[lg] += lc
			ause += lc
			lg++
			ttlg *= 2
		}
	}
	return ause
}

// numusehash - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31879
func numusehash(t []Table, nums []int32, pnasize []int32) int32 {
	var totaluse int32
	var ause int32
	var i int32 = 1 << uint64(int32(uint8(((t)[0].lsizenode))))
	for func() int32 {
		defer func() {
			i--
		}()
		return i
	}() != 0 {
		var n []Node = t[0].node[i:]
		if !(((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt == 0) {
			ause += countint(((*[1000000]TValue)(unsafe.Pointer(&(*(n)[0].i_key.tvk())))[:]), nums)
			totaluse++
		}
	}
	pnasize[0] += ause
	return totaluse
}

// setarrayvector - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31895
func setarrayvector(L []lua_State, t []Table, size int32) {
	var i int32
	t[0].array = func() interface{} {
		if uint(size+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (t[0].array), uint(uint32(t[0].sizearray)*16), uint(uint32(size)*16))
		}
		return luaM_toobig(L)
	}().([]TValue)
	for i = t[0].sizearray; i < size; i++ {
		(func() int32 {
			(t[0].array[i:])[0].tt = 0
			return (t[0].array[i:])[0].tt
		}())
	}
	t[0].sizearray = size
}

// setnodevector - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31904
func setnodevector(L []lua_State, t []Table, size int32) {
	var lsize int32
	if size == 0 {
		t[0].node = (*[1000000]Node)(unsafe.Pointer(&dummynode_))[:]
		lsize = 0
	} else {
		var i int32
		lsize = luaO_log2(uint32(size-1)) + 1
		if lsize > 26 {
			luaG_runerror(L, []byte("table overflow\x00"))
		}
		size = 1 << uint64(lsize)
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		// Warning (*ast.UnaryExprOrTypeTraitExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31916 :Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `string`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
		t[0].node = func() interface{} {
			if uint(size+1) <= (uint(^uint(0))-uint(2))/uint(0) {
				return luaM_realloc_(L, nil, uint(uint32(0)*0), uint(uint32(size)*0))
			}
			return luaM_toobig(L)
		}().([]Node)
		for i = 0; i < size; i++ {
			var n []Node = (t)[0].node[i:]
			(*(n)[0].i_key.nk()).next = nil
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31920 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004dafec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])[0].tt = 0
		}
	}
	t[0].lsizenode = lu_byte(lsize)
	t[0].lastfree = (t)[0].node[size:]
}

// resize - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31929
func resize(L []lua_State, t []Table, nasize int32, nhsize int32) {
	// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31954 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	{
		var i int32
		var oldasize int32 = t[0].sizearray
		var oldhsize int32 = int32(uint8((lu_byte(t[0].lsizenode))))
		var nold []Node = t[0].node
		if nasize > oldasize {
			setarrayvector(L, t, nasize)
		}
		setnodevector(L, t, nhsize)
		if nasize < oldasize {
			t[0].sizearray = nasize
			for i = nasize; i < oldasize; i++ {
				if !((t[0].array[i:])[0].tt == 0) {
					var o2 []TValue = (t[0].array[i:])
					var o1 []TValue = luaH_setnum(L, t, i+1)
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
			}
			t[0].array = func() interface{} {
				if uint(nasize+1) <= (uint(^uint(0))-uint(2))/uint(16) {
					return luaM_realloc_(L, (t[0].array), uint(uint32(oldasize)*16), uint(uint32(nasize)*16))
				}
				return luaM_toobig(L)
			}().([]TValue)
		}
		for i = 1<<uint64(oldhsize) - 1; i >= 0; i-- {
			var old []Node = nold[0+i:]
			if !(((*[1000000]TValue)(unsafe.Pointer(&(old)[0].i_val))[:])[0].tt == 0) {
				var o2 []TValue = ((*[1000000]TValue)(unsafe.Pointer(&(old)[0].i_val))[:])
				var o1 []TValue = luaH_set(L, t, ((*[1000000]TValue)(unsafe.Pointer(&(*(old)[0].i_key.tvk())))[:]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
		}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31954 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	}
}

// luaH_resizearray - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31959
func luaH_resizearray(L []lua_State, t []Table, nasize int32) {
	var // Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.VarDecl):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31960 :Cannot getDefaultValueForVar : err = Cannot transpileToExpr. err = Cannot transpile ConditionalOperator : err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	nsize int32
	resize(L, t, nasize, nsize)
}

// rehash - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31965
func rehash(L []lua_State, t []Table, ek []TValue) {
	var nasize int32
	var na int32
	var nums []int32 = make([]int32, 27)
	var i int32
	var totaluse int32
	for i = 0; i <= 26; i++ {
		nums[i] = 0
	}
	nasize = numusearray(t, nums)
	totaluse = nasize
	totaluse += numusehash(t, nums, c4goUnsafeConvert_int32(&nasize))
	nasize += countint(ek, nums)
	totaluse++
	na = computesizes(nums, c4goUnsafeConvert_int32(&nasize))
	resize(L, t, nasize, totaluse-na)
}

// luaH_new - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:31990
func luaH_new(L []lua_State, narray int32, nhash int32) []Table {
	var t []Table = luaM_realloc_(L, nil, 0, uint(56)).([]Table)
	luaC_link(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&t[0]))) / int64(1))))[:], lu_byte(5))
	t[0].metatable = nil
	t[0].flags = lu_byte(^0)
	t[0].array = nil
	t[0].sizearray = 0
	t[0].lsizenode = lu_byte(0)
	t[0].node = (*[1000000]Node)(unsafe.Pointer(&dummynode_))[:]
	setarrayvector(L, t, narray)
	setnodevector(L, t, nhash)
	return t
}

// luaH_free - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32006
func luaH_free(L []lua_State, t []Table) {
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32007 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32007 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `!=`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	func() interface{} {
		if uint(0+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(L, (t[0].array), uint(uint32(t[0].sizearray)*16), uint(uint32(0)*16))
		}
		return luaM_toobig(L)
	}()
	luaM_realloc_(L, (t), uint(56), 0)
}

// getfreepos - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32014
func getfreepos(t []Table) []Node {
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32015 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.ForStmt):  :0 :Cannot tranpile ForStmt: err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.WhileStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32015 :Cannot transpileToStmt : Cannot tranpile ForStmt: err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `>`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	return nil
}

// newkey - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32031
func newkey(L []lua_State, t []Table, key []TValue) []TValue {
	var mp []Node = mainposition(t, key)
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32033 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown53}. Error: operator is `||`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile BinaryOperator with type 'Value' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Value' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbca00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	{
		if (key)[0].tt >= 4 && int32(uint8(((func() []GCObject {
			(0)
			tempVar := &(*(key)[0].value.gc())
			return *tempVar
		}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&t[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32057 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `=`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005bbcc80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			luaC_barrierback(L, t)
		}
	}
	_ = 0
	return (*[1000000]TValue)(unsafe.Pointer(&(mp)[0].i_val))[:]
}

// luaH_getnum - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32067
func luaH_getnum(t []Table, key int32) (c4goDefaultReturn []TValue) {
	if uint32(key-1) < uint32(t[0].sizearray) {
		return t[0].array[key-1:]
	} else {
		var nk lua_Number = lua_Number(key)
		var n []Node = hashnum(t, nk)
		for {
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			if n == nil {
				// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32075 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc008a2c840), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				break
			}
		}
		return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
	}
	return
}

// luaH_getstr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32087
func luaH_getstr(t []Table, key []TString) []TValue {
	var n []Node = (t)[0].node[func() int32 {
		(0)
		tempVar := &int32((key)[0].tsv.hash & uint32(1<<uint64(int32(uint8(((t)[0].lsizenode))))-1))
		return *tempVar
	}():]
	for {
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		if n == nil {
			// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32090 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `&&`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21419:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc000a75e80), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			break
		}
	}
	return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
}

// luaH_get - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32101
func luaH_get(t []Table, key []TValue) (c4goDefaultReturn []TValue) {
	switch (key)[0].tt {
	case 0:
		return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
	case 4:
		return luaH_getstr(t, func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(key)[0].value.gc())[0].ts))[:]
			return *tempVar
		}())
	case 3:
		var k int32
		var n lua_Number = func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}()
		k = int32(float64((n)))
		if lua_Number(k) == func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}() {
			return luaH_getnum(t, k)
		}
		fallthrough
	default:
		var n []Node = mainposition(t, key)
		for {
			if luaO_rawequalObj(((*[1000000]TValue)(unsafe.Pointer(&(*(n)[0].i_key.tvk())))[:]), key) != 0 {
				return ((*[1000000]TValue)(unsafe.Pointer(&(n)[0].i_val))[:])
			} else {
				n = (*(n)[0].i_key.nk()).next
			}
			if n == nil {
				break
			}
		}
		return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
	}
	return
}

// luaH_set - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32126
func luaH_set(L []lua_State, t []Table, key []TValue) (c4goDefaultReturn []TValue) {
	var p []TValue = luaH_get(t, key)
	t[0].flags = lu_byte(0)
	if (int64(uintptr(unsafe.Pointer(&p[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0])))/int64(16)) != 0 {
		return p
	} else {
		if (key)[0].tt == 0 {
			luaG_runerror(L, []byte("table index is nil\x00"))
		} else if (key)[0].tt == 3 && !(func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}() == func() lua_Number {
			(0)
			tempVar := &(*(key)[0].value.n())
			return *tempVar
		}()) {
			luaG_runerror(L, []byte("table index is NaN\x00"))
		}
		return newkey(L, t, key)
	}
	return
}

// luaH_setnum - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32140
func luaH_setnum(L []lua_State, t []Table, key int32) (c4goDefaultReturn []TValue) {
	var p []TValue = luaH_getnum(t, key)
	if (int64(uintptr(unsafe.Pointer(&p[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0])))/int64(16)) != 0 {
		return p
	} else {
		var k TValue
		{
			var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&k))[:]
			(*i_o[0].value.n()) = lua_Number(key)
			i_o[0].tt = 3
		}
		return newkey(L, t, (*[1000000]TValue)(unsafe.Pointer(&k))[:])
	}
	return
}

// luaH_setstr - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32152
func luaH_setstr(L []lua_State, t []Table, key []TString) (c4goDefaultReturn []TValue) {
	var p []TValue = luaH_getstr(t, key)
	if (int64(uintptr(unsafe.Pointer(&p[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&(*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[0])))/int64(16)) != 0 {
		return p
	} else {
		var k TValue
		{
			var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&k))[:]
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&key[0]))) / int64(1))))[:]
			i_o[0].tt = 4
			_ = 0
		}
		return newkey(L, t, (*[1000000]TValue)(unsafe.Pointer(&k))[:])
	}
	return
}

// unbound_search - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32164
func unbound_search(t []Table, j uint32) int32 {
	var i uint32 = j
	j++
	for !((luaH_getnum(t, int32(j)))[0].tt == 0) {
		i = j
		j *= 2
		if j > uint32(2147483647-2) {
			i = 1
			for !((luaH_getnum(t, int32(i)))[0].tt == 0) {
				i++
			}
			return int32(i - 1)
		}
	}
	for j-i > 1 {
		var m uint32 = (i + j) / 2
		if (luaH_getnum(t, int32(m)))[0].tt == 0 {
			j = m
		} else {
			i = m
		}
	}
	return int32(i)
}

// luaH_getn - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32192
func luaH_getn(t []Table) (c4goDefaultReturn int32) {
	var j uint32 = uint32(t[0].sizearray)
	// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32205 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	if j > 0 && (t[0].array[j-1:])[0].tt == 0 {
		var i uint32
		for j-i > 1 {
			var m uint32 = (i + j) / 2
			if (t[0].array[m-1:])[0].tt == 0 {
				j = m
			} else {
				i = m
			}
		}
		return int32(i)
	} else {
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32205 :Cannot transpile BinaryOperator with type 'int' : result type = {PointerOperation_unknown04}. Error: operator is `==`. Cannot determine sizeof : |Node|. err = Cannot determine sizeof : |struct Node|. err = Cannot calculate `struct` sizeof for `string`. bytes = '0'. Cannot determine sizeof : |TKey|. err = Cannot determine sizeof : |union TKey|. err = Cannot canculate `union` sizeof for `*program.Struct`. Cannot determine sizeof : |struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_|. err = Cannot calculate `struct` sizeof for `*program.Struct`. bytes = '0'. Cannot determine sizeof : |Node|. err = sizeof stack loop : [Node struct Node TKey union TKey struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21419_3_]
	}
	return
}

// luaT_init - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32254
func luaT_init(L []lua_State) {
	var luaT_eventname [][]byte = [][]byte{[]byte("__index\x00"), []byte("__newindex\x00"), []byte("__gc\x00"), []byte("__mode\x00"), []byte("__eq\x00"), []byte("__add\x00"), []byte("__sub\x00"), []byte("__mul\x00"), []byte("__div\x00"), []byte("__mod\x00"), []byte("__pow\x00"), []byte("__unm\x00"), []byte("__len\x00"), []byte("__lt\x00"), []byte("__le\x00"), []byte("__concat\x00"), []byte("__call\x00")}
	var i int32
	for i = 0; i < int32((TM_N)); i++ {
		(L[0].l_G)[0].tmname[:][i] = luaS_newlstr(L, luaT_eventname[i], uint(noarch.Strlen(luaT_eventname[i])))
		((L[0].l_G)[0].tmname[:][i])[0].tsv.marked |= lu_byte((uint8(1 << uint64(5))))
	}
}

// luaT_gettm - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32274
func luaT_gettm(events []Table, event int32, ename []TString) (c4goDefaultReturn []TValue) {
	var tm []TValue = luaH_getstr(events, ename)
	_ = 0
	if (tm)[0].tt == 0 {
		events[0].flags |= lu_byte((uint8(int32(uint8((lu_byte(1 << uint64(uint32(event)))))))))
		return nil
	} else {
		return tm
	}
	return
}

// luaT_gettmbyobj - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32285
func luaT_gettmbyobj(L []lua_State, o []TValue, event int32) []TValue {
	var mt []Table
	switch (o)[0].tt {
	case 5:
		mt = (func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(o)[0].value.gc())[0].h))[:]
			return *tempVar
		}())[0].metatable
	case 7:
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32292 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'Table *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007987000), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	default:
		mt = (L[0].l_G)[0].mt[:][(o)[0].tt]
	}
	return func() []TValue {
		if mt != nil {
			return luaH_getstr(mt, (L[0].l_G)[0].tmname[:][event])
		}
		return (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:]
	}()
}

// error_ - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32342
func error_(S []LoadState, why []byte) {
	luaO_pushfstring(S[0].L, []byte("%s: %s in precompiled chunk\x00"), S[0].name, why)
	luaD_throw(S[0].L, 3)
}

// LoadBlock - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32354
func LoadBlock(S []LoadState, b interface{}, size uint) {
	var r uint = luaZ_read(S[0].Z, b, size)
	if r != uint(0) {
		error_(S, []byte("unexpected end\x00"))
	}
}

// LoadChar - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32360
func LoadChar(S []LoadState) int32 {
	var x byte
	LoadBlock(S, c4goUnsafeConvert_byte(&x), uint(uint32(1)*1))
	return int32(x)
}

// LoadInt - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32367
func LoadInt(S []LoadState) int32 {
	var x int32
	LoadBlock(S, c4goUnsafeConvert_int32(&x), uint(uint32(1)*4))
	if x < 0 {
		error_(S, []byte("bad integer\x00"))
	}
	return x
}

// LoadNumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32375
func LoadNumber(S []LoadState) lua_Number {
	var x lua_Number
	LoadBlock(S, c4goUnsafeConvert_float64(&x), uint(uint32(1)*8))
	return x
}

// LoadString - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32382
func LoadString(S []LoadState) (c4goDefaultReturn []TString) {
	var size uint
	LoadBlock(S, c4goUnsafeConvert_uint(&size), uint(uint32(1)*8))
	if size == uint(0) {
		return nil
	} else {
		var s []byte = luaZ_openspace(S[0].L, S[0].b, size)
		LoadBlock(S, s, size)
		// remove trailing '\0'
		return luaS_newlstr(S[0].L, s, size-uint(1))
	}
	return
}

// LoadCode - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32396
func LoadCode(S []LoadState, f []Proto) {
	var n int32 = LoadInt(S)
	f[0].code = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*4), uint(uint32(n)*4))
		}
		return luaM_toobig(S[0].L)
	}().([]Instruction)
	f[0].sizecode = n
	LoadBlock(S, f[0].code, uint(uint32(n)*4))
}

// LoadConstants - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32406
func LoadConstants(S []LoadState, f []Proto) {
	var i int32
	var n int32
	n = LoadInt(S)
	f[0].k = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*16), uint(uint32(n)*16))
		}
		return luaM_toobig(S[0].L)
	}().([]TValue)
	f[0].sizek = n
	for i = 0; i < n; i++ {
		(func() int32 {
			(f[0].k[i:])[0].tt = 0
			return (f[0].k[i:])[0].tt
		}())
	}
	for i = 0; i < n; i++ {
		var o []TValue = f[0].k[i:]
		var t int32 = LoadChar(S)
		switch t {
		case 0:
			(func() int32 {
				(o)[0].tt = 0
				return (o)[0].tt
			}())
		case 1:
			var i_o []TValue = o
			(*i_o[0].value.b()) = noarch.BoolToInt(LoadChar(S) != 0)
			i_o[0].tt = 1
		case 3:
			var i_o []TValue = o
			(*i_o[0].value.n()) = LoadNumber(S)
			i_o[0].tt = 3
		case 4:
			var i_o []TValue = o
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := LoadString(S)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			i_o[0].tt = 4
			_ = 0
		default:
			error_(S, []byte("bad constant\x00"))
			break
		}
	}
	n = LoadInt(S)
	f[0].p = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*8), uint(uint32(n)*8))
		}
		return luaM_toobig(S[0].L)
	}()
	f[0].sizep = n
	for i = 0; i < n; i++ {
		f[0].p[i] = nil
	}
	for i = 0; i < n; i++ {
		f[0].p[i] = LoadFunction(S, f[0].source)
	}
}

// LoadDebug - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32443
func LoadDebug(S []LoadState, f []Proto) {
	var i int32
	var n int32
	n = LoadInt(S)
	f[0].lineinfo = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(4) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*4), uint(uint32(n)*4))
		}
		return luaM_toobig(S[0].L)
	}().([]int32)
	f[0].sizelineinfo = n
	LoadBlock(S, f[0].lineinfo, uint(uint32(n)*4))
	n = LoadInt(S)
	f[0].locvars = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(16) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*16), uint(uint32(n)*16))
		}
		return luaM_toobig(S[0].L)
	}().([]LocVar)
	f[0].sizelocvars = n
	for i = 0; i < n; i++ {
		f[0].locvars[i].varname = nil
	}
	for i = 0; i < n; i++ {
		f[0].locvars[i].varname = LoadString(S)
		f[0].locvars[i].startpc = LoadInt(S)
		f[0].locvars[i].endpc = LoadInt(S)
	}
	n = LoadInt(S)
	f[0].upvalues = func() interface{} {
		if uint(n+1) <= (uint(^uint(0))-uint(2))/uint(8) {
			return luaM_realloc_(S[0].L, nil, uint(uint32(0)*8), uint(uint32(n)*8))
		}
		return luaM_toobig(S[0].L)
	}()
	f[0].sizeupvalues = n
	for i = 0; i < n; i++ {
		f[0].upvalues[i] = nil
	}
	for i = 0; i < n; i++ {
		f[0].upvalues[i] = LoadString(S)
	}
}

// LoadFunction - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32467
func LoadFunction(S []LoadState, p []TString) []Proto {
	var f []Proto
	if int32(func() uint16 {
		tempVar := &S[0].L[0].nCcalls
		*tempVar++
		return *tempVar
	}()) > 200 {
		error_(S, []byte("code too deep\x00"))
	}
	f = luaF_newproto(S[0].L)
	{
		var i_o []TValue = []TValue((S[0].L[0].top))
		(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&f[0]))) / int64(1))))[:]
		i_o[0].tt = 8 + 1
		_ = 0
	}
	{
		if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(S[0].L[0].stack_last)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId(S[0].L[0].top)
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[0])))/int64(1))) <= 1*int32(16) {
			luaD_growstack(S[0].L, 1)
		} else {
			_ = (0)
		}
		func() StkId {
			tempVarUnary := S[0].L[0].top
			defer func() {
				S[0].L[0].top = S[0].L[0].top[0+1:]
			}()
			return tempVarUnary
		}()
	}
	f[0].source = LoadString(S)
	if len(f[0].source) == 0 {
		f[0].source = p
	}
	f[0].linedefined = LoadInt(S)
	f[0].lastlinedefined = LoadInt(S)
	f[0].nups = lu_byte(LoadChar(S))
	f[0].numparams = lu_byte(LoadChar(S))
	f[0].is_vararg = lu_byte(LoadChar(S))
	f[0].maxstacksize = lu_byte(LoadChar(S))
	LoadCode(S, f)
	LoadConstants(S, f)
	LoadDebug(S, f)
	if noarch.Not(luaG_checkcode(f)) {
		error_(S, []byte("bad code\x00"))
	}
	func() StkId {
		tempVarUnary := S[0].L[0].top
		defer func() {
			S[0].L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&S[0].L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(S[0].L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	S[0].L[0].nCcalls -= uint16(1)
	return f
}

// LoadHeader - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32489
func LoadHeader(S []LoadState) {
	var h []byte = make([]byte, 12)
	var s []byte = make([]byte, 12)
	luaU_header(h)
	LoadBlock(S, s, 12)
	if noarch.Memcmp(h, s, 12) != 0 {
		error_(S, []byte("bad header\x00"))
	}
}

// luaU_undump - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32501
func luaU_undump(L []lua_State, Z []ZIO, buff []Mbuffer, name []byte) []Proto {
	var S LoadState
	if int32(name[0]) == int32('@') || int32(name[0]) == int32('=') {
		//
		//** load precompiled chunk
		//
		S.name = name[0+1:]
	} else if int32(name[0]) == int32([]byte("\x1bLua\x00")[0]) {
		S.name = []byte("binary string\x00")
	} else {
		S.name = name
	}
	S.L = L
	S.Z = Z
	S.b = buff
	LoadHeader((*[1000000]LoadState)(unsafe.Pointer(&S))[:])
	return LoadFunction((*[1000000]LoadState)(unsafe.Pointer(&S))[:], luaS_newlstr(L, []byte("=?\x00"), uint(3/1-1)))
}

// luaU_header - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32520
func luaU_header(h []byte) {
	var x int32 = 1
	//
	//* make header
	//
	noarch.Memcpy(h, []byte("\x1bLua\x00"), uint(5-1))
	h = (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&h[0])) + (uintptr)(int32(5-1))*unsafe.Sizeof(h[0]))))[:]
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(81)
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(0)
	// endianness
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = ((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goUnsafeConvert_int32(&x)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:])[0]
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(4)
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(8)
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(4)
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(8)
	// is lua_Number integral?
	(func() []byte {
		defer func() {
			func() []byte {
				tempVarUnary := h
				defer func() {
					h = h[0+1:]
				}()
				return tempVarUnary
			}()
		}()
		return h
	}())[0] = byte(noarch.BoolToInt(lua_Number(0.5) == lua_Number((0))))
}

// luaV_tonumber - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32572
func luaV_tonumber(obj []TValue, n []TValue) (c4goDefaultReturn []TValue) {
	var num lua_Number
	if (obj)[0].tt == 3 {
		//-- File: src.cpp/lundump.cpp end --
		//-- #include "src.cpp/lundump.h" start --
		//-- File: src.cpp/lvm.cpp start --
		//
		//** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
		//** Lua virtual machine
		//** See Copyright Notice in lua.h
		//
		//-- #include "src.cpp/stdio.h" start --
		//-- #include "src.cpp/stdlib.h" start --
		//-- #include "src.cpp/string.h" start --
		//-- #include "src.cpp/lua.h" start --
		//-- #include "src.cpp/ldebug.h" start --
		//-- #include "src.cpp/ldo.h" start --
		//-- #include "src.cpp/lfunc.h" start --
		//-- #include "src.cpp/lgc.h" start --
		//-- #include "src.cpp/lobject.h" start --
		//-- #include "src.cpp/lopcodes.h" start --
		//-- #include "src.cpp/lstate.h" start --
		//-- #include "src.cpp/lstring.h" start --
		//-- #include "src.cpp/ltable.h" start --
		//-- #include "src.cpp/ltm.h" start --
		//-- #include "src.cpp/lvm.h" start --
		// limit for table tag-method chains (to avoid loops)
		return obj
	}
	if (obj)[0].tt == 4 && luaO_str2d((*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]TString)(unsafe.Pointer(&(*(obj)[0].value.gc())[0].ts))[:])[func() int32 {
		(0)
		tempVar := &0
		return *tempVar
	}()+1]))) / int64(1))))[:], c4goUnsafeConvert_float64(&num)) != 0 {
		{
			var i_o []TValue = n
			(*i_o[0].value.n()) = num
			i_o[0].tt = 3
		}
		return n
	} else {
		return nil
	}
	return
}

// luaV_tostring - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32584
func luaV_tostring(L []lua_State, obj StkId) (c4goDefaultReturn int32) {
	if !(StkId((obj))[0].tt == 3) {
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32585 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
		return 0
	} else {
		var s []byte = make([]byte, 32)
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32589 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		n lua_Number = func() lua_Number {
			(0)
			tempVar := &(*StkId((obj))[0].value.n())
			return *tempVar
		}()
		noarch.Sprintf(s, []byte("%.14g\x00"), n)
		{
			var i_o []TValue = []TValue((obj))
			(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := luaS_newlstr(L, s, uint(noarch.Strlen(s)))
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			i_o[0].tt = 4
			_ = 0
		}
		return 1
	}
	return
}

// traceexec - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32597
func traceexec(L []lua_State, pc []Instruction) {
	var mask lu_byte = lu_byte(L[0].hookmask)
	var oldpc []Instruction = L[0].savedpc
	L[0].savedpc = pc
	if int32(uint8((mask)))&(1<<uint64(3)) != 0 && L[0].hookcount == 0 {
		L[0].hookcount = L[0].basehookcount
		luaD_callhook(L, 3, -1)
	}
	if int32(uint8((mask)))&(1<<uint64(2)) != 0 {
		var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32606 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
		p []Proto = (*(func() []Closure {
			(0)
			tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId(((L[0].ci)[0].func_))[0].value.gc())[0].cl))[:]
			return *tempVar
		}())[0].l()).p
		var npc int32 = int32((int64(uintptr(unsafe.Pointer(&pc[0])))/int64(4) - int64(uintptr(unsafe.Pointer(&(p)[0].code[0])))/int64(4))) - 1
		var newline int32 = func() int32 {
			if (p)[0].lineinfo != nil {
				return (p)[0].lineinfo[npc]
			}
			return 0
		}()
		if npc == 0 || (int64(uintptr(unsafe.Pointer(&pc[0])))/int64(4)-int64(uintptr(unsafe.Pointer(&oldpc[0])))/int64(4)) <= 0 || newline != func() int32 {
			if (p)[0].lineinfo != nil {
				return (p)[0].lineinfo[int32((int64(uintptr(unsafe.Pointer(&oldpc[0])))/int64(4)-int64(uintptr(unsafe.Pointer(&(p)[0].code[0])))/int64(4)))-1]
			}
			return 0
		}() {
			// call linehook when enter a new function, when jump back (loop),
			//       or when enter a new line
			luaD_callhook(L, 2, newline)
		}
	}
}

// callTMres - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32617
func callTMres(L []lua_State, res StkId, f []TValue, p1 []TValue, p2 []TValue) {
	var result noarch.PtrdiffT = noarch.PtrdiffT(int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&res[0]))) / int64(1))))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))))
	{
		var o2 []TValue = f
		var o1 []TValue = []TValue((L[0].top))
		// push function
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = p1
		var o1 []TValue = []TValue((L[0].top[0+1:]))
		// 1st argument
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = p2
		var o1 []TValue = []TValue((L[0].top[0+2:]))
		// 2nd argument
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack_last)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))) <= 3*int32(16) {
		luaD_growstack(L, 3)
	} else {
		_ = (0)
	}
	L[0].top = L[0].top[0+3:]
	luaD_call(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(3)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])), 1)
	res = StkId(((*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&((*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:])[0+result]))) / int64(1))))[:]))
	func() StkId {
		tempVarUnary := L[0].top
		defer func() {
			L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].top[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].top[0]))))[:]))
		}()
		return tempVarUnary
	}()
	{
		var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
			c4go_temp_name := StkId((L[0].top))
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}())))[:]
		var o1 []TValue = []TValue((res))
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
}

// callTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32633
func callTM(L []lua_State, f []TValue, p1 []TValue, p2 []TValue, p3 []TValue) {
	{
		var o2 []TValue = f
		var o1 []TValue = []TValue((L[0].top))
		// push function
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = p1
		var o1 []TValue = []TValue((L[0].top[0+1:]))
		// 1st argument
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = p2
		var o1 []TValue = []TValue((L[0].top[0+2:]))
		// 2nd argument
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	{
		var o2 []TValue = p3
		var o1 []TValue = []TValue((L[0].top[0+3:]))
		// 3th argument
		o1[0].value = o2[0].value
		o1[0].tt = o2[0].tt
		_ = 0
	}
	if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].stack_last)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := StkId(L[0].top)
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[0])))/int64(1))) <= 4*int32(16) {
		luaD_growstack(L, 4)
	} else {
		_ = (0)
	}
	L[0].top = L[0].top[0+4:]
	luaD_call(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(L[0].top)[0])) - (uintptr)(4)*unsafe.Sizeof(StkId(L[0].top)[0]))))[:])), 0)
}

// luaV_gettable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32645
func luaV_gettable(L []lua_State, t []TValue, key []TValue, val StkId) {
	var loop int32
	for loop = 0; loop < 100; loop++ {
		var tm []TValue
		if (t)[0].tt == 5 {
			var h []Table = func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t)[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			var res []TValue = luaH_get(h, key)
			if !((res)[0].tt == 0) || len((func() []TValue {
				tm = func() []TValue {
					if len(h[0].metatable) == 0 {
						return nil
					}
					return func() []TValue {
						if uint32(uint8((lu_byte((h[0].metatable)[0].flags))))&uint32(1<<int32((uint64(int32((TM_INDEX)))))) != 0 {
							return nil
						}
						return luaT_gettm(h[0].metatable, int32((TM_INDEX)), (L[0].l_G)[0].tmname[:][TM_INDEX])
					}()
				}()
				return tm
			}())) == 0 {
				{
					var o2 []TValue = res
					var o1 []TValue = []TValue((val))
					// `t' is a table?
					// do a primitive get
					// result is no nil?
					// or no TM?
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
				return
			}
		} else if (func() []TValue {
			tm = luaT_gettmbyobj(L, t, int32((TM_INDEX)))
			return tm
		}())[0].tt == 0 {
			// else will try the tag method
			luaG_typeerror(L, t, []byte("index\x00"))
		}
		if (tm)[0].tt == 6 {
			callTMres(L, val, tm, t, key)
			return
		}
		// else repeat with `tm'
		t = tm
	}
	luaG_runerror(L, []byte("loop in gettable\x00"))
}

// luaV_settable - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32671
func luaV_settable(L []lua_State, t []TValue, key []TValue, val StkId) {
	var loop int32
	var temp TValue
	for loop = 0; loop < 100; loop++ {
		var tm []TValue
		if (t)[0].tt == 5 {
			var h []Table = func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t)[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			var oldval []TValue = luaH_set(L, h, key)
			if !((oldval)[0].tt == 0) || len((func() []TValue {
				tm = func() []TValue {
					if len(h[0].metatable) == 0 {
						return nil
					}
					return func() []TValue {
						if uint32(uint8((lu_byte((h[0].metatable)[0].flags))))&uint32(1<<int32((uint64(int32((TM_NEWINDEX)))))) != 0 {
							return nil
						}
						return luaT_gettm(h[0].metatable, int32((TM_NEWINDEX)), (L[0].l_G)[0].tmname[:][TM_NEWINDEX])
					}()
				}()
				return tm
			}())) == 0 {
				{
					var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := StkId((val))
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:]
					var o1 []TValue = oldval
					// `t' is a table?
					// do a primitive set
					// result is no nil?
					// or no TM?
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
				h[0].flags = lu_byte(0)
				{
					if StkId((val))[0].tt >= 4 && int32(uint8(((func() []GCObject {
						(0)
						tempVar := &(*StkId((val))[0].value.gc())
						return *tempVar
					}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&h[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
						// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
						// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
						// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
						// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32683 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
						luaC_barrierback(L, h)
					}
				}
				return
			}
		} else if (func() []TValue {
			tm = luaT_gettmbyobj(L, t, int32((TM_NEWINDEX)))
			return tm
		}())[0].tt == 0 {
			// else will try the tag method
			luaG_typeerror(L, t, []byte("index\x00"))
		}
		if (tm)[0].tt == 6 {
			callTM(L, tm, t, key, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(val)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:])
			return
		}
		{
			var o2 []TValue = tm
			var o1 []TValue = (*[1000000]TValue)(unsafe.Pointer(&temp))[:]
			// else repeat with `tm'
			// avoid pointing inside table (may rehash)
			o1[0].value = o2[0].value
			o1[0].tt = o2[0].tt
			_ = 0
		}
		t = (*[1000000]TValue)(unsafe.Pointer(&temp))[:]
	}
	luaG_runerror(L, []byte("loop in settable\x00"))
}

// call_binTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32702
func call_binTM(L []lua_State, p1 []TValue, p2 []TValue, res StkId, event int32) int32 {
	var tm []TValue = luaT_gettmbyobj(L, p1, event)
	if (tm)[0].tt == 0 {
		// try first operand
		// try second operand
		tm = luaT_gettmbyobj(L, p2, event)
	}
	if (tm)[0].tt == 0 {
		return 0
	}
	callTMres(L, res, tm, p1, p2)
	return 1
}

// get_compTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32713
func get_compTM(L []lua_State, mt1 []Table, mt2 []Table, event int32) []TValue {
	var tm1 []TValue = func() []TValue {
		if len(mt1) == 0 {
			return nil
		}
		return func() []TValue {
			if uint32(uint8((lu_byte((mt1)[0].flags))))&uint32(1<<uint64(uint32(event))) != 0 {
				return nil
			}
			return luaT_gettm(mt1, event, (L[0].l_G)[0].tmname[:][event])
		}()
	}()
	var tm2 []TValue
	if len(tm1) == 0 {
		// no metamethod
		return nil
	}
	if (int64(uintptr(unsafe.Pointer(&mt1[0])))/int64(56) - int64(uintptr(unsafe.Pointer(&mt2[0])))/int64(56)) == 0 {
		// same metatables => same metamethods
		return tm1
	}
	tm2 = func() []TValue {
		if len(mt2) == 0 {
			return nil
		}
		return func() []TValue {
			if uint32(uint8((lu_byte((mt2)[0].flags))))&uint32(1<<uint64(uint32(event))) != 0 {
				return nil
			}
			return luaT_gettm(mt2, event, (L[0].l_G)[0].tmname[:][event])
		}()
	}()
	if len(tm2) == 0 {
		// no metamethod
		return nil
	}
	if luaO_rawequalObj(tm1, tm2) != 0 {
		// same metamethods?
		return tm1
	}
	return nil
}

// call_orderTM - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32727
func call_orderTM(L []lua_State, p1 []TValue, p2 []TValue, event int32) int32 {
	var tm1 []TValue = luaT_gettmbyobj(L, p1, event)
	var tm2 []TValue
	if (tm1)[0].tt == 0 {
		// no metamethod?
		return -1
	}
	tm2 = luaT_gettmbyobj(L, p2, event)
	if noarch.Not(luaO_rawequalObj(tm1, tm2)) {
		// different metamethods?
		return -1
	}
	callTMres(L, StkId(L[0].top), tm1, p1, p2)
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32736 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return noarch.BoolToInt(!(StkId((L[0].top))[0].tt == 0 || StkId((L[0].top))[0].tt == 1 && func() int32 {
		(0)
		tempVar := &(*StkId((L[0].top))[0].value.b())
		return *tempVar
	}() == 0))
}

// l_strcmp - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32740
func l_strcmp(ls []TString, rs []TString) (c4goDefaultReturn int32) {
	var l []byte = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ls[0+1]))) / int64(1))))[:]
	var ll uint = uint(ls[0].tsv.len_)
	var r []byte = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&rs[0+1]))) / int64(1))))[:]
	var lr uint = uint(rs[0].tsv.len_)
	for {
		var temp int32 = strcoll(l, r)
		if temp != 0 {
			return temp
		} else {
			var len_ uint = uint(noarch.Strlen(l))
			if len_ == lr {
				// strings are equal up to a `\0'
				// index of first `\0' in both strings
				// r is finished?
				return func() int32 {
					if len_ == ll {
						return 0
					}
					return 1
				}()
			} else if len_ == ll {
				// l is finished?
				// l is smaller than r (because r is not finished)
				return -1
			}
			// both strings longer than `len'; go on comparing (after the `\0')
			len_++
			l = l[0+len_:]
			ll -= len_
			r = r[0+len_:]
			lr -= len_
		}
	}
	return
}

// luaV_lessthan - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32762
func luaV_lessthan(L []lua_State, l []TValue, r []TValue) int32 {
	var res int32
	if (l)[0].tt != (r)[0].tt {
		return luaG_ordererror(L, l, r)
	} else if (l)[0].tt == 3 {
		return noarch.BoolToInt(func() lua_Number {
			(0)
			tempVar := &(*(l)[0].value.n())
			return *tempVar
		}() < func() lua_Number {
			(0)
			tempVar := &(*(r)[0].value.n())
			return *tempVar
		}())
	} else if (l)[0].tt == 4 {
		return noarch.BoolToInt(l_strcmp((func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(l)[0].value.gc())[0].ts))[:]
			return *tempVar
		}()), (func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(r)[0].value.gc())[0].ts))[:]
			return *tempVar
		}())) < 0)
	} else if (func() int32 {
		res = call_orderTM(L, l, r, int32((TM_LT)))
		return res
	}()) != -1 {
		return res
	}
	return luaG_ordererror(L, l, r)
}

// lessequal - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32776
func lessequal(L []lua_State, l []TValue, r []TValue) int32 {
	var res int32
	if (l)[0].tt != (r)[0].tt {
		return luaG_ordererror(L, l, r)
	} else if (l)[0].tt == 3 {
		return noarch.BoolToInt(func() lua_Number {
			(0)
			tempVar := &(*(l)[0].value.n())
			return *tempVar
		}() <= func() lua_Number {
			(0)
			tempVar := &(*(r)[0].value.n())
			return *tempVar
		}())
	} else if (l)[0].tt == 4 {
		return noarch.BoolToInt(l_strcmp((func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(l)[0].value.gc())[0].ts))[:]
			return *tempVar
		}()), (func() []TString {
			(0)
			tempVar := &(*[1000000]TString)(unsafe.Pointer(&(*(r)[0].value.gc())[0].ts))[:]
			return *tempVar
		}())) <= 0)
	} else if (func() int32 {
		res = call_orderTM(L, l, r, int32((TM_LE)))
		return res
	}()) != -1 {
		// first try `le'
		return res
	} else if (func() int32 {
		res = call_orderTM(L, r, l, int32((TM_LT)))
		return res
	}()) != -1 {
		// else try `lt'
		return noarch.BoolToInt(noarch.Not(res))
	}
	return luaG_ordererror(L, l, r)
}

// luaV_equalval - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32792
func luaV_equalval(L []lua_State, t1 []TValue, t2 []TValue) int32 {
	var tm []TValue
	_ = 0
	switch (t1)[0].tt {
	case 0:
		return 1
	case 3:
		return noarch.BoolToInt(func() lua_Number {
			(0)
			tempVar := &(*(t1)[0].value.n())
			return *tempVar
		}() == func() lua_Number {
			(0)
			tempVar := &(*(t2)[0].value.n())
			return *tempVar
		}())
	case 1:
		// true must be 1 !!
		return noarch.BoolToInt(func() int32 {
			(0)
			tempVar := &(*(t1)[0].value.b())
			return *tempVar
		}() == func() int32 {
			(0)
			tempVar := &(*(t2)[0].value.b())
			return *tempVar
		}())
	case 2:
		return noarch.BoolToInt((func() int64 {
			c4go_temp_name := func() interface{} {
				(0)
				tempVar := &(*(t1)[0].value.p())
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - func() int64 {
			c4go_temp_name := func() interface{} {
				(0)
				tempVar := &(*(t2)[0].value.p())
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) == 0)
	case 7:
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32801 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005feb6c0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.ImplicitCastExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpile BinaryOperator with type 'const TValue *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is get_compTM. argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		// will try TM
		// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32802 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'const TValue *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Error in transpileCallExpr : name of call function is get_compTM. argument position is 1. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21312_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21312:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc005fd9100), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
	case 5:
		if (func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t1)[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - func() int64 {
			c4go_temp_name := func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t2)[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) == 0 {
			return 1
		}
		tm = get_compTM(L, (func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t1)[0].value.gc())[0].h))[:]
			return *tempVar
		}())[0].metatable, (func() []Table {
			(0)
			tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(t2)[0].value.gc())[0].h))[:]
			return *tempVar
		}())[0].metatable, int32((TM_EQ)))
		// will try TM
	default:
		return noarch.BoolToInt((func() int64 {
			c4go_temp_name := func() []GCObject {
				(0)
				tempVar := &(*(t1)[0].value.gc())
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}() - func() int64 {
			c4go_temp_name := func() []GCObject {
				(0)
				tempVar := &(*(t2)[0].value.gc())
				return *tempVar
			}()
			return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
		}()) == 0)
	}
	if len(tm) == 0 {
		// no TM?
		return 0
	}
	// call TM
	callTMres(L, StkId(L[0].top), tm, t1, t2)
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32815 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	return noarch.BoolToInt(!(StkId((L[0].top))[0].tt == 0 || StkId((L[0].top))[0].tt == 1 && func() int32 {
		(0)
		tempVar := &(*StkId((L[0].top))[0].value.b())
		return *tempVar
	}() == 0))
}

// luaV_concat - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32819
func luaV_concat(L []lua_State, total int32, last int32) {
	for {
		var top StkId = L[0].base[0+last+1:]
		var n int32 = 2
		// Warning (*ast.IfStmt):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpileToStmt : Cannot transpileIfStmt. Cannot transpile for condition. Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		if !((StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(2)*unsafe.Sizeof(top[0]))))[:])))[0].tt == 4 || (StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(2)*unsafe.Sizeof(top[0]))))[:])))[0].tt == 3) || !((StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(1)*unsafe.Sizeof(top[0]))))[:])))[0].tt == 4 || luaV_tostring(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(1)*unsafe.Sizeof(top[0]))))[:]))) != 0) {
			if noarch.Not(call_binTM(L, (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(2)*unsafe.Sizeof(top[0]))))[:], (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(1)*unsafe.Sizeof(top[0]))))[:], StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(2)*unsafe.Sizeof(top[0]))))[:])), int32((TM_CONCAT)))) {
				// number of elements handled in this pass (at least 2)
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32823 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				luaG_concaterror(L, StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(2)*unsafe.Sizeof(top[0]))))[:])), StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&top[0])) - (uintptr)(1)*unsafe.Sizeof(top[0]))))[:])))
			}
		} else {
			// second op is empty?
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
			// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32826 :Cannot transpile BinaryOperator with type 'int' : result type = {unknown52}. Error: operator is `==`. cannot atomic for left part. Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc007a55c00), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
		}
		// result is first op (as string)
		// at least two string values; get as many as possible
		// collect total length
		// concat all strings
		// got `n' strings to create 1 new
		total -= n - 1
		last -= n - 1
		if !(total > 1) {
			break
		}
	}
}

// Arith - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32854
func Arith(L []lua_State, ra StkId, rb []TValue, rc []TValue, op int32) {
	var tempb TValue
	var tempc TValue
	var b []TValue
	var c []TValue
	if len((func() []TValue {
		b = luaV_tonumber(rb, (*[1000000]TValue)(unsafe.Pointer(&tempb))[:])
		return b
	}())) != 0 && len((func() []TValue {
		c = luaV_tonumber(rc, (*[1000000]TValue)(unsafe.Pointer(&tempc))[:])
		return c
	}())) != 0 {
		var nb lua_Number = func() lua_Number {
			(0)
			tempVar := &(*(b)[0].value.n())
			return *tempVar
		}()
		var nc lua_Number = func() lua_Number {
			(0)
			tempVar := &(*(c)[0].value.n())
			return *tempVar
		}()
		switch uint32(op) {
		case uint32(int32((TM_ADD))):
			var i_o []TValue = []TValue((ra))
			// repeat until only 1 result left
			(*i_o[0].value.n()) = nb + nc
			i_o[0].tt = 3
		case uint32(int32((TM_SUB))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = nb - nc
			i_o[0].tt = 3
		case uint32(int32((TM_MUL))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = nb * nc
			i_o[0].tt = 3
		case uint32(int32((TM_DIV))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = nb / nc
			i_o[0].tt = 3
		case uint32(int32((TM_MOD))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = nb - lua_Number((math.Floor(float64((nb / nc))) * float64((nc))))
			i_o[0].tt = 3
		case uint32(int32((TM_POW))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = lua_Number((math.Pow(float64((nb)), float64((nc)))))
			i_o[0].tt = 3
		case uint32(int32((TM_UNM))):
			var i_o []TValue = []TValue((ra))
			(*i_o[0].value.n()) = -lua_Number((nb))
			i_o[0].tt = 3
		default:
			_ = (0)
			break
		}
	} else if noarch.Not(call_binTM(L, rb, rc, ra, op)) {
		luaG_aritherror(L, rb, rc)
	}
}

// luaV_execute - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32914
func luaV_execute(L []lua_State, nexeccalls int32) {
	var cl []LClosure
	var base StkId
	var k []TValue
	var pc []Instruction
reentry:
	;
	//
	//** some macros for common tasks in `luaV_execute'
	//
	// to be used after possible stack reallocation
	// entry point
	_ = (0)
	pc = L[0].savedpc
	// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32922 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
	cl = (*[1000000]LClosure)(unsafe.Pointer(&(*(func() []Closure {
		(0)
		tempVar := &(*[1000000]Closure)(unsafe.Pointer(&(*StkId((L[0].ci[0].func_))[0].value.gc())[0].cl))[:]
		return *tempVar
	}())[0].l())))[:]
	base = StkId(L[0].base)
	k = cl[0].p[0].k
	for {
		var i Instruction = (func() []Instruction {
			defer func() {
				func() []Instruction {
					tempVarUnary := pc
					defer func() {
						pc = pc[0+1:]
					}()
					return tempVarUnary
				}()
			}()
			return pc
		}())[0]
		var ra StkId
		if int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(2)|1<<uint64(3)) != 0 && (func() int32 {
			tempVar := &L[0].hookcount
			*tempVar--
			return *tempVar
		}() == 0 || int32(uint8((lu_byte(L[0].hookmask))))&(1<<uint64(2)) != 0) {
			// main loop of interpreter
			traceexec(L, pc)
			if int32(uint8((lu_byte(L[0].status)))) == 1 {
				// did hook yield?
				L[0].savedpc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) - (uintptr)(1)*unsafe.Sizeof(pc[0]))))[:]
				return
			}
			base = StkId(L[0].base)
		}
		// warning!! several calls may realloc the stack and invalidate `ra'
		ra = base[0+int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))):]
		_ = 0
		_ = 0
		_ = 0
		switch uint32(int32(uint32((lu_int32((i >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) {
		case uint32(int32((OP_MOVE))):
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := func() StkId {
						(0)
						tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
						return *tempVar
					}()
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				var o1 []TValue = []TValue((ra))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			continue
			fallthrough
		case uint32(int32((OP_LOADK))):
			{
				var o2 []TValue = (func() []TValue {
					(0)
					tempVar := &k[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0))))))):]
					return *tempVar
				}())
				var o1 []TValue = []TValue((ra))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			continue
			fallthrough
		case uint32(int32((OP_LOADBOOL))):
			{
				var i_o []TValue = []TValue((ra))
				(*i_o[0].value.b()) = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
				i_o[0].tt = 1
			}
			if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) != 0 {
				// skip next instruction (if C)
				func() []Instruction {
					tempVarUnary := pc
					defer func() {
						pc = pc[0+1:]
					}()
					return tempVarUnary
				}()
			}
			continue
			fallthrough
		case uint32(int32((OP_LOADNIL))):
			var rb []TValue = []TValue((func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}()))
			for {
				(func() []TValue {
					defer func() {
						func() []TValue {
							tempVarUnary := rb
							defer func() {
								rb = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&rb[0])) - (uintptr)(1)*unsafe.Sizeof(rb[0]))))[:]
							}()
							return tempVarUnary
						}()
					}()
					return rb
				}())[0].tt = 0
				if !((int64(uintptr(unsafe.Pointer(&rb[0])))/int64(16) - int64(uintptr(unsafe.Pointer(&ra[0])))/int64(16)) >= 0) {
					break
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_GETUPVAL))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			{
				var o2 []TValue = (cl[0].upvals[:][b][0].v)
				var o1 []TValue = []TValue((ra))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			continue
			fallthrough
		case uint32(int32((OP_GETGLOBAL))):
			var g TValue
			var rb []TValue = func() []TValue {
				(0)
				tempVar := &k[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0))))))):]
				return *tempVar
			}()
			{
				var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&g))[:]
				(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].env[0]))) / int64(1))))[:]
				i_o[0].tt = 5
				_ = 0
			}
			_ = 0
			{
				L[0].savedpc = pc
				{
					luaV_gettable(L, (*[1000000]TValue)(unsafe.Pointer(&g))[:], rb, ra)
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_GETTABLE))):
			{
				L[0].savedpc = pc
				{
					luaV_gettable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := func() StkId {
							(0)
							tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
							return *tempVar
						}()
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:], func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}(), ra)
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_SETGLOBAL))):
			var g TValue
			{
				var i_o []TValue = (*[1000000]TValue)(unsafe.Pointer(&g))[:]
				(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&cl[0].env[0]))) / int64(1))))[:]
				i_o[0].tt = 5
				_ = 0
			}
			_ = 0
			{
				L[0].savedpc = pc
				{
					luaV_settable(L, (*[1000000]TValue)(unsafe.Pointer(&g))[:], func() []TValue {
						(0)
						tempVar := &k[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0))))))):]
						return *tempVar
					}(), ra)
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_SETUPVAL))):
			var uv []UpVal = cl[0].upvals[:][int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))]
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId((ra))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				var o1 []TValue = uv[0].v
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			{
				if StkId((ra))[0].tt >= 4 && int32(uint8(((func() []GCObject {
					(0)
					tempVar := &(*StkId((ra))[0].value.gc())
					return *tempVar
				}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:32991 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
					luaC_barrierf(L, (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&uv[0]))) / int64(1))))[:], func() []GCObject {
						(0)
						tempVar := &(*StkId((ra))[0].value.gc())
						return *tempVar
					}())
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_SETTABLE))):
			{
				L[0].savedpc = pc
				{
					luaV_settable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := StkId(ra)
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:], func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}(), StkId((func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}())))
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_NEWTABLE))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			var c int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			{
				var i_o []TValue = []TValue((ra))
				(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := luaH_new(L, luaO_fb2int(b), luaO_fb2int(c))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				i_o[0].tt = 5
				_ = 0
			}
			{
				L[0].savedpc = pc
				{
					{
						_ = 0
						if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
							luaC_step(L)
						}
					}
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_SELF))):
			var rb StkId = func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}()
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId((rb))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				var o1 []TValue = []TValue((ra[0+1:]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			{
				L[0].savedpc = pc
				{
					luaV_gettable(L, (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := StkId(rb)
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:], func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}(), ra)
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_ADD))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = nb + nc
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_ADD)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_SUB))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = nb - nc
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_SUB)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_MUL))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = nb * nc
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_MUL)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_DIV))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = nb / nc
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_DIV)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_MOD))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = nb - lua_Number((math.Floor(float64((nb / nc))) * float64((nc))))
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_MOD)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_POW))):
			{
				var rb []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				var rc []TValue = func() []TValue {
					(0)
					if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
						return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
					}
					return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
				}()
				if (rb)[0].tt == 3 && (rc)[0].tt == 3 {
					var nb lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rb)[0].value.n())
						return *tempVar
					}()
					var nc lua_Number = func() lua_Number {
						(0)
						tempVar := &(*(rc)[0].value.n())
						return *tempVar
					}()
					{
						var i_o []TValue = []TValue((ra))
						(*i_o[0].value.n()) = lua_Number((math.Pow(float64((nb)), float64((nc)))))
						i_o[0].tt = 3
					}
				} else {
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rc, int32((TM_POW)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_UNM))):
			var rb []TValue = []TValue((func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}()))
			if (rb)[0].tt == 3 {
				var nb lua_Number = func() lua_Number {
					(0)
					tempVar := &(*(rb)[0].value.n())
					return *tempVar
				}()
				{
					var i_o []TValue = []TValue((ra))
					(*i_o[0].value.n()) = -lua_Number((nb))
					i_o[0].tt = 3
				}
			} else {
				{
					L[0].savedpc = pc
					{
						Arith(L, ra, rb, rb, int32((TM_UNM)))
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_NOT))):
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33047 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			res int32 = noarch.BoolToInt((func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}())[0].tt == 0 || (func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}())[0].tt == 1 && func() int32 {
				(0)
				tempVar := &(*(func() StkId {
					(0)
					tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
					return *tempVar
				}())[0].value.b())
				return *tempVar
			}() == 0)
			{
				var i_o []TValue = []TValue((ra))
				// next assignment may change this value
				(*i_o[0].value.b()) = res
				i_o[0].tt = 1
			}
			continue
			fallthrough
		case uint32(int32((OP_LEN))):
			var rb []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := func() StkId {
					(0)
					tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
					return *tempVar
				}()
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			switch (rb)[0].tt {
			case 5:
				var i_o []TValue = []TValue((ra))
				(*i_o[0].value.n()) = lua_Number(luaH_getn(func() []Table {
					(0)
					tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*(rb)[0].value.gc())[0].h))[:]
					return *tempVar
				}()))
				i_o[0].tt = 3
			case 4:
				var i_o []TValue = []TValue((ra))
				// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.ParenExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpile BinaryOperator with type 'lua_Number' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				// Warning (*ast.BinaryOperator):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33059 :Cannot transpileToStmt : Cannot transpileToExpr. err = Cannot transpile BinaryOperator with type 'lua_Number' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpileImplicitCastExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot transpileToExpr. err = Cannot transpile MemberExpr. err = Cannot transpileToExpr. err = Cannot transpile ParenExpr. err = Cannot casting {struct __struct_at__home_1828_sandbox_src_the_language_core_arch_c_lang_c_21296_3_ * -> struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *}. err = Found mistake `cToType` `struct (anonymous struct at /home/1828_sandbox/src/the-language/core/arch/c/lang.c:21296:3) *` C type: &ast.SliceExpr{X:(*ast.CallExpr)(0xc004631ec0), Lbrack:0, Low:ast.Expr(nil), High:ast.Expr(nil), Max:ast.Expr(nil), Slice3:false, Rbrack:0}
				i_o[0].tt = 3
			default:
				{
					// try metamethod
					L[0].savedpc = pc
					{
						if noarch.Not(call_binTM(L, rb, (*[1000000]TValue)(unsafe.Pointer(&luaO_nilobject_))[:], ra, int32((TM_LEN)))) {
							luaG_typeerror(L, rb, []byte("get length of\x00"))
						}
					}
					base = StkId(L[0].base)
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_CONCAT))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			var c int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			{
				L[0].savedpc = pc
				{
					luaV_concat(L, c-b+1, c)
					{
						_ = 0
						if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
							luaC_step(L)
						}
					}
				}
				base = StkId(L[0].base)
			}
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&base[0+b]))) / int64(1))))[:]
				var o1 []TValue = []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))):]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			continue
			fallthrough
		case uint32(int32((OP_JMP))):
			{
				pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
				{
					_ = 0
					_ = 0
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_EQ))):
			var rb []TValue = func() []TValue {
				(0)
				if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
					return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
				}
				return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
			}()
			var rc []TValue = func() []TValue {
				(0)
				if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
					return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
				}
				return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
			}()
			{
				L[0].savedpc = pc
				{
					if ((rb)[0].tt == (rc)[0].tt && luaV_equalval(L, rb, rc) != 0) == (int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))) != 0) {
						pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
						{
							_ = 0
							_ = 0
						}
					}
				}
				base = StkId(L[0].base)
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_LT))):
			{
				L[0].savedpc = pc
				{
					if luaV_lessthan(L, (func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}()), (func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}())) == int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))) {
						pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
						{
							_ = 0
							_ = 0
						}
					}
				}
				base = StkId(L[0].base)
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_LE))):
			{
				L[0].savedpc = pc
				{
					if lessequal(L, (func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}()), (func() []TValue {
						(0)
						if int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))&(1<<uint64(9-1)) != 0 {
							return (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&k[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))) & ^(1<<uint64(9-1)))*unsafe.Sizeof(k[0]))))[:]
						}
						return []TValue((base[0+int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]))
					}())) == int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))) {
						pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
						{
							_ = 0
							_ = 0
						}
					}
				}
				base = StkId(L[0].base)
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_TEST))):
			if (StkId((ra))[0].tt == 0 || StkId((ra))[0].tt == 1 && func() int32 {
				(0)
				tempVar := &(*StkId((ra))[0].value.b())
				return *tempVar
			}() == 0) != (int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) != 0) {
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33109 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
				{
					_ = 0
					_ = 0
				}
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_TESTSET))):
			var rb []TValue = []TValue((func() StkId {
				(0)
				tempVar := &base[0+int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))):]
				return *tempVar
			}()))
			if ((rb)[0].tt == 0 || (rb)[0].tt == 1 && func() int32 {
				(0)
				tempVar := &(*(rb)[0].value.b())
				return *tempVar
			}() == 0) != (int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) != 0) {
				{
					var o2 []TValue = (rb)
					var o1 []TValue = []TValue((ra))
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
				{
					pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
					{
						_ = 0
						_ = 0
					}
				}
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_CALL))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			var nresults int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) - 1
			if b != 0 {
				// else previous instruction set top
				L[0].top = ra[0+b:]
			}
			L[0].savedpc = pc
			switch luaD_precall(L, ra, nresults) {
			case 0:
				nexeccalls++
				// restart luaV_execute over new Lua function
				goto reentry
				fallthrough
			case 1:
				if nresults >= 0 {
					// it was a C function (`precall' called it); adjust results
					L[0].top = StkId(L[0].ci[0].top)
				}
				base = StkId(L[0].base)
				continue
				fallthrough
			default:
				// yield
				return
			}
			fallthrough
		case uint32(int32((OP_TAILCALL))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			if b != 0 {
				// else previous instruction set top
				L[0].top = ra[0+b:]
			}
			L[0].savedpc = pc
			_ = 0
			switch luaD_precall(L, ra, -1) {
			case 0:
				var ci []CallInfo = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].ci[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].ci[0]))))[:]
				var aux int32
				var func_ StkId = StkId(ci[0].func_)
				var pfunc StkId = StkId((ci[0+1:])[0].func_)
				if L[0].openupval != nil {
					// tail call: put new frame in place of previous one
					// previous frame
					// previous function index
					luaF_close(L, StkId(ci[0].base))
				}
				ci[0].base = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(ci[0].func_)[0])) + (uintptr)(int32((func() int64 {
					c4go_temp_name := StkId((ci[0+1:])[0].base)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}()-int64(uintptr(unsafe.Pointer(&pfunc[0])))/int64(8))))*unsafe.Sizeof(StkId(ci[0].func_)[0]))))[:]))
				L[0].base = ci[0].base
				{
					// move frame down
					for aux = 0; (int64(uintptr(unsafe.Pointer(&pfunc[0+aux])))/int64(8) - func() int64 {
						c4go_temp_name := StkId(L[0].top)
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}()) < 0; aux++ {
						var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&pfunc[0+aux]))) / int64(1))))[:]
						var o1 []TValue = []TValue((func_[0+aux:]))
						o1[0].value = o2[0].value
						o1[0].tt = o2[0].tt
						_ = 0
					}
				}
				L[0].top = func_[0+aux:]
				// correct top
				ci[0].top = L[0].top
				_ = 0
				ci[0].savedpc = L[0].savedpc
				// one more call lost
				ci[0].tailcalls++
				// remove new frame
				func() []CallInfo {
					tempVarUnary := L[0].ci
					defer func() {
						L[0].ci = (*(*[1000000]CallInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(&L[0].ci[0])) - (uintptr)(1)*unsafe.Sizeof(L[0].ci[0]))))[:]
					}()
					return tempVarUnary
				}()
				goto reentry
				fallthrough
			case 1:
				// it was a C function (`precall' called it)
				base = StkId(L[0].base)
				continue
				fallthrough
			default:
				// yield
				return
			}
			fallthrough
		case uint32(int32((OP_RETURN))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			if b != 0 {
				L[0].top = StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&ra[0+b:][0])) - (uintptr)(1)*unsafe.Sizeof(ra[0+b:][0]))))[:]))
			}
			if L[0].openupval != nil {
				luaF_close(L, base)
			}
			L[0].savedpc = pc
			b = luaD_poscall(L, ra)
			if func() int32 {
				nexeccalls--
				return nexeccalls
			}() == 0 {
				// was previous function running `here'?
				// no: return
				return
			} else {
				if b != 0 {
					// yes: continue its execution
					L[0].top = StkId(L[0].ci[0].top)
				}
				_ = 0
				_ = 0
				goto reentry
			}
			fallthrough
		case uint32(int32((OP_FORLOOP))):
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33192 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			step lua_Number = func() lua_Number {
				(0)
				tempVar := &(*(ra[0+2:])[0].value.n())
				return *tempVar
			}()
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33193 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			idx lua_Number = func() lua_Number {
				(0)
				tempVar := &(*StkId((ra))[0].value.n())
				return *tempVar
			}() + step
			var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33194 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			limit lua_Number = func() lua_Number {
				(0)
				tempVar := &(*(ra[0+1:])[0].value.n())
				return *tempVar
			}()
			if func() int32 {
				if float64(0) < float64((step)) {
					return noarch.BoolToInt(idx <= limit)
				}
				return noarch.BoolToInt(limit <= idx)
			}() != 0 {
				{
					// increment index
					// jump back
					pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
					{
						_ = 0
						_ = 0
					}
				}
				{
					var i_o []TValue = []TValue((ra))
					// update internal index...
					(*i_o[0].value.n()) = idx
					i_o[0].tt = 3
				}
				{
					var i_o []TValue = []TValue((ra[0+3:]))
					// ...and external index
					(*i_o[0].value.n()) = idx
					i_o[0].tt = 3
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_FORPREP))):
			var init_ []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
				c4go_temp_name := StkId(ra)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())))[:]
			var plimit []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ra[0+1]))) / int64(1))))[:]
			var pstep []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ra[0+2]))) / int64(1))))[:]
			// next steps may throw errors
			L[0].savedpc = pc
			if !((init_)[0].tt == 3 || len((func() []TValue {
				init_ = luaV_tonumber(init_, []TValue((ra)))
				return init_
			}())) != 0) {
				luaG_runerror(L, []byte("'for' initial value must be a number\x00"))
			} else if !((plimit)[0].tt == 3 || len((func() []TValue {
				plimit = luaV_tonumber(plimit, []TValue((ra[0+1:])))
				return plimit
			}())) != 0) {
				luaG_runerror(L, []byte("'for' limit must be a number\x00"))
			} else if !((pstep)[0].tt == 3 || len((func() []TValue {
				pstep = luaV_tonumber(pstep, []TValue((ra[0+2:])))
				return pstep
			}())) != 0) {
				luaG_runerror(L, []byte("'for' step must be a number\x00"))
			}
			{
				var i_o []TValue = []TValue((ra))
				// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33214 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
				(*i_o[0].value.n()) = func() lua_Number {
					(0)
					tempVar := &(*StkId((ra))[0].value.n())
					return *tempVar
				}() - func() lua_Number {
					(0)
					tempVar := &(*(pstep)[0].value.n())
					return *tempVar
				}()
				i_o[0].tt = 3
			}
			{
				pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((i>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
				{
					_ = 0
					_ = 0
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_TFORLOOP))):
			var cb StkId = ra[0+3:]
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ra[0+2]))) / int64(1))))[:]
				var o1 []TValue = []TValue((cb[0+2:]))
				// call base
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ra[0+1]))) / int64(1))))[:]
				var o1 []TValue = []TValue((cb[0+1:]))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			{
				var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
					c4go_temp_name := StkId((ra))
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}())))[:]
				var o1 []TValue = []TValue((cb))
				o1[0].value = o2[0].value
				o1[0].tt = o2[0].tt
				_ = 0
			}
			// func. + 2 args (state and index)
			L[0].top = cb[0+3:]
			{
				L[0].savedpc = pc
				{
					luaD_call(L, cb, int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))))
				}
				base = StkId(L[0].base)
			}
			L[0].top = StkId(L[0].ci[0].top)
			// previous call may change the stack
			cb = base[0+int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0)))))))+3:]
			if !(StkId((cb))[0].tt == 0) {
				{
					var // Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33227 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
					o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
						c4go_temp_name := StkId((cb))
						return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
					}())))[:]
					var o1 []TValue = (*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&cb[0])) - (uintptr)(1)*unsafe.Sizeof(cb[0]))))[:]
					// continue loop?
					// save control variable
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
				{
					// jump back
					pc = (*(*[1000000]Instruction)(unsafe.Pointer(uintptr(unsafe.Pointer(&pc[0])) + (uintptr)(int32(uint32((lu_int32((pc[0]>>uint64(0+6+8)&(^(^Instruction(0)<<uint64(9+9))<<uint64(0)))))))-(1<<uint64(9+9)-1)>>uint64(1))*unsafe.Sizeof(pc[0]))))[:]
					{
						_ = 0
						_ = 0
					}
				}
			}
			func() []Instruction {
				tempVarUnary := pc
				defer func() {
					pc = pc[0+1:]
				}()
				return tempVarUnary
			}()
			continue
			fallthrough
		case uint32(int32((OP_SETLIST))):
			var n int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			var c int32 = int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))
			var last int32
			var h []Table
			if n == 0 {
				n = int32((func() int64 {
					c4go_temp_name := StkId(L[0].top)
					return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
				}() - int64(uintptr(unsafe.Pointer(&ra[0])))/int64(8))) - 1
				L[0].top = StkId(L[0].ci[0].top)
			}
			if c == 0 {
				c = int32(uint32((lu_int32(((func() []Instruction {
					defer func() {
						func() []Instruction {
							tempVarUnary := pc
							defer func() {
								pc = pc[0+1:]
							}()
							return tempVarUnary
						}()
					}()
					return pc
				}())[0])))))
			}
			{
				if !(StkId((ra))[0].tt == 5) {
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33244 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
					break
				}
			}
			// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33245 :cannot determine type for RHS 'value', will use 'void *' for all fields. Is lvalue = true. n.Name = `value`
			h = func() []Table {
				(0)
				tempVar := &(*[1000000]Table)(unsafe.Pointer(&(*StkId((ra))[0].value.gc())[0].h))[:]
				return *tempVar
			}()
			last = (c-1)*50 + n
			if last > h[0].sizearray {
				// needs more space?
				// pre-alloc it at once
				luaH_resizearray(L, h, last)
			}
			for ; n > 0; n-- {
				var val []TValue = []TValue((ra[0+n:]))
				{
					var o2 []TValue = (val)
					var o1 []TValue = luaH_setnum(L, h, func() int32 {
						defer func() {
							last--
						}()
						return last
					}())
					o1[0].value = o2[0].value
					o1[0].tt = o2[0].tt
					_ = 0
				}
				{
					if (val)[0].tt >= 4 && int32(uint8(((func() []GCObject {
						(0)
						tempVar := &(*(val)[0].value.gc())
						return *tempVar
					}())[0].gch.marked)))&(1<<uint64(0)|1<<uint64(1)) != 0 && int32(uint8((((*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&h[0]))) / int64(1))))[:])[0].gch.marked)))&(1<<uint64(2)) != 0 {
						luaC_barrierback(L, h)
					}
				}
			}
			continue
			fallthrough
		case uint32(int32((OP_CLOSE))):
			luaF_close(L, ra)
			continue
			fallthrough
		case uint32(int32((OP_CLOSURE))):
			var p []Proto
			var ncl []Closure
			var nup int32
			var j int32
			p = cl[0].p[0].p[int32(uint32((lu_int32((i >> uint64(0+6+8) & (^(^Instruction(0) << uint64(9+9)) << uint64(0)))))))]
			nup = int32(uint8((lu_byte(p[0].nups))))
			ncl = luaF_newLclosure(L, nup, cl[0].env)
			ncl[0].l.p = p
			for j = 0; j < nup; {
				if uint32(int32(uint32((lu_int32((pc[0] >> uint64(0) & (^(^Instruction(0) << uint64(6)) << uint64(0)))))))) == uint32(int32((OP_GETUPVAL))) {
					ncl[0].l.upvals[:][j] = cl[0].upvals[:][int32(uint32((lu_int32((pc[0] >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0)))))))]
				} else {
					_ = 0
					ncl[0].l.upvals[:][j] = luaF_findupval(L, base[0+int32(uint32((lu_int32((pc[0]>>uint64(0+6+8+9)&(^(^Instruction(0)<<uint64(9))<<uint64(0))))))):])
				}
				j++
				func() []Instruction {
					tempVarUnary := pc
					defer func() {
						pc = pc[0+1:]
					}()
					return tempVarUnary
				}()
			}
			{
				var i_o []TValue = []TValue((ra))
				(*i_o[0].value.gc()) = (*[1000000]GCObject)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&ncl[0]))) / int64(1))))[:]
				i_o[0].tt = 6
				_ = 0
			}
			{
				L[0].savedpc = pc
				{
					{
						_ = 0
						if lu_mem((L[0].l_G)[0].totalbytes) >= lu_mem((L[0].l_G)[0].GCthreshold) {
							luaC_step(L)
						}
					}
				}
				base = StkId(L[0].base)
			}
			continue
			fallthrough
		case uint32(int32((OP_VARARG))):
			var b int32 = int32(uint32((lu_int32((i >> uint64(0+6+8+9) & (^(^Instruction(0) << uint64(9)) << uint64(0))))))) - 1
			var j int32
			var ci []CallInfo = L[0].ci
			var n int32 = int32((func() int64 {
				c4go_temp_name := StkId(ci[0].base)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}() - func() int64 {
				c4go_temp_name := StkId(ci[0].func_)
				return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
			}())) - int32(uint8((lu_byte(cl[0].p[0].numparams)))) - 1
			if b == -1 {
				{
					L[0].savedpc = pc
					{
						if int32((int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
							c4go_temp_name := StkId(L[0].stack_last)
							return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
						}())))[0])))/int64(1) - int64(uintptr(unsafe.Pointer(&(*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
							c4go_temp_name := StkId(L[0].top)
							return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
						}())))[0])))/int64(1))) <= n*int32(16) {
							luaD_growstack(L, n)
						} else {
							_ = (0)
						}
					}
					base = StkId(L[0].base)
				}
				// previous call may change the stack
				ra = base[0+int32(uint32((lu_int32((i >> uint64(0+6) & (^(^Instruction(0) << uint64(8)) << uint64(0))))))):]
				b = n
				L[0].top = ra[0+n:]
			}
			for j = 0; j < b; j++ {
				if j < n {
					{
						var o2 []TValue = (*[1000000]TValue)(unsafe.Pointer(uintptr(func() int64 {
							c4go_temp_name := StkId(((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&(*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(ci[0].base)[0])) - (uintptr)(n)*unsafe.Sizeof(StkId(ci[0].base)[0]))))[:][0])) + (uintptr)(j)*unsafe.Sizeof((*(*[1000000]TValue)(unsafe.Pointer(uintptr(unsafe.Pointer(&StkId(ci[0].base)[0])) - (uintptr)(n)*unsafe.Sizeof(StkId(ci[0].base)[0]))))[:][0]))))[:]))
							return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
						}())))[:]
						var o1 []TValue = []TValue((ra[0+j:]))
						o1[0].value = o2[0].value
						o1[0].tt = o2[0].tt
						_ = 0
					}
				} else {
					// Warning (*ast.MemberExpr):  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33296 :cannot determine type for LHS 'StkId', will use 'void *' for all fields. Is lvalue = true. n.Name = tt
					(ra[0+j:])[0].tt = 0
				}
			}
			continue
		}
	}
}

// luaZ_fill - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33329
func luaZ_fill(z []ZIO) int32 {
	var size uint
	var L []lua_State = z[0].L
	var buff []byte
	//-- File: src.cpp/lvm.cpp end --
	//-- #include "src.cpp/lvm.h" start --
	//-- File: src.cpp/lzio.cpp start --
	//
	//** $Id: lzio.c,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
	//** a generic input stream interface
	//** See Copyright Notice in lua.h
	//
	//-- #include "src.cpp/string.h" start --
	//-- #include "src.cpp/lua.h" start --
	//-- #include "src.cpp/llimits.h" start --
	//-- #include "src.cpp/lmem.h" start --
	//-- #include "src.cpp/lstate.h" start --
	//-- #include "src.cpp/lzio.h" start --
	_ = 0
	buff = z.reader(L, z[0].data, c4goUnsafeConvert_uint(&size))
	_ = 0
	if len(buff) == 0 || size == uint(0) {
		return -1
	}
	z[0].n = size - uint(1)
	z[0].p = buff
	return int32(uint8((func() []byte {
		tempVar := z[0].p
		defer func() {
			z[0].p = z[0].p[1:]
		}()
		return tempVar
	}())[0]))
}

// luaZ_lookahead - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33343
func luaZ_lookahead(z []ZIO) int32 {
	if uint(z[0].n) == uint(0) {
		if luaZ_fill(z) == -1 {
			return -1
		} else {
			// luaZ_fill removed first byte; put back it
			z[0].n += uint(1)
			func() []byte {
				tempVarUnary := z[0].p
				defer func() {
					z[0].p = (*(*[1000000]byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&z[0].p[0])) - (uintptr)(1)*unsafe.Sizeof(z[0].p[0]))))[:]
				}()
				return tempVarUnary
			}()
		}
	}
	return int32(uint8(z[0].p[0]))
}

// luaZ_init - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33356
func luaZ_init(L []lua_State, z []ZIO, reader lua_Reader, data interface{}) {
	z[0].L = L
	z[0].reader = reader
	z[0].data = data
	z[0].n = 0
	z[0].p = nil
}

// luaZ_read - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33366
func luaZ_read(z []ZIO, b interface{}, n uint) uint {
	for bool(n) {
		var m uint
		if luaZ_lookahead(z) == -1 {
			// --------------------------------------------------------------- read ---
			// return number of missing bytes
			return n
		}
		// min. between n and z->n
		m = uint(func() uint32 {
			if n <= uint(z[0].n) {
				return uint32(n)
			}
			return uint32(uint(z[0].n))
		}())
		noarch.Memcpy(b, z[0].p, m)
		z[0].n -= m
		z[0].p = z[0].p[0+m:]
		b = (b.([]byte))[0+m:]
		n -= m
	}
	return 0
}

// luaZ_openspace - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/lang.c:33382
func luaZ_openspace(L []lua_State, buff []Mbuffer, n uint) []byte {
	if n > uint(buff[0].buffsize) {
		if n < uint(32) {
			// ------------------------------------------------------------------------
			n = 32
		}
		(func() []byte {
			(buff)[0].buffer = func() interface{} {
				if uint(n+uint(1)) <= (uint(^uint(0))-uint(2))/uint(1) {
					return luaM_realloc_(L, ((buff)[0].buffer), (buff)[0].buffsize*uint(1), n*uint(1))
				}
				return luaM_toobig(L)
			}().([]byte)
			return (buff)[0].buffer
		}())
		(buff)[0].buffsize = n
	}
	return buff[0].buffer
}

// main - transpiled function from  /home/1828_sandbox/src/the-language/core/arch/c/testmain.c:23
func main() {
	defer noarch.AtexitRun()
	var L []lang_state = lang_state_new_orNULL()
	//
	//    The Language
	//    Copyright (C) 2019  Zaoqi <zaomir@outlook.com>
	//
	//    This program is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU Affero General Public License as published
	//    by the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    This program is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU Affero General Public License for more details.
	//
	//    You should have received a copy of the GNU Affero General Public License
	//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
	//
	//
	func() {
		if L != nil {
		} else {
			linux.AssertFail([]byte("L\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/testmain.c\x00"), 25, []byte("int main()\x00"))
		}
	}()
	var x []lang_value = lang_complex_parse_orNULL(L, []byte(":&>化滅\x00"))
	func() {
		if x != nil {
		} else {
			linux.AssertFail([]byte("x\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/testmain.c\x00"), 27, []byte("int main()\x00"))
		}
	}()
	var s []byte = lang_simple_print_orNULL(L, x)
	lang_value_delete(L, x)
	func() {
		if s != nil {
		} else {
			linux.AssertFail([]byte("s\x00"), []byte("/home/1828_sandbox/src/the-language/core/arch/c/testmain.c\x00"), 30, []byte("int main()\x00"))
		}
	}()
	noarch.Puts(s)
	_ = s
	return
}

// c4goUnsafeConvert_BlockCnt : created by c4go
func c4goUnsafeConvert_BlockCnt(c4go_name *BlockCnt) []BlockCnt {
	return (*[1000000]BlockCnt)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_CCallS : created by c4go
func c4goUnsafeConvert_CCallS(c4go_name *CCallS) []CCallS {
	return (*[1000000]CCallS)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_CallS : created by c4go
func c4goUnsafeConvert_CallS(c4go_name *CallS) []CallS {
	return (*[1000000]CallS)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_ConsControl : created by c4go
func c4goUnsafeConvert_ConsControl(c4go_name *ConsControl) []ConsControl {
	return (*[1000000]ConsControl)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_FuncState : created by c4go
func c4goUnsafeConvert_FuncState(c4go_name *FuncState) []FuncState {
	return (*[1000000]FuncState)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_LHS_assign : created by c4go
func c4goUnsafeConvert_LHS_assign(c4go_name *LHS_assign) []LHS_assign {
	return (*[1000000]LHS_assign)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_LexState : created by c4go
func c4goUnsafeConvert_LexState(c4go_name *LexState) []LexState {
	return (*[1000000]LexState)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_LoadF : created by c4go
func c4goUnsafeConvert_LoadF(c4go_name *LoadF) []LoadF {
	return (*[1000000]LoadF)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_LoadS : created by c4go
func c4goUnsafeConvert_LoadS(c4go_name *LoadS) []LoadS {
	return (*[1000000]LoadS)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_MatchState : created by c4go
func c4goUnsafeConvert_MatchState(c4go_name *MatchState) []MatchState {
	return (*[1000000]MatchState)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_SParser : created by c4go
func c4goUnsafeConvert_SParser(c4go_name *SParser) []SParser {
	return (*[1000000]SParser)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_byte : created by c4go
func c4goUnsafeConvert_byte(c4go_name *byte) []byte {
	return (*[1000000]byte)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_expdesc : created by c4go
func c4goUnsafeConvert_expdesc(c4go_name *expdesc) []expdesc {
	return (*[1000000]expdesc)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_float64 : created by c4go
func c4goUnsafeConvert_float64(c4go_name *float64) []float64 {
	return (*[1000000]float64)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_int32 : created by c4go
func c4goUnsafeConvert_int32(c4go_name *int32) []int32 {
	return (*[1000000]int32)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_luaL_Buffer : created by c4go
func c4goUnsafeConvert_luaL_Buffer(c4go_name *luaL_Buffer) []luaL_Buffer {
	return (*[1000000]luaL_Buffer)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_lua_Debug : created by c4go
func c4goUnsafeConvert_lua_Debug(c4go_name *lua_Debug) []lua_Debug {
	return (*[1000000]lua_Debug)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_lua_longjmp : created by c4go
func c4goUnsafeConvert_lua_longjmp(c4go_name *lua_longjmp) []lua_longjmp {
	return (*[1000000]lua_longjmp)(unsafe.Pointer(c4go_name))[:]
}

// c4goUnsafeConvert_uint : created by c4go
func c4goUnsafeConvert_uint(c4go_name *uint) []uint {
	return (*[1000000]uint)(unsafe.Pointer(c4go_name))[:]
}

//-- File: src.cpp/lzio.cpp end --
//-- #include "src.cpp/lzio.h" start --
//-- #include "src.cpp/math.h" start --
//-- #include "src.cpp/readline/history.h" start --
//-- #include "src.cpp/readline/readline.h" start --
//-- #include "src.cpp/setjmp.h" start --
//-- #include "src.cpp/stdarg.h" start --
//-- #include "src.cpp/stddef.h" start --
//-- #include "src.cpp/stdio.h" start --
//-- #include "src.cpp/stdlib.h" start --
//-- #include "src.cpp/string.h" start --
//-- #include "src.cpp/unistd.h" start --

// _setjmp - add c-binding for implemention function
func _setjmp(arg0 []__jmp_buf_tag) int32 {
	return int32(C._setjmp((*C.__jmp_buf_tag)(unsafe.Pointer(&arg0[0]))))
}

// ferror - add c-binding for implemention function
func ferror(arg0 *noarch.File) int32 {
	return int32(C.ferror((*C.FILE)(unsafe.Pointer(&arg0))))
}

// freopen - add c-binding for implemention function
func freopen(arg0 []byte, arg1 []byte, arg2 *noarch.File) *noarch.File {
	return *noarch.File(C.freopen((*C.char)(unsafe.Pointer(&arg0[0])), (*C.char)(unsafe.Pointer(&arg1[0])), (*C.FILE)(unsafe.Pointer(&arg2))))
}

// longjmp - add c-binding for implemention function
func longjmp(arg0 []__jmp_buf_tag, arg1 int32) {
	return C.longjmp((*C.__jmp_buf_tag)(unsafe.Pointer(&arg0[0])), C.int(arg1))
}

// memchr - add c-binding for implemention function
func memchr(arg0 interface{}, arg1 int32, arg2 uint32) interface{} {
	return interface{}(C.memchr(unsafe.Pointer(&arg0), C.int(arg1), C.ulong(arg2)))
}

// strcoll - add c-binding for implemention function
func strcoll(arg0 []byte, arg1 []byte) int32 {
	return int32(C.strcoll((*C.char)(unsafe.Pointer(&arg0[0])), (*C.char)(unsafe.Pointer(&arg1[0]))))
}

// strcspn - add c-binding for implemention function
func strcspn(arg0 []byte, arg1 []byte) uint32 {
	return uint32(C.strcspn((*C.char)(unsafe.Pointer(&arg0[0])), (*C.char)(unsafe.Pointer(&arg1[0]))))
}

// strpbrk - add c-binding for implemention function
func strpbrk(arg0 []byte, arg1 []byte) []byte {
	return []byte(C.GoString(C.strpbrk((*C.char)(unsafe.Pointer(&arg0[0])), (*C.char)(unsafe.Pointer(&arg1[0])))))
}

// ungetc - add c-binding for implemention function
func ungetc(arg0 int32, arg1 *noarch.File) int32 {
	return int32(C.ungetc(C.int(arg0), (*C.FILE)(unsafe.Pointer(&arg1))))
}

// va_list is C4GO implementation of va_list from "stdarg.h"
type va_list struct {
	position int
	slice    []interface{}
}

func create_va_list(list []interface{}) *va_list {
	return &va_list{
		position: 0,
		slice:    list,
	}
}

func va_start(v *va_list, count interface{}) {
	v.position = 0
}

func va_end(v *va_list) {
	// do nothing
}

func va_arg(v *va_list) interface{} {
	defer func() {
		v.position++
	}()
	value := v.slice[v.position]
	switch value.(type) {
	case int:
		return int32(value.(int))
	default:
		return value
	}
}
