/* Generated by make.rkt */
/*
    The Language
    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
#include "lang.h"
/*-- #include "src.cpp/assert.h" start --*/
#include <assert.h>

/*-- #include "src.cpp/ctype.h" start --*/
/* ctype.h 單文件時起作用，只用於精簡 */

#ifndef string_isspace_h
#define string_isspace_h

/* 避免与标准库符号冲突 */
#define isspace user_defined_isspace

/* https://github.com/bminor/musl/blob/da55d4884bf26ce31cd6a64ed176019c2ba9839a/src/ctype/isspace.c */
static inline int isspace(int c) {
	return c == ' ' || (unsigned)c-'\t' < 5;
}

#endif

/*-- #include "src.cpp/errno.h" start --*/

/*-- #include "src.cpp/io.h" start --*/

/*-- File: src.cpp/lang.cpp start --*/
/*-- #include "src.cpp/lauxlib.h" start --*/
/*
** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


/*-- #include "src.cpp/stddef.h" start --*/
#include <stddef.h>

/*-- #include "src.cpp/stdio.h" start --*/
#include <stdio.h>


/*-- #include "src.cpp/lua.h" start --*/
/*
** $Id: lua.h,v 1.218.1.7 2012/01/13 20:36:20 roberto Exp $
** Lua - An Extensible Extension Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

/*-- #include "src.cpp/stdarg.h" start --*/
#include <stdarg.h>

/*-- #include "src.cpp/stddef.h" start --*/


/*-- #include "src.cpp/luaconf.h" start --*/
/*
** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef lconfig_h
#define lconfig_h

/*-- #include "src.cpp/limits.h" start --*/
#include <limits.h>

/*-- #include "src.cpp/stddef.h" start --*/


/*
** ==================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
@@ LUA_ANSI controls the use of non-ansi features.
** CHANGE it (define it) if you want Lua to avoid the use of any
** non-ansi feature or library.
*/
#if defined(__STRICT_ANSI__)
#define LUA_ANSI
#endif


#if !defined(LUA_ANSI) && defined(_WIN32)
#define LUA_WIN
#endif

#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif

#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_DL_DYLD		/* does not need extra library */
#endif



/*
@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
@* Interfaces Extension (XSI).
** CHANGE it (define it) if your system is XSI compatible.
*/
#if defined(LUA_USE_POSIX)
#define LUA_USE_MKSTEMP
#define LUA_USE_ISATTY
#define LUA_USE_POPEN
#define LUA_USE_ULONGJMP
#endif


/*
@@ LUA_PATH and LUA_CPATH are the names of the environment variables that
@* Lua check to set its paths.
@@ LUA_INIT is the name of the environment variable that Lua
@* checks for initialization code.
** CHANGE them if you want different names.
*/
#define LUA_PATH        "LUA_PATH"
#define LUA_CPATH       "LUA_CPATH"
#define LUA_INIT	"LUA_INIT"


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
@* Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
@* C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#if defined(_WIN32)
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_PATH_DEFAULT  \
		".\\?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		             LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua"
#define LUA_CPATH_DEFAULT \
	".\\?.dll;"  LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll"

#else
#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/5.1/"
#define LUA_CDIR	LUA_ROOT "lib/lua/5.1/"
#define LUA_PATH_DEFAULT  \
		"./?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		            LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua"
#define LUA_CPATH_DEFAULT \
	"./?.so;"  LUA_CDIR"?.so;" LUA_CDIR"loadall.so"
#endif


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif


/*
@@ LUA_PATHSEP is the character that separates templates in a path.
@@ LUA_PATH_MARK is the string that marks the substitution points in a
@* template.
@@ LUA_EXECDIR in a Windows path is replaced by the executable's
@* directory.
@@ LUA_IGMARK is a mark to ignore all before it when bulding the
@* luaopen_ function name.
** CHANGE them if for some reason your system cannot use those
** characters. (E.g., if one of those characters is a common character
** in file/directory names.) Probably you do not need to change them.
*/
#define LUA_PATHSEP	";"
#define LUA_PATH_MARK	"?"
#define LUA_EXECDIR	"!"
#define LUA_IGMARK	"-"


/*
@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
** machines, ptrdiff_t gives a good choice between int or long.)
*/
#define LUA_INTEGER	ptrdiff_t


/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all standard library functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)

#if defined(LUA_CORE) || defined(LUA_LIB)
#define LUA_API static inline
#else
#define LUA_API static inline
#endif

#else

#define LUA_API static inline

#endif

/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
@* exported to outside modules.
@@ LUAI_DATA is a mark for all extern (const) variables that are not to
@* be exported to outside modules.
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library.
*/
#if defined(luaall_c)
#define LUAI_FUNC static inline
#define LUAI_DATA /* empty */

#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
      defined(__ELF__)
#define LUAI_FUNC static inline
#define LUAI_DATA /* empty */

#else
#define LUAI_FUNC static inline
#define LUAI_DATA /* empty */
#endif



/*
@@ LUA_QL describes how error messages quote program elements.
** CHANGE it if you want a different appearance.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@* of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
** {==================================================================
** Stand-alone configuration
** ===================================================================
*/

#if defined(lua_c) || defined(luaall_c)

/*
@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
@* is, whether we're running lua interactively).
** CHANGE it if you have a better definition for non-POSIX/non-Windows
** systems.
*/
#if defined(LUA_USE_ISATTY)
/*-- #include "src.cpp/unistd.h" start --*/

#define lua_stdin_is_tty()	isatty(0)
#elif defined(LUA_WIN)
/*-- #include "src.cpp/io.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
#else
#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
#endif


/*
@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
** CHANGE them if you want different prompts. (You can also change the
** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
*/
#define LUA_PROMPT		"> "
#define LUA_PROMPT2		">> "


/*
@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
** CHANGE it if your stand-alone interpreter has a different name and
** your system is not able to detect that name automatically.
*/
#define LUA_PROGNAME		"lua"


/*
@@ LUA_MAXINPUT is the maximum length for an input line in the
@* stand-alone interpreter.
** CHANGE it if you need longer lines.
*/
#define LUA_MAXINPUT	512


/*
@@ lua_readline defines how to show a prompt and then read a line from
@* the standard input.
@@ lua_saveline defines how to "save" a read line in a "history".
@@ lua_freeline defines how to free a line read by lua_readline.
** CHANGE them if you want to improve this functionality (e.g., by using
** GNU readline and history facilities).
*/
#if 0
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/readline/readline.h" start --*/

/*-- #include "src.cpp/readline/history.h" start --*/

#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define lua_saveline(L,idx) \
	if (lua_strlen(L,idx) > 0)  /* non-empty line? */ \
	  add_history(lua_tostring(L, idx));  /* add it to history */
#define lua_freeline(L,b)	((void)L, free(b))
#else
#define lua_readline(L,b,p)	\
	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }
#endif

#endif

/* }================================================================== */


/*
@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
@* as a percentage.
** CHANGE it if you want the GC to run faster or slower (higher values
** mean larger pauses which mean slower collection.) You can also change
** this value dynamically.
*/
#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */


/*
@@ LUAI_GCMUL defines the default speed of garbage collection relative to
@* memory allocation as a percentage.
** CHANGE it if you want to change the granularity of the garbage
** collection. (Higher values mean coarser collections. 0 represents
** infinity, where each step performs a full collection.) You can also
** change this value dynamically.
*/
#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */



/*
@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
** CHANGE it (define it) if you want exact compatibility with the
** behavior of setn/getn in Lua 5.0.
*/
#undef LUA_COMPAT_GETN

/*
@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.
** CHANGE it to undefined as soon as you do not need a global 'loadlib'
** function (the function is still available as 'package.loadlib').
*/
#undef LUA_COMPAT_LOADLIB

/*
@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.
** CHANGE it to undefined as soon as your programs use only '...' to
** access vararg parameters (instead of the old 'arg' table).
*/
#define LUA_COMPAT_VARARG

/*
@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
** CHANGE it to undefined as soon as your programs use 'math.fmod' or
** the new '%' operator instead of 'math.mod'.
*/
#define LUA_COMPAT_MOD

/*
@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
@* facility.
** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
** off the advisory error when nesting [[...]].
*/
#define LUA_COMPAT_LSTR		1

/*
@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
** CHANGE it to undefined as soon as you rename 'string.gfind' to
** 'string.gmatch'.
*/
#define LUA_COMPAT_GFIND

/*
@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
@* behavior.
** CHANGE it to undefined as soon as you replace to 'luaL_register'
** your uses of 'luaL_openlib'
*/
#define LUA_COMPAT_OPENLIB



/*
@@ luai_apicheck is the assert macro used by the Lua-C API.
** CHANGE luai_apicheck if you want Lua to perform some checks in the
** parameters it gets from API calls. This may slow down the interpreter
** a bit, but may be quite useful when debugging C code that interfaces
** with Lua. A useful redefinition is to use assert.h.
*/
#if defined(LUA_USE_APICHECK)
/*-- #include "src.cpp/assert.h" start --*/
#define luai_apicheck(L,o)	{ (void)L; assert(o); }
#else
#define luai_apicheck(L,o)	{ (void)L; }
#endif


/*
@@ LUAI_BITSINT defines the number of bits in an int.
** CHANGE here if Lua cannot automatically detect the number of bits of
** your machine. Probably you do not need to change this.
*/
/* avoid overflows in comparison */
#if INT_MAX-20 < 32760
#define LUAI_BITSINT	16
#elif INT_MAX > 2147483640L
/* int has at least 32 bits */
#define LUAI_BITSINT	32
#else
#error "you must define LUA_BITSINT with number of bits in an integer"
#endif


/*
@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
@@ LUAI_INT32 is an signed integer with at least 32 bits.
@@ LUAI_UMEM is an unsigned integer big enough to count the total
@* memory used by Lua.
@@ LUAI_MEM is a signed integer big enough to count the total memory
@* used by Lua.
** CHANGE here if for some weird reason the default definitions are not
** good enough for your machine. (The definitions in the 'else'
** part always works, but may waste space on machines with 64-bit
** longs.) Probably you do not need to change this.
*/
#if LUAI_BITSINT >= 32
#define LUAI_UINT32	unsigned int
#define LUAI_INT32	int
#define LUAI_MAXINT32	INT_MAX
#define LUAI_UMEM	size_t
#define LUAI_MEM	ptrdiff_t
#else
/* 16-bit ints */
#define LUAI_UINT32	unsigned long
#define LUAI_INT32	long
#define LUAI_MAXINT32	LONG_MAX
#define LUAI_UMEM	unsigned long
#define LUAI_MEM	long
#endif


/*
@@ LUAI_MAXCALLS limits the number of nested calls.
** CHANGE it if you need really deep recursive calls. This limit is
** arbitrary; its only purpose is to stop infinite recursion before
** exhausting memory.
*/
#define LUAI_MAXCALLS	20000


/*
@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
@* can use.
** CHANGE it if you need lots of (Lua) stack space for your C
** functions. This limit is arbitrary; its only purpose is to stop C
** functions to consume unlimited stack space. (must be smaller than
** -LUA_REGISTRYINDEX)
*/
#define LUAI_MAXCSTACK	8000



/*
** {==================================================================
** CHANGE (to smaller values) the following definitions if your system
** has a small C stack. (Or you may want to change them to larger
** values if your system has a large C stack and these limits are
** too rigid for you.) Some of these constants control the size of
** stack-allocated arrays used by the compiler or the interpreter, while
** others limit the maximum number of recursive calls that the compiler
** or the interpreter can perform. Values too large may cause a C stack
** overflow for some forms of deep constructs.
** ===================================================================
*/


/*
@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
@* syntactical nested non-terminals in a program.
*/
#define LUAI_MAXCCALLS		200


/*
@@ LUAI_MAXVARS is the maximum number of local variables per function
@* (must be smaller than 250).
*/
#define LUAI_MAXVARS		200


/*
@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
@* (must be smaller than 250).
*/
#define LUAI_MAXUPVALUES	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
*/
#define LUAL_BUFFERSIZE		BUFSIZ

/* }================================================================== */




/*
** {==================================================================
@@ LUA_NUMBER is the type of numbers in Lua.
** CHANGE the following definitions only if you want to build Lua
** with a number type different from double. You may also need to
** change lua_number2int & lua_number2integer.
** ===================================================================
*/

#define LUA_NUMBER_DOUBLE
#define LUA_NUMBER	double

/*
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@* over a number.
*/
#define LUAI_UACNUMBER	double


/*
@@ LUA_NUMBER_SCAN is the format for reading numbers.
@@ LUA_NUMBER_FMT is the format for writing numbers.
@@ lua_number2str converts a number to a string.
@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
@@ lua_str2number converts a string to a number.
*/
#define LUA_NUMBER_SCAN		"%lf"
#define LUA_NUMBER_FMT		"%.14g"
#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
#define lua_str2number(s,p)	strtod((s), (p))


/*
@@ The luai_num* macros define the primitive operations over numbers.
*/
#if 1
/*-- #include "src.cpp/math.h" start --*/
/* math.h 單文件時起作用，只用於精簡 */

#ifndef math_unFLOOR_unPOW_h
#define math_unFLOOR_unPOW_h

/*-- #include "src.cpp/assert.h" start --*/


#define pow(base, exponent) ({assert(!"[錯誤]pow()未實現 : pow("#base","#exponent")");*((volatile int*)0)=0;(double)*((volatile double*)0);})
#define floor(x) ({assert(!"[錯誤]floor()未實現 : floor("#x")");*((volatile int*)0)=0;(double)*((volatile double*)0);})

#endif

#define luai_numadd(a,b)	((a)+(b))
#define luai_numsub(a,b)	((a)-(b))
#define luai_nummul(a,b)	((a)*(b))
#define luai_numdiv(a,b)	((a)/(b))
#define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
#define luai_numpow(a,b)	(pow(a,b))
#define luai_numunm(a)		(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)<(b))
#define luai_numle(a,b)		((a)<=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ lua_number2int is a macro to convert lua_Number to int.
@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
** CHANGE them if you know a faster way to convert a lua_Number to
** int (with any rounding method and without throwing errors) in your
** system. In Pentium machines, a naive typecast from double to int
** in C is extremely slow, so any alternative is worth trying.
*/

/* On a Pentium, resort to a trick */
#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
    (defined(__i386) || defined (_M_IX86) || defined(__i386__))

/* On a Microsoft compiler, use assembler */
#if defined(_MSC_VER)

#define lua_number2int(i,d)   __asm fld d   __asm fistp i
#define lua_number2integer(i,n)		lua_number2int(i, n)

/* the next trick should work on any Pentium, but sometimes clashes
   with a DirectX idiosyncrasy */
#else

union luai_Cast { double l_d; long l_l; };
#define lua_number2int(i,d) \
  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
#define lua_number2integer(i,n)		lua_number2int(i, n)

#endif


/* this option always works, but may be slow */
#else
#define lua_number2int(i,d)	((i)=(int)(d))
#define lua_number2integer(i,d)	((i)=(lua_Integer)(d))

#endif

/* }================================================================== */


/*
@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
** CHANGE it if your system requires alignments larger than double. (For
** instance, if your system supports long doubles and they must be
** aligned in 16-byte boundaries, then you should add long double in the
** union.) Probably you do not need to change this.
*/
#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }


/*
@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
** CHANGE them if you prefer to use longjmp/setjmp even with C++
** or if want/don't to use _longjmp/_setjmp instead of regular
** longjmp/setjmp. By default, Lua handles errors with exceptions when
** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
** and with longjmp/setjmp otherwise.
*/
#if defined(__cplusplus)
/* C++ exceptions */
#define LUAI_THROW(L,c)	throw(c)
#define LUAI_TRY(L,c,a)	try { a } catch(...) \
	{ if ((c)->status == 0) (c)->status = -1; }
#define luai_jmpbuf	int  /* dummy variable */

#elif defined(LUA_USE_ULONGJMP)
/* in Unix, try _longjmp/_setjmp (more efficient) */
#define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#else
/* default handling with long jumps */
#define LUAI_THROW(L,c)	longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#endif


/*
@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
@* can do during pattern-matching.
** CHANGE it if you need more captures. This limit is arbitrary.
*/
#define LUA_MAXCAPTURES		32


/*
@@ lua_tmpnam is the function that the OS library uses to create a
@* temporary name.
@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
** CHANGE them if you have an alternative to tmpnam (which is considered
** insecure) or if you want the original tmpnam anyway.  By default, Lua
** uses tmpnam except when POSIX is available, where it uses mkstemp.
*/
#if defined(loslib_c) || defined(luaall_c)

#if defined(LUA_USE_MKSTEMP)
/*-- #include "src.cpp/unistd.h" start --*/
#define LUA_TMPNAMBUFSIZE	32
#define lua_tmpnam(b,e)	{ \
	strcpy(b, "/tmp/lua_XXXXXX"); \
	e = mkstemp(b); \
	if (e != -1) close(e); \
	e = (e == -1); }

#else
#define LUA_TMPNAMBUFSIZE	L_tmpnam
#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
#endif

#endif


/*
@@ lua_popen spawns a new process connected to the current one through
@* the file streams.
** CHANGE it if you have a way to implement it in your system.
*/
#if defined(LUA_USE_POPEN)

#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))

#elif defined(LUA_WIN)

#define lua_popen(L,c,m)	((void)L, _popen(c,m))
#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))

#else

#define lua_popen(L,c,m)	((void)((void)c, m),  \
		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
#define lua_pclose(L,file)		((void)((void)L, file), 0)

#endif

/*
@@ LUA_DL_* define which dynamic-library system Lua should use.
** CHANGE here if Lua has problems choosing the appropriate
** dynamic-library system for your platform (either Windows' DLL, Mac's
** dyld, or Unix's dlopen). If your system is some kind of Unix, there
** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
** it.  To use dlopen you also need to adapt the src/Makefile (probably
** adding -ldl to the linker options), so Lua does not select it
** automatically.  (When you change the makefile to add -ldl, you must
** also add -DLUA_USE_DLOPEN.)
** If you do not want any kind of dynamic library, undefine all these
** options.
** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
*/
#if defined(LUA_USE_DLOPEN)
#define LUA_DL_DLOPEN
#endif

#if defined(LUA_WIN)
#define LUA_DL_DLL
#endif


/*
@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
@* (the data goes just *before* the lua_State pointer).
** CHANGE (define) this if you really need that. This value must be
** a multiple of the maximum alignment required for your machine.
*/
#define LUAI_EXTRASPACE		0


/*
@@ luai_userstate* allow user-specific actions on threads.
** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
** extra when a thread is created/deleted/resumed/yielded.
*/
#define luai_userstateopen(L)		((void)L)
#define luai_userstateclose(L)		((void)L)
#define luai_userstatethread(L,L1)	((void)L)
#define luai_userstatefree(L)		((void)L)
#define luai_userstateresume(L,n)	((void)L)
#define luai_userstateyield(L,n)	((void)L)


/*
@@ LUA_INTFRMLEN is the length modifier for integer conversions
@* in 'string.format'.
@@ LUA_INTFRM_T is the integer type correspoding to the previous length
@* modifier.
** CHANGE them if your system supports long long or does not support long.
*/

#if defined(LUA_USELONGLONG)

#define LUA_INTFRMLEN		"ll"
#define LUA_INTFRM_T		long long

#else

#define LUA_INTFRMLEN		"l"
#define LUA_INTFRM_T		long

#endif



/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/



#endif




#define LUA_VERSION	"Lua 5.1"
#define LUA_RELEASE	"Lua 5.1.5"
#define LUA_VERSION_NUM	501
#define LUA_COPYRIGHT	"Copyright (C) 1994-2012 Lua.org, PUC-Rio"
#define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"


/* mark for precompiled code (`<esc>Lua') */
#define	LUA_SIGNATURE	"\033Lua"

/* option for multiple returns in `lua_pcall' and `lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	(-10000)
#define LUA_ENVIRONINDEX	(-10001)
#define LUA_GLOBALSINDEX	(-10002)
#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))


/* thread status; 0 is OK */
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRERR	5


typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);


/*
** functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);


/*
** prototype for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;



/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


/*
** basic stack manipulation
*/
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_remove) (lua_State *L, int idx);
LUA_API void  (lua_insert) (lua_State *L, int idx);
LUA_API void  (lua_replace) (lua_State *L, int idx);
LUA_API int   (lua_checkstack) (lua_State *L, int sz);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);

LUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);
LUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_objlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** push functions (C -> stack)
*/
LUA_API void  (lua_pushnil) (lua_State *L);
LUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);
LUA_API void  (lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API void  (lua_gettable) (lua_State *L, int idx);
LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawget) (lua_State *L, int idx);
LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_getfenv) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API int   (lua_setfenv) (lua_State *L, int idx);


/*
** `load' and `call' functions (load and run Lua code)
*/
LUA_API void  (lua_call) (lua_State *L, int nargs, int nresults);
LUA_API int   (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
LUA_API int   (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);




/*
** coroutine functions
*/
LUA_API int  (lua_yield) (lua_State *L, int nresults);
LUA_API int  (lua_resume) (lua_State *L, int narg);
LUA_API int  (lua_status) (lua_State *L);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);



/*
** ===============================================================
** some useful macros
** ===============================================================
*/

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_strlen(L,i)		lua_objlen(L, (i))

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

#define lua_setglobal(L,s)	lua_setfield(L, LUA_GLOBALSINDEX, (s))
#define lua_getglobal(L,s)	lua_getfield(L, LUA_GLOBALSINDEX, (s))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)



/*
** compatibility macros and functions
*/

#define lua_open()	luaL_newstate()

#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)


#define lua_Chunkreader		lua_Reader
#define lua_Chunkwriter		lua_Writer


/* hack */
LUA_API void lua_setlevel	(lua_State *from, lua_State *to);


/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILRET 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debuger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);

LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook lua_gethook (lua_State *L);
LUA_API int lua_gethookmask (lua_State *L);
LUA_API int lua_gethookcount (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) `global', `local', `field', `method' */
  const char *what;	/* (S) `Lua', `C', `main', `tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int nups;		/* (u) number of upvalues */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  int i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2012 Lua.org, PUC-Rio.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif



#if defined(LUA_COMPAT_GETN)
LUALIB_API int (luaL_getn) (lua_State *L, int t);
LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
#else
#define luaL_getn(L,i)          ((int)lua_objlen(L, i))
#define luaL_setn(L,i,j)        ((void)0)  /* no op! */
#endif

#if defined(LUA_COMPAT_OPENLIB)
#define luaI_openlib	luaL_openlib
#endif


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;



LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int narg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API lua_State *(luaL_newstate) (void);


LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);




/*
** ===============================================================
** some useful macros
** ===============================================================
*/

#define luaL_argcheck(L, cond,numarg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/



typedef struct luaL_Buffer {
  char *p;			/* current position in buffer */
  int lvl;  /* number of strings in the stack (level) */
  lua_State *L;
  char buffer[LUAL_BUFFERSIZE];
} luaL_Buffer;

#define luaL_addchar(B,c) \
  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
   (*(B)->p++ = (char)(c)))

/* compatibility only */
#define luaL_putchar(B,c)	luaL_addchar(B,c)

#define luaL_addsize(B,n)	((B)->p += (n))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);


/* }====================================================== */


/* compatibility with ref system */

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

#define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
      (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))

#define lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))

#define lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))


#define luaL_reg	luaL_Reg

#endif

/*-- #include "src.cpp/lua.h" start --*/
/*-- #include "src.cpp/lualib.h" start --*/
/*
** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/

#ifndef lualib_h
#define lualib_h

/*-- #include "src.cpp/lua.h" start --*/

/* Key to file-handle type */
#define LUA_FILEHANDLE "FILE*"

#define LUA_COLIBNAME "coroutine"
LUALIB_API int(luaopen_base)(lua_State *L);

#define LUA_TABLIBNAME  "table"
LUALIB_API int (luaopen_table) (lua_State *L);

#define LUA_STRLIBNAME "string"
LUALIB_API int(luaopen_string)(lua_State *L);

/* open all previous libraries */
LUALIB_API void(luaL_openlibs)(lua_State *L);

#ifndef lua_assert
#define lua_assert(x) ((void)0)
#endif

#endif

/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
#include <stdlib.h>


/*-- #include "src.cpp/string.h" start --*/
#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static inline void lc_newclosuretable(lua_State *L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L, idx);
  lua_rawseti(L, -2, 0);
}

/*-- #include "src.cpp/assert.h" start --*/

/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static inline void lc_add(lua_State *L, int idxa, int idxb) {
  if (lua_isnumber(L, idxa) && lua_isnumber(L, idxb)) {
    lua_pushnumber(L, lua_tonumber(L, idxa) + lua_tonumber(L, idxb));
  } else {
    if (luaL_getmetafield(L, idxa, "__add") ||
        luaL_getmetafield(L, idxb, "__add")) {
      lua_pushvalue(L, idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa - 1 : idxa);
      lua_pushvalue(L, idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb - 2 : idxb);
      lua_call(L, 2, 1);
    } else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}

/* name: v
 * function(e,...) */
static inline int lcf1_v(lua_State *L) {
  enum { lc_nformalargs = 1 };
  if ((lua_gettop(L) < lc_nformalargs)) {
    lua_settop(L, lc_nformalargs);
  }
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);

  /* local t=({...}) */
  lua_createtable(L, 1, 0);
  const int lc2 = lua_gettop(L);
  {
    int i;
    for (i = lc_nformalargs + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc2)) {
    lua_rawseti(L, lc2, (0 + (lua_gettop(L) - lc2)));
  }
  assert(lua_gettop(L) - lc_nextra == 2);

  /* for a,t in ipairs(t)do
   * internal: local f, s, var = explist */
  enum { lc3 = 2 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lua_pushvalue(L, (2 + lc_nextra));
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local a with idx 6
     * internal: local t with idx 7 */

    /* e[#e+1]=t */
    lua_pushvalue(L, (7 + lc_nextra));
    const double lc4 = lua_objlen(L, 1);
    lua_pushnumber(L, lc4);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_insert(L, -2);
    lua_settable(L, 1);
    assert(lua_gettop(L) - lc_nextra == 7);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 2);
  }
  lua_settop(L, (lc3 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 2);

  /* return#e */
  const double lc5 = lua_objlen(L, 1);
  lua_pushnumber(L, lc5);
  return 1;
  assert(lua_gettop(L) - lc_nextra == 2);
}

/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static inline void lc_sub(lua_State *L, int idxa, int idxb) {
  if (lua_isnumber(L, idxa) && lua_isnumber(L, idxb)) {
    lua_pushnumber(L, lua_tonumber(L, idxa) - lua_tonumber(L, idxb));
  } else {
    if (luaL_getmetafield(L, idxa, "__sub") ||
        luaL_getmetafield(L, idxb, "__sub")) {
      lua_pushvalue(L, idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa - 1 : idxa);
      lua_pushvalue(L, idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb - 2 : idxb);
      lua_call(L, 2, 1);
    } else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}

/* warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static inline int lc_le(lua_State *L, int idxa, int idxb) {
  if (lua_type(L, idxa) == LUA_TNUMBER && lua_type(L, idxb) == LUA_TNUMBER) {
    return lua_tonumber(L, idxa) <= lua_tonumber(L, idxb);
  } else if (lua_type(L, idxa) == LUA_TSTRING &&
             lua_type(L, idxb) == LUA_TSTRING) {
    /* result similar to lvm.c l_strcmp */
    return lua_lessthan(L, idxa, idxb) || lua_rawequal(L, idxa, idxb);
  } else if (luaL_getmetafield(L, idxa, "__le") ||
             luaL_getmetafield(L, idxb, "__le")) {
    lua_pushvalue(L, idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa - 1 : idxa);
    lua_pushvalue(L, idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb - 2 : idxb);
    lua_call(L, 2, 1);
    const int result = lua_toboolean(L, -1);
    lua_pop(L, 1);
    return result;
  } else if (luaL_getmetafield(L, idxa, "__lt") ||
             luaL_getmetafield(L, idxb, "__lt")) {
    lua_pushvalue(L, idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb - 1 : idxb);
    lua_pushvalue(L, idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa - 2 : idxa);
    lua_call(L, 2, 1);
    const int result = !lua_toboolean(L, -1);
    lua_pop(L, 1);
    return result;
  } else {
    return luaL_error(L, "attempt to compare");
  }
}

/* name: Ne
 * function(a,...) */
static inline int lcf1_Ne(lua_State *L) {
  enum { lc_nformalargs = 1 };
  if ((lua_gettop(L) < lc_nformalargs)) {
    lua_settop(L, lc_nformalargs);
  }
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);

  /* local t=({...}) */
  lua_createtable(L, 1, 0);
  const int lc7 = lua_gettop(L);
  {
    int i;
    for (i = lc_nformalargs + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc7)) {
    lua_rawseti(L, lc7, (0 + (lua_gettop(L) - lc7)));
  }
  assert(lua_gettop(L) - lc_nextra == 2);

  /* do
   * local e=#t-1 */
  const double lc8 = lua_objlen(L, (2 + lc_nextra));
  lua_pushnumber(L, lc8);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* while e>=0 do */
  enum { lc9 = 3 };
  while (1) {
    lua_pushnumber(L, 0);
    const int lc10 = lc_le(L, -1, (3 + lc_nextra));
    lua_pop(L, 1);
    lua_pushboolean(L, lc10);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* table.insert(a,1,t[e+1]) */
    lua_getfield(L, LUA_ENVIRONINDEX, "table");
    lua_pushliteral(L, "insert");
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_pushnumber(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, (3 + lc_nextra), -1);
    lua_remove(L, -2);
    lua_gettable(L, (2 + lc_nextra));
    lua_call(L, 3, 0);
    assert(lua_gettop(L) - lc_nextra == 3);

    /* e=e-1 */
    lua_pushnumber(L, 1);
    lc_sub(L, (3 + lc_nextra), -1);
    lua_remove(L, -2);
    lua_replace(L, (3 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 3);
  }
  lua_settop(L, (lc9 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) - lc_nextra == 2);

  /* return#a */
  const double lc11 = lua_objlen(L, 1);
  lua_pushnumber(L, lc11);
  return 1;
  assert(lua_gettop(L) - lc_nextra == 2);
}

/* name: j
 * function() */
static inline int lcf1_j(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* error("TheLanguage PANIC") */
  lua_getfield(L, LUA_ENVIRONINDEX, "error");
  lua_pushliteral(L, "TheLanguage PANIC");
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 0);
  return 0;
}

static inline void lc_setupvalue(lua_State *L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L, tidx, varid);
  } else {
    lua_pushvalue(L, tidx);
    while (--level >= 0) {
      lua_rawgeti(L, tidx, 0); /* 0 links to parent table */
      lua_remove(L, -2);
      tidx = -1;
    }
    lua_insert(L, -2);
    lua_rawseti(L, -2, varid);
    lua_pop(L, 1);
  }
}

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static inline void lc_getupvalue(lua_State *L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L, tidx, varid);
  } else {
    lua_pushvalue(L, tidx);
    while (--level >= 0) {
      lua_rawgeti(L, tidx, 0); /* 0 links to parent table */
      lua_remove(L, -2);
      tidx = -1;
    }
    lua_rawgeti(L, -1, varid);
    lua_remove(L, -2);
  }
}

/* name: H
 * function(e) */
static inline int lcf1_H(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if not e then */
  enum { lc13 = 1 };
  lua_pushboolean(L, !(lua_toboolean(L, 1)));
  const int lc14 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc14) {

    /* return j() */
    const int lc15 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 117);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc15);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc13);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: fe
 * function(e,t) */
static inline int lcf1_fe(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * ye,
   * e,
   * t,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 104);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: I
 * function(e) */
static inline int lcf1_I(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==ye */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 104);
  const int lc16 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc16);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: oe
 * function(e) */
static inline int lcf1_oe(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: K
 * function(e) */
static inline int lcf1_K(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: qe
 * function(e) */
static inline int lcf1_qe(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* while I(e)do */
  enum { lc17 = 1 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 0, 101);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* e=K(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 99);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc17);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: p
 * function(e) */
static inline int lcf1_p(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==Ve */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 114);
  const int lc18 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc18);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: le
 * function(e) */
static inline int lcf1_le(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: de
 * function(e) */
static inline int lcf1_de(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return m()[le(e)] */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 115);
  lua_call(L, 0, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: D
 * function(t,e) */
static inline int lcf1_D(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* if t==e then */
  enum { lc19 = 2 };
  const int lc20 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc20);
  const int lc21 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc21) {

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc19);
  assert(lua_gettop(L) == 2);

  /* if le(t)==le(e) then */
  enum { lc22 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 96);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc23 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc23);
  const int lc24 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc24) {

    /* O(t,e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 2);

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  } else {

    /* else
     * return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc22);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: s
 * function(t,e) */
static inline int lcf1_s(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * Ie,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 113);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: a
 * function(e) */
static inline int lcf1_a(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==Ie */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 113);
  const int lc25 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc25);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: o
 * function(e) */
static inline int lcf1_o(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: i
 * function(e) */
static inline int lcf1_i(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: h
 * function(e) */
static inline int lcf1_h(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==Ae */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 112);
  const int lc26 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc26);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: T
 * function(t,e) */
static inline int lcf1_T(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * b,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 111);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: c
 * function(e) */
static inline int lcf1_c(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==b */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 111);
  const int lc27 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc27);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: E
 * function(e) */
static inline int lcf1_E(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: A
 * function(e) */
static inline int lcf1_A(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: L
 * function(t,e) */
static inline int lcf1_L(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * M,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 110);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: g
 * function(e) */
static inline int lcf1_g(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==M */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 110);
  const int lc28 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc28);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: C
 * function(e) */
static inline int lcf1_C(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: U
 * function(e) */
static inline int lcf1_U(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: B
 * function(e) */
static inline int lcf1_B(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==Y */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 109);
  const int lc29 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc29);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: rt
 * function(e) */
static inline int lcf1_rt(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: S
 * function(t,e) */
static inline int lcf1_S(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * ne,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 108);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: Q
 * function(e) */
static inline int lcf1_Q(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==ne */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 108);
  const int lc30 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc30);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: X
 * function(e) */
static inline int lcf1_X(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Z
 * function(e) */
static inline int lcf1_Z(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Oe
 * function(e,a,t) */
static inline int lcf1_Oe(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* return{
   * pe,
   * e,
   * a,
   * t,
   * } */
  lua_createtable(L, 4, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 106);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 4);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: G
 * function(e) */
static inline int lcf1_G(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==pe */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 106);
  const int lc31 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc31);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: _e
 * function(e) */
static inline int lcf1__e(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Te
 * function(e) */
static inline int lcf1_Te(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: ze
 * function(e) */
static inline int lcf1_ze(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[4] */
  lua_pushnumber(L, 4);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: q
 * function(t,e) */
static inline int lcf1_q(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * ae,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 107);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: P
 * function(e) */
static inline int lcf1_P(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==ae */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 107);
  const int lc32 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc32);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: ue
 * function(e) */
static inline int lcf1_ue(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: re
 * function(e) */
static inline int lcf1_re(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: F
 * function(t,e) */
static inline int lcf1_F(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return{
   * he,
   * t,
   * e,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 105);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: V
 * function(e) */
static inline int lcf1_V(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==he */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 105);
  const int lc33 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc33);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: je
 * function(e) */
static inline int lcf1_je(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: xe
 * function(e) */
static inline int lcf1_xe(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: t
 * function(e) */
static inline int lcf1_t(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* e[2]=W(e[2]) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 60);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 1);

  /* e[3]=W(e[3]) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 60);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: W
 * function(e) */
static inline int lcf1_W(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local e=r(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 21);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 2);

  /* local function t(e)
   * e[2]=W(e[2])
   * e[3]=W(e[3])
   * return e
   * end */
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf1_t, 1);
  assert(lua_gettop(L) == 3);

  /* if c(e) then */
  enum { lc34 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 86);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc35 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc35) {

    /* return t(e) */
    const int lc36 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc36);
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif g(e) then */
    enum { lc37 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 82);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc38 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc38) {

      /* return t(e) */
      const int lc39 = lua_gettop(L);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 2);
      lua_call(L, 1, LUA_MULTRET);
      return (lua_gettop(L) - lc39);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif a(e) then */
      enum { lc40 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      const int lc41 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc41) {

        /* return t(e) */
        const int lc42 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc42);
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif I(e) then */
        enum { lc43 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 101);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        const int lc44 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc44) {

          /* return t(e) */
          const int lc45 = lua_gettop(L);
          lua_pushvalue(L, 3);
          lua_pushvalue(L, 2);
          lua_call(L, 1, LUA_MULTRET);
          return (lua_gettop(L) - lc45);
          assert(lua_gettop(L) == 3);
        }
        lua_settop(L, lc43);
      }
      lua_settop(L, lc40);
    }
    lua_settop(L, lc37);
  }
  lua_settop(L, lc34);
  assert(lua_gettop(L) == 3);

  /* return e */
  lua_pushvalue(L, 2);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: ge
 * function() */
static inline int lcf1_ge(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return{se} */
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 103);
  lua_rawseti(L, -2, 1);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function(e) */
static inline int lcf1_d(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e[1]==se */
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 103);
  const int lc46 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc46);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: O
 * function(e,t) */
static inline int lcf1_O(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* if e==t then */
  enum { lc47 = 2 };
  const int lc48 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc48);
  const int lc49 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc49) {

    /* return */
    return 0;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc47);
  assert(lua_gettop(L) == 2);

  /* e[1]=Y */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 109);
  lua_pushnumber(L, 1);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 2);

  /* e[2]=t */
  lua_pushvalue(L, 2);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 2);

  /* e[3]=false */
  lua_pushboolean(L, 0);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 2);

  /* e[4]=false */
  lua_pushboolean(L, 0);
  lua_pushnumber(L, 4);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: we
 * function(e,t) */
static inline int lcf1_we(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* H(d(e)) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 116);
  const int lc50 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 58);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc50), 0);
  assert(lua_gettop(L) == 2);

  /* H(not d(t)) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 116);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 58);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 2);

  /* local e=e */
  lua_pushvalue(L, 1);
  assert(lua_gettop(L) == 3);

  /* local t=t */
  lua_pushvalue(L, 2);
  assert(lua_gettop(L) == 4);

  /* e[1]=t[1] */
  lua_pushnumber(L, 1);
  lua_gettable(L, 4);
  lua_pushnumber(L, 1);
  lua_insert(L, -2);
  lua_settable(L, 3);
  assert(lua_gettop(L) == 4);

  /* e[2]=t[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 4);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 3);
  assert(lua_gettop(L) == 4);

  /* e[3]=t[3] */
  lua_pushnumber(L, 3);
  lua_gettable(L, 4);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 3);
  assert(lua_gettop(L) == 4);

  /* e[4]=t[4] */
  lua_pushnumber(L, 4);
  lua_gettable(L, 4);
  lua_pushnumber(L, 4);
  lua_insert(L, -2);
  lua_settable(L, 3);
  assert(lua_gettop(L) == 4);
  return 0;
}

/* name: lt
 * function(t) */
static inline int lcf1_lt(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local e=ge() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 59);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* we(e,t) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 56);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  assert(lua_gettop(L) == 2);

  /* return e */
  lua_pushvalue(L, 2);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: _
 * function(a) */
static inline int lcf1__(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local t=y */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 89);
  assert(lua_gettop(L) == 2);

  /* do
   * local e=#a-1 */
  const double lc51 = lua_objlen(L, 1);
  lua_pushnumber(L, lc51);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  assert(lua_gettop(L) == 3);

  /* while e>=0 do */
  enum { lc52 = 3 };
  while (1) {
    lua_pushnumber(L, 0);
    const int lc53 = lc_le(L, -1, 3);
    lua_pop(L, 1);
    lua_pushboolean(L, lc53);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* t=s(a[e+1],t) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 93);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 3);

    /* e=e-1 */
    lua_pushnumber(L, 1);
    lc_sub(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc52);
  assert(lua_gettop(L) == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 2);

  /* return t */
  lua_pushvalue(L, 2);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: e
 * function(...) */
static inline int lcf1_e(lua_State *L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);

  /* local e=({...}) */
  lua_createtable(L, 1, 0);
  const int lc54 = lua_gettop(L);
  {
    int i;
    for (i = lc_nformalargs + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc54)) {
    lua_rawseti(L, lc54, (0 + (lua_gettop(L) - lc54)));
  }
  assert(lua_gettop(L) - lc_nextra == 1);

  /* return _(e) */
  const int lc55 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 28);
  lua_pushvalue(L, (1 + lc_nextra));
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc55);
  assert(lua_gettop(L) - lc_nextra == 1);
}

/* name: N
 * function(e) */
static inline int lcf1_N(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if not B(e) then */
  enum { lc56 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 79);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc57 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc57) {

    /* return e */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc56);
  assert(lua_gettop(L) == 1);

  /* local e=e */
  lua_pushvalue(L, 1);
  assert(lua_gettop(L) == 2);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 3);

  /* while B(e)do */
  enum { lc58 = 3 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 0, 79);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* v(t,e) */
    lc_getupvalue(L, lua_upvalueindex(1), 2, 1);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* e=rt(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 78);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc58);
  assert(lua_gettop(L) == 3);

  /* for a,t in ipairs(t)do
   * internal: local f, s, var = explist */
  enum { lc59 = 3 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lua_pushvalue(L, 3);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local a with idx 7
     * internal: local t with idx 8 */

    /* O(t,e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
    lua_pushvalue(L, 8);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 8);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 2);
  }
  lua_settop(L, lc59);
  assert(lua_gettop(L) == 3);

  /* return e */
  lua_pushvalue(L, 2);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: me
 * function(e) */
static inline int lcf1_me(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return Q(e)or G(e)or P(e)or V(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 76);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 72);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 67);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 63);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: w
 * function(e) */
static inline int lcf1_w(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return B(e)or me(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 79);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 25);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: r
 * function(t) */
static inline int lcf1_r(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* O(e,t) */
  lc_getupvalue(L, lua_upvalueindex(1), 2, 57);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 123);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  assert(lua_gettop(L) == 1);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 2);

  /* while e<#a do */
  enum { lc71 = 2 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 1, 120);
    const double lc72 = lua_objlen(L, -1);
    lua_pop(L, 1);
    lua_pushnumber(L, lc72);
    const int lc73 = lua_lessthan(L, 2, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc73);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* O(a[e+1],t) */
    lc_getupvalue(L, lua_upvalueindex(1), 2, 57);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 120);
    lua_pushnumber(L, 1);
    lc_add(L, 2, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 2);

    /* e=e+1 */
    lua_pushnumber(L, 1);
    lc_add(L, 2, -1);
    lua_remove(L, -2);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc71);
  assert(lua_gettop(L) == 2);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 1);

  /* return t */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: s
 * function(t) */
static inline int lcf2_s(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* r(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 122);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);

  /* if w(t) then */
  enum { lc74 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 2, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc75 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc75) {

    /* v(a,e) */
    lc_getupvalue(L, lua_upvalueindex(1), 4, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 120);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 123);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 1);

    /* return n(t,i,{
     * false,
     * false,
     * },a) */
    const int lc76 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 2, 23);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 118);
    lua_createtable(L, 2, 0);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 1);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 2);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 120);
    lua_call(L, 4, LUA_MULTRET);
    return (lua_gettop(L) - lc76);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc74);
  assert(lua_gettop(L) == 1);

  /* return t */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: o
 * function() */
static inline int lcf2_o(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* t[2]=true */
  lua_pushboolean(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 119);
  lua_insert(L, -2);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, -3);
  lua_pop(L, 1);
  assert(lua_gettop(L) == 0);

  /* return s(dt) */
  const int lc78 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 121);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 50);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc78);
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function() */
static inline int lcf2_d(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* local e={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 1);

  /* for t in pairs(h)do
   * internal: local f, s, var = explist */
  enum { lc79 = 1 };
  lua_getfield(L, LUA_ENVIRONINDEX, "pairs");
  lc_getupvalue(L, lua_upvalueindex(1), 0, 124);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if (lua_isnil(L, -1)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);

    /* internal: local t with idx 5 */

    /* e[t]=true */
    lua_pushboolean(L, 1);
    lua_pushvalue(L, 5);
    lua_insert(L, -2);
    lua_settable(L, 1);
    assert(lua_gettop(L) == 5);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc79);
  assert(lua_gettop(L) == 1);

  /* for t in pairs(i)do
   * internal: local f, s, var = explist */
  enum { lc80 = 1 };
  lua_getfield(L, LUA_ENVIRONINDEX, "pairs");
  lc_getupvalue(L, lua_upvalueindex(1), 2, 118);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if (lua_isnil(L, -1)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);

    /* internal: local t with idx 5 */

    /* e[t]=true */
    lua_pushboolean(L, 1);
    lua_pushvalue(L, 5);
    lua_insert(L, -2);
    lua_settable(L, 1);
    assert(lua_gettop(L) == 5);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc80);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: n
 * function(o,i,t,a) */
static inline int lcf1_n(lua_State *L) {
  lua_checkstack(L, 29);
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc60 = 5 };
  assert((lua_gettop(L) == lc60));
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 118);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 119);
  lua_pushvalue(L, 4);
  lua_rawseti(L, -2, 120);

  /* if i==nil then */
  enum { lc61 = 5 };
  lc_getupvalue(L, lc60, 0, 118);
  lua_pushnil(L);
  const int lc62 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc62);
  const int lc63 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc63) {

    /* i={} */
    lua_newtable(L);
    lc_setupvalue(L, lc60, 0, 118);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc61);
  assert(lua_gettop(L) == 5);

  /* if t==nil then */
  enum { lc64 = 5 };
  lc_getupvalue(L, lc60, 0, 119);
  lua_pushnil(L);
  const int lc65 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc65);
  const int lc66 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc66) {

    /* t={
     * false,
     * false,
     * } */
    lua_createtable(L, 2, 0);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 1);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 2);
    lc_setupvalue(L, lc60, 0, 119);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc64);
  assert(lua_gettop(L) == 5);

  /* if a==nil then */
  enum { lc67 = 5 };
  lc_getupvalue(L, lc60, 0, 120);
  lua_pushnil(L);
  const int lc68 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc68);
  const int lc69 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc69) {

    /* a={} */
    lua_newtable(L);
    lc_setupvalue(L, lc60, 0, 120);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc67);
  assert(lua_gettop(L) == 5);

  /* local e,r,s */
  lc_newclosuretable(L, lc60);
  enum { lc70 = 6 };
  assert((lua_gettop(L) == lc70));
  lua_settop(L, (lua_gettop(L) + 3));
  lua_rawseti(L, lc70, 121);
  lua_rawseti(L, lc70, 122);
  lua_rawseti(L, lc70, 123);
  assert(lua_gettop(L) == 6);

  /* function r(t)
   * O(e,t)
   * do
   * local e=0
   * while e<#a do
   * O(a[e+1],t)
   * e=e+1
   * end
   * end
   * return t
   * end */
  lua_pushvalue(L, lc70);
  lua_pushcclosure(L, lcf1_r, 1);
  lc_setupvalue(L, lc70, 0, 122);
  assert(lua_gettop(L) == 6);

  /* function s(t)
   * r(t)
   * if w(t)then
   * v(a,e)
   * return n(t,i,{
   * false,
   * false,
   * },a)
   * end
   * return t
   * end */
  lua_pushvalue(L, lc70);
  lua_pushcclosure(L, lcf2_s, 1);
  lc_setupvalue(L, lc70, 0, 121);
  assert(lua_gettop(L) == 6);

  /* local h={} */
  lc_newclosuretable(L, lc70);
  enum { lc77 = 7 };
  assert((lua_gettop(L) == lc77));
  lua_newtable(L);
  lua_rawseti(L, lc77, 124);
  assert(lua_gettop(L) == 7);

  /* e=o */
  lua_pushvalue(L, 1);
  lc_setupvalue(L, lc77, 1, 123);
  assert(lua_gettop(L) == 7);

  /* local function o()
   * t[2]=true
   * return s(dt)
   * end */
  lua_pushvalue(L, lc77);
  lua_pushcclosure(L, lcf2_o, 1);
  assert(lua_gettop(L) == 8);

  /* local function d()
   * local e={}
   * for t in pairs(h)do
   * e[t]=true
   * end
   * for t in pairs(i)do
   * e[t]=true
   * end
   * return e
   * end */
  lua_pushvalue(L, lc77);
  lua_pushcclosure(L, lcf2_d, 1);
  assert(lua_gettop(L) == 9);

  /* do
   * local t=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 10);

  /* while w(e)and t<32 do */
  enum { lc81 = 10 };
  while (1) {
    lc_getupvalue(L, lc77, 3, 24);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lua_pushnumber(L, 32);
      const int lc82 = lua_lessthan(L, 10, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc82);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* v(a,e) */
    lc_getupvalue(L, lc77, 5, 1);
    lc_getupvalue(L, lc77, 2, 120);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 10);

    /* e=k(e) */
    lc_getupvalue(L, lc77, 3, 22);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 1, 1);
    lc_setupvalue(L, lc77, 1, 123);
    assert(lua_gettop(L) == 10);

    /* t=t+1 */
    lua_pushnumber(L, 1);
    lc_add(L, 10, -1);
    lua_remove(L, -2);
    lua_replace(L, 10);
    assert(lua_gettop(L) == 10);
  }
  lua_settop(L, lc81);
  assert(lua_gettop(L) == 10);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 9);

  /* while w(e)do */
  enum { lc83 = 9 };
  while (1) {
    lc_getupvalue(L, lc77, 3, 24);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* local r=f(e) */
    lc_getupvalue(L, lc77, 3, 3);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 10);

    /* if i[r]==true then */
    enum { lc84 = 10 };
    lc_getupvalue(L, lc77, 2, 118);
    lua_pushvalue(L, 10);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushboolean(L, 1);
    const int lc85 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc85);
    const int lc86 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc86) {

      /* return o() */
      const int lc87 = lua_gettop(L);
      lua_pushvalue(L, 8);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc87);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L, lc84);
    assert(lua_gettop(L) == 10);

    /* if h[r]==true then */
    enum { lc88 = 10 };
    lc_getupvalue(L, lc77, 0, 124);
    lua_pushvalue(L, 10);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushboolean(L, 1);
    const int lc89 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc89);
    const int lc90 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc90) {

      /* t[1]=true */
      lua_pushboolean(L, 1);
      lc_getupvalue(L, lc77, 2, 119);
      lua_insert(L, -2);
      lua_pushnumber(L, 1);
      lua_insert(L, -2);
      lua_settable(L, -3);
      lua_pop(L, 1);
      assert(lua_gettop(L) == 10);

      /* if Q(e) then */
      enum { lc91 = 10 };
      lc_getupvalue(L, lc77, 3, 76);
      lc_getupvalue(L, lc77, 1, 123);
      lua_call(L, 1, 1);
      const int lc92 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc92) {

        /* return o() */
        const int lc93 = lua_gettop(L);
        lua_pushvalue(L, 8);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc93);
        assert(lua_gettop(L) == 10);
      } else {

        /* elseif P(e) then */
        enum { lc94 = 10 };
        lc_getupvalue(L, lc77, 3, 67);
        lc_getupvalue(L, lc77, 1, 123);
        lua_call(L, 1, 1);
        const int lc95 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc95) {

          /* local a=ue(e) */
          lc_getupvalue(L, lc77, 3, 66);
          lc_getupvalue(L, lc77, 1, 123);
          lua_call(L, 1, 1);
          assert(lua_gettop(L) == 11);

          /* local e=re(e) */
          lc_getupvalue(L, lc77, 3, 65);
          lc_getupvalue(L, lc77, 1, 123);
          lua_call(L, 1, 1);
          assert(lua_gettop(L) == 12);

          /* local h={
           * He,
           * We,
           * Fe,
           * Ye,
           * Pe,
           * Me,
           * De,
           * Re,
           * Le,
           * Ue,
           * Ce,
           * } */
          lua_createtable(L, 11, 0);
          lc_getupvalue(L, lc77, 3, 49);
          lua_rawseti(L, -2, 1);
          lc_getupvalue(L, lc77, 3, 48);
          lua_rawseti(L, -2, 2);
          lc_getupvalue(L, lc77, 3, 47);
          lua_rawseti(L, -2, 3);
          lc_getupvalue(L, lc77, 3, 46);
          lua_rawseti(L, -2, 4);
          lc_getupvalue(L, lc77, 3, 45);
          lua_rawseti(L, -2, 5);
          lc_getupvalue(L, lc77, 3, 44);
          lua_rawseti(L, -2, 6);
          lc_getupvalue(L, lc77, 3, 43);
          lua_rawseti(L, -2, 7);
          lc_getupvalue(L, lc77, 3, 42);
          lua_rawseti(L, -2, 8);
          lc_getupvalue(L, lc77, 3, 41);
          lua_rawseti(L, -2, 9);
          lc_getupvalue(L, lc77, 3, 40);
          lua_rawseti(L, -2, 10);
          lc_getupvalue(L, lc77, 3, 39);
          lua_rawseti(L, -2, 11);
          assert(lua_gettop(L) == 13);

          /* local i=false */
          lua_pushboolean(L, 0);
          assert(lua_gettop(L) == 14);

          /* for t,e in ipairs(h)do
           * internal: local f, s, var = explist */
          enum { lc96 = 14 };
          lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
          lua_pushvalue(L, 13);
          lua_call(L, 1, 3);
          while (1) {

            /* internal: local var_1, ..., var_n = f(s, var)
             *           if var_1 == nil then break end
             *           var = var_1 */
            lua_pushvalue(L, -3);
            lua_pushvalue(L, -3);
            lua_pushvalue(L, -3);
            lua_call(L, 2, 2);
            if (lua_isnil(L, -2)) {
              break;
            }
            lua_pushvalue(L, -2);
            lua_replace(L, -4);

            /* internal: local t with idx 18
             * internal: local e with idx 19 */

            /* if l(e,a) then */
            enum { lc97 = 19 };
            lc_getupvalue(L, lc77, 3, 4);
            lua_pushvalue(L, 19);
            lua_pushvalue(L, 11);
            lua_call(L, 2, 1);
            const int lc98 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc98) {

              /* i=true */
              lua_pushboolean(L, 1);
              lua_replace(L, 14);
              assert(lua_gettop(L) == 19);

              /* break */
              break;
              assert(lua_gettop(L) == 19);
            }
            lua_settop(L, lc97);
            assert(lua_gettop(L) == 19);

            /* internal: stack cleanup on scope exit */
            lua_pop(L, 2);
          }
          lua_settop(L, lc96);
          assert(lua_gettop(L) == 14);

          /* if i then */
          enum { lc99 = 14 };
          if (lua_toboolean(L, 14)) {

            /* H(#e==1) */
            lc_getupvalue(L, lc77, 3, 116);
            const double lc100 = lua_objlen(L, 12);
            lua_pushnumber(L, lc100);
            lua_pushnumber(L, 1);
            const int lc101 = lua_equal(L, -2, -1);
            lua_pop(L, 2);
            lua_pushboolean(L, lc101);
            lua_call(L, 1, 0);
            assert(lua_gettop(L) == 14);

            /* H(t[2]==false) */
            lc_getupvalue(L, lc77, 3, 116);
            lc_getupvalue(L, lc77, 2, 119);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lua_pushboolean(L, 0);
            const int lc102 = lua_equal(L, -2, -1);
            lua_pop(L, 2);
            lua_pushboolean(L, lc102);
            lua_call(L, 1, 0);
            assert(lua_gettop(L) == 14);

            /* local e=n(e[1],d(),t) */
            lc_getupvalue(L, lc77, 3, 23);
            lua_pushnumber(L, 1);
            lua_gettable(L, 12);
            lua_pushvalue(L, 9);
            lua_call(L, 0, 1);
            lc_getupvalue(L, lc77, 2, 119);
            lua_call(L, 3, 1);
            assert(lua_gettop(L) == 15);

            /* if t[2] then */
            enum { lc103 = 15 };
            lc_getupvalue(L, lc77, 2, 119);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            const int lc104 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc104) {

              /* return s(q(a,{e})) */
              const int lc105 = lua_gettop(L);
              lc_getupvalue(L, lc77, 1, 121);
              const int lc106 = lua_gettop(L);
              lc_getupvalue(L, lc77, 3, 68);
              lua_pushvalue(L, 11);
              lua_createtable(L, 1, 0);
              lua_pushvalue(L, 15);
              lua_rawseti(L, -2, 1);
              lua_call(L, 2, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc106), LUA_MULTRET);
              return (lua_gettop(L) - lc105);
              assert(lua_gettop(L) == 15);
            } else {

              /* else
               * return j() */
              const int lc107 = lua_gettop(L);
              lc_getupvalue(L, lc77, 3, 117);
              lua_call(L, 0, LUA_MULTRET);
              return (lua_gettop(L) - lc107);
              assert(lua_gettop(L) == 15);
            }
            lua_settop(L, lc103);
            assert(lua_gettop(L) == 15);
          }
          lua_settop(L, lc99);
          assert(lua_gettop(L) == 14);

          /* if l(a,te) then */
          enum { lc108 = 14 };
          lc_getupvalue(L, lc77, 3, 4);
          lua_pushvalue(L, 11);
          lc_getupvalue(L, lc77, 3, 38);
          lua_call(L, 2, 1);
          const int lc109 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc109) {

            /* return o() */
            const int lc110 = lua_gettop(L);
            lua_pushvalue(L, 8);
            lua_call(L, 0, LUA_MULTRET);
            return (lua_gettop(L) - lc110);
            assert(lua_gettop(L) == 14);
          } else {

            /* elseif l(a,be) then */
            enum { lc111 = 14 };
            lc_getupvalue(L, lc77, 3, 4);
            lua_pushvalue(L, 11);
            lc_getupvalue(L, lc77, 3, 37);
            lua_call(L, 2, 1);
            const int lc112 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc112) {

              /* return o() */
              const int lc113 = lua_gettop(L);
              lua_pushvalue(L, 8);
              lua_call(L, 0, LUA_MULTRET);
              return (lua_gettop(L) - lc113);
              assert(lua_gettop(L) == 14);
            } else {

              /* elseif l(a,ve) then */
              enum { lc114 = 14 };
              lc_getupvalue(L, lc77, 3, 4);
              lua_pushvalue(L, 11);
              lc_getupvalue(L, lc77, 3, 36);
              lua_call(L, 2, 1);
              const int lc115 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc115) {

                /* return o() */
                const int lc116 = lua_gettop(L);
                lua_pushvalue(L, 8);
                lua_call(L, 0, LUA_MULTRET);
                return (lua_gettop(L) - lc116);
                assert(lua_gettop(L) == 14);
              } else {

                /* elseif l(a,ee) then */
                enum { lc117 = 14 };
                lc_getupvalue(L, lc77, 3, 4);
                lua_pushvalue(L, 11);
                lc_getupvalue(L, lc77, 3, 35);
                lua_call(L, 2, 1);
                const int lc118 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc118) {

                  /* H(#e==3) */
                  lc_getupvalue(L, lc77, 3, 116);
                  const double lc119 = lua_objlen(L, 12);
                  lua_pushnumber(L, lc119);
                  lua_pushnumber(L, 3);
                  const int lc120 = lua_equal(L, -2, -1);
                  lua_pop(L, 2);
                  lua_pushboolean(L, lc120);
                  lua_call(L, 1, 0);
                  assert(lua_gettop(L) == 14);

                  /* H(t[2]==false) */
                  lc_getupvalue(L, lc77, 3, 116);
                  lc_getupvalue(L, lc77, 2, 119);
                  lua_pushnumber(L, 2);
                  lua_gettable(L, -2);
                  lua_remove(L, -2);
                  lua_pushboolean(L, 0);
                  const int lc121 = lua_equal(L, -2, -1);
                  lua_pop(L, 2);
                  lua_pushboolean(L, lc121);
                  lua_call(L, 1, 0);
                  assert(lua_gettop(L) == 14);

                  /* local a=n(e[1],d(),t) */
                  lc_getupvalue(L, lc77, 3, 23);
                  lua_pushnumber(L, 1);
                  lua_gettable(L, 12);
                  lua_pushvalue(L, 9);
                  lua_call(L, 0, 1);
                  lc_getupvalue(L, lc77, 2, 119);
                  lua_call(L, 3, 1);
                  assert(lua_gettop(L) == 15);

                  /* if t[2] then */
                  enum { lc122 = 15 };
                  lc_getupvalue(L, lc77, 2, 119);
                  lua_pushnumber(L, 2);
                  lua_gettable(L, -2);
                  lua_remove(L, -2);
                  const int lc123 = lua_toboolean(L, -1);
                  lua_pop(L, 1);
                  if (lc123) {

                    /* return s(q(ee,{
                     * a,
                     * e[2],
                     * e[3],
                     * })) */
                    const int lc124 = lua_gettop(L);
                    lc_getupvalue(L, lc77, 1, 121);
                    const int lc125 = lua_gettop(L);
                    lc_getupvalue(L, lc77, 3, 68);
                    lc_getupvalue(L, lc77, 3, 35);
                    lua_createtable(L, 3, 0);
                    lua_pushvalue(L, 15);
                    lua_rawseti(L, -2, 1);
                    lua_pushnumber(L, 2);
                    lua_gettable(L, 12);
                    lua_rawseti(L, -2, 2);
                    lua_pushnumber(L, 3);
                    lua_gettable(L, 12);
                    lua_rawseti(L, -2, 3);
                    lua_call(L, 2, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc125), LUA_MULTRET);
                    return (lua_gettop(L) - lc124);
                    assert(lua_gettop(L) == 15);
                  } else {

                    /* else
                     * return j() */
                    const int lc126 = lua_gettop(L);
                    lc_getupvalue(L, lc77, 3, 117);
                    lua_call(L, 0, LUA_MULTRET);
                    return (lua_gettop(L) - lc126);
                    assert(lua_gettop(L) == 15);
                  }
                  lua_settop(L, lc122);
                  assert(lua_gettop(L) == 15);
                }
                lua_settop(L, lc117);
              }
              lua_settop(L, lc114);
            }
            lua_settop(L, lc111);
          }
          lua_settop(L, lc108);
          assert(lua_gettop(L) == 14);

          /* return j() */
          const int lc127 = lua_gettop(L);
          lc_getupvalue(L, lc77, 3, 117);
          lua_call(L, 0, LUA_MULTRET);
          return (lua_gettop(L) - lc127);
          assert(lua_gettop(L) == 14);
        } else {

          /* elseif G(e) then */
          enum { lc128 = 10 };
          lc_getupvalue(L, lc77, 3, 72);
          lc_getupvalue(L, lc77, 1, 123);
          lua_call(L, 1, 1);
          const int lc129 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc129) {

            /* return o() */
            const int lc130 = lua_gettop(L);
            lua_pushvalue(L, 8);
            lua_call(L, 0, LUA_MULTRET);
            return (lua_gettop(L) - lc130);
            assert(lua_gettop(L) == 10);
          } else {

            /* elseif V(e) then */
            enum { lc131 = 10 };
            lc_getupvalue(L, lc77, 3, 63);
            lc_getupvalue(L, lc77, 1, 123);
            lua_call(L, 1, 1);
            const int lc132 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc132) {

              /* return o() */
              const int lc133 = lua_gettop(L);
              lua_pushvalue(L, 8);
              lua_call(L, 0, LUA_MULTRET);
              return (lua_gettop(L) - lc133);
              assert(lua_gettop(L) == 10);
            }
            lua_settop(L, lc131);
          }
          lua_settop(L, lc128);
        }
        lua_settop(L, lc94);
      }
      lua_settop(L, lc91);
      assert(lua_gettop(L) == 10);

      /* return j() */
      const int lc134 = lua_gettop(L);
      lc_getupvalue(L, lc77, 3, 117);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc134);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L, lc88);
    assert(lua_gettop(L) == 10);

    /* h[r]=true */
    lua_pushboolean(L, 1);
    lc_getupvalue(L, lc77, 0, 124);
    lua_insert(L, -2);
    lua_pushvalue(L, 10);
    lua_insert(L, -2);
    lua_settable(L, -3);
    lua_pop(L, 1);
    assert(lua_gettop(L) == 10);

    /* v(a,e) */
    lc_getupvalue(L, lc77, 5, 1);
    lc_getupvalue(L, lc77, 2, 120);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 10);

    /* e=k(e) */
    lc_getupvalue(L, lc77, 3, 22);
    lc_getupvalue(L, lc77, 1, 123);
    lua_call(L, 1, 1);
    lc_setupvalue(L, lc77, 1, 123);
    assert(lua_gettop(L) == 10);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc83);
  assert(lua_gettop(L) == 9);

  /* return r(e) */
  const int lc135 = lua_gettop(L);
  lc_getupvalue(L, lc77, 1, 122);
  lc_getupvalue(L, lc77, 1, 123);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc135);
  assert(lua_gettop(L) == 9);
}

/* name: k
 * function(a) */
static inline int lcf1_k(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local e=N(a) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 2);

  /* local t */
  lua_settop(L, (lua_gettop(L) + 1));
  assert(lua_gettop(L) == 3);

  /* H(not B(e)) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 116);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 79);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 3);

  /* if Q(e) then */
  enum { lc136 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 76);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc137 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc137) {

    /* t=it(X(e),Z(e),a) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 12);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 75);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 74);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 1);
    lua_call(L, 3, 1);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif G(e) then */
    enum { lc138 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 72);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc139 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc139) {

      /* t=Xe(_e(e),Te(e),ze(e),a) */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 7);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 71);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 70);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 69);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushvalue(L, 1);
      lua_call(L, 4, 1);
      lua_replace(L, 3);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif P(e) then */
      enum { lc140 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 67);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      const int lc141 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc141) {

        /* t=Ze(ue(e),re(e),a) */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 8);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 66);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 65);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushvalue(L, 1);
        lua_call(L, 3, 1);
        lua_replace(L, 3);
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif V(e) then */
        enum { lc142 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 63);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        const int lc143 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc143) {

          /* t=ht(je(e),xe(e),a) */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 9);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 62);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 61);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushvalue(L, 1);
          lua_call(L, 3, 1);
          lua_replace(L, 3);
          assert(lua_gettop(L) == 3);
        } else {

          /* else
           * t=e */
          lua_pushvalue(L, 2);
          lua_replace(L, 3);
          assert(lua_gettop(L) == 3);
        }
        lua_settop(L, lc142);
      }
      lua_settop(L, lc140);
    }
    lua_settop(L, lc138);
  }
  lua_settop(L, lc136);
  assert(lua_gettop(L) == 3);

  /* t=N(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 26);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lua_replace(L, 3);
  assert(lua_gettop(L) == 3);

  /* O(e,t) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 3);
  lua_call(L, 2, 0);
  assert(lua_gettop(L) == 3);

  /* return t */
  lua_pushvalue(L, 3);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: r
 * function(e) */
static inline int lcf2_r(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return n(e) */
  const int lc144 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 23);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc144);
  assert(lua_gettop(L) == 1);
}

/* name: Qe
 * function(e) */
static inline int lcf1_Qe(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* while w(e)or I(e)do */
  enum { lc145 = 1 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 0, 24);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      lua_pop(L, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 101);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* e=r(qe(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 21);
    const int lc146 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc146), 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc145);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Ee
 * function(a,o,i) */
static inline int lcf1_Ee(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 5);

  /* while e<#a do */
  enum { lc147 = 5 };
  while (1) {
    const double lc148 = lua_objlen(L, 1);
    lua_pushnumber(L, lc148);
    const int lc149 = lua_lessthan(L, 5, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc149);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if l(a[(e+0)+1],o) then */
    enum { lc150 = 5 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 5, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc151 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc151) {

      /* t[(e+0)+1]=o */
      lua_pushvalue(L, 2);
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      assert(lua_gettop(L) == 5);

      /* t[(e+1)+1]=i */
      lua_pushvalue(L, 3);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      assert(lua_gettop(L) == 5);

      /* do
       * e=e+2 */
      lua_pushnumber(L, 2);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_replace(L, 5);
      assert(lua_gettop(L) == 5);

      /* while e<#a do */
      enum { lc152 = 5 };
      while (1) {
        const double lc153 = lua_objlen(L, 1);
        lua_pushnumber(L, lc153);
        const int lc154 = lua_lessthan(L, 5, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc154);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* t[(e+0)+1]=a[(e+0)+1] */
        lua_pushnumber(L, 0);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_gettable(L, 1);
        lua_pushnumber(L, 0);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 4);
        assert(lua_gettop(L) == 5);

        /* t[(e+1)+1]=a[(e+1)+1] */
        lua_pushnumber(L, 1);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_gettable(L, 1);
        lua_pushnumber(L, 1);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 4);
        assert(lua_gettop(L) == 5);

        /* e=e+2 */
        lua_pushnumber(L, 2);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_replace(L, 5);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc152);
      assert(lua_gettop(L) == 5);
      assert(lua_gettop(L) == 5);

      /* return t */
      lua_pushvalue(L, 4);
      return 1;
      assert(lua_gettop(L) == 5);
    } else {

      /* else
       * t[(e+0)+1]=a[(e+0)+1] */
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      assert(lua_gettop(L) == 5);

      /* t[(e+1)+1]=a[(e+1)+1] */
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L, lc150);
    assert(lua_gettop(L) == 5);

    /* e=e+2 */
    lua_pushnumber(L, 2);
    lc_add(L, 5, -1);
    lua_remove(L, -2);
    lua_replace(L, 5);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc147);
  assert(lua_gettop(L) == 5);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 4);

  /* t[(#a+0)+1]=o */
  lua_pushvalue(L, 2);
  const double lc155 = lua_objlen(L, 1);
  lua_pushnumber(L, lc155);
  lua_pushnumber(L, 0);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_insert(L, -2);
  lua_settable(L, 4);
  assert(lua_gettop(L) == 4);

  /* t[(#a+1)+1]=i */
  lua_pushvalue(L, 3);
  const double lc156 = lua_objlen(L, 1);
  lua_pushnumber(L, lc156);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_insert(L, -2);
  lua_settable(L, 4);
  assert(lua_gettop(L) == 4);

  /* return t */
  lua_pushvalue(L, 4);
  return 1;
  assert(lua_gettop(L) == 4);
}

/* name: Ge
 * function(t,a,o) */
static inline int lcf1_Ge(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 4);

  /* while e<#t do */
  enum { lc157 = 4 };
  while (1) {
    const double lc158 = lua_objlen(L, 1);
    lua_pushnumber(L, lc158);
    const int lc159 = lua_lessthan(L, 4, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc159);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if l(t[(e+0)+1],a) then */
    enum { lc160 = 4 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 4, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc161 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc161) {

      /* return t[(e+1)+1] */
      lua_pushnumber(L, 1);
      lc_add(L, 4, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      return 1;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L, lc160);
    assert(lua_gettop(L) == 4);

    /* e=e+2 */
    lua_pushnumber(L, 2);
    lc_add(L, 4, -1);
    lua_remove(L, -2);
    lua_replace(L, 4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc157);
  assert(lua_gettop(L) == 4);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 3);

  /* return o */
  lua_pushvalue(L, 3);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: et
 * function(t,a) */
static inline int lcf1_et(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 3);

  /* while e<#t do */
  enum { lc162 = 3 };
  while (1) {
    const double lc163 = lua_objlen(L, 1);
    lua_pushnumber(L, lc163);
    const int lc164 = lua_lessthan(L, 3, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc164);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if l(t[(e+0)+1],a) then */
    enum { lc165 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc166 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc166) {

      /* return t[(e+1)+1] */
      lua_pushnumber(L, 1);
      lc_add(L, 3, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      return 1;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L, lc165);
    assert(lua_gettop(L) == 3);

    /* e=e+2 */
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc162);
  assert(lua_gettop(L) == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 2);

  /* return j() */
  const int lc167 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc167);
  assert(lua_gettop(L) == 2);
}

/* name: R
 * function(o) */
static inline int lcf1_R(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local a=y */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 89);
  assert(lua_gettop(L) == 2);

  /* do
   * local t=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 3);

  /* while t<#o do */
  enum { lc168 = 3 };
  while (1) {
    const double lc169 = lua_objlen(L, 1);
    lua_pushnumber(L, lc169);
    const int lc170 = lua_lessthan(L, 3, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc170);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* a=s(e(o[(t+0)+1],o[(t+1)+1]),a) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 93);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 27);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_call(L, 2, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 3);

    /* t=t+2 */
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc168);
  assert(lua_gettop(L) == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 2);

  /* return T(Se,e(a)) */
  const int lc171 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 87);
  const int lc172 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 51);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 27);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc172), LUA_MULTRET);
  return (lua_gettop(L) - lc171);
  assert(lua_gettop(L) == 2);
}

/* name: Ke
 * function(t,a) */
static inline int lcf1_Ke(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 3);

  /* while e<#t do */
  enum { lc173 = 3 };
  while (1) {
    const double lc174 = lua_objlen(L, 1);
    lua_pushnumber(L, lc174);
    const int lc175 = lua_lessthan(L, 3, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc175);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* a(t[(e+0)+1],t[(e+1)+1]) */
    lua_pushvalue(L, 2);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* e=e+2 */
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc173);
  assert(lua_gettop(L) == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: ot
 * function(e,d,r,l) */
static inline int lcf1_ot(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* local s={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 6);

  /* local e=N(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 7);

  /* local n=true */
  lua_pushboolean(L, 1);
  assert(lua_gettop(L) == 8);

  /* while true do */
  enum { lc176 = 8 };
  while (1) {
    lua_pushboolean(L, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if h(e) then */
    enum { lc177 = 8 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 88);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    const int lc178 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc178) {

      /* return l(t,s) */
      const int lc179 = lua_gettop(L);
      lua_pushvalue(L, 4);
      lua_pushvalue(L, 6);
      lua_pushvalue(L, 5);
      lua_call(L, 2, LUA_MULTRET);
      return (lua_gettop(L) - lc179);
      assert(lua_gettop(L) == 8);
    } else {

      /* elseif I(e) then */
      enum { lc180 = 8 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 101);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc181 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc181) {

        /* v(t,oe(e)) */
        lc_getupvalue(L, lua_upvalueindex(1), 2, 1);
        const int lc182 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 100);
        lua_pushvalue(L, 7);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc182), 0);
        assert(lua_gettop(L) == 8);

        /* e=K(e) */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 99);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        lua_replace(L, 7);
        assert(lua_gettop(L) == 8);
      } else {

        /* elseif a(e) then */
        enum { lc183 = 8 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        const int lc184 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc184) {

          /* v(s,o(e)) */
          lc_getupvalue(L, lua_upvalueindex(1), 2, 1);
          const int lc185 = lua_gettop(L);
          lua_pushvalue(L, 5);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 91);
          lua_pushvalue(L, 7);
          lua_call(L, 1, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc185), 0);
          assert(lua_gettop(L) == 8);

          /* e=i(e) */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 90);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lua_replace(L, 7);
          assert(lua_gettop(L) == 8);
        } else {

          /* elseif w(e) then */
          enum { lc186 = 8 };
          lc_getupvalue(L, lua_upvalueindex(1), 0, 24);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          const int lc187 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc187) {

            /* if n then */
            enum { lc188 = 8 };
            if (lua_toboolean(L, 8)) {

              /* n=false */
              lua_pushboolean(L, 0);
              lua_replace(L, 8);
              assert(lua_gettop(L) == 8);

              /* e=k(e) */
              lc_getupvalue(L, lua_upvalueindex(1), 0, 22);
              lua_pushvalue(L, 7);
              lua_call(L, 1, 1);
              lua_replace(L, 7);
              assert(lua_gettop(L) == 8);
            } else {

              /* else
               * return r() */
              const int lc189 = lua_gettop(L);
              lua_pushvalue(L, 3);
              lua_call(L, 0, LUA_MULTRET);
              return (lua_gettop(L) - lc189);
              assert(lua_gettop(L) == 8);
            }
            lua_settop(L, lc188);
            assert(lua_gettop(L) == 8);
          } else {

            /* else
             * return d() */
            const int lc190 = lua_gettop(L);
            lua_pushvalue(L, 2);
            lua_call(L, 0, LUA_MULTRET);
            return (lua_gettop(L) - lc190);
            assert(lua_gettop(L) == 8);
          }
          lua_settop(L, lc186);
        }
        lua_settop(L, lc183);
      }
      lua_settop(L, lc180);
    }
    lua_settop(L, lc177);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L, lc176);
  assert(lua_gettop(L) == 8);
  return 0;
}

/* name: t
 * function() */
static inline int lcf2_t(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return L(z,e(J,e(ve,e(R(s),n)))) */
  const int lc196 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 83);
  const int lc197 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 54);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 27);
  const int lc198 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 32);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 27);
  const int lc199 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 36);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 15);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 127);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc199), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc198), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc197), LUA_MULTRET);
  return (lua_gettop(L) - lc196);
  assert(lua_gettop(L) == 0);
}

/* function() */
static inline int lcf203(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return d */
  lc_getupvalue(L, lua_upvalueindex(1), 2, 126);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* function(n,e) */
static inline int lcf273(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* if#n~=0 then */
  enum { lc204 = 2 };
  const double lc205 = lua_objlen(L, 1);
  lua_pushnumber(L, lc205);
  lua_pushnumber(L, 0);
  const int lc206 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc206);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc207 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc207) {

    /* error("WIP") */
    lua_getfield(L, LUA_ENVIRONINDEX, "error");
    lua_pushliteral(L, "WIP");
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc204);
  assert(lua_gettop(L) == 2);

  /* if l(e[1],ie) then */
  enum { lc208 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 3, 4);
  lua_pushnumber(L, 1);
  lua_gettable(L, 2);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 31);
  lua_call(L, 2, 1);
  const int lc209 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc209) {

    /* if#e==1 then */
    enum { lc210 = 2 };
    const double lc211 = lua_objlen(L, 2);
    lua_pushnumber(L, lc211);
    lua_pushnumber(L, 1);
    const int lc212 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc212);
    const int lc213 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc213) {

      /* return t() */
      const int lc214 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc214);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L, lc210);
    assert(lua_gettop(L) == 2);

    /* local o=e[2] */
    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    assert(lua_gettop(L) == 3);

    /* local a={} */
    lua_newtable(L);
    assert(lua_gettop(L) == 4);

    /* do
     * local t=2 */
    lua_pushnumber(L, 2);
    assert(lua_gettop(L) == 5);

    /* while t<#e do */
    enum { lc215 = 5 };
    while (1) {
      const double lc216 = lua_objlen(L, 2);
      lua_pushnumber(L, lc216);
      const int lc217 = lua_lessthan(L, 5, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc217);
      if (!(lua_toboolean(L, -1))) {
        break;
      }
      lua_pop(L, 1);

      /* v(a,e[t+1]) */
      lc_getupvalue(L, lua_upvalueindex(1), 5, 1);
      lua_pushvalue(L, 4);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_gettable(L, 2);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 5);

      /* t=t+1 */
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_replace(L, 5);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L, lc215);
    assert(lua_gettop(L) == 5);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
    assert(lua_gettop(L) == 4);

    /* return Oe(s,o,a) */
    const int lc218 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 3, 73);
    lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 4);
    lua_call(L, 3, LUA_MULTRET);
    return (lua_gettop(L) - lc218);
    assert(lua_gettop(L) == 4);
  } else {

    /* elseif l(e[1],nt) then */
    enum { lc219 = 2 };
    lc_getupvalue(L, lua_upvalueindex(1), 3, 4);
    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    lc_getupvalue(L, lua_upvalueindex(1), 3, 30);
    lua_call(L, 2, 1);
    const int lc220 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc220) {

      /* if#e==1 then */
      enum { lc221 = 2 };
      const double lc222 = lua_objlen(L, 2);
      lua_pushnumber(L, lc222);
      lua_pushnumber(L, 1);
      const int lc223 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc223);
      const int lc224 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc224) {

        /* return t() */
        const int lc225 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc225);
        assert(lua_gettop(L) == 2);
      }
      lua_settop(L, lc221);
      assert(lua_gettop(L) == 2);

      /* local n=r(S(s,e[2])) */
      lc_getupvalue(L, lua_upvalueindex(1), 3, 21);
      const int lc226 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 77);
      lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
      lua_pushnumber(L, 2);
      lua_gettable(L, 2);
      lua_call(L, 2, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc226), 1);
      assert(lua_gettop(L) == 3);

      /* if not c(n) then */
      enum { lc227 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 86);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc228 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc228) {

        /* return t() */
        const int lc229 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc229);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc227);
      assert(lua_gettop(L) == 3);

      /* local r=k(E(n)) */
      lc_getupvalue(L, lua_upvalueindex(1), 3, 22);
      const int lc230 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 85);
      lua_pushvalue(L, 3);
      lua_call(L, 1, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc230), 1);
      assert(lua_gettop(L) == 4);

      /* if w(r) then */
      enum { lc231 = 4 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 24);
      lua_pushvalue(L, 4);
      lua_call(L, 1, 1);
      const int lc232 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc232) {

        /* return d */
        lc_getupvalue(L, lua_upvalueindex(1), 2, 126);
        return 1;
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L, lc231);
      assert(lua_gettop(L) == 4);

      /* if not p(r) then */
      enum { lc233 = 4 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 97);
      lua_pushvalue(L, 4);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc234 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc234) {

        /* return t() */
        const int lc235 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc235);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L, lc233);
      assert(lua_gettop(L) == 4);

      /* if not D(r,x) then */
      enum { lc236 = 4 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 94);
      lua_pushvalue(L, 4);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 52);
      lua_call(L, 2, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc237 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc237) {

        /* return t() */
        const int lc238 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc238);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L, lc236);
      assert(lua_gettop(L) == 4);

      /* local n=k(A(n)) */
      lc_getupvalue(L, lua_upvalueindex(1), 3, 22);
      const int lc239 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 84);
      lua_pushvalue(L, 3);
      lua_call(L, 1, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc239), 1);
      assert(lua_gettop(L) == 5);

      /* if w(n) then */
      enum { lc240 = 5 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 24);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      const int lc241 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc241) {

        /* return d */
        lc_getupvalue(L, lua_upvalueindex(1), 2, 126);
        return 1;
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc240);
      assert(lua_gettop(L) == 5);

      /* if not a(n) then */
      enum { lc242 = 5 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 92);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc243 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc243) {

        /* return t() */
        const int lc244 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc244);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc242);
      assert(lua_gettop(L) == 5);

      /* local o=o(n) */
      lc_getupvalue(L, lua_upvalueindex(1), 3, 91);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      assert(lua_gettop(L) == 6);

      /* local a=k(i(n)) */
      lc_getupvalue(L, lua_upvalueindex(1), 3, 22);
      const int lc245 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 90);
      lua_pushvalue(L, 5);
      lua_call(L, 1, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc245), 1);
      assert(lua_gettop(L) == 7);

      /* if w(a) then */
      enum { lc246 = 7 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 24);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc247 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc247) {

        /* return d */
        lc_getupvalue(L, lua_upvalueindex(1), 2, 126);
        return 1;
        assert(lua_gettop(L) == 7);
      }
      lua_settop(L, lc246);
      assert(lua_gettop(L) == 7);

      /* if not h(a) then */
      enum { lc248 = 7 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 88);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc249 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc249) {

        /* return t() */
        const int lc250 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc250);
        assert(lua_gettop(L) == 7);
      }
      lua_settop(L, lc248);
      assert(lua_gettop(L) == 7);

      /* local a={R(s)} */
      lua_createtable(L, 1, 0);
      const int lc251 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 15);
      lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
      lua_call(L, 1, LUA_MULTRET);
      while ((lua_gettop(L) > lc251)) {
        lua_rawseti(L, lc251, (0 + (lua_gettop(L) - lc251)));
      }
      assert(lua_gettop(L) == 8);

      /* do
       * local t=2 */
      lua_pushnumber(L, 2);
      assert(lua_gettop(L) == 9);

      /* while t<#e do */
      enum { lc252 = 9 };
      while (1) {
        const double lc253 = lua_objlen(L, 2);
        lua_pushnumber(L, lc253);
        const int lc254 = lua_lessthan(L, 9, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc254);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* v(a,e[t+1]) */
        lc_getupvalue(L, lua_upvalueindex(1), 5, 1);
        lua_pushvalue(L, 8);
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_gettable(L, 2);
        lua_call(L, 2, 0);
        assert(lua_gettop(L) == 9);

        /* t=t+1 */
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_replace(L, 9);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L, lc252);
      assert(lua_gettop(L) == 9);

      /* internal: stack cleanup on scope exit */
      lua_pop(L, 1);
      assert(lua_gettop(L) == 8);

      /* return F(o,a) */
      const int lc255 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 64);
      lua_pushvalue(L, 6);
      lua_pushvalue(L, 8);
      lua_call(L, 2, LUA_MULTRET);
      return (lua_gettop(L) - lc255);
      assert(lua_gettop(L) == 8);
    } else {

      /* elseif l(e[1],J) then */
      enum { lc256 = 2 };
      lc_getupvalue(L, lua_upvalueindex(1), 3, 4);
      lua_pushnumber(L, 1);
      lua_gettable(L, 2);
      lc_getupvalue(L, lua_upvalueindex(1), 3, 32);
      lua_call(L, 2, 1);
      const int lc257 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc257) {

        /* if#e==1 then */
        enum { lc258 = 2 };
        const double lc259 = lua_objlen(L, 2);
        lua_pushnumber(L, lc259);
        lua_pushnumber(L, 1);
        const int lc260 = lua_equal(L, -2, -1);
        lua_pop(L, 2);
        lua_pushboolean(L, lc260);
        const int lc261 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc261) {

          /* return t() */
          const int lc262 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 128);
          lua_call(L, 0, LUA_MULTRET);
          return (lua_gettop(L) - lc262);
          assert(lua_gettop(L) == 2);
        }
        lua_settop(L, lc258);
        assert(lua_gettop(L) == 2);

        /* local o=e[2] */
        lua_pushnumber(L, 2);
        lua_gettable(L, 2);
        assert(lua_gettop(L) == 3);

        /* local a={} */
        lua_newtable(L);
        assert(lua_gettop(L) == 4);

        /* do
         * local t=2 */
        lua_pushnumber(L, 2);
        assert(lua_gettop(L) == 5);

        /* while t<#e do */
        enum { lc263 = 5 };
        while (1) {
          const double lc264 = lua_objlen(L, 2);
          lua_pushnumber(L, lc264);
          const int lc265 = lua_lessthan(L, 5, -1);
          lua_pop(L, 1);
          lua_pushboolean(L, lc265);
          if (!(lua_toboolean(L, -1))) {
            break;
          }
          lua_pop(L, 1);

          /* v(a,S(s,e[t+1])) */
          lc_getupvalue(L, lua_upvalueindex(1), 5, 1);
          const int lc266 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lc_getupvalue(L, lua_upvalueindex(1), 3, 77);
          lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_gettable(L, 2);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc266), 0);
          assert(lua_gettop(L) == 5);

          /* t=t+1 */
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_replace(L, 5);
          assert(lua_gettop(L) == 5);
        }
        lua_settop(L, lc263);
        assert(lua_gettop(L) == 5);

        /* internal: stack cleanup on scope exit */
        lua_pop(L, 1);
        assert(lua_gettop(L) == 4);

        /* return q(o,a) */
        const int lc267 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 3, 68);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 4);
        lua_call(L, 2, LUA_MULTRET);
        return (lua_gettop(L) - lc267);
        assert(lua_gettop(L) == 4);
      } else {

        /* else
         * local o=S(s,e[1]) */
        lc_getupvalue(L, lua_upvalueindex(1), 3, 77);
        lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
        lua_pushnumber(L, 1);
        lua_gettable(L, 2);
        lua_call(L, 2, 1);
        assert(lua_gettop(L) == 3);

        /* local a={} */
        lua_newtable(L);
        assert(lua_gettop(L) == 4);

        /* do
         * local t=1 */
        lua_pushnumber(L, 1);
        assert(lua_gettop(L) == 5);

        /* while t<#e do */
        enum { lc268 = 5 };
        while (1) {
          const double lc269 = lua_objlen(L, 2);
          lua_pushnumber(L, lc269);
          const int lc270 = lua_lessthan(L, 5, -1);
          lua_pop(L, 1);
          lua_pushboolean(L, lc270);
          if (!(lua_toboolean(L, -1))) {
            break;
          }
          lua_pop(L, 1);

          /* v(a,S(s,e[t+1])) */
          lc_getupvalue(L, lua_upvalueindex(1), 5, 1);
          const int lc271 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lc_getupvalue(L, lua_upvalueindex(1), 3, 77);
          lc_getupvalue(L, lua_upvalueindex(1), 2, 125);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_gettable(L, 2);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc271), 0);
          assert(lua_gettop(L) == 5);

          /* t=t+1 */
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_replace(L, 5);
          assert(lua_gettop(L) == 5);
        }
        lua_settop(L, lc268);
        assert(lua_gettop(L) == 5);

        /* internal: stack cleanup on scope exit */
        lua_pop(L, 1);
        assert(lua_gettop(L) == 4);

        /* return F(o,a) */
        const int lc272 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 3, 64);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 4);
        lua_call(L, 2, LUA_MULTRET);
        return (lua_gettop(L) - lc272);
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L, lc256);
    }
    lua_settop(L, lc219);
  }
  lua_settop(L, lc208);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: it
 * function(s,t,d) */
static inline int lcf1_it(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc191 = 4 };
  assert((lua_gettop(L) == lc191));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 125);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 126);

  /* local n=k(t) */
  lc_newclosuretable(L, lc191);
  enum { lc192 = 5 };
  assert((lua_gettop(L) == lc192));
  lc_getupvalue(L, lc191, 1, 22);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_rawseti(L, lc192, 127);
  assert(lua_gettop(L) == 5);

  /* if w(n) then */
  enum { lc193 = 5 };
  lc_getupvalue(L, lc192, 2, 24);
  lc_getupvalue(L, lc192, 0, 127);
  lua_call(L, 1, 1);
  const int lc194 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc194) {

    /* return d */
    lc_getupvalue(L, lc192, 1, 126);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc193);
  assert(lua_gettop(L) == 5);

  /* local function t()return L(z,e(J,e(ve,e(R(s),n))))end */
  lc_newclosuretable(L, lc192);
  enum { lc195 = 6 };
  assert((lua_gettop(L) == lc195));
  lua_pushvalue(L, lc195);
  lua_pushcclosure(L, lcf2_t, 1);
  lua_rawseti(L, lc195, 128);
  assert(lua_gettop(L) == 6);

  /* if a(n) then */
  enum { lc200 = 6 };
  lc_getupvalue(L, lc195, 3, 92);
  lc_getupvalue(L, lc195, 1, 127);
  lua_call(L, 1, 1);
  const int lc201 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc201) {

    /* return ot(n,t,function()return d end,function(n,e)
     * if#n~=0 then
     * error("WIP")
     * end
     * if l(e[1],ie)then
     * if#e==1 then
     * return t()
     * end
     * local o=e[2]
     * local a={}
     * do
     * local t=2
     * while t<#e do
     * v(a,e[t+1])
     * t=t+1
     * end
     * end
     * return Oe(s,o,a)
     * elseif l(e[1],nt)then
     * if#e==1 then
     * return t()
     * end
     * local n=r(S(s,e[2]))
     * if not c(n)then
     * return t()
     * end
     * local r=k(E(n))
     * if w(r)then
     * return d
     * end
     * if not p(r)then
     * return t()
     * end
     * if not D(r,x)then
     * return t()
     * end
     * local n=k(A(n))
     * if w(n)then
     * return d
     * end
     * if not a(n)then
     * return t()
     * end
     * local o=o(n)
     * local a=k(i(n))
     * if w(a)then
     * return d
     * end
     * if not h(a)then
     * return t()
     * end
     * local a={R(s)}
     * do
     * local t=2
     * while t<#e do
     * v(a,e[t+1])
     * t=t+1
     * end
     * end
     * return F(o,a)
     * elseif l(e[1],J)then
     * if#e==1 then
     * return t()
     * end
     * local o=e[2]
     * local a={}
     * do
     * local t=2
     * while t<#e do
     * v(a,S(s,e[t+1]))
     * t=t+1
     * end
     * end
     * return q(o,a)
     * else
     * local o=S(s,e[1])
     * local a={}
     * do
     * local t=1
     * while t<#e do
     * v(a,S(s,e[t+1]))
     * t=t+1
     * end
     * end
     * return F(o,a)
     * end
     * end) */
    const int lc202 = lua_gettop(L);
    lc_getupvalue(L, lc195, 3, 13);
    lc_getupvalue(L, lc195, 1, 127);
    lc_getupvalue(L, lc195, 0, 128);
    lua_pushvalue(L, lc195);
    lua_pushcclosure(L, lcf203, 1);
    lua_pushvalue(L, lc195);
    lua_pushcclosure(L, lcf273, 1);
    lua_call(L, 4, LUA_MULTRET);
    return (lua_gettop(L) - lc202);
    assert(lua_gettop(L) == 6);
  } else {

    /* elseif h(n) then */
    enum { lc274 = 6 };
    lc_getupvalue(L, lc195, 3, 88);
    lc_getupvalue(L, lc195, 1, 127);
    lua_call(L, 1, 1);
    const int lc275 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc275) {

      /* return n */
      lc_getupvalue(L, lc195, 1, 127);
      return 1;
      assert(lua_gettop(L) == 6);
    } else {

      /* elseif u(n) then */
      enum { lc276 = 6 };
      lc_getupvalue(L, lc195, 3, 11);
      lc_getupvalue(L, lc195, 1, 127);
      lua_call(L, 1, 1);
      const int lc277 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc277) {

        /* return Ge(s,n,t()) */
        const int lc278 = lua_gettop(L);
        lc_getupvalue(L, lc195, 3, 17);
        const int lc279 = lua_gettop(L);
        lc_getupvalue(L, lc195, 2, 125);
        lc_getupvalue(L, lc195, 1, 127);
        lc_getupvalue(L, lc195, 0, 128);
        lua_call(L, 0, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc279), LUA_MULTRET);
        return (lua_gettop(L) - lc278);
        assert(lua_gettop(L) == 6);
      } else {

        /* elseif g(n) then */
        enum { lc280 = 6 };
        lc_getupvalue(L, lc195, 3, 82);
        lc_getupvalue(L, lc195, 1, 127);
        lua_call(L, 1, 1);
        const int lc281 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc281) {

          /* return t() */
          const int lc282 = lua_gettop(L);
          lc_getupvalue(L, lc195, 0, 128);
          lua_call(L, 0, LUA_MULTRET);
          return (lua_gettop(L) - lc282);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L, lc280);
      }
      lua_settop(L, lc276);
    }
    lua_settop(L, lc274);
  }
  lua_settop(L, lc200);
  assert(lua_gettop(L) == 6);

  /* return j() */
  const int lc283 = lua_gettop(L);
  lc_getupvalue(L, lc195, 3, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc283);
  assert(lua_gettop(L) == 6);
}

/* name: u
 * function(e) */
static inline int lcf1_u(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return p(e)or c(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 97);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 86);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: d
 * function() */
static inline int lcf3_d(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return L(z,e(J,e(be,e(l,_(n))))) */
  const int lc285 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 83);
  const int lc286 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 54);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc287 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 32);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc288 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 37);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc289 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 129);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 28);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 130);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc289), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc288), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc287), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc286), LUA_MULTRET);
  return (lua_gettop(L) - lc285);
  assert(lua_gettop(L) == 0);
}

/* name: ht
 * function(l,n,m) */
static inline int lcf1_ht(lua_State *L) {
  lua_checkstack(L, 24);
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc284 = 4 };
  assert((lua_gettop(L) == lc284));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 129);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 130);

  /* local function d()return L(z,e(J,e(be,e(l,_(n)))))end */
  lua_pushvalue(L, lc284);
  lua_pushcclosure(L, lcf3_d, 1);
  assert(lua_gettop(L) == 5);

  /* l=k(l) */
  lc_getupvalue(L, lc284, 1, 22);
  lc_getupvalue(L, lc284, 0, 129);
  lua_call(L, 1, 1);
  lc_setupvalue(L, lc284, 0, 129);
  assert(lua_gettop(L) == 5);

  /* if w(l) then */
  enum { lc290 = 5 };
  lc_getupvalue(L, lc284, 1, 24);
  lc_getupvalue(L, lc284, 0, 129);
  lua_call(L, 1, 1);
  const int lc291 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc291) {

    /* return m */
    lua_pushvalue(L, 3);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc290);
  assert(lua_gettop(L) == 5);

  /* if not c(l) then */
  enum { lc292 = 5 };
  lc_getupvalue(L, lc284, 1, 86);
  lc_getupvalue(L, lc284, 0, 129);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc293 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc293) {

    /* return d() */
    const int lc294 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc294);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc292);
  assert(lua_gettop(L) == 5);

  /* local e=r(E(l)) */
  lc_getupvalue(L, lc284, 1, 21);
  const int lc295 = lua_gettop(L);
  lc_getupvalue(L, lc284, 1, 85);
  lc_getupvalue(L, lc284, 0, 129);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc295), 1);
  assert(lua_gettop(L) == 6);

  /* if not(p(e)and D(e,t)) then */
  enum { lc296 = 6 };
  lc_getupvalue(L, lc284, 1, 97);
  lua_pushvalue(L, 6);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lc284, 1, 94);
    lua_pushvalue(L, 6);
    lc_getupvalue(L, lc284, 1, 53);
    lua_call(L, 2, 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc297 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc297) {

    /* return d() */
    const int lc298 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc298);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L, lc296);
  assert(lua_gettop(L) == 6);

  /* local t=r(A(l)) */
  lc_getupvalue(L, lc284, 1, 21);
  const int lc299 = lua_gettop(L);
  lc_getupvalue(L, lc284, 1, 84);
  lc_getupvalue(L, lc284, 0, 129);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc299), 1);
  assert(lua_gettop(L) == 7);

  /* if not a(t) then */
  enum { lc300 = 7 };
  lc_getupvalue(L, lc284, 1, 92);
  lua_pushvalue(L, 7);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc301 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc301) {

    /* return d() */
    const int lc302 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc302);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L, lc300);
  assert(lua_gettop(L) == 7);

  /* local e=W(o(t)) */
  lc_getupvalue(L, lc284, 1, 60);
  const int lc303 = lua_gettop(L);
  lc_getupvalue(L, lc284, 1, 91);
  lua_pushvalue(L, 7);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc303), 1);
  assert(lua_gettop(L) == 8);

  /* local t=r(i(t)) */
  lc_getupvalue(L, lc284, 1, 21);
  const int lc304 = lua_gettop(L);
  lc_getupvalue(L, lc284, 1, 90);
  lua_pushvalue(L, 7);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc304), 1);
  assert(lua_gettop(L) == 9);

  /* if not(a(t)and h(r(i(t)))) then */
  enum { lc305 = 9 };
  lc_getupvalue(L, lc284, 1, 92);
  lua_pushvalue(L, 9);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lc284, 1, 88);
    const int lc306 = lua_gettop(L);
    lc_getupvalue(L, lc284, 1, 21);
    const int lc307 = lua_gettop(L);
    lc_getupvalue(L, lc284, 1, 90);
    lua_pushvalue(L, 9);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc307), LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc306), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc308 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc308) {

    /* return d() */
    const int lc309 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc309);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L, lc305);
  assert(lua_gettop(L) == 9);

  /* local l=o(t) */
  lc_getupvalue(L, lc284, 1, 91);
  lua_pushvalue(L, 9);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 10);

  /* local r=Be */
  lc_getupvalue(L, lc284, 1, 19);
  assert(lua_gettop(L) == 11);

  /* local t=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 12);

  /* while not h(e)do */
  enum { lc310 = 12 };
  while (1) {
    lc_getupvalue(L, lc284, 1, 88);
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if u(e) then */
    enum { lc311 = 12 };
    lc_getupvalue(L, lc284, 1, 11);
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    const int lc312 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc312) {

      /* local a=y */
      lc_getupvalue(L, lc284, 1, 89);
      assert(lua_gettop(L) == 13);

      /* do
       * local e=#n-1 */
      lc_getupvalue(L, lc284, 0, 130);
      const double lc313 = lua_objlen(L, -1);
      lua_pop(L, 1);
      lua_pushnumber(L, lc313);
      lua_pushnumber(L, 1);
      lc_sub(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      assert(lua_gettop(L) == 14);

      /* while e>=t do */
      enum { lc314 = 14 };
      while (1) {
        lua_pushboolean(L, lc_le(L, 12, 14));
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* a=s(n[e+1],a) */
        lc_getupvalue(L, lc284, 1, 93);
        lc_getupvalue(L, lc284, 0, 130);
        lua_pushnumber(L, 1);
        lc_add(L, 14, -1);
        lua_remove(L, -2);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_pushvalue(L, 13);
        lua_call(L, 2, 1);
        lua_replace(L, 13);
        assert(lua_gettop(L) == 14);

        /* e=e-1 */
        lua_pushnumber(L, 1);
        lc_sub(L, 14, -1);
        lua_remove(L, -2);
        lua_replace(L, 14);
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L, lc314);
      assert(lua_gettop(L) == 14);

      /* internal: stack cleanup on scope exit */
      lua_pop(L, 1);
      assert(lua_gettop(L) == 13);

      /* r=Ee(r,e,a) */
      lc_getupvalue(L, lc284, 1, 18);
      lua_pushvalue(L, 11);
      lua_pushvalue(L, 8);
      lua_pushvalue(L, 13);
      lua_call(L, 3, 1);
      lua_replace(L, 11);
      assert(lua_gettop(L) == 13);

      /* t=#n */
      lc_getupvalue(L, lc284, 0, 130);
      const double lc315 = lua_objlen(L, -1);
      lua_pop(L, 1);
      lua_pushnumber(L, lc315);
      lua_replace(L, 12);
      assert(lua_gettop(L) == 13);

      /* e=y */
      lc_getupvalue(L, lc284, 1, 89);
      lua_replace(L, 8);
      assert(lua_gettop(L) == 13);
    } else {

      /* elseif a(e) then */
      enum { lc316 = 12 };
      lc_getupvalue(L, lc284, 1, 92);
      lua_pushvalue(L, 8);
      lua_call(L, 1, 1);
      const int lc317 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc317) {

        /* if t<#n then */
        enum { lc318 = 12 };
        lc_getupvalue(L, lc284, 0, 130);
        const double lc319 = lua_objlen(L, -1);
        lua_pop(L, 1);
        lua_pushnumber(L, lc319);
        const int lc320 = lua_lessthan(L, 12, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc320);
        const int lc321 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc321) {

          /* local a=n[t+1] */
          lc_getupvalue(L, lc284, 0, 130);
          lua_pushnumber(L, 1);
          lc_add(L, 12, -1);
          lua_remove(L, -2);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          assert(lua_gettop(L) == 13);

          /* t=t+1 */
          lua_pushnumber(L, 1);
          lc_add(L, 12, -1);
          lua_remove(L, -2);
          lua_replace(L, 12);
          assert(lua_gettop(L) == 13);

          /* r=Ee(r,o(e),a) */
          lc_getupvalue(L, lc284, 1, 18);
          lua_pushvalue(L, 11);
          lc_getupvalue(L, lc284, 1, 91);
          lua_pushvalue(L, 8);
          lua_call(L, 1, 1);
          lua_pushvalue(L, 13);
          lua_call(L, 3, 1);
          lua_replace(L, 11);
          assert(lua_gettop(L) == 13);

          /* e=i(e) */
          lc_getupvalue(L, lc284, 1, 90);
          lua_pushvalue(L, 8);
          lua_call(L, 1, 1);
          lua_replace(L, 8);
          assert(lua_gettop(L) == 13);
        } else {

          /* else
           * return d() */
          const int lc322 = lua_gettop(L);
          lua_pushvalue(L, 5);
          lua_call(L, 0, LUA_MULTRET);
          return (lua_gettop(L) - lc322);
          assert(lua_gettop(L) == 12);
        }
        lua_settop(L, lc318);
        assert(lua_gettop(L) == 12);
      } else {

        /* else
         * return d() */
        const int lc323 = lua_gettop(L);
        lua_pushvalue(L, 5);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc323);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L, lc316);
    }
    lua_settop(L, lc311);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L, lc310);
  assert(lua_gettop(L) == 12);

  /* if#n~=t then */
  enum { lc324 = 12 };
  lc_getupvalue(L, lc284, 0, 130);
  const double lc325 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc325);
  const int lc326 = lua_equal(L, -1, 12);
  lua_pop(L, 1);
  lua_pushboolean(L, lc326);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc327 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc327) {

    /* return d() */
    const int lc328 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc328);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L, lc324);
  assert(lua_gettop(L) == 12);

  /* return S(r,l) */
  const int lc329 = lua_gettop(L);
  lc_getupvalue(L, lc284, 1, 77);
  lua_pushvalue(L, 11);
  lua_pushvalue(L, 10);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc329);
  assert(lua_gettop(L) == 12);
}

/* name: a
 * function() */
static inline int lcf2_a(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return L(z,e(J,e(i,_(t)))) */
  const int lc331 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 83);
  const int lc332 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 54);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc333 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 32);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc334 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 131);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 28);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 132);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc334), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc333), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc332), LUA_MULTRET);
  return (lua_gettop(L) - lc331);
  assert(lua_gettop(L) == 0);
}

/* name: Ze
 * function(i,t,o) */
static inline int lcf1_Ze(lua_State *L) {
  lua_checkstack(L, 20);
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc330 = 4 };
  assert((lua_gettop(L) == lc330));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 131);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 132);

  /* local function a()return L(z,e(J,e(i,_(t))))end */
  lua_pushvalue(L, lc330);
  lua_pushcclosure(L, lcf2_a, 1);
  assert(lua_gettop(L) == 5);

  /* for n,e in ipairs(at)do
   * internal: local f, s, var = explist */
  enum { lc335 = 5 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lc_getupvalue(L, lc330, 1, 10);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local n with idx 9
     * internal: local e with idx 10 */

    /* if l(i,e[1]) then */
    enum { lc336 = 10 };
    lc_getupvalue(L, lc330, 1, 4);
    lc_getupvalue(L, lc330, 0, 131);
    lua_pushnumber(L, 1);
    lua_gettable(L, 10);
    lua_call(L, 2, 1);
    const int lc337 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc337) {

      /* if#t~=e[2] then */
      enum { lc338 = 10 };
      lc_getupvalue(L, lc330, 0, 132);
      const double lc339 = lua_objlen(L, -1);
      lua_pop(L, 1);
      lua_pushnumber(L, lc339);
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      const int lc340 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc340);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc341 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc341) {

        /* return a() */
        const int lc342 = lua_gettop(L);
        lua_pushvalue(L, 5);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc342);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L, lc338);
      assert(lua_gettop(L) == 10);

      /* if e[2]==1 then */
      enum { lc343 = 10 };
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      lua_pushnumber(L, 1);
      const int lc344 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc344);
      const int lc345 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc345) {

        /* return e[3](t[1],a,o) */
        const int lc346 = lua_gettop(L);
        lua_pushnumber(L, 3);
        lua_gettable(L, 10);
        lc_getupvalue(L, lc330, 0, 132);
        lua_pushnumber(L, 1);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_pushvalue(L, 5);
        lua_pushvalue(L, 3);
        lua_call(L, 3, LUA_MULTRET);
        return (lua_gettop(L) - lc346);
        assert(lua_gettop(L) == 10);
      } else {

        /* elseif e[2]==2 then */
        enum { lc347 = 10 };
        lua_pushnumber(L, 2);
        lua_gettable(L, 10);
        lua_pushnumber(L, 2);
        const int lc348 = lua_equal(L, -2, -1);
        lua_pop(L, 2);
        lua_pushboolean(L, lc348);
        const int lc349 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc349) {

          /* return e[3](t[1],t[2],a,o) */
          const int lc350 = lua_gettop(L);
          lua_pushnumber(L, 3);
          lua_gettable(L, 10);
          lc_getupvalue(L, lc330, 0, 132);
          lua_pushnumber(L, 1);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          lc_getupvalue(L, lc330, 0, 132);
          lua_pushnumber(L, 2);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          lua_pushvalue(L, 5);
          lua_pushvalue(L, 3);
          lua_call(L, 4, LUA_MULTRET);
          return (lua_gettop(L) - lc350);
          assert(lua_gettop(L) == 10);
        } else {

          /* elseif e[2]==3 then */
          enum { lc351 = 10 };
          lua_pushnumber(L, 2);
          lua_gettable(L, 10);
          lua_pushnumber(L, 3);
          const int lc352 = lua_equal(L, -2, -1);
          lua_pop(L, 2);
          lua_pushboolean(L, lc352);
          const int lc353 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc353) {

            /* return e[3](t[1],t[2],t[3],a,o) */
            const int lc354 = lua_gettop(L);
            lua_pushnumber(L, 3);
            lua_gettable(L, 10);
            lc_getupvalue(L, lc330, 0, 132);
            lua_pushnumber(L, 1);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lc_getupvalue(L, lc330, 0, 132);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lc_getupvalue(L, lc330, 0, 132);
            lua_pushnumber(L, 3);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lua_pushvalue(L, 5);
            lua_pushvalue(L, 3);
            lua_call(L, 5, LUA_MULTRET);
            return (lua_gettop(L) - lc354);
            assert(lua_gettop(L) == 10);
          }
          lua_settop(L, lc351);
        }
        lua_settop(L, lc347);
      }
      lua_settop(L, lc343);
      assert(lua_gettop(L) == 10);

      /* return j() */
      const int lc355 = lua_gettop(L);
      lc_getupvalue(L, lc330, 1, 117);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc355);
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L, lc336);
    assert(lua_gettop(L) == 10);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 2);
  }
  lua_settop(L, lc335);
  assert(lua_gettop(L) == 5);

  /* return a() */
  const int lc356 = lua_gettop(L);
  lua_pushvalue(L, 5);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc356);
  assert(lua_gettop(L) == 5);
}

/* name: a
 * function() */
static inline int lcf3_a(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return L(z,e(ie,e(R(i),o,_(t)))) */
  const int lc358 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 83);
  const int lc359 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 54);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc360 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 31);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 27);
  const int lc361 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 15);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 133);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 134);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 28);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 135);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc361), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc360), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc359), LUA_MULTRET);
  return (lua_gettop(L) - lc358);
  assert(lua_gettop(L) == 0);
}

/* name: Xe
 * function(i,o,t,a) */
static inline int lcf1_Xe(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc357 = 5 };
  assert((lua_gettop(L) == lc357));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 133);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 134);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 135);

  /* local function a()return L(z,e(ie,e(R(i),o,_(t))))end */
  lua_pushvalue(L, lc357);
  lua_pushcclosure(L, lcf3_a, 1);
  assert(lua_gettop(L) == 6);

  /* if l(o,ke) then */
  enum { lc362 = 6 };
  lc_getupvalue(L, lc357, 1, 4);
  lc_getupvalue(L, lc357, 0, 134);
  lc_getupvalue(L, lc357, 1, 34);
  lua_call(L, 2, 1);
  const int lc363 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc363) {

    /* if#t~=1 then */
    enum { lc364 = 6 };
    lc_getupvalue(L, lc357, 0, 135);
    const double lc365 = lua_objlen(L, -1);
    lua_pop(L, 1);
    lua_pushnumber(L, lc365);
    lua_pushnumber(L, 1);
    const int lc366 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc366);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc367 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc367) {

      /* return a() */
      const int lc368 = lua_gettop(L);
      lua_pushvalue(L, 6);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc368);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L, lc364);
    assert(lua_gettop(L) == 6);

    /* return t[1] */
    lc_getupvalue(L, lc357, 0, 135);
    lua_pushnumber(L, 1);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    return 1;
    assert(lua_gettop(L) == 6);
  } else {

    /* elseif l(o,st) then */
    enum { lc369 = 6 };
    lc_getupvalue(L, lc357, 1, 4);
    lc_getupvalue(L, lc357, 0, 134);
    lc_getupvalue(L, lc357, 1, 33);
    lua_call(L, 2, 1);
    const int lc370 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc370) {

      /* if#t~=2 then */
      enum { lc371 = 6 };
      lc_getupvalue(L, lc357, 0, 135);
      const double lc372 = lua_objlen(L, -1);
      lua_pop(L, 1);
      lua_pushnumber(L, lc372);
      lua_pushnumber(L, 2);
      const int lc373 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc373);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc374 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc374) {

        /* return a() */
        const int lc375 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc375);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L, lc371);
      assert(lua_gettop(L) == 6);

      /* return Je(i,t[1],t[2],a) */
      const int lc376 = lua_gettop(L);
      lc_getupvalue(L, lc357, 1, 5);
      lc_getupvalue(L, lc357, 0, 133);
      lc_getupvalue(L, lc357, 0, 135);
      lua_pushnumber(L, 1);
      lua_gettable(L, -2);
      lua_remove(L, -2);
      lc_getupvalue(L, lc357, 0, 135);
      lua_pushnumber(L, 2);
      lua_gettable(L, -2);
      lua_remove(L, -2);
      lua_pushvalue(L, 6);
      lua_call(L, 4, LUA_MULTRET);
      return (lua_gettop(L) - lc376);
      assert(lua_gettop(L) == 6);
    } else {

      /* elseif l(o,tt) then */
      enum { lc377 = 6 };
      lc_getupvalue(L, lc357, 1, 4);
      lc_getupvalue(L, lc357, 0, 134);
      lc_getupvalue(L, lc357, 1, 29);
      lua_call(L, 2, 1);
      const int lc378 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc378) {

        /* if#t~=2 then */
        enum { lc379 = 6 };
        lc_getupvalue(L, lc357, 0, 135);
        const double lc380 = lua_objlen(L, -1);
        lua_pop(L, 1);
        lua_pushnumber(L, lc380);
        lua_pushnumber(L, 2);
        const int lc381 = lua_equal(L, -2, -1);
        lua_pop(L, 2);
        lua_pushboolean(L, lc381);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc382 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc382) {

          /* return a() */
          const int lc383 = lua_gettop(L);
          lua_pushvalue(L, 6);
          lua_call(L, 0, LUA_MULTRET);
          return (lua_gettop(L) - lc383);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L, lc379);
        assert(lua_gettop(L) == 6);

        /* return fe(t[1],S(i,t[2])) */
        const int lc384 = lua_gettop(L);
        lc_getupvalue(L, lc357, 1, 102);
        const int lc385 = lua_gettop(L);
        lc_getupvalue(L, lc357, 0, 135);
        lua_pushnumber(L, 1);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lc_getupvalue(L, lc357, 1, 77);
        lc_getupvalue(L, lc357, 0, 133);
        lc_getupvalue(L, lc357, 0, 135);
        lua_pushnumber(L, 2);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc385), LUA_MULTRET);
        return (lua_gettop(L) - lc384);
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L, lc377);
    }
    lua_settop(L, lc369);
  }
  lua_settop(L, lc362);
  assert(lua_gettop(L) == 6);

  /* return a() */
  const int lc386 = lua_gettop(L);
  lua_pushvalue(L, 6);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc386);
  assert(lua_gettop(L) == 6);
}

/* name: ce
 * function(t) */
static inline int lcf1_ce(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e(ie,ke,t) */
  const int lc387 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 31);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 34);
  lua_pushvalue(L, 1);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc387);
  assert(lua_gettop(L) == 1);
}

/* function(t,e) */
static inline int lcf403(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* do
   * local e=0 */
  lua_pushnumber(L, 0);
  assert(lua_gettop(L) == 3);

  /* while e<#r do */
  enum { lc398 = 3 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 1, 136);
    const double lc399 = lua_objlen(L, -1);
    lua_pop(L, 1);
    lua_pushnumber(L, lc399);
    const int lc400 = lua_lessthan(L, 3, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc400);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if l(r[e+1],t) then */
    enum { lc401 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 2, 4);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 136);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_call(L, 2, 1);
    const int lc402 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc402) {

      /* return */
      return 0;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L, lc401);
    assert(lua_gettop(L) == 3);

    /* e=e+1 */
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc398);
  assert(lua_gettop(L) == 3);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 2);

  /* v(a,t) */
  lc_getupvalue(L, lua_upvalueindex(1), 4, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 137);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: Je
 * function(m,d,f,w) */
static inline int lcf1_Je(lua_State *L) {
  lua_checkstack(L, 22);
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* d=W(d) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 60);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  assert(lua_gettop(L) == 4);

  /* local r={} */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc388 = 5 };
  assert((lua_gettop(L) == lc388));
  lua_newtable(L);
  lua_rawseti(L, lc388, 136);
  assert(lua_gettop(L) == 5);

  /* local c=false */
  lua_pushboolean(L, 0);
  assert(lua_gettop(L) == 6);

  /* local n=d */
  lua_pushvalue(L, 2);
  assert(lua_gettop(L) == 7);

  /* while not h(n)do */
  enum { lc389 = 7 };
  while (1) {
    lc_getupvalue(L, lc388, 1, 88);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if u(n) then */
    enum { lc390 = 7 };
    lc_getupvalue(L, lc388, 1, 11);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    const int lc391 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc391) {

      /* v(r,n) */
      lc_getupvalue(L, lc388, 3, 1);
      lc_getupvalue(L, lc388, 0, 136);
      lua_pushvalue(L, 7);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 7);

      /* c=true */
      lua_pushboolean(L, 1);
      lua_replace(L, 6);
      assert(lua_gettop(L) == 7);

      /* n=y */
      lc_getupvalue(L, lc388, 1, 89);
      lua_replace(L, 7);
      assert(lua_gettop(L) == 7);
    } else {

      /* elseif a(n) then */
      enum { lc392 = 7 };
      lc_getupvalue(L, lc388, 1, 92);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc393 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc393) {

        /* v(r,o(n)) */
        lc_getupvalue(L, lc388, 3, 1);
        const int lc394 = lua_gettop(L);
        lc_getupvalue(L, lc388, 0, 136);
        lc_getupvalue(L, lc388, 1, 91);
        lua_pushvalue(L, 7);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc394), 0);
        assert(lua_gettop(L) == 7);

        /* n=i(n) */
        lc_getupvalue(L, lc388, 1, 90);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        lua_replace(L, 7);
        assert(lua_gettop(L) == 7);
      } else {

        /* else
         * return w() */
        const int lc395 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc395);
        assert(lua_gettop(L) == 7);
      }
      lua_settop(L, lc392);
    }
    lua_settop(L, lc390);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L, lc389);
  assert(lua_gettop(L) == 7);

  /* local o */
  lua_settop(L, (lua_gettop(L) + 1));
  assert(lua_gettop(L) == 8);

  /* if c then */
  enum { lc396 = 8 };
  if (lua_toboolean(L, 6)) {

    /* o=_(r) */
    lc_getupvalue(L, lc388, 1, 28);
    lc_getupvalue(L, lc388, 0, 136);
    lua_call(L, 1, 1);
    lua_replace(L, 8);
    assert(lua_gettop(L) == 8);
  } else {

    /* else
     * o=d */
    lua_pushvalue(L, 2);
    lua_replace(L, 8);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L, lc396);
  assert(lua_gettop(L) == 8);

  /* local a={} */
  lc_newclosuretable(L, lc388);
  enum { lc397 = 9 };
  assert((lua_gettop(L) == lc397));
  lua_newtable(L);
  lua_rawseti(L, lc397, 137);
  assert(lua_gettop(L) == 9);

  /* Ke(m,function(t,e)
   * do
   * local e=0
   * while e<#r do
   * if l(r[e+1],t)then
   * return
   * end
   * e=e+1
   * end
   * end
   * v(a,t)
   * end) */
  lc_getupvalue(L, lc397, 2, 14);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, lc397);
  lua_pushcclosure(L, lcf403, 1);
  lua_call(L, 2, 0);
  assert(lua_gettop(L) == 9);

  /* local i=o */
  lua_pushvalue(L, 8);
  assert(lua_gettop(L) == 10);

  /* do
   * local e=#a-1 */
  lc_getupvalue(L, lc397, 0, 137);
  const double lc404 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc404);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  assert(lua_gettop(L) == 11);

  /* while e>=0 do */
  enum { lc405 = 11 };
  while (1) {
    lua_pushnumber(L, 0);
    const int lc406 = lc_le(L, -1, 11);
    lua_pop(L, 1);
    lua_pushboolean(L, lc406);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* i=s(a[e+1],i) */
    lc_getupvalue(L, lc397, 2, 93);
    lc_getupvalue(L, lc397, 0, 137);
    lua_pushnumber(L, 1);
    lc_add(L, 11, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 10);
    lua_call(L, 2, 1);
    lua_replace(L, 10);
    assert(lua_gettop(L) == 11);

    /* e=e-1 */
    lua_pushnumber(L, 1);
    lc_sub(L, 11, -1);
    lua_remove(L, -2);
    lua_replace(L, 11);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L, lc405);
  assert(lua_gettop(L) == 11);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 10);

  /* local o=o */
  lua_pushvalue(L, 8);
  assert(lua_gettop(L) == 11);

  /* do
   * local e=#a-1 */
  lc_getupvalue(L, lc397, 0, 137);
  const double lc407 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc407);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  assert(lua_gettop(L) == 12);

  /* while e>=0 do */
  enum { lc408 = 12 };
  while (1) {
    lua_pushnumber(L, 0);
    const int lc409 = lc_le(L, -1, 12);
    lua_pop(L, 1);
    lua_pushboolean(L, lc409);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* o=s(ce(et(m,a[e+1])),o) */
    lc_getupvalue(L, lc397, 2, 93);
    lc_getupvalue(L, lc397, 2, 6);
    const int lc410 = lua_gettop(L);
    lc_getupvalue(L, lc397, 2, 16);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, lc397, 0, 137);
    lua_pushnumber(L, 1);
    lc_add(L, 12, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_call(L, 2, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc410), 1);
    lua_pushvalue(L, 11);
    lua_call(L, 2, 1);
    lua_replace(L, 11);
    assert(lua_gettop(L) == 12);

    /* e=e-1 */
    lua_pushnumber(L, 1);
    lc_sub(L, 12, -1);
    lua_remove(L, -2);
    lua_replace(L, 12);
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L, lc408);
  assert(lua_gettop(L) == 12);

  /* internal: stack cleanup on scope exit */
  lua_pop(L, 1);
  assert(lua_gettop(L) == 11);

  /* return T(t,e(d,s(ce(T(t,e(i,f))),o))) */
  const int lc411 = lua_gettop(L);
  lc_getupvalue(L, lc397, 2, 87);
  const int lc412 = lua_gettop(L);
  lc_getupvalue(L, lc397, 2, 53);
  lc_getupvalue(L, lc397, 2, 27);
  const int lc413 = lua_gettop(L);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, lc397, 2, 93);
  lc_getupvalue(L, lc397, 2, 6);
  const int lc414 = lua_gettop(L);
  lc_getupvalue(L, lc397, 2, 87);
  const int lc415 = lua_gettop(L);
  lc_getupvalue(L, lc397, 2, 53);
  lc_getupvalue(L, lc397, 2, 27);
  lua_pushvalue(L, 10);
  lua_pushvalue(L, 3);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc415), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc414), 1);
  lua_pushvalue(L, 11);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc413), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc412), LUA_MULTRET);
  return (lua_gettop(L) - lc411);
  assert(lua_gettop(L) == 11);
}

/* name: n
 * function(t,e,o,a) */
static inline int lcf2_n(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* if l(o(t),o(e))and l(a(t),a(e)) then */
  enum { lc422 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 4);
  const int lc423 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc423), 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 4);
    const int lc424 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc424), 1);
  }
  const int lc425 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc425) {

    /* O(t,e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 4);

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 4);
  } else {

    /* else
     * return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc422);
  assert(lua_gettop(L) == 4);
  return 0;
}

/* name: l
 * function(e,t) */
static inline int lcf1_l(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* if e==t then */
  enum { lc416 = 2 };
  const int lc417 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc417);
  const int lc418 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc418) {

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc416);
  assert(lua_gettop(L) == 2);

  /* e=r(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 21);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 2);

  /* t=r(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 21);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  assert(lua_gettop(L) == 2);

  /* if e==t then */
  enum { lc419 = 2 };
  const int lc420 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc420);
  const int lc421 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc421) {

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc419);
  assert(lua_gettop(L) == 2);

  /* local function n(t,e,o,a)
   * if l(o(t),o(e))and l(a(t),a(e))then
   * O(t,e)
   * return true
   * else
   * return false
   * end
   * end */
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf2_n, 1);
  assert(lua_gettop(L) == 3);

  /* if h(e) then */
  enum { lc426 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc427 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc427) {

    /* if not h(t) then */
    enum { lc428 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 88);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc429 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc429) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L, lc428);
    assert(lua_gettop(L) == 3);

    /* O(e,y) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 89);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* O(t,y) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 57);
    lua_pushvalue(L, 2);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 89);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif p(e) then */
    enum { lc430 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc431 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc431) {

      /* if not p(t) then */
      enum { lc432 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 97);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc433 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc433) {

        /* return false */
        lua_pushboolean(L, 0);
        return 1;
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc432);
      assert(lua_gettop(L) == 3);

      /* return D(e,t) */
      const int lc434 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 94);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 2);
      lua_call(L, 2, LUA_MULTRET);
      return (lua_gettop(L) - lc434);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif a(e) then */
      enum { lc435 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc436 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc436) {

        /* if not a(t) then */
        enum { lc437 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc438 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc438) {

          /* return false */
          lua_pushboolean(L, 0);
          return 1;
          assert(lua_gettop(L) == 3);
        }
        lua_settop(L, lc437);
        assert(lua_gettop(L) == 3);

        /* return n(e,t,o,i) */
        const int lc439 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 91);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 90);
        lua_call(L, 4, LUA_MULTRET);
        return (lua_gettop(L) - lc439);
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif g(e) then */
        enum { lc440 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 82);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc441 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc441) {

          /* if not g(t) then */
          enum { lc442 = 3 };
          lc_getupvalue(L, lua_upvalueindex(1), 0, 82);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc443 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc443) {

            /* return false */
            lua_pushboolean(L, 0);
            return 1;
            assert(lua_gettop(L) == 3);
          }
          lua_settop(L, lc442);
          assert(lua_gettop(L) == 3);

          /* return n(e,t,C,U) */
          const int lc444 = lua_gettop(L);
          lua_pushvalue(L, 3);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 81);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 80);
          lua_call(L, 4, LUA_MULTRET);
          return (lua_gettop(L) - lc444);
          assert(lua_gettop(L) == 3);
        } else {

          /* elseif c(e) then */
          enum { lc445 = 3 };
          lc_getupvalue(L, lua_upvalueindex(1), 0, 86);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc446 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc446) {

            /* if not c(t) then */
            enum { lc447 = 3 };
            lc_getupvalue(L, lua_upvalueindex(1), 0, 86);
            lua_pushvalue(L, 2);
            lua_call(L, 1, 1);
            lua_pushboolean(L, !(lua_toboolean(L, -1)));
            lua_remove(L, -2);
            const int lc448 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc448) {

              /* return false */
              lua_pushboolean(L, 0);
              return 1;
              assert(lua_gettop(L) == 3);
            }
            lua_settop(L, lc447);
            assert(lua_gettop(L) == 3);

            /* return n(e,t,E,A) */
            const int lc449 = lua_gettop(L);
            lua_pushvalue(L, 3);
            lua_pushvalue(L, 1);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, lua_upvalueindex(1), 0, 85);
            lc_getupvalue(L, lua_upvalueindex(1), 0, 84);
            lua_call(L, 4, LUA_MULTRET);
            return (lua_gettop(L) - lc449);
            assert(lua_gettop(L) == 3);
          }
          lua_settop(L, lc445);
        }
        lua_settop(L, lc440);
      }
      lua_settop(L, lc435);
    }
    lua_settop(L, lc430);
  }
  lua_settop(L, lc426);
  assert(lua_gettop(L) == 3);

  /* return j() */
  const int lc450 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc450);
  assert(lua_gettop(L) == 3);
}

/* name: f
 * function(e) */
static inline int lcf1_f(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* e=N(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 1);

  /* local t="" */
  lua_pushliteral(L, "");
  assert(lua_gettop(L) == 2);

  /* local n="" */
  lua_pushliteral(L, "");
  assert(lua_gettop(L) == 3);

  /* if h(e) then */
  enum { lc451 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc452 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc452) {

    /* return"()" */
    lua_pushliteral(L, "()");
    return 1;
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif a(e) then */
    enum { lc453 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc454 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc454) {

      /* t="(" */
      lua_pushliteral(L, "(");
      lua_replace(L, 2);
      assert(lua_gettop(L) == 3);

      /* n="" */
      lua_pushliteral(L, "");
      lua_replace(L, 3);
      assert(lua_gettop(L) == 3);

      /* while a(e)do */
      enum { lc455 = 3 };
      while (1) {
        lc_getupvalue(L, lua_upvalueindex(1), 0, 92);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* t=tostring(t)..tostring(n)..tostring(f(o(e))) */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc456 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
        const int lc457 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 91);
        lua_pushvalue(L, 1);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc457), LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc456), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 2);
        assert(lua_gettop(L) == 3);

        /* n=" " */
        lua_pushliteral(L, " ");
        lua_replace(L, 3);
        assert(lua_gettop(L) == 3);

        /* e=N(i(e)) */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 26);
        const int lc458 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 90);
        lua_pushvalue(L, 1);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc458), 1);
        lua_replace(L, 1);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc455);
      assert(lua_gettop(L) == 3);

      /* if h(e) then */
      enum { lc459 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 88);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc460 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc460) {

        /* t=tostring(t)..")" */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushliteral(L, ")");
        lua_concat(L, 2);
        lua_replace(L, 2);
        assert(lua_gettop(L) == 3);
      } else {

        /* else
         * t=tostring(t).." . "..tostring(f(e))..")" */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushliteral(L, " . ");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc461 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
        lua_pushvalue(L, 1);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc461), 1);
        lua_pushliteral(L, ")");
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 2);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc459);
      assert(lua_gettop(L) == 3);

      /* return t */
      lua_pushvalue(L, 2);
      return 1;
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif c(e) then */
      enum { lc462 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 0, 86);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc463 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc463) {

        /* return"#"..tostring(f(s(E(e),A(e)))) */
        lua_pushliteral(L, "#");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc464 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
        const int lc465 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 93);
        const int lc466 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 85);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        lc_getupvalue(L, lua_upvalueindex(1), 0, 84);
        lua_pushvalue(L, 1);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc466), LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc465), LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc464), 1);
        lua_concat(L, 2);
        return 1;
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif g(e) then */
        enum { lc467 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 0, 82);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc468 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc468) {

          /* return"!"..tostring(f(s(C(e),U(e)))) */
          lua_pushliteral(L, "!");
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc469 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
          const int lc470 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 93);
          const int lc471 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 81);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 80);
          lua_pushvalue(L, 1);
          lua_call(L, 1, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc471), LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc470), LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc469), 1);
          lua_concat(L, 2);
          return 1;
          assert(lua_gettop(L) == 3);
        } else {

          /* elseif p(e) then */
          enum { lc472 = 3 };
          lc_getupvalue(L, lua_upvalueindex(1), 0, 97);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc473 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc473) {

            /* return de(e) */
            const int lc474 = lua_gettop(L);
            lc_getupvalue(L, lua_upvalueindex(1), 0, 95);
            lua_pushvalue(L, 1);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc474);
            assert(lua_gettop(L) == 3);
          } else {

            /* elseif I(e) then */
            enum { lc475 = 3 };
            lc_getupvalue(L, lua_upvalueindex(1), 0, 101);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 1);
            const int lc476 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc476) {

              /* return";("..tostring(f(oe(e))).." "..tostring(f(K(e)))..")" */
              lua_pushliteral(L, ";(");
              lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
              const int lc477 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
              const int lc478 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 0, 100);
              lua_pushvalue(L, 1);
              lua_call(L, 1, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc478), LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc477), 1);
              lua_pushliteral(L, " ");
              lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
              const int lc479 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
              const int lc480 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 0, 99);
              lua_pushvalue(L, 1);
              lua_call(L, 1, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc480), LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc479), 1);
              lua_pushliteral(L, ")");
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              return 1;
              assert(lua_gettop(L) == 3);
            } else {

              /* elseif Q(e) then */
              enum { lc481 = 3 };
              lc_getupvalue(L, lua_upvalueindex(1), 0, 76);
              lua_pushvalue(L, 1);
              lua_call(L, 1, 1);
              const int lc482 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc482) {

                /* return"$("..tostring(f(R(X(e)))).." "..tostring(f(Z(e)))..")"
                 */
                lua_pushliteral(L, "$(");
                lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                const int lc483 = lua_gettop(L);
                lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                const int lc484 = lua_gettop(L);
                lc_getupvalue(L, lua_upvalueindex(1), 0, 15);
                const int lc485 = lua_gettop(L);
                lc_getupvalue(L, lua_upvalueindex(1), 0, 75);
                lua_pushvalue(L, 1);
                lua_call(L, 1, LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc485), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc484), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc483), 1);
                lua_pushliteral(L, " ");
                lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                const int lc486 = lua_gettop(L);
                lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                const int lc487 = lua_gettop(L);
                lc_getupvalue(L, lua_upvalueindex(1), 0, 74);
                lua_pushvalue(L, 1);
                lua_call(L, 1, LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc487), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc486), 1);
                lua_pushliteral(L, ")");
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                return 1;
                assert(lua_gettop(L) == 3);
              } else {

                /* elseif P(e) then */
                enum { lc488 = 3 };
                lc_getupvalue(L, lua_upvalueindex(1), 0, 67);
                lua_pushvalue(L, 1);
                lua_call(L, 1, 1);
                const int lc489 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc489) {

                  /* return"%("..tostring(f(ue(e))).."
                   * "..tostring(f(_(re(e))))..")" */
                  lua_pushliteral(L, "%(");
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  const int lc490 = lua_gettop(L);
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                  const int lc491 = lua_gettop(L);
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 66);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc491), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc490), 1);
                  lua_pushliteral(L, " ");
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  const int lc492 = lua_gettop(L);
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                  const int lc493 = lua_gettop(L);
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 28);
                  const int lc494 = lua_gettop(L);
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 65);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc494), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc493), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc492), 1);
                  lua_pushliteral(L, ")");
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  return 1;
                  assert(lua_gettop(L) == 3);
                } else {

                  /* elseif G(e) then */
                  enum { lc495 = 3 };
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 72);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, 1);
                  const int lc496 = lua_toboolean(L, -1);
                  lua_pop(L, 1);
                  if (lc496) {

                    /* return"@("..tostring(f(R(_e(e)))).."
                     * "..tostring(f(Te(e))).." "..tostring(f(_(ze(e))))..")" */
                    lua_pushliteral(L, "@(");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc497 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                    const int lc498 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 15);
                    const int lc499 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 71);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc499), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc498), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc497), 1);
                    lua_pushliteral(L, " ");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc500 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                    const int lc501 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 70);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc501), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc500), 1);
                    lua_pushliteral(L, " ");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc502 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                    const int lc503 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 28);
                    const int lc504 = lua_gettop(L);
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 69);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc504), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc503), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc502), 1);
                    lua_pushliteral(L, ")");
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    return 1;
                    assert(lua_gettop(L) == 3);
                  } else {

                    /* elseif V(e) then */
                    enum { lc505 = 3 };
                    lc_getupvalue(L, lua_upvalueindex(1), 0, 63);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, 1);
                    const int lc506 = lua_toboolean(L, -1);
                    lua_pop(L, 1);
                    if (lc506) {

                      /* return"^("..tostring(f(je(e))).."
                       * "..tostring(f(_(xe(e))))..")" */
                      lua_pushliteral(L, "^(");
                      lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                      const int lc507 = lua_gettop(L);
                      lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                      const int lc508 = lua_gettop(L);
                      lc_getupvalue(L, lua_upvalueindex(1), 0, 62);
                      lua_pushvalue(L, 1);
                      lua_call(L, 1, LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc508), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc507), 1);
                      lua_pushliteral(L, " ");
                      lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                      const int lc509 = lua_gettop(L);
                      lc_getupvalue(L, lua_upvalueindex(1), 0, 3);
                      const int lc510 = lua_gettop(L);
                      lc_getupvalue(L, lua_upvalueindex(1), 0, 28);
                      const int lc511 = lua_gettop(L);
                      lc_getupvalue(L, lua_upvalueindex(1), 0, 61);
                      lua_pushvalue(L, 1);
                      lua_call(L, 1, LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc511), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc510), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc509), 1);
                      lua_pushliteral(L, ")");
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      return 1;
                      assert(lua_gettop(L) == 3);
                    }
                    lua_settop(L, lc505);
                  }
                  lua_settop(L, lc495);
                }
                lua_settop(L, lc488);
              }
              lua_settop(L, lc481);
            }
            lua_settop(L, lc475);
          }
          lua_settop(L, lc472);
        }
        lua_settop(L, lc467);
      }
      lua_settop(L, lc462);
    }
    lua_settop(L, lc453);
  }
  lua_settop(L, lc451);
  assert(lua_gettop(L) == 3);

  /* return j() */
  const int lc512 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc512);
  assert(lua_gettop(L) == 3);
}

/* name: n
 * function() */
static inline int lcf3_n(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return{
   * ["0"]="0",
   * ["1"]="1",
   * ["2"]="2",
   * ["3"]="3",
   * ["4"]="4",
   * ["5"]="5",
   * ["6"]="6",
   * ["7"]="7",
   * ["8"]="8",
   * ["9"]="9",
   * A="A",
   * B="B",
   * C="C",
   * D="D",
   * E="E",
   * F="F",
   * G="G",
   * H="H",
   * I="I",
   * J="J",
   * K="K",
   * L="L",
   * M="M",
   * N="N",
   * O="O",
   * P="P",
   * Q="Q",
   * R="R",
   * S="S",
   * T="T",
   * U="U",
   * V="V",
   * W="W",
   * X="X",
   * Y="Y",
   * Z="Z",
   * a="a",
   * b="b",
   * c="c",
   * d="d",
   * e="e",
   * f="f",
   * g="g",
   * h="h",
   * i="i",
   * j="j",
   * k="k",
   * l="l",
   * m="m",
   * n="n",
   * o="o",
   * p="p",
   * q="q",
   * r="r",
   * s="s",
   * t="t",
   * u="u",
   * v="v",
   * w="w",
   * x="x",
   * y="y",
   * z="z",
   * ["一類何物"]="㝉",
   * ["之物"]="𫙦",
   * ["其子"]="𦮪",
   * ["出入改滅"]="𢒟",
   * ["列序"]="𠜺",
   * ["化滅"]="𠏁",
   * ["參形"]="𠫰",
   * ["吾自"]="𦣹",
   * ["太始初核"]="𣝗",
   * ["如若"]="𦱡",
   * ["宇宙亡矣"]="𨹹",
   * ["尾末"]="𡲵",
   * ["序丁"]="𠆤",
   * ["序丙"]="𠇮",
   * ["序乙"]="㐈",
   * ["序甲"]="𠇚",
   * ["式形"]="佱",
   * ["引用"]="㧈",
   * ["應用"]="𤰆",
   * ["效應"]="効",
   * ["映表"]="𤅔",
   * ["是非"]="欤",
   * ["構物"]="𡒫",
   * ["為符名連"]="‐",
   * ["爻陰"]="侌",
   * ["爻陽"]="𣆄",
   * ["特定其物"]="亓",
   * ["省略一物"]="畧",
   * ["符名"]="謼",
   * ["等同"]="弌",
   * ["解算"]="筭",
   * ["註疏"]="疎",
   * ["詞素"]="𧥝",
   * ["謬誤"]="䥘",
   * ["連頸"]="丩",
   * ["間空"]="𣣓",
   * ["首始"]="𩠐",
   * } */
  lua_createtable(L, 0, 99);
  lua_pushliteral(L, "0");
  lua_pushliteral(L, "0");
  lua_rawset(L, -3);
  lua_pushliteral(L, "1");
  lua_pushliteral(L, "1");
  lua_rawset(L, -3);
  lua_pushliteral(L, "2");
  lua_pushliteral(L, "2");
  lua_rawset(L, -3);
  lua_pushliteral(L, "3");
  lua_pushliteral(L, "3");
  lua_rawset(L, -3);
  lua_pushliteral(L, "4");
  lua_pushliteral(L, "4");
  lua_rawset(L, -3);
  lua_pushliteral(L, "5");
  lua_pushliteral(L, "5");
  lua_rawset(L, -3);
  lua_pushliteral(L, "6");
  lua_pushliteral(L, "6");
  lua_rawset(L, -3);
  lua_pushliteral(L, "7");
  lua_pushliteral(L, "7");
  lua_rawset(L, -3);
  lua_pushliteral(L, "8");
  lua_pushliteral(L, "8");
  lua_rawset(L, -3);
  lua_pushliteral(L, "9");
  lua_pushliteral(L, "9");
  lua_rawset(L, -3);
  lua_pushliteral(L, "A");
  lua_pushliteral(L, "A");
  lua_rawset(L, -3);
  lua_pushliteral(L, "B");
  lua_pushliteral(L, "B");
  lua_rawset(L, -3);
  lua_pushliteral(L, "C");
  lua_pushliteral(L, "C");
  lua_rawset(L, -3);
  lua_pushliteral(L, "D");
  lua_pushliteral(L, "D");
  lua_rawset(L, -3);
  lua_pushliteral(L, "E");
  lua_pushliteral(L, "E");
  lua_rawset(L, -3);
  lua_pushliteral(L, "F");
  lua_pushliteral(L, "F");
  lua_rawset(L, -3);
  lua_pushliteral(L, "G");
  lua_pushliteral(L, "G");
  lua_rawset(L, -3);
  lua_pushliteral(L, "H");
  lua_pushliteral(L, "H");
  lua_rawset(L, -3);
  lua_pushliteral(L, "I");
  lua_pushliteral(L, "I");
  lua_rawset(L, -3);
  lua_pushliteral(L, "J");
  lua_pushliteral(L, "J");
  lua_rawset(L, -3);
  lua_pushliteral(L, "K");
  lua_pushliteral(L, "K");
  lua_rawset(L, -3);
  lua_pushliteral(L, "L");
  lua_pushliteral(L, "L");
  lua_rawset(L, -3);
  lua_pushliteral(L, "M");
  lua_pushliteral(L, "M");
  lua_rawset(L, -3);
  lua_pushliteral(L, "N");
  lua_pushliteral(L, "N");
  lua_rawset(L, -3);
  lua_pushliteral(L, "O");
  lua_pushliteral(L, "O");
  lua_rawset(L, -3);
  lua_pushliteral(L, "P");
  lua_pushliteral(L, "P");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Q");
  lua_pushliteral(L, "Q");
  lua_rawset(L, -3);
  lua_pushliteral(L, "R");
  lua_pushliteral(L, "R");
  lua_rawset(L, -3);
  lua_pushliteral(L, "S");
  lua_pushliteral(L, "S");
  lua_rawset(L, -3);
  lua_pushliteral(L, "T");
  lua_pushliteral(L, "T");
  lua_rawset(L, -3);
  lua_pushliteral(L, "U");
  lua_pushliteral(L, "U");
  lua_rawset(L, -3);
  lua_pushliteral(L, "V");
  lua_pushliteral(L, "V");
  lua_rawset(L, -3);
  lua_pushliteral(L, "W");
  lua_pushliteral(L, "W");
  lua_rawset(L, -3);
  lua_pushliteral(L, "X");
  lua_pushliteral(L, "X");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Y");
  lua_pushliteral(L, "Y");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Z");
  lua_pushliteral(L, "Z");
  lua_rawset(L, -3);
  lua_pushliteral(L, "a");
  lua_pushliteral(L, "a");
  lua_rawset(L, -3);
  lua_pushliteral(L, "b");
  lua_pushliteral(L, "b");
  lua_rawset(L, -3);
  lua_pushliteral(L, "c");
  lua_pushliteral(L, "c");
  lua_rawset(L, -3);
  lua_pushliteral(L, "d");
  lua_pushliteral(L, "d");
  lua_rawset(L, -3);
  lua_pushliteral(L, "e");
  lua_pushliteral(L, "e");
  lua_rawset(L, -3);
  lua_pushliteral(L, "f");
  lua_pushliteral(L, "f");
  lua_rawset(L, -3);
  lua_pushliteral(L, "g");
  lua_pushliteral(L, "g");
  lua_rawset(L, -3);
  lua_pushliteral(L, "h");
  lua_pushliteral(L, "h");
  lua_rawset(L, -3);
  lua_pushliteral(L, "i");
  lua_pushliteral(L, "i");
  lua_rawset(L, -3);
  lua_pushliteral(L, "j");
  lua_pushliteral(L, "j");
  lua_rawset(L, -3);
  lua_pushliteral(L, "k");
  lua_pushliteral(L, "k");
  lua_rawset(L, -3);
  lua_pushliteral(L, "l");
  lua_pushliteral(L, "l");
  lua_rawset(L, -3);
  lua_pushliteral(L, "m");
  lua_pushliteral(L, "m");
  lua_rawset(L, -3);
  lua_pushliteral(L, "n");
  lua_pushliteral(L, "n");
  lua_rawset(L, -3);
  lua_pushliteral(L, "o");
  lua_pushliteral(L, "o");
  lua_rawset(L, -3);
  lua_pushliteral(L, "p");
  lua_pushliteral(L, "p");
  lua_rawset(L, -3);
  lua_pushliteral(L, "q");
  lua_pushliteral(L, "q");
  lua_rawset(L, -3);
  lua_pushliteral(L, "r");
  lua_pushliteral(L, "r");
  lua_rawset(L, -3);
  lua_pushliteral(L, "s");
  lua_pushliteral(L, "s");
  lua_rawset(L, -3);
  lua_pushliteral(L, "t");
  lua_pushliteral(L, "t");
  lua_rawset(L, -3);
  lua_pushliteral(L, "u");
  lua_pushliteral(L, "u");
  lua_rawset(L, -3);
  lua_pushliteral(L, "v");
  lua_pushliteral(L, "v");
  lua_rawset(L, -3);
  lua_pushliteral(L, "w");
  lua_pushliteral(L, "w");
  lua_rawset(L, -3);
  lua_pushliteral(L, "x");
  lua_pushliteral(L, "x");
  lua_rawset(L, -3);
  lua_pushliteral(L, "y");
  lua_pushliteral(L, "y");
  lua_rawset(L, -3);
  lua_pushliteral(L, "z");
  lua_pushliteral(L, "z");
  lua_rawset(L, -3);
  lua_pushliteral(L, "一類何物");
  lua_pushliteral(L, "㝉");
  lua_rawset(L, -3);
  lua_pushliteral(L, "之物");
  lua_pushliteral(L, "𫙦");
  lua_rawset(L, -3);
  lua_pushliteral(L, "其子");
  lua_pushliteral(L, "𦮪");
  lua_rawset(L, -3);
  lua_pushliteral(L, "出入改滅");
  lua_pushliteral(L, "𢒟");
  lua_rawset(L, -3);
  lua_pushliteral(L, "列序");
  lua_pushliteral(L, "𠜺");
  lua_rawset(L, -3);
  lua_pushliteral(L, "化滅");
  lua_pushliteral(L, "𠏁");
  lua_rawset(L, -3);
  lua_pushliteral(L, "參形");
  lua_pushliteral(L, "𠫰");
  lua_rawset(L, -3);
  lua_pushliteral(L, "吾自");
  lua_pushliteral(L, "𦣹");
  lua_rawset(L, -3);
  lua_pushliteral(L, "太始初核");
  lua_pushliteral(L, "𣝗");
  lua_rawset(L, -3);
  lua_pushliteral(L, "如若");
  lua_pushliteral(L, "𦱡");
  lua_rawset(L, -3);
  lua_pushliteral(L, "宇宙亡矣");
  lua_pushliteral(L, "𨹹");
  lua_rawset(L, -3);
  lua_pushliteral(L, "尾末");
  lua_pushliteral(L, "𡲵");
  lua_rawset(L, -3);
  lua_pushliteral(L, "序丁");
  lua_pushliteral(L, "𠆤");
  lua_rawset(L, -3);
  lua_pushliteral(L, "序丙");
  lua_pushliteral(L, "𠇮");
  lua_rawset(L, -3);
  lua_pushliteral(L, "序乙");
  lua_pushliteral(L, "㐈");
  lua_rawset(L, -3);
  lua_pushliteral(L, "序甲");
  lua_pushliteral(L, "𠇚");
  lua_rawset(L, -3);
  lua_pushliteral(L, "式形");
  lua_pushliteral(L, "佱");
  lua_rawset(L, -3);
  lua_pushliteral(L, "引用");
  lua_pushliteral(L, "㧈");
  lua_rawset(L, -3);
  lua_pushliteral(L, "應用");
  lua_pushliteral(L, "𤰆");
  lua_rawset(L, -3);
  lua_pushliteral(L, "效應");
  lua_pushliteral(L, "効");
  lua_rawset(L, -3);
  lua_pushliteral(L, "映表");
  lua_pushliteral(L, "𤅔");
  lua_rawset(L, -3);
  lua_pushliteral(L, "是非");
  lua_pushliteral(L, "欤");
  lua_rawset(L, -3);
  lua_pushliteral(L, "構物");
  lua_pushliteral(L, "𡒫");
  lua_rawset(L, -3);
  lua_pushliteral(L, "為符名連");
  lua_pushliteral(L, "‐");
  lua_rawset(L, -3);
  lua_pushliteral(L, "爻陰");
  lua_pushliteral(L, "侌");
  lua_rawset(L, -3);
  lua_pushliteral(L, "爻陽");
  lua_pushliteral(L, "𣆄");
  lua_rawset(L, -3);
  lua_pushliteral(L, "特定其物");
  lua_pushliteral(L, "亓");
  lua_rawset(L, -3);
  lua_pushliteral(L, "省略一物");
  lua_pushliteral(L, "畧");
  lua_rawset(L, -3);
  lua_pushliteral(L, "符名");
  lua_pushliteral(L, "謼");
  lua_rawset(L, -3);
  lua_pushliteral(L, "等同");
  lua_pushliteral(L, "弌");
  lua_rawset(L, -3);
  lua_pushliteral(L, "解算");
  lua_pushliteral(L, "筭");
  lua_rawset(L, -3);
  lua_pushliteral(L, "註疏");
  lua_pushliteral(L, "疎");
  lua_rawset(L, -3);
  lua_pushliteral(L, "詞素");
  lua_pushliteral(L, "𧥝");
  lua_rawset(L, -3);
  lua_pushliteral(L, "謬誤");
  lua_pushliteral(L, "䥘");
  lua_rawset(L, -3);
  lua_pushliteral(L, "連頸");
  lua_pushliteral(L, "丩");
  lua_rawset(L, -3);
  lua_pushliteral(L, "間空");
  lua_pushliteral(L, "𣣓");
  lua_rawset(L, -3);
  lua_pushliteral(L, "首始");
  lua_pushliteral(L, "𩠐");
  lua_rawset(L, -3);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: u
 * function() */
static inline int lcf2_u(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return{
   * ["0"]="0",
   * ["1"]="1",
   * ["2"]="2",
   * ["3"]="3",
   * ["4"]="4",
   * ["5"]="5",
   * ["6"]="6",
   * ["7"]="7",
   * ["8"]="8",
   * ["9"]="9",
   * A="A",
   * B="B",
   * C="C",
   * D="D",
   * E="E",
   * F="F",
   * G="G",
   * H="H",
   * I="I",
   * J="J",
   * K="K",
   * L="L",
   * M="M",
   * N="N",
   * O="O",
   * P="P",
   * Q="Q",
   * R="R",
   * S="S",
   * T="T",
   * U="U",
   * V="V",
   * W="W",
   * X="X",
   * Y="Y",
   * Z="Z",
   * a="a",
   * b="b",
   * c="c",
   * d="d",
   * e="e",
   * f="f",
   * g="g",
   * h="h",
   * i="i",
   * j="j",
   * k="k",
   * l="l",
   * m="m",
   * n="n",
   * o="o",
   * p="p",
   * q="q",
   * r="r",
   * s="s",
   * t="t",
   * u="u",
   * v="v",
   * w="w",
   * x="x",
   * y="y",
   * z="z",
   * ["㝉"]="一類何物",
   * ["𫙦"]="之物",
   * ["𦮪"]="其子",
   * ["𢒟"]="出入改滅",
   * ["𠜺"]="列序",
   * ["𠏁"]="化滅",
   * ["𠫰"]="參形",
   * ["𦣹"]="吾自",
   * ["𣝗"]="太始初核",
   * ["𦱡"]="如若",
   * ["𨹹"]="宇宙亡矣",
   * ["𡲵"]="尾末",
   * ["𠆤"]="序丁",
   * ["𠇮"]="序丙",
   * ["㐈"]="序乙",
   * ["𠇚"]="序甲",
   * ["佱"]="式形",
   * ["㧈"]="引用",
   * ["𤰆"]="應用",
   * ["効"]="效應",
   * ["𤅔"]="映表",
   * ["欤"]="是非",
   * ["𡒫"]="構物",
   * ["‐"]="為符名連",
   * ["侌"]="爻陰",
   * ["𣆄"]="爻陽",
   * ["亓"]="特定其物",
   * ["畧"]="省略一物",
   * ["謼"]="符名",
   * ["弌"]="等同",
   * ["筭"]="解算",
   * ["疎"]="註疏",
   * ["𧥝"]="詞素",
   * ["䥘"]="謬誤",
   * ["丩"]="連頸",
   * ["𣣓"]="間空",
   * ["𩠐"]="首始",
   * } */
  lua_createtable(L, 0, 99);
  lua_pushliteral(L, "0");
  lua_pushliteral(L, "0");
  lua_rawset(L, -3);
  lua_pushliteral(L, "1");
  lua_pushliteral(L, "1");
  lua_rawset(L, -3);
  lua_pushliteral(L, "2");
  lua_pushliteral(L, "2");
  lua_rawset(L, -3);
  lua_pushliteral(L, "3");
  lua_pushliteral(L, "3");
  lua_rawset(L, -3);
  lua_pushliteral(L, "4");
  lua_pushliteral(L, "4");
  lua_rawset(L, -3);
  lua_pushliteral(L, "5");
  lua_pushliteral(L, "5");
  lua_rawset(L, -3);
  lua_pushliteral(L, "6");
  lua_pushliteral(L, "6");
  lua_rawset(L, -3);
  lua_pushliteral(L, "7");
  lua_pushliteral(L, "7");
  lua_rawset(L, -3);
  lua_pushliteral(L, "8");
  lua_pushliteral(L, "8");
  lua_rawset(L, -3);
  lua_pushliteral(L, "9");
  lua_pushliteral(L, "9");
  lua_rawset(L, -3);
  lua_pushliteral(L, "A");
  lua_pushliteral(L, "A");
  lua_rawset(L, -3);
  lua_pushliteral(L, "B");
  lua_pushliteral(L, "B");
  lua_rawset(L, -3);
  lua_pushliteral(L, "C");
  lua_pushliteral(L, "C");
  lua_rawset(L, -3);
  lua_pushliteral(L, "D");
  lua_pushliteral(L, "D");
  lua_rawset(L, -3);
  lua_pushliteral(L, "E");
  lua_pushliteral(L, "E");
  lua_rawset(L, -3);
  lua_pushliteral(L, "F");
  lua_pushliteral(L, "F");
  lua_rawset(L, -3);
  lua_pushliteral(L, "G");
  lua_pushliteral(L, "G");
  lua_rawset(L, -3);
  lua_pushliteral(L, "H");
  lua_pushliteral(L, "H");
  lua_rawset(L, -3);
  lua_pushliteral(L, "I");
  lua_pushliteral(L, "I");
  lua_rawset(L, -3);
  lua_pushliteral(L, "J");
  lua_pushliteral(L, "J");
  lua_rawset(L, -3);
  lua_pushliteral(L, "K");
  lua_pushliteral(L, "K");
  lua_rawset(L, -3);
  lua_pushliteral(L, "L");
  lua_pushliteral(L, "L");
  lua_rawset(L, -3);
  lua_pushliteral(L, "M");
  lua_pushliteral(L, "M");
  lua_rawset(L, -3);
  lua_pushliteral(L, "N");
  lua_pushliteral(L, "N");
  lua_rawset(L, -3);
  lua_pushliteral(L, "O");
  lua_pushliteral(L, "O");
  lua_rawset(L, -3);
  lua_pushliteral(L, "P");
  lua_pushliteral(L, "P");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Q");
  lua_pushliteral(L, "Q");
  lua_rawset(L, -3);
  lua_pushliteral(L, "R");
  lua_pushliteral(L, "R");
  lua_rawset(L, -3);
  lua_pushliteral(L, "S");
  lua_pushliteral(L, "S");
  lua_rawset(L, -3);
  lua_pushliteral(L, "T");
  lua_pushliteral(L, "T");
  lua_rawset(L, -3);
  lua_pushliteral(L, "U");
  lua_pushliteral(L, "U");
  lua_rawset(L, -3);
  lua_pushliteral(L, "V");
  lua_pushliteral(L, "V");
  lua_rawset(L, -3);
  lua_pushliteral(L, "W");
  lua_pushliteral(L, "W");
  lua_rawset(L, -3);
  lua_pushliteral(L, "X");
  lua_pushliteral(L, "X");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Y");
  lua_pushliteral(L, "Y");
  lua_rawset(L, -3);
  lua_pushliteral(L, "Z");
  lua_pushliteral(L, "Z");
  lua_rawset(L, -3);
  lua_pushliteral(L, "a");
  lua_pushliteral(L, "a");
  lua_rawset(L, -3);
  lua_pushliteral(L, "b");
  lua_pushliteral(L, "b");
  lua_rawset(L, -3);
  lua_pushliteral(L, "c");
  lua_pushliteral(L, "c");
  lua_rawset(L, -3);
  lua_pushliteral(L, "d");
  lua_pushliteral(L, "d");
  lua_rawset(L, -3);
  lua_pushliteral(L, "e");
  lua_pushliteral(L, "e");
  lua_rawset(L, -3);
  lua_pushliteral(L, "f");
  lua_pushliteral(L, "f");
  lua_rawset(L, -3);
  lua_pushliteral(L, "g");
  lua_pushliteral(L, "g");
  lua_rawset(L, -3);
  lua_pushliteral(L, "h");
  lua_pushliteral(L, "h");
  lua_rawset(L, -3);
  lua_pushliteral(L, "i");
  lua_pushliteral(L, "i");
  lua_rawset(L, -3);
  lua_pushliteral(L, "j");
  lua_pushliteral(L, "j");
  lua_rawset(L, -3);
  lua_pushliteral(L, "k");
  lua_pushliteral(L, "k");
  lua_rawset(L, -3);
  lua_pushliteral(L, "l");
  lua_pushliteral(L, "l");
  lua_rawset(L, -3);
  lua_pushliteral(L, "m");
  lua_pushliteral(L, "m");
  lua_rawset(L, -3);
  lua_pushliteral(L, "n");
  lua_pushliteral(L, "n");
  lua_rawset(L, -3);
  lua_pushliteral(L, "o");
  lua_pushliteral(L, "o");
  lua_rawset(L, -3);
  lua_pushliteral(L, "p");
  lua_pushliteral(L, "p");
  lua_rawset(L, -3);
  lua_pushliteral(L, "q");
  lua_pushliteral(L, "q");
  lua_rawset(L, -3);
  lua_pushliteral(L, "r");
  lua_pushliteral(L, "r");
  lua_rawset(L, -3);
  lua_pushliteral(L, "s");
  lua_pushliteral(L, "s");
  lua_rawset(L, -3);
  lua_pushliteral(L, "t");
  lua_pushliteral(L, "t");
  lua_rawset(L, -3);
  lua_pushliteral(L, "u");
  lua_pushliteral(L, "u");
  lua_rawset(L, -3);
  lua_pushliteral(L, "v");
  lua_pushliteral(L, "v");
  lua_rawset(L, -3);
  lua_pushliteral(L, "w");
  lua_pushliteral(L, "w");
  lua_rawset(L, -3);
  lua_pushliteral(L, "x");
  lua_pushliteral(L, "x");
  lua_rawset(L, -3);
  lua_pushliteral(L, "y");
  lua_pushliteral(L, "y");
  lua_rawset(L, -3);
  lua_pushliteral(L, "z");
  lua_pushliteral(L, "z");
  lua_rawset(L, -3);
  lua_pushliteral(L, "㝉");
  lua_pushliteral(L, "一類何物");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𫙦");
  lua_pushliteral(L, "之物");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𦮪");
  lua_pushliteral(L, "其子");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𢒟");
  lua_pushliteral(L, "出入改滅");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠜺");
  lua_pushliteral(L, "列序");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠏁");
  lua_pushliteral(L, "化滅");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠫰");
  lua_pushliteral(L, "參形");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𦣹");
  lua_pushliteral(L, "吾自");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𣝗");
  lua_pushliteral(L, "太始初核");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𦱡");
  lua_pushliteral(L, "如若");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𨹹");
  lua_pushliteral(L, "宇宙亡矣");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𡲵");
  lua_pushliteral(L, "尾末");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠆤");
  lua_pushliteral(L, "序丁");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠇮");
  lua_pushliteral(L, "序丙");
  lua_rawset(L, -3);
  lua_pushliteral(L, "㐈");
  lua_pushliteral(L, "序乙");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𠇚");
  lua_pushliteral(L, "序甲");
  lua_rawset(L, -3);
  lua_pushliteral(L, "佱");
  lua_pushliteral(L, "式形");
  lua_rawset(L, -3);
  lua_pushliteral(L, "㧈");
  lua_pushliteral(L, "引用");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𤰆");
  lua_pushliteral(L, "應用");
  lua_rawset(L, -3);
  lua_pushliteral(L, "効");
  lua_pushliteral(L, "效應");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𤅔");
  lua_pushliteral(L, "映表");
  lua_rawset(L, -3);
  lua_pushliteral(L, "欤");
  lua_pushliteral(L, "是非");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𡒫");
  lua_pushliteral(L, "構物");
  lua_rawset(L, -3);
  lua_pushliteral(L, "‐");
  lua_pushliteral(L, "為符名連");
  lua_rawset(L, -3);
  lua_pushliteral(L, "侌");
  lua_pushliteral(L, "爻陰");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𣆄");
  lua_pushliteral(L, "爻陽");
  lua_rawset(L, -3);
  lua_pushliteral(L, "亓");
  lua_pushliteral(L, "特定其物");
  lua_rawset(L, -3);
  lua_pushliteral(L, "畧");
  lua_pushliteral(L, "省略一物");
  lua_rawset(L, -3);
  lua_pushliteral(L, "謼");
  lua_pushliteral(L, "符名");
  lua_rawset(L, -3);
  lua_pushliteral(L, "弌");
  lua_pushliteral(L, "等同");
  lua_rawset(L, -3);
  lua_pushliteral(L, "筭");
  lua_pushliteral(L, "解算");
  lua_rawset(L, -3);
  lua_pushliteral(L, "疎");
  lua_pushliteral(L, "註疏");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𧥝");
  lua_pushliteral(L, "詞素");
  lua_rawset(L, -3);
  lua_pushliteral(L, "䥘");
  lua_pushliteral(L, "謬誤");
  lua_rawset(L, -3);
  lua_pushliteral(L, "丩");
  lua_pushliteral(L, "連頸");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𣣓");
  lua_pushliteral(L, "間空");
  lua_rawset(L, -3);
  lua_pushliteral(L, "𩠐");
  lua_pushliteral(L, "首始");
  lua_rawset(L, -3);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function() */
static inline int lcf4_d(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return e */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 141);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function() */
static inline int lcf5_d(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* local e=n() */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc516 = 1 };
  assert((lua_gettop(L) == lc516));
  lc_getupvalue(L, lua_upvalueindex(1), 2, 138);
  lua_call(L, 0, 1);
  lua_rawseti(L, lc516, 141);
  assert(lua_gettop(L) == 1);

  /* function d()return e end */
  lua_pushvalue(L, lc516);
  lua_pushcclosure(L, lcf4_d, 1);
  lc_setupvalue(L, lc516, 1, 140);
  assert(lua_gettop(L) == 1);

  /* return e */
  lc_getupvalue(L, lc516, 0, 141);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: m
 * function() */
static inline int lcf1_m(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return e */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 142);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: m
 * function() */
static inline int lcf2_m(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* local e=u() */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc517 = 1 };
  assert((lua_gettop(L) == lc517));
  lc_getupvalue(L, lua_upvalueindex(1), 1, 139);
  lua_call(L, 0, 1);
  lua_rawseti(L, lc517, 142);
  assert(lua_gettop(L) == 1);

  /* function m()return e end */
  lua_pushvalue(L, lc517);
  lua_pushcclosure(L, lcf1_m, 1);
  lc_setupvalue(L, lc517, 4, 115);
  assert(lua_gettop(L) == 1);

  /* return e */
  lc_getupvalue(L, lc517, 0, 142);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: rt
 * function(e) */
static inline int lcf2_rt(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return m()[e]~=nil */
  lc_getupvalue(L, lua_upvalueindex(1), 4, 115);
  lua_call(L, 0, 1);
  lua_pushvalue(L, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lua_pushnil(L);
  const int lc519 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc519);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Ze
 * function(e) */
static inline int lcf2_Ze(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return{
   * Ve,
   * e,
   * } */
  lua_createtable(L, 2, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 114);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Xe
 * function(e) */
static inline int lcf2_Xe(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return d()[e]~=nil */
  lc_getupvalue(L, lua_upvalueindex(1), 3, 140);
  lua_call(L, 0, 1);
  lua_pushvalue(L, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lua_pushnil(L);
  const int lc522 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc522);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: n
 * function(e) */
static inline int lcf4_n(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return Ze(d()[e]) */
  const int lc524 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 144);
  lc_getupvalue(L, lua_upvalueindex(1), 4, 140);
  lua_call(L, 0, 1);
  lua_pushvalue(L, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc524);
  assert(lua_gettop(L) == 1);
}

/* name: o
 * function(e) */
static inline int lcf3_o(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* e[2]=W(e[2]) */
  lc_getupvalue(L, lua_upvalueindex(1), 8, 60);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 1);

  /* e[3]=W(e[3]) */
  lc_getupvalue(L, lua_upvalueindex(1), 8, 60);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  assert(lua_gettop(L) == 1);

  /* if I(e[2])or I(e[3]) then */
  enum { lc526 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 8, 101);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 8, 101);
    lua_pushnumber(L, 3);
    lua_gettable(L, 1);
    lua_call(L, 1, 1);
  }
  const int lc527 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc527) {

    /* local t=lt(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 8, 55);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 2);

    /* local a=e[2] */
    lua_pushnumber(L, 2);
    lua_gettable(L, 1);
    assert(lua_gettop(L) == 3);

    /* local e=e[3] */
    lua_pushnumber(L, 3);
    lua_gettable(L, 1);
    assert(lua_gettop(L) == 4);

    /* local a=Ve(a) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 147);
    lua_pushvalue(L, 3);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 5);

    /* local e=Ve(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 147);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 6);

    /* t[2]=a */
    lua_pushvalue(L, 5);
    lua_pushnumber(L, 2);
    lua_insert(L, -2);
    lua_settable(L, 2);
    assert(lua_gettop(L) == 6);

    /* t[3]=e */
    lua_pushvalue(L, 6);
    lua_pushnumber(L, 3);
    lua_insert(L, -2);
    lua_settable(L, 2);
    assert(lua_gettop(L) == 6);

    /* return t */
    lua_pushvalue(L, 2);
    return 1;
    assert(lua_gettop(L) == 6);
  } else {

    /* else
     * return e */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc526);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: Ve
 * function(e) */
static inline int lcf1_Ve(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local t=Qe(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 8, 20);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 2);

  /* local function o(e)
   * e[2]=W(e[2])
   * e[3]=W(e[3])
   * if I(e[2])or I(e[3])then
   * local t=lt(e)
   * local a=e[2]
   * local e=e[3]
   * local a=Ve(a)
   * local e=Ve(e)
   * t[2]=a
   * t[3]=e
   * return t
   * else
   * return e
   * end
   * end */
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf3_o, 1);
  assert(lua_gettop(L) == 3);

  /* if c(t) then */
  enum { lc528 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 8, 86);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc529 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc529) {

    /* return o(t) */
    const int lc530 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc530);
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif g(t) then */
    enum { lc531 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 8, 82);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc532 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc532) {

      /* return o(t) */
      const int lc533 = lua_gettop(L);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 2);
      lua_call(L, 1, LUA_MULTRET);
      return (lua_gettop(L) - lc533);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif a(t) then */
      enum { lc534 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 8, 92);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      const int lc535 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc535) {

        /* return o(t) */
        const int lc536 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc536);
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc534);
    }
    lua_settop(L, lc531);
  }
  lua_settop(L, lc528);
  assert(lua_gettop(L) == 3);

  /* return t */
  lua_pushvalue(L, 2);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* name: b
 * function(e) */
static inline int lcf1_b(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return T(ye,s(z,s(e,y))) */
  const int lc547 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 87);
  const int lc548 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 8, 148);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 93);
  const int lc549 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 54);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 93);
  lua_pushvalue(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc549), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc548), LUA_MULTRET);
  return (lua_gettop(L) - lc547);
  assert(lua_gettop(L) == 1);
}

/* name: Ae
 * function(a) */
static inline int lcf1_Ae(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return b(e(u,e(t,m,a),Y)) */
  const int lc550 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 156);
  const int lc551 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 151);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 53);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 150);
  lua_pushvalue(L, 1);
  lua_call(L, 3, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 7, 149);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc551), LUA_MULTRET);
  return (lua_gettop(L) - lc550);
  assert(lua_gettop(L) == 1);
}

/* name: d
 * function(a,o) */
static inline int lcf6_d(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return b(e(u,e(t,e(a),m),o)) */
  const int lc552 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 156);
  const int lc553 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 151);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 53);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 150);
  lua_call(L, 3, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc553), LUA_MULTRET);
  return (lua_gettop(L) - lc552);
  assert(lua_gettop(L) == 2);
}

/* name: M
 * function(a) */
static inline int lcf1_M(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return b(e(u,t,e(ae,e(u,a,m)))) */
  const int lc554 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 156);
  const int lc555 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  const int lc556 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 151);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 53);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  const int lc557 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 4, 152);
  lc_getupvalue(L, lua_upvalueindex(1), 17, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 151);
  lua_pushvalue(L, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 150);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc557), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc556), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc555), LUA_MULTRET);
  return (lua_gettop(L) - lc554);
  assert(lua_gettop(L) == 1);
}

/* name: ke
 * function(e,n,s) */
static inline int lcf1_ke(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);

  /* while a(e)do */
  enum { lc580 = 4 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 21, 92);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* v(t,o(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 23, 1);
    const int lc581 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lc_getupvalue(L, lua_upvalueindex(1), 21, 91);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc581), 0);
    assert(lua_gettop(L) == 4);

    /* e=i(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 21, 90);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc580);
  assert(lua_gettop(L) == 4);

  /* if h(e) then */
  enum { lc582 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 21, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc583 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc583) {

    /* return n(t) */
    const int lc584 = lua_gettop(L);
    lua_pushvalue(L, 2);
    lua_pushvalue(L, 4);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc584);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc582);
  assert(lua_gettop(L) == 4);

  /* return s(t,e) */
  const int lc585 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc585);
  assert(lua_gettop(L) == 4);
}

/* function(e) */
static inline int lcf588(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* function(e,e) */
static inline int lcf589(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return false */
  lua_pushboolean(L, 0);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: M
 * function(e) */
static inline int lcf2_M(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return ke(e,function(e)return e end,function(e,e)return false end) */
  const int lc587 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 160);
  lua_pushvalue(L, 1);
  lua_pushcfunction(L, lcf588);
  lua_pushcfunction(L, lcf589);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc587);
  assert(lua_gettop(L) == 1);
}

/* name: tt
 * function(e) */
static inline int lcf1_tt(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* while B(e)or I(e)do */
  enum { lc590 = 1 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 22, 79);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      lua_pop(L, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 22, 101);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* e=N(qe(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 22, 26);
    const int lc591 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 22, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc591), 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc590);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: Ae
 * function(e) */
static inline int lcf2_Ae(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if Q(e) then */
  enum { lc593 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 23, 76);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc594 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc594) {

    /* return e */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  } else {

    /* elseif G(e) then */
    enum { lc595 = 1 };
    lc_getupvalue(L, lua_upvalueindex(1), 23, 72);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc596 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc596) {

      /* error("WIP") */
      lua_getfield(L, LUA_ENVIRONINDEX, "error");
      lua_pushliteral(L, "WIP");
      lua_call(L, 1, 0);
      assert(lua_gettop(L) == 1);
    } else {

      /* elseif P(e) then */
      enum { lc597 = 1 };
      lc_getupvalue(L, lua_upvalueindex(1), 23, 67);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc598 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc598) {

        /* error("WIP") */
        lua_getfield(L, LUA_ENVIRONINDEX, "error");
        lua_pushliteral(L, "WIP");
        lua_call(L, 1, 0);
        assert(lua_gettop(L) == 1);
      } else {

        /* elseif V(e) then */
        enum { lc599 = 1 };
        lc_getupvalue(L, lua_upvalueindex(1), 23, 63);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc600 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc600) {

          /* error("WIP") */
          lua_getfield(L, LUA_ENVIRONINDEX, "error");
          lua_pushliteral(L, "WIP");
          lua_call(L, 1, 0);
          assert(lua_gettop(L) == 1);
        }
        lua_settop(L, lc599);
      }
      lua_settop(L, lc597);
    }
    lua_settop(L, lc595);
  }
  lua_settop(L, lc593);
  assert(lua_gettop(L) == 1);

  /* return j() */
  const int lc601 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 23, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc601);
  assert(lua_gettop(L) == 1);
}

/* name: it
 * function(e) */
static inline int lcf2_it(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return X(Ae(e)) */
  const int lc602 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 23, 75);
  const int lc603 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 162);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc603), LUA_MULTRET);
  return (lua_gettop(L) - lc602);
  assert(lua_gettop(L) == 1);
}

/* name: ct
 * function(e) */
static inline int lcf1_ct(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return Z(Ae(e)) */
  const int lc604 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 23, 74);
  const int lc605 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 162);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc605), LUA_MULTRET);
  return (lua_gettop(L) - lc604);
  assert(lua_gettop(L) == 1);
}

/* name: st
 * function(e) */
static inline int lcf1_st(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if I(e) then */
  enum { lc606 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 23, 101);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc607 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc607) {

    /* return K(e) */
    const int lc608 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 23, 99);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc608);
    assert(lua_gettop(L) == 1);
  } else {

    /* else
     * return k(e) */
    const int lc609 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 23, 22);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc609);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc606);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: he
 * function(t) */
static inline int lcf1_he(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* t=r(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 1);

  /* if not c(t) then */
  enum { lc611 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 86);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc612 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc612) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc611);
  assert(lua_gettop(L) == 1);

  /* local e=r(E(t)) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  const int lc613 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 85);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc613), 1);
  assert(lua_gettop(L) == 2);

  /* if not p(e) then */
  enum { lc614 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 97);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc615 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc615) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc614);
  assert(lua_gettop(L) == 2);

  /* if not D(e,Se) then */
  enum { lc616 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 94);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 51);
  lua_call(L, 2, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc617 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc617) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc616);
  assert(lua_gettop(L) == 2);

  /* e=r(A(t)) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  const int lc618 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 84);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc618), 1);
  lua_replace(L, 2);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc619 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc620 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc620) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc619);
  assert(lua_gettop(L) == 2);

  /* if not h(r(i(e))) then */
  enum { lc621 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 88);
  const int lc622 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  const int lc623 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc623), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc622), 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc624 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc624) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc621);
  assert(lua_gettop(L) == 2);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 3);

  /* local n=r(o(e)) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  const int lc625 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc625), 1);
  assert(lua_gettop(L) == 4);

  /* while not h(n)do */
  enum { lc626 = 4 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 24, 88);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* if not a(n) then */
    enum { lc627 = 4 };
    lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc628 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc628) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L, lc627);
    assert(lua_gettop(L) == 4);

    /* local e=r(o(n)) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
    const int lc629 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
    lua_pushvalue(L, 4);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc629), 1);
    assert(lua_gettop(L) == 5);

    /* n=r(i(n)) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
    const int lc630 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 90);
    lua_pushvalue(L, 4);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc630), 1);
    lua_replace(L, 4);
    assert(lua_gettop(L) == 5);

    /* if not a(e) then */
    enum { lc631 = 5 };
    lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc632 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc632) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L, lc631);
    assert(lua_gettop(L) == 5);

    /* local n=o(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 6);

    /* e=r(i(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
    const int lc633 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc633), 1);
    lua_replace(L, 5);
    assert(lua_gettop(L) == 6);

    /* if not a(e) then */
    enum { lc634 = 6 };
    lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc635 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc635) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L, lc634);
    assert(lua_gettop(L) == 6);

    /* local o=o(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 7);

    /* if not h(r(i(e))) then */
    enum { lc636 = 7 };
    lc_getupvalue(L, lua_upvalueindex(1), 24, 88);
    const int lc637 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
    const int lc638 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc638), LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc637), 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc639 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc639) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L, lc636);
    assert(lua_gettop(L) == 7);

    /* local a=true */
    lua_pushboolean(L, 1);
    assert(lua_gettop(L) == 8);

    /* do
     * local e=0 */
    lua_pushnumber(L, 0);
    assert(lua_gettop(L) == 9);

    /* while e<#t do */
    enum { lc640 = 9 };
    while (1) {
      const double lc641 = lua_objlen(L, 3);
      lua_pushnumber(L, lc641);
      const int lc642 = lua_lessthan(L, 9, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc642);
      if (!(lua_toboolean(L, -1))) {
        break;
      }
      lua_pop(L, 1);

      /* if l(t[(e+0)+1],n) then */
      enum { lc643 = 9 };
      lc_getupvalue(L, lua_upvalueindex(1), 24, 4);
      lua_pushnumber(L, 0);
      lc_add(L, 9, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 3);
      lua_pushvalue(L, 6);
      lua_call(L, 2, 1);
      const int lc644 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc644) {

        /* t[(e+1)+1]=o */
        lua_pushvalue(L, 7);
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 3);
        assert(lua_gettop(L) == 9);

        /* a=false */
        lua_pushboolean(L, 0);
        lua_replace(L, 8);
        assert(lua_gettop(L) == 9);

        /* break */
        break;
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L, lc643);
      assert(lua_gettop(L) == 9);

      /* e=e+2 */
      lua_pushnumber(L, 2);
      lc_add(L, 9, -1);
      lua_remove(L, -2);
      lua_replace(L, 9);
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L, lc640);
    assert(lua_gettop(L) == 9);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
    assert(lua_gettop(L) == 8);

    /* if a then */
    enum { lc645 = 8 };
    if (lua_toboolean(L, 8)) {

      /* v(t,n) */
      lc_getupvalue(L, lua_upvalueindex(1), 26, 1);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 6);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 8);

      /* v(t,o) */
      lc_getupvalue(L, lua_upvalueindex(1), 26, 1);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 7);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L, lc645);
    assert(lua_gettop(L) == 8);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 4);
  }
  lua_settop(L, lc626);
  assert(lua_gettop(L) == 4);

  /* return t */
  lua_pushvalue(L, 3);
  return 1;
  assert(lua_gettop(L) == 4);
}

/* function(e) */
static inline int lcf652(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* e=k(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 25, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 1);

  /* if w(e) then */
  enum { lc647 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 25, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc648 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc648) {

    /* return q(t,{e}) */
    const int lc649 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 25, 68);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 164);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc649);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc647);
  assert(lua_gettop(L) == 1);

  /* if a(e) then */
  enum { lc650 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 165);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc651 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc651) {

    /* return se */
    lc_getupvalue(L, lua_upvalueindex(1), 5, 159);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc650);
  assert(lua_gettop(L) == 1);

  /* return d */
  lc_getupvalue(L, lua_upvalueindex(1), 6, 158);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: ie
 * function(t,a) */
static inline int lcf1_ie(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc646 = 3 };
  assert((lua_gettop(L) == lc646));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 164);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 165);

  /* return{
   * t,
   * 1,
   * function(e)
   * e=k(e)
   * if w(e)then
   * return q(t,{e})
   * end
   * if a(e)then
   * return se
   * end
   * return d
   * end,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lc646, 0, 164);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, lc646);
  lua_pushcclosure(L, lcf652, 1);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* function(e,i) */
static inline int lcf661(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* e=k(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 25, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 2);

  /* if w(e) then */
  enum { lc654 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 25, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc655 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc655) {

    /* return q(t,{e}) */
    const int lc656 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 25, 68);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 166);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc656);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc654);
  assert(lua_gettop(L) == 2);

  /* if a(e) then */
  enum { lc657 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 167);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc658 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc658) {

    /* return o(e) */
    const int lc659 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 168);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc659);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc657);
  assert(lua_gettop(L) == 2);

  /* return i() */
  const int lc660 = lua_gettop(L);
  lua_pushvalue(L, 2);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc660);
  assert(lua_gettop(L) == 2);
}

/* name: J
 * function(t,a,o) */
static inline int lcf1_J(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc653 = 4 };
  assert((lua_gettop(L) == lc653));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 166);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 167);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 168);

  /* return{
   * t,
   * 1,
   * function(e,i)
   * e=k(e)
   * if w(e)then
   * return q(t,{e})
   * end
   * if a(e)then
   * return o(e)
   * end
   * return i()
   * end,
   * } */
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, lc653, 0, 166);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, lc653);
  lua_pushcclosure(L, lcf661, 1);
  lua_rawseti(L, -2, 3);
  return 1;
  assert(lua_gettop(L) == 4);
}

/* name: n
 * function(a,t,e) */
static inline int lcf5_n(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* return q(ee,{
   * a,
   * t,
   * e,
   * }) */
  const int lc672 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 25, 68);
  lc_getupvalue(L, lua_upvalueindex(1), 25, 35);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 3);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc672);
  assert(lua_gettop(L) == 3);
}

/* name: s
 * function(t,e) */
static inline int lcf3_s(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return n(t,e,d) */
  const int lc674 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 169);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, lua_upvalueindex(1), 7, 158);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc674);
  assert(lua_gettop(L) == 2);
}

/* name: n
 * function(e,o,t,a) */
static inline int lcf6_n(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* return s(q(te,{
   * t(e),
   * t(o),
   * }),q(te,{
   * a(e),
   * a(o),
   * })) */
  const int lc675 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 170);
  const int lc676 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 26, 68);
  lc_getupvalue(L, lua_upvalueindex(1), 26, 38);
  lua_createtable(L, 2, 0);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, -2, 1);
  const int lc677 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  while ((lua_gettop(L) > lc677)) {
    lua_rawseti(L, lc677, (1 + (lua_gettop(L) - lc677)));
  }
  lua_call(L, 2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 26, 68);
  lc_getupvalue(L, lua_upvalueindex(1), 26, 38);
  lua_createtable(L, 2, 0);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, -2, 1);
  const int lc678 = lua_gettop(L);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  while ((lua_gettop(L) > lc678)) {
    lua_rawseti(L, lc678, (1 + (lua_gettop(L) - lc678)));
  }
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc676), LUA_MULTRET);
  return (lua_gettop(L) - lc675);
  assert(lua_gettop(L) == 4);
}

/* function(e,t,n) */
static inline int lcf705(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* if e==t then */
  enum { lc662 = 3 };
  const int lc663 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc663);
  const int lc664 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc664) {

    /* return se */
    lc_getupvalue(L, lua_upvalueindex(1), 4, 159);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc662);
  assert(lua_gettop(L) == 3);

  /* e=k(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 3);

  /* t=k(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 22);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  assert(lua_gettop(L) == 3);

  /* if w(e)or w(t) then */
  enum { lc665 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 24);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
  }
  const int lc666 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc666) {

    /* return q(te,{
     * e,
     * t,
     * }) */
    const int lc667 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 68);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 38);
    lua_createtable(L, 2, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 2);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc667);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc665);
  assert(lua_gettop(L) == 3);

  /* if e==t then */
  enum { lc668 = 3 };
  const int lc669 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc669);
  const int lc670 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc670) {

    /* return se */
    lc_getupvalue(L, lua_upvalueindex(1), 4, 159);
    return 1;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc668);
  assert(lua_gettop(L) == 3);

  /* local function n(a,t,e)
   * return q(ee,{
   * a,
   * t,
   * e,
   * })
   * end */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc671 = 4 };
  assert((lua_gettop(L) == lc671));
  lua_pushvalue(L, lc671);
  lua_pushcclosure(L, lcf5_n, 1);
  lua_rawseti(L, lc671, 169);
  assert(lua_gettop(L) == 4);

  /* local function s(t,e)
   * return n(t,e,d)
   * end */
  lc_newclosuretable(L, lc671);
  enum { lc673 = 5 };
  assert((lua_gettop(L) == lc673));
  lua_pushvalue(L, lc673);
  lua_pushcclosure(L, lcf3_s, 1);
  lua_rawseti(L, lc673, 170);
  assert(lua_gettop(L) == 5);

  /* H(not w(e)) */
  lc_getupvalue(L, lc673, 26, 116);
  lc_getupvalue(L, lc673, 26, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 5);

  /* local function n(e,o,t,a)
   * return s(q(te,{
   * t(e),
   * t(o),
   * }),q(te,{
   * a(e),
   * a(o),
   * }))
   * end */
  lua_pushvalue(L, lc673);
  lua_pushcclosure(L, lcf6_n, 1);
  assert(lua_gettop(L) == 6);

  /* if h(e) then */
  enum { lc679 = 6 };
  lc_getupvalue(L, lc673, 26, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc680 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc680) {

    /* if not h(e) then */
    enum { lc681 = 6 };
    lc_getupvalue(L, lc673, 26, 88);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc682 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc682) {

      /* return d */
      lc_getupvalue(L, lc673, 7, 158);
      return 1;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L, lc681);
    assert(lua_gettop(L) == 6);

    /* return se */
    lc_getupvalue(L, lc673, 6, 159);
    return 1;
    assert(lua_gettop(L) == 6);
  } else {

    /* elseif p(e) then */
    enum { lc683 = 6 };
    lc_getupvalue(L, lc673, 26, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc684 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc684) {

      /* if not p(t) then */
      enum { lc685 = 6 };
      lc_getupvalue(L, lc673, 26, 97);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc686 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc686) {

        /* return d */
        lc_getupvalue(L, lc673, 7, 158);
        return 1;
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L, lc685);
      assert(lua_gettop(L) == 6);

      /* if D(e,t) then */
      enum { lc687 = 6 };
      lc_getupvalue(L, lc673, 26, 94);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 2);
      lua_call(L, 2, 1);
      const int lc688 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc688) {

        /* return se */
        lc_getupvalue(L, lc673, 6, 159);
        return 1;
        assert(lua_gettop(L) == 6);
      } else {

        /* else
         * return d */
        lc_getupvalue(L, lc673, 7, 158);
        return 1;
        assert(lua_gettop(L) == 6);
      }
      lua_settop(L, lc687);
      assert(lua_gettop(L) == 6);
    } else {

      /* elseif c(e) then */
      enum { lc689 = 6 };
      lc_getupvalue(L, lc673, 26, 86);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc690 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc690) {

        /* if not c(t) then */
        enum { lc691 = 6 };
        lc_getupvalue(L, lc673, 26, 86);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc692 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc692) {

          /* return d */
          lc_getupvalue(L, lc673, 7, 158);
          return 1;
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L, lc691);
        assert(lua_gettop(L) == 6);

        /* return n(e,t,E,A) */
        const int lc693 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lc_getupvalue(L, lc673, 26, 85);
        lc_getupvalue(L, lc673, 26, 84);
        lua_call(L, 4, LUA_MULTRET);
        return (lua_gettop(L) - lc693);
        assert(lua_gettop(L) == 6);
      } else {

        /* elseif a(e) then */
        enum { lc694 = 6 };
        lc_getupvalue(L, lc673, 26, 92);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc695 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc695) {

          /* if not a(t) then */
          enum { lc696 = 6 };
          lc_getupvalue(L, lc673, 26, 92);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc697 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc697) {

            /* return d */
            lc_getupvalue(L, lc673, 7, 158);
            return 1;
            assert(lua_gettop(L) == 6);
          }
          lua_settop(L, lc696);
          assert(lua_gettop(L) == 6);

          /* return n(e,t,o,i) */
          const int lc698 = lua_gettop(L);
          lua_pushvalue(L, 6);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, lc673, 26, 91);
          lc_getupvalue(L, lc673, 26, 90);
          lua_call(L, 4, LUA_MULTRET);
          return (lua_gettop(L) - lc698);
          assert(lua_gettop(L) == 6);
        } else {

          /* elseif g(e) then */
          enum { lc699 = 6 };
          lc_getupvalue(L, lc673, 26, 82);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc700 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc700) {

            /* if not g(t) then */
            enum { lc701 = 6 };
            lc_getupvalue(L, lc673, 26, 82);
            lua_pushvalue(L, 2);
            lua_call(L, 1, 1);
            lua_pushboolean(L, !(lua_toboolean(L, -1)));
            lua_remove(L, -2);
            const int lc702 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc702) {

              /* return d */
              lc_getupvalue(L, lc673, 7, 158);
              return 1;
              assert(lua_gettop(L) == 6);
            }
            lua_settop(L, lc701);
            assert(lua_gettop(L) == 6);

            /* return n(e,t,C,U) */
            const int lc703 = lua_gettop(L);
            lua_pushvalue(L, 6);
            lua_pushvalue(L, 1);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, lc673, 26, 81);
            lc_getupvalue(L, lc673, 26, 80);
            lua_call(L, 4, LUA_MULTRET);
            return (lua_gettop(L) - lc703);
            assert(lua_gettop(L) == 6);
          }
          lua_settop(L, lc699);
        }
        lua_settop(L, lc694);
      }
      lua_settop(L, lc689);
    }
    lua_settop(L, lc683);
  }
  lua_settop(L, lc679);
  assert(lua_gettop(L) == 6);

  /* return j() */
  const int lc704 = lua_gettop(L);
  lc_getupvalue(L, lc673, 26, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc704);
  assert(lua_gettop(L) == 6);
}

/* function(n,e,s) */
static inline int lcf713(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);

  /* local e=r(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 5);

  /* while a(e)do */
  enum { lc706 = 5 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* v(t,o(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 26, 1);
    const int lc707 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc707), 0);
    assert(lua_gettop(L) == 5);

    /* e=r(i(e)) */
    lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
    const int lc708 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc708), 1);
    lua_replace(L, 5);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc706);
  assert(lua_gettop(L) == 5);

  /* if not h(e) then */
  enum { lc709 = 5 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 88);
  lua_pushvalue(L, 5);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc710 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc710) {

    /* return s() */
    const int lc711 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc711);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc709);
  assert(lua_gettop(L) == 5);

  /* return F(n,t) */
  const int lc712 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 64);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 4);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc712);
  assert(lua_gettop(L) == 5);
}

/* function(e,a,t) */
static inline int lcf719(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* local e=he(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 163);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 4);

  /* if e==false then */
  enum { lc714 = 4 };
  lua_pushboolean(L, 0);
  const int lc715 = lua_equal(L, 4, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc715);
  const int lc716 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc716) {

    /* return t() */
    const int lc717 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc717);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc714);
  assert(lua_gettop(L) == 4);

  /* return S(e,a) */
  const int lc718 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 77);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc718);
  assert(lua_gettop(L) == 4);
}

/* function(e,t) */
static inline int lcf727(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* e=k(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 2);

  /* if w(e) then */
  enum { lc720 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc721 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc721) {

    /* return q(Ie,{e}) */
    const int lc722 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 68);
    lc_getupvalue(L, lua_upvalueindex(1), 6, 157);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc722);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc720);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc723 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 92);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc724 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc724) {

    /* return t() */
    const int lc725 = lua_gettop(L);
    lua_pushvalue(L, 2);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc725);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc723);
  assert(lua_gettop(L) == 2);

  /* return o(e) */
  const int lc726 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 91);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc726);
  assert(lua_gettop(L) == 2);
}

/* function(e,a,o,t) */
static inline int lcf743(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* e=k(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 4);

  /* if w(e) then */
  enum { lc728 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc729 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc729) {

    /* return q(ee,{
     * e,
     * a,
     * o,
     * }) */
    const int lc730 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 68);
    lc_getupvalue(L, lua_upvalueindex(1), 24, 35);
    lua_createtable(L, 3, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 2);
    lua_pushvalue(L, 3);
    lua_rawseti(L, -2, 3);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc730);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc728);
  assert(lua_gettop(L) == 4);

  /* if not c(e) then */
  enum { lc731 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 86);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc732 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc732) {

    /* return t() */
    const int lc733 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc733);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc731);
  assert(lua_gettop(L) == 4);

  /* local e=r(E(e)) */
  lc_getupvalue(L, lua_upvalueindex(1), 24, 21);
  const int lc734 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 24, 85);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc734), 1);
  assert(lua_gettop(L) == 5);

  /* if not p(e) then */
  enum { lc735 = 5 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 97);
  lua_pushvalue(L, 5);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc736 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc736) {

    /* return t() */
    const int lc737 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc737);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc735);
  assert(lua_gettop(L) == 5);

  /* if D(e,Je) then */
  enum { lc738 = 5 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 94);
  lua_pushvalue(L, 5);
  lc_getupvalue(L, lua_upvalueindex(1), 9, 154);
  lua_call(L, 2, 1);
  const int lc739 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc739) {

    /* return a */
    lua_pushvalue(L, 2);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc738);
  assert(lua_gettop(L) == 5);

  /* if D(e,et) then */
  enum { lc740 = 5 };
  lc_getupvalue(L, lua_upvalueindex(1), 24, 94);
  lua_pushvalue(L, 5);
  lc_getupvalue(L, lua_upvalueindex(1), 8, 155);
  lua_call(L, 2, 1);
  const int lc741 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc741) {

    /* return o */
    lua_pushvalue(L, 3);
    return 1;
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc740);
  assert(lua_gettop(L) == 5);

  /* return t() */
  const int lc742 = lua_gettop(L);
  lua_pushvalue(L, 4);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc742);
  assert(lua_gettop(L) == 5);
}

/* name: n
 * function(e,t,a,o) */
static inline int lcf7_n(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* if d(a(e),a(t))and d(o(e),o(t)) then */
  enum { lc751 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 171);
  const int lc752 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc752), 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 171);
    const int lc753 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc753), 1);
  }
  const int lc754 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc754) {

    /* O(e,t) */
    lc_getupvalue(L, lua_upvalueindex(1), 25, 57);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 4);

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 4);
  } else {

    /* else
     * return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc751);
  assert(lua_gettop(L) == 4);
  return 0;
}

/* name: d
 * function(e,t) */
static inline int lcf7_d(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* if e==t then */
  enum { lc745 = 2 };
  const int lc746 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc746);
  const int lc747 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc747) {

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc745);
  assert(lua_gettop(L) == 2);

  /* e=N(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 25, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  assert(lua_gettop(L) == 2);

  /* t=N(t) */
  lc_getupvalue(L, lua_upvalueindex(1), 25, 26);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  assert(lua_gettop(L) == 2);

  /* if e==t then */
  enum { lc748 = 2 };
  const int lc749 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc749);
  const int lc750 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc750) {

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc748);
  assert(lua_gettop(L) == 2);

  /* local function n(e,t,a,o)
   * if d(a(e),a(t))and d(o(e),o(t))then
   * O(e,t)
   * return true
   * else
   * return false
   * end
   * end */
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf7_n, 1);
  assert(lua_gettop(L) == 3);

  /* if h(e) then */
  enum { lc755 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 25, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc756 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc756) {

    /* if not h(t) then */
    enum { lc757 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 25, 88);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc758 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc758) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L, lc757);
    assert(lua_gettop(L) == 3);

    /* O(e,y) */
    lc_getupvalue(L, lua_upvalueindex(1), 25, 57);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 25, 89);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* O(t,y) */
    lc_getupvalue(L, lua_upvalueindex(1), 25, 57);
    lua_pushvalue(L, 2);
    lc_getupvalue(L, lua_upvalueindex(1), 25, 89);
    lua_call(L, 2, 0);
    assert(lua_gettop(L) == 3);

    /* return true */
    lua_pushboolean(L, 1);
    return 1;
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif p(e) then */
    enum { lc759 = 3 };
    lc_getupvalue(L, lua_upvalueindex(1), 25, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc760 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc760) {

      /* if not p(t) then */
      enum { lc761 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 25, 97);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc762 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc762) {

        /* return false */
        lua_pushboolean(L, 0);
        return 1;
        assert(lua_gettop(L) == 3);
      }
      lua_settop(L, lc761);
      assert(lua_gettop(L) == 3);

      /* return D(e,t) */
      const int lc763 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 25, 94);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 2);
      lua_call(L, 2, LUA_MULTRET);
      return (lua_gettop(L) - lc763);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif a(e) then */
      enum { lc764 = 3 };
      lc_getupvalue(L, lua_upvalueindex(1), 25, 92);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc765 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc765) {

        /* if not a(t) then */
        enum { lc766 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 25, 92);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc767 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc767) {

          /* return false */
          lua_pushboolean(L, 0);
          return 1;
          assert(lua_gettop(L) == 3);
        }
        lua_settop(L, lc766);
        assert(lua_gettop(L) == 3);

        /* return n(e,t,o,i) */
        const int lc768 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lc_getupvalue(L, lua_upvalueindex(1), 25, 91);
        lc_getupvalue(L, lua_upvalueindex(1), 25, 90);
        lua_call(L, 4, LUA_MULTRET);
        return (lua_gettop(L) - lc768);
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif g(e) then */
        enum { lc769 = 3 };
        lc_getupvalue(L, lua_upvalueindex(1), 25, 82);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc770 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc770) {

          /* if not g(t) then */
          enum { lc771 = 3 };
          lc_getupvalue(L, lua_upvalueindex(1), 25, 82);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc772 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc772) {

            /* return false */
            lua_pushboolean(L, 0);
            return 1;
            assert(lua_gettop(L) == 3);
          }
          lua_settop(L, lc771);
          assert(lua_gettop(L) == 3);

          /* return n(e,t,C,U) */
          const int lc773 = lua_gettop(L);
          lua_pushvalue(L, 3);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, lua_upvalueindex(1), 25, 81);
          lc_getupvalue(L, lua_upvalueindex(1), 25, 80);
          lua_call(L, 4, LUA_MULTRET);
          return (lua_gettop(L) - lc773);
          assert(lua_gettop(L) == 3);
        } else {

          /* elseif c(e) then */
          enum { lc774 = 3 };
          lc_getupvalue(L, lua_upvalueindex(1), 25, 86);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc775 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc775) {

            /* if not c(t) then */
            enum { lc776 = 3 };
            lc_getupvalue(L, lua_upvalueindex(1), 25, 86);
            lua_pushvalue(L, 2);
            lua_call(L, 1, 1);
            lua_pushboolean(L, !(lua_toboolean(L, -1)));
            lua_remove(L, -2);
            const int lc777 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc777) {

              /* return false */
              lua_pushboolean(L, 0);
              return 1;
              assert(lua_gettop(L) == 3);
            }
            lua_settop(L, lc776);
            assert(lua_gettop(L) == 3);

            /* return n(e,t,E,A) */
            const int lc778 = lua_gettop(L);
            lua_pushvalue(L, 3);
            lua_pushvalue(L, 1);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, lua_upvalueindex(1), 25, 85);
            lc_getupvalue(L, lua_upvalueindex(1), 25, 84);
            lua_call(L, 4, LUA_MULTRET);
            return (lua_gettop(L) - lc778);
            assert(lua_gettop(L) == 3);
          } else {

            /* elseif me(e) then */
            enum { lc779 = 3 };
            lc_getupvalue(L, lua_upvalueindex(1), 25, 25);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 1);
            const int lc780 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc780) {

              /* return false */
              lua_pushboolean(L, 0);
              return 1;
              assert(lua_gettop(L) == 3);
            }
            lua_settop(L, lc779);
          }
          lua_settop(L, lc774);
        }
        lua_settop(L, lc769);
      }
      lua_settop(L, lc764);
    }
    lua_settop(L, lc759);
  }
  lua_settop(L, lc755);
  assert(lua_gettop(L) == 3);

  /* return j() */
  const int lc781 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 25, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc781);
  assert(lua_gettop(L) == 3);
}

/* name: l
 * function() */
static inline int lcf2_l(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return#D==w */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 198);
  const double lc784 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc784);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  const int lc785 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc785);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function() */
static inline int lcf8_d(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* H(not l()) */
  lc_getupvalue(L, lua_upvalueindex(1), 27, 116);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 0);

  /* local e=string.sub(D,w+1,w+1) */
  lua_getfield(L, LUA_ENVIRONINDEX, "string");
  lua_pushliteral(L, "sub");
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 198);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_call(L, 3, 1);
  assert(lua_gettop(L) == 1);

  /* w=w+1 */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, lua_upvalueindex(1), 0, 197);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: c
 * function(e) */
static inline int lcf2_c(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* H(string.sub(D,w,w)==e) */
  lc_getupvalue(L, lua_upvalueindex(1), 27, 116);
  lua_getfield(L, LUA_ENVIRONINDEX, "string");
  lua_pushliteral(L, "sub");
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 198);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lua_call(L, 3, 1);
  lua_pushvalue(L, 1);
  const int lc786 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc786);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);

  /* w=w-1 */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 197);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, lua_upvalueindex(1), 0, 197);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: r
 * function(e) */
static inline int lcf3_r(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if e==nil then */
  enum { lc787 = 1 };
  lua_pushnil(L);
  const int lc788 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc788);
  const int lc789 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc789) {

    /* e="" */
    lua_pushliteral(L, "");
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc787);
  assert(lua_gettop(L) == 1);

  /* error("TheLanguage parse ERROR!"..tostring(e)) */
  lua_getfield(L, LUA_ENVIRONINDEX, "error");
  lua_pushliteral(L, "TheLanguage parse ERROR!");
  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: j
 * function(e) */
static inline int lcf2_j(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e==" "or e=="\n"or e=="\t"or e=="\r" */
  lua_pushvalue(L, 1);
  lua_pushliteral(L, " ");
  const int lc790 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc790);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lua_pushvalue(L, 1);
    lua_pushliteral(L, "\n");
    const int lc791 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc791);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lua_pushvalue(L, 1);
    lua_pushliteral(L, "	");
    const int lc792 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc792);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lua_pushvalue(L, 1);
    lua_pushliteral(L, "\r");
    const int lc793 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc793);
  }
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: E
 * function() */
static inline int lcf2_E(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc794 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc795 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc795) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc794);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if not j(e) then */
  enum { lc796 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 192);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc797 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc797) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc796);
  assert(lua_gettop(L) == 1);

  /* while j(e)and not l()do */
  enum { lc798 = 1 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 0, 192);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
      lua_call(L, 0, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* e=d() */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc798);
  assert(lua_gettop(L) == 1);

  /* if not j(e) then */
  enum { lc799 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 192);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc800 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc800) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc799);
  assert(lua_gettop(L) == 1);

  /* return true */
  lua_pushboolean(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: B
 * function() */
static inline int lcf2_B(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc801 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc802 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc802) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc801);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* local t="" */
  lua_pushliteral(L, "");
  assert(lua_gettop(L) == 2);

  /* if not W(e) then */
  enum { lc803 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 181);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc804 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc804) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 2);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc803);
  assert(lua_gettop(L) == 2);

  /* while W(e)and not l()do */
  enum { lc805 = 2 };
  while (1) {
    lc_getupvalue(L, lua_upvalueindex(1), 0, 181);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
      lua_call(L, 0, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* t=tostring(t)..tostring(e) */
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_concat(L, 2);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 2);

    /* e=d() */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc805);
  assert(lua_gettop(L) == 2);

  /* if W(e) then */
  enum { lc806 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 181);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc807 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc807) {

    /* t=tostring(t)..tostring(e) */
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_concat(L, 2);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 2);
  } else {

    /* else
     * c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc806);
  assert(lua_gettop(L) == 2);

  /* if Xe(t) then */
  enum { lc808 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 21, 145);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc809 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc809) {

    /* return n(t) */
    const int lc810 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 20, 146);
    lua_pushvalue(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc810);
    assert(lua_gettop(L) == 2);
  } else {

    /* else
     * return r("Not Atom"..tostring(t)) */
    const int lc811 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_pushliteral(L, "Not Atom");
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_concat(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc811);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc808);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: o
 * function(a) */
static inline int lcf4_o(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local e=ge() */
  lc_getupvalue(L, lua_upvalueindex(1), 28, 59);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* we(t,s(a,e)) */
  lc_getupvalue(L, lua_upvalueindex(1), 28, 56);
  const int lc818 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 199);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 93);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc818), 0);
  assert(lua_gettop(L) == 2);

  /* t=e */
  lua_pushvalue(L, 2);
  lc_setupvalue(L, lua_upvalueindex(1), 0, 199);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: g
 * function() */
static inline int lcf2_g(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc812 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc813 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc813) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc812);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e~="(" then */
  enum { lc814 = 1 };
  lua_pushliteral(L, "(");
  const int lc815 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc815);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc816 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc816) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc814);
  assert(lua_gettop(L) == 1);

  /* local t=ge() */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc817 = 2 };
  assert((lua_gettop(L) == lc817));
  lc_getupvalue(L, lua_upvalueindex(1), 27, 59);
  lua_call(L, 0, 1);
  lua_rawseti(L, lc817, 199);
  assert(lua_gettop(L) == 2);

  /* local a=t */
  lc_getupvalue(L, lc817, 0, 199);
  assert(lua_gettop(L) == 3);

  /* local function o(a)
   * local e=ge()
   * we(t,s(a,e))
   * t=e
   * end */
  lua_pushvalue(L, lc817);
  lua_pushcclosure(L, lcf4_o, 1);
  assert(lua_gettop(L) == 4);

  /* while true do */
  enum { lc819 = 4 };
  while (1) {
    lua_pushboolean(L, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* E() */
    lc_getupvalue(L, lc817, 1, 191);
    lua_call(L, 0, 0);
    assert(lua_gettop(L) == 4);

    /* if l() then */
    enum { lc820 = 4 };
    lc_getupvalue(L, lc817, 1, 196);
    lua_call(L, 0, 1);
    const int lc821 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc821) {

      /* return r() */
      const int lc822 = lua_gettop(L);
      lc_getupvalue(L, lc817, 1, 193);
      lua_call(L, 0, LUA_MULTRET);
      return (lua_gettop(L) - lc822);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L, lc820);
    assert(lua_gettop(L) == 4);

    /* e=d() */
    lc_getupvalue(L, lc817, 1, 195);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 4);

    /* if e==")" then */
    enum { lc823 = 4 };
    lua_pushliteral(L, ")");
    const int lc824 = lua_equal(L, 1, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc824);
    const int lc825 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc825) {

      /* we(t,y) */
      lc_getupvalue(L, lc817, 28, 56);
      lc_getupvalue(L, lc817, 0, 199);
      lc_getupvalue(L, lc817, 28, 89);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 4);

      /* return a */
      lua_pushvalue(L, 3);
      return 1;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L, lc823);
    assert(lua_gettop(L) == 4);

    /* if e=="." then */
    enum { lc826 = 4 };
    lua_pushliteral(L, ".");
    const int lc827 = lua_equal(L, 1, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc827);
    const int lc828 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc828) {

      /* E() */
      lc_getupvalue(L, lc817, 1, 191);
      lua_call(L, 0, 0);
      assert(lua_gettop(L) == 4);

      /* local o=M() */
      lc_getupvalue(L, lc817, 1, 180);
      lua_call(L, 0, 1);
      assert(lua_gettop(L) == 5);

      /* we(t,o) */
      lc_getupvalue(L, lc817, 28, 56);
      lc_getupvalue(L, lc817, 0, 199);
      lua_pushvalue(L, 5);
      lua_call(L, 2, 0);
      assert(lua_gettop(L) == 5);

      /* E() */
      lc_getupvalue(L, lc817, 1, 191);
      lua_call(L, 0, 0);
      assert(lua_gettop(L) == 5);

      /* if l() then */
      enum { lc829 = 5 };
      lc_getupvalue(L, lc817, 1, 196);
      lua_call(L, 0, 1);
      const int lc830 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc830) {

        /* return r() */
        const int lc831 = lua_gettop(L);
        lc_getupvalue(L, lc817, 1, 193);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc831);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc829);
      assert(lua_gettop(L) == 5);

      /* e=d() */
      lc_getupvalue(L, lc817, 1, 195);
      lua_call(L, 0, 1);
      lua_replace(L, 1);
      assert(lua_gettop(L) == 5);

      /* if e~=")" then */
      enum { lc832 = 5 };
      lua_pushliteral(L, ")");
      const int lc833 = lua_equal(L, 1, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc833);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc834 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc834) {

        /* return r() */
        const int lc835 = lua_gettop(L);
        lc_getupvalue(L, lc817, 1, 193);
        lua_call(L, 0, LUA_MULTRET);
        return (lua_gettop(L) - lc835);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc832);
      assert(lua_gettop(L) == 5);

      /* return a */
      lua_pushvalue(L, 3);
      return 1;
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L, lc826);
    assert(lua_gettop(L) == 4);

    /* c(e) */
    lc_getupvalue(L, lc817, 1, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 4);

    /* local e=M() */
    lc_getupvalue(L, lc817, 1, 180);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 5);

    /* o(e) */
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 5);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc819);
  assert(lua_gettop(L) == 4);
  return 0;
}

/* name: O
 * function() */
static inline int lcf2_O(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc836 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc837 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc837) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc836);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e~="#" then */
  enum { lc838 = 1 };
  lua_pushliteral(L, "#");
  const int lc839 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc839);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc840 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc840) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc838);
  assert(lua_gettop(L) == 1);

  /* local e=g() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 189);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* if e==false then */
  enum { lc841 = 2 };
  lua_pushboolean(L, 0);
  const int lc842 = lua_equal(L, 2, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc842);
  const int lc843 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc843) {

    /* return r() */
    const int lc844 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc844);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc841);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc845 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 27, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc846 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc846) {

    /* return r() */
    const int lc847 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc847);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc845);
  assert(lua_gettop(L) == 2);

  /* return T(o(e),i(e)) */
  const int lc848 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 87);
  const int lc849 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc849), LUA_MULTRET);
  return (lua_gettop(L) - lc848);
  assert(lua_gettop(L) == 2);
}

/* name: I
 * function() */
static inline int lcf2_I(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc850 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc851 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc851) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc850);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e~="!" then */
  enum { lc852 = 1 };
  lua_pushliteral(L, "!");
  const int lc853 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc853);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc854 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc854) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc852);
  assert(lua_gettop(L) == 1);

  /* local e=g() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 189);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* if e==false then */
  enum { lc855 = 2 };
  lua_pushboolean(L, 0);
  const int lc856 = lua_equal(L, 2, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc856);
  const int lc857 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc857) {

    /* return r() */
    const int lc858 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc858);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc855);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc859 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 27, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc860 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc860) {

    /* return r() */
    const int lc861 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc861);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc859);
  assert(lua_gettop(L) == 2);

  /* return L(o(e),i(e)) */
  const int lc862 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 83);
  const int lc863 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc863), LUA_MULTRET);
  return (lua_gettop(L) - lc862);
  assert(lua_gettop(L) == 2);
}

/* name: W
 * function(e) */
static inline int lcf2_W(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if j(e) then */
  enum { lc864 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 192);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc865 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc865) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc864);
  assert(lua_gettop(L) == 1);

  /* for a,t in ipairs({
   * "(",
   * ")",
   * "!",
   * "#",
   * ".",
   * "$",
   * "%",
   * "^",
   * "@",
   * "~",
   * "/",
   * "-",
   * ">",
   * "_",
   * ":",
   * "?",
   * "[",
   * "]",
   * "&",
   * ";",
   * })do
   * internal: local f, s, var = explist */
  enum { lc866 = 1 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lua_createtable(L, 20, 0);
  lua_pushliteral(L, "(");
  lua_rawseti(L, -2, 1);
  lua_pushliteral(L, ")");
  lua_rawseti(L, -2, 2);
  lua_pushliteral(L, "!");
  lua_rawseti(L, -2, 3);
  lua_pushliteral(L, "#");
  lua_rawseti(L, -2, 4);
  lua_pushliteral(L, ".");
  lua_rawseti(L, -2, 5);
  lua_pushliteral(L, "$");
  lua_rawseti(L, -2, 6);
  lua_pushliteral(L, "%");
  lua_rawseti(L, -2, 7);
  lua_pushliteral(L, "^");
  lua_rawseti(L, -2, 8);
  lua_pushliteral(L, "@");
  lua_rawseti(L, -2, 9);
  lua_pushliteral(L, "~");
  lua_rawseti(L, -2, 10);
  lua_pushliteral(L, "/");
  lua_rawseti(L, -2, 11);
  lua_pushliteral(L, "-");
  lua_rawseti(L, -2, 12);
  lua_pushliteral(L, ">");
  lua_rawseti(L, -2, 13);
  lua_pushliteral(L, "_");
  lua_rawseti(L, -2, 14);
  lua_pushliteral(L, ":");
  lua_rawseti(L, -2, 15);
  lua_pushliteral(L, "?");
  lua_rawseti(L, -2, 16);
  lua_pushliteral(L, "[");
  lua_rawseti(L, -2, 17);
  lua_pushliteral(L, "]");
  lua_rawseti(L, -2, 18);
  lua_pushliteral(L, "&");
  lua_rawseti(L, -2, 19);
  lua_pushliteral(L, ";");
  lua_rawseti(L, -2, 20);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local a with idx 5
     * internal: local t with idx 6 */

    /* if t==e then */
    enum { lc867 = 6 };
    const int lc868 = lua_equal(L, 6, 1);
    lua_pushboolean(L, lc868);
    const int lc869 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc869) {

      /* return false */
      lua_pushboolean(L, 0);
      return 1;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L, lc867);
    assert(lua_gettop(L) == 6);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 2);
  }
  lua_settop(L, lc866);
  assert(lua_gettop(L) == 1);

  /* return true */
  lua_pushboolean(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: M
 * function() */
static inline int lcf3_M(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* E() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 191);
  lua_call(L, 0, 0);
  assert(lua_gettop(L) == 0);

  /* local e={
   * g,
   * Q,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * } */
  lua_createtable(L, 9, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 189);
  lua_rawseti(L, -2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 173);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 188);
  lua_rawseti(L, -2, 3);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 187);
  lua_rawseti(L, -2, 4);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 186);
  lua_rawseti(L, -2, 5);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 185);
  lua_rawseti(L, -2, 6);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 184);
  lua_rawseti(L, -2, 7);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 183);
  lua_rawseti(L, -2, 8);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 182);
  lua_rawseti(L, -2, 9);
  assert(lua_gettop(L) == 1);

  /* for t,e in ipairs(e)do
   * internal: local f, s, var = explist */
  enum { lc870 = 1 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local t with idx 5
     * internal: local e with idx 6 */

    /* local e=e() */
    lua_pushvalue(L, 6);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 7);

    /* if e~=false then */
    enum { lc871 = 7 };
    lua_pushboolean(L, 0);
    const int lc872 = lua_equal(L, 7, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc872);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc873 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc873) {

      /* return e */
      lua_pushvalue(L, 7);
      return 1;
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L, lc871);
    assert(lua_gettop(L) == 7);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 3);
  }
  lua_settop(L, lc870);
  assert(lua_gettop(L) == 1);

  /* return r() */
  const int lc874 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc874);
  assert(lua_gettop(L) == 1);
}

/* name: A
 * function(e) */
static inline int lcf2_A(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if e==false then */
  enum { lc875 = 1 };
  lua_pushboolean(L, 0);
  const int lc876 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc876);
  const int lc877 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc877) {

    /* return r() */
    const int lc878 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc878);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc875);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: U
 * function() */
static inline int lcf2_U(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return not l() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: k
 * function(e) */
static inline int lcf2_k(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* A(U()) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 179);
  const int lc879 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 178);
  lua_call(L, 0, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc879), 0);
  assert(lua_gettop(L) == 1);

  /* A(d()==e) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 179);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  lua_pushvalue(L, 1);
  const int lc880 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc880);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: a
 * function() */
static inline int lcf4_a(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* k("[") */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 177);
  lua_pushliteral(L, "[");
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 0);

  /* local e=f() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* k("]") */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 177);
  lua_pushliteral(L, "]");
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* name: f
 * function(t) */
static inline int lcf2_f(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if t==nil then */
  enum { lc881 = 1 };
  lua_pushnil(L);
  const int lc882 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc882);
  const int lc883 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc883) {

    /* t=false */
    lua_pushboolean(L, 0);
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc881);
  assert(lua_gettop(L) == 1);

  /* local function a()
   * k("[")
   * local e=f()
   * k("]")
   * return e
   * end */
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf4_a, 1);
  assert(lua_gettop(L) == 2);

  /* local e */
  lua_settop(L, (lua_gettop(L) + 1));
  assert(lua_gettop(L) == 3);

  /* if t then */
  enum { lc884 = 3 };
  if (lua_toboolean(L, 1)) {

    /* e={
     * g,
     * B,
     * a,
     * O,
     * I,
     * N,
     * V,
     * C,
     * P,
     * R,
     * } */
    lua_createtable(L, 10, 0);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 189);
    lua_rawseti(L, -2, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 190);
    lua_rawseti(L, -2, 2);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 3);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 188);
    lua_rawseti(L, -2, 4);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 187);
    lua_rawseti(L, -2, 5);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 186);
    lua_rawseti(L, -2, 6);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 185);
    lua_rawseti(L, -2, 7);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 184);
    lua_rawseti(L, -2, 8);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 183);
    lua_rawseti(L, -2, 9);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 182);
    lua_rawseti(L, -2, 10);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  } else {

    /* else
     * e={
     * g,
     * G,
     * O,
     * I,
     * N,
     * V,
     * C,
     * P,
     * R,
     * } */
    lua_createtable(L, 9, 0);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 189);
    lua_rawseti(L, -2, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 174);
    lua_rawseti(L, -2, 2);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 188);
    lua_rawseti(L, -2, 3);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 187);
    lua_rawseti(L, -2, 4);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 186);
    lua_rawseti(L, -2, 5);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 185);
    lua_rawseti(L, -2, 6);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 184);
    lua_rawseti(L, -2, 7);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 183);
    lua_rawseti(L, -2, 8);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 182);
    lua_rawseti(L, -2, 9);
    lua_replace(L, 3);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc884);
  assert(lua_gettop(L) == 3);

  /* for t,e in ipairs(e)do
   * internal: local f, s, var = explist */
  enum { lc885 = 3 };
  lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
  lua_pushvalue(L, 3);
  lua_call(L, 1, 3);
  while (1) {

    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if (lua_isnil(L, -2)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);

    /* internal: local t with idx 7
     * internal: local e with idx 8 */

    /* local e=e() */
    lua_pushvalue(L, 8);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 9);

    /* if e~=false then */
    enum { lc886 = 9 };
    lua_pushboolean(L, 0);
    const int lc887 = lua_equal(L, 9, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc887);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc888 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc888) {

      /* return e */
      lua_pushvalue(L, 9);
      return 1;
      assert(lua_gettop(L) == 9);
    }
    lua_settop(L, lc886);
    assert(lua_gettop(L) == 9);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 3);
  }
  lua_settop(L, lc885);
  assert(lua_gettop(L) == 3);

  /* return r() */
  const int lc889 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc889);
  assert(lua_gettop(L) == 3);
}

/* name: K
 * function(a) */
static inline int lcf2_K(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if l() then */
  enum { lc890 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc891 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc891) {

    /* return a */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc890);
  assert(lua_gettop(L) == 1);

  /* local o=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* if o=="." then */
  enum { lc892 = 2 };
  lua_pushliteral(L, ".");
  const int lc893 = lua_equal(L, 2, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc893);
  const int lc894 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc894) {

    /* local o=f() */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 3);

    /* return e(u,e(t,e(a),m),o) */
    const int lc895 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
    lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 53);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
    lua_call(L, 3, 1);
    lua_pushvalue(L, 3);
    lua_call(L, 3, LUA_MULTRET);
    return (lua_gettop(L) - lc895);
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif o==":" then */
    enum { lc896 = 2 };
    lua_pushliteral(L, ":");
    const int lc897 = lua_equal(L, 2, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc897);
    const int lc898 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc898) {

      /* local t=f() */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
      lua_call(L, 0, 1);
      assert(lua_gettop(L) == 3);

      /* return e(u,t,a) */
      const int lc899 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
      lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 1);
      lua_call(L, 3, LUA_MULTRET);
      return (lua_gettop(L) - lc899);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif o=="~" then */
      enum { lc900 = 2 };
      lua_pushliteral(L, "~");
      const int lc901 = lua_equal(L, 2, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc901);
      const int lc902 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc902) {

        /* return e(ae,a) */
        const int lc903 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
        lc_getupvalue(L, lua_upvalueindex(1), 14, 152);
        lua_pushvalue(L, 1);
        lua_call(L, 2, LUA_MULTRET);
        return (lua_gettop(L) - lc903);
        assert(lua_gettop(L) == 2);
      } else {

        /* elseif o=="@" then */
        enum { lc904 = 2 };
        lua_pushliteral(L, "@");
        const int lc905 = lua_equal(L, 2, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc905);
        const int lc906 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc906) {

          /* local o=f() */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
          lua_call(L, 0, 1);
          assert(lua_gettop(L) == 3);

          /* return e(u,e(t,s(a,m),m),o) */
          const int lc907 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
          lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 53);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 93);
          lua_pushvalue(L, 1);
          lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
          lua_call(L, 2, 1);
          lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
          lua_call(L, 3, 1);
          lua_pushvalue(L, 3);
          lua_call(L, 3, LUA_MULTRET);
          return (lua_gettop(L) - lc907);
          assert(lua_gettop(L) == 3);
        } else {

          /* elseif o=="?" then */
          enum { lc908 = 2 };
          lua_pushliteral(L, "?");
          const int lc909 = lua_equal(L, 2, -1);
          lua_pop(L, 1);
          lua_pushboolean(L, lc909);
          const int lc910 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc910) {

            /* return e(u,t,e(ae,a)) */
            const int lc911 = lua_gettop(L);
            lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
            const int lc912 = lua_gettop(L);
            lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
            lc_getupvalue(L, lua_upvalueindex(1), 27, 53);
            lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
            lc_getupvalue(L, lua_upvalueindex(1), 14, 152);
            lua_pushvalue(L, 1);
            lua_call(L, 2, LUA_MULTRET);
            lua_call(L, (lua_gettop(L) - lc912), LUA_MULTRET);
            return (lua_gettop(L) - lc911);
            assert(lua_gettop(L) == 2);
          } else {

            /* elseif o=="/" then */
            enum { lc913 = 2 };
            lua_pushliteral(L, "/");
            const int lc914 = lua_equal(L, 2, -1);
            lua_pop(L, 1);
            lua_pushboolean(L, lc914);
            const int lc915 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc915) {

              /* local t={a} */
              lua_createtable(L, 1, 0);
              lua_pushvalue(L, 1);
              lua_rawseti(L, -2, 1);
              assert(lua_gettop(L) == 3);

              /* while true do */
              enum { lc916 = 3 };
              while (1) {
                lua_pushboolean(L, 1);
                if (!(lua_toboolean(L, -1))) {
                  break;
                }
                lua_pop(L, 1);

                /* local e=f(true) */
                lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
                lua_pushboolean(L, 1);
                lua_call(L, 1, 1);
                assert(lua_gettop(L) == 4);

                /* v(t,e) */
                lc_getupvalue(L, lua_upvalueindex(1), 29, 1);
                lua_pushvalue(L, 3);
                lua_pushvalue(L, 4);
                lua_call(L, 2, 0);
                assert(lua_gettop(L) == 4);

                /* if l() then */
                enum { lc917 = 4 };
                lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
                lua_call(L, 0, 1);
                const int lc918 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc918) {

                  /* break */
                  break;
                  assert(lua_gettop(L) == 4);
                }
                lua_settop(L, lc917);
                assert(lua_gettop(L) == 4);

                /* local e=d() */
                lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
                lua_call(L, 0, 1);
                assert(lua_gettop(L) == 5);

                /* if e~="/" then */
                enum { lc919 = 5 };
                lua_pushliteral(L, "/");
                const int lc920 = lua_equal(L, 5, -1);
                lua_pop(L, 1);
                lua_pushboolean(L, lc920);
                lua_pushboolean(L, !(lua_toboolean(L, -1)));
                lua_remove(L, -2);
                const int lc921 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc921) {

                  /* c(e) */
                  lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
                  lua_pushvalue(L, 5);
                  lua_call(L, 1, 0);
                  assert(lua_gettop(L) == 5);

                  /* break */
                  break;
                  assert(lua_gettop(L) == 5);
                }
                lua_settop(L, lc919);
                assert(lua_gettop(L) == 5);

                /* internal: stack cleanup on scope exit */
                lua_pop(L, 2);
              }
              lua_settop(L, lc916);
              assert(lua_gettop(L) == 3);

              /* return e(pe,_(t)) */
              const int lc922 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
              const int lc923 = lua_gettop(L);
              lc_getupvalue(L, lua_upvalueindex(1), 13, 153);
              lc_getupvalue(L, lua_upvalueindex(1), 27, 28);
              lua_pushvalue(L, 3);
              lua_call(L, 1, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc923), LUA_MULTRET);
              return (lua_gettop(L) - lc922);
              assert(lua_gettop(L) == 3);
            } else {

              /* else
               * c(o) */
              lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
              lua_pushvalue(L, 2);
              lua_call(L, 1, 0);
              assert(lua_gettop(L) == 2);

              /* return a */
              lua_pushvalue(L, 1);
              return 1;
              assert(lua_gettop(L) == 2);
            }
            lua_settop(L, lc913);
          }
          lua_settop(L, lc908);
        }
        lua_settop(L, lc904);
      }
      lua_settop(L, lc900);
    }
    lua_settop(L, lc896);
  }
  lua_settop(L, lc892);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: G
 * function() */
static inline int lcf2_G(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc924 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 196);
  lua_call(L, 0, 1);
  const int lc925 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc925) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc924);
  assert(lua_gettop(L) == 0);

  /* local a=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if a=="&" then */
  enum { lc926 = 1 };
  lua_pushliteral(L, "&");
  const int lc927 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc927);
  const int lc928 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc928) {

    /* A(U()) */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 179);
    const int lc929 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 178);
    lua_call(L, 0, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc929), 0);
    assert(lua_gettop(L) == 1);

    /* local t=d() */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 2);

    /* if t=="+" then */
    enum { lc930 = 2 };
    lua_pushliteral(L, "+");
    const int lc931 = lua_equal(L, 2, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc931);
    const int lc932 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc932) {

      /* local t=f() */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
      lua_call(L, 0, 1);
      assert(lua_gettop(L) == 3);

      /* return e(x,e(z,t)) */
      const int lc933 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
      const int lc934 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 52);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 54);
      lua_pushvalue(L, 3);
      lua_call(L, 2, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc934), LUA_MULTRET);
      return (lua_gettop(L) - lc933);
      assert(lua_gettop(L) == 3);
    } else {

      /* else
       * c(t) */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 0);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L, lc930);
    assert(lua_gettop(L) == 2);

    /* local t=f() */
    lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 3);

    /* return e(x,t) */
    const int lc935 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
    lc_getupvalue(L, lua_upvalueindex(1), 27, 52);
    lua_pushvalue(L, 3);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc935);
    assert(lua_gettop(L) == 3);
  } else {

    /* elseif a==":" then */
    enum { lc936 = 1 };
    lua_pushliteral(L, ":");
    const int lc937 = lua_equal(L, 1, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc937);
    const int lc938 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc938) {

      /* A(U()) */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 179);
      const int lc939 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 0, 178);
      lua_call(L, 0, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc939), 0);
      assert(lua_gettop(L) == 1);

      /* local a=d() */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 195);
      lua_call(L, 0, 1);
      assert(lua_gettop(L) == 2);

      /* if a=="&" then */
      enum { lc940 = 2 };
      lua_pushliteral(L, "&");
      const int lc941 = lua_equal(L, 2, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc941);
      const int lc942 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc942) {

        /* k(">") */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 177);
        lua_pushliteral(L, ">");
        lua_call(L, 1, 0);
        assert(lua_gettop(L) == 2);

        /* local a=f() */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
        lua_call(L, 0, 1);
        assert(lua_gettop(L) == 3);

        /* return e(u,e(x,e(t,m,a)),Y) */
        const int lc943 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
        lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
        const int lc944 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 52);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 53);
        lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
        lua_pushvalue(L, 3);
        lua_call(L, 3, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc944), 1);
        lc_getupvalue(L, lua_upvalueindex(1), 17, 149);
        lua_call(L, 3, LUA_MULTRET);
        return (lua_gettop(L) - lc943);
        assert(lua_gettop(L) == 3);
      } else {

        /* elseif a==">" then */
        enum { lc945 = 2 };
        lua_pushliteral(L, ">");
        const int lc946 = lua_equal(L, 2, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc946);
        const int lc947 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc947) {

          /* local a=f() */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
          lua_call(L, 0, 1);
          assert(lua_gettop(L) == 3);

          /* return e(u,e(t,m,a),Y) */
          const int lc948 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
          lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
          lc_getupvalue(L, lua_upvalueindex(1), 27, 53);
          lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
          lua_pushvalue(L, 3);
          lua_call(L, 3, 1);
          lc_getupvalue(L, lua_upvalueindex(1), 17, 149);
          lua_call(L, 3, LUA_MULTRET);
          return (lua_gettop(L) - lc948);
          assert(lua_gettop(L) == 3);
        } else {

          /* else
           * c(a) */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 0);
          assert(lua_gettop(L) == 2);
        }
        lua_settop(L, lc945);
      }
      lua_settop(L, lc940);
      assert(lua_gettop(L) == 2);

      /* local t=f() */
      lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
      lua_call(L, 0, 1);
      assert(lua_gettop(L) == 3);

      /* return e(u,t,Y) */
      const int lc949 = lua_gettop(L);
      lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
      lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
      lua_pushvalue(L, 3);
      lc_getupvalue(L, lua_upvalueindex(1), 17, 149);
      lua_call(L, 3, LUA_MULTRET);
      return (lua_gettop(L) - lc949);
      assert(lua_gettop(L) == 3);
    } else {

      /* elseif a=="+" then */
      enum { lc950 = 1 };
      lua_pushliteral(L, "+");
      const int lc951 = lua_equal(L, 1, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc951);
      const int lc952 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc952) {

        /* local t=f() */
        lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
        lua_call(L, 0, 1);
        assert(lua_gettop(L) == 2);

        /* return e(z,t) */
        const int lc953 = lua_gettop(L);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
        lc_getupvalue(L, lua_upvalueindex(1), 27, 54);
        lua_pushvalue(L, 2);
        lua_call(L, 2, LUA_MULTRET);
        return (lua_gettop(L) - lc953);
        assert(lua_gettop(L) == 2);
      } else {

        /* elseif a=="[" then */
        enum { lc954 = 1 };
        lua_pushliteral(L, "[");
        const int lc955 = lua_equal(L, 1, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc955);
        const int lc956 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc956) {

          /* local e=f() */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
          lua_call(L, 0, 1);
          assert(lua_gettop(L) == 2);

          /* k("]") */
          lc_getupvalue(L, lua_upvalueindex(1), 0, 177);
          lua_pushliteral(L, "]");
          lua_call(L, 1, 0);
          assert(lua_gettop(L) == 2);

          /* return K(e) */
          const int lc957 = lua_gettop(L);
          lc_getupvalue(L, lua_upvalueindex(1), 0, 175);
          lua_pushvalue(L, 2);
          lua_call(L, 1, LUA_MULTRET);
          return (lua_gettop(L) - lc957);
          assert(lua_gettop(L) == 2);
        } else {

          /* elseif a=="_" then */
          enum { lc958 = 1 };
          lua_pushliteral(L, "_");
          const int lc959 = lua_equal(L, 1, -1);
          lua_pop(L, 1);
          lua_pushboolean(L, lc959);
          const int lc960 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc960) {

            /* k(":") */
            lc_getupvalue(L, lua_upvalueindex(1), 0, 177);
            lua_pushliteral(L, ":");
            lua_call(L, 1, 0);
            assert(lua_gettop(L) == 1);

            /* local t=f() */
            lc_getupvalue(L, lua_upvalueindex(1), 0, 176);
            lua_call(L, 0, 1);
            assert(lua_gettop(L) == 2);

            /* return e(u,t,m) */
            const int lc961 = lua_gettop(L);
            lc_getupvalue(L, lua_upvalueindex(1), 27, 27);
            lc_getupvalue(L, lua_upvalueindex(1), 15, 151);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, lua_upvalueindex(1), 16, 150);
            lua_call(L, 3, LUA_MULTRET);
            return (lua_gettop(L) - lc961);
            assert(lua_gettop(L) == 2);
          } else {

            /* else
             * c(a) */
            lc_getupvalue(L, lua_upvalueindex(1), 0, 194);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 0);
            assert(lua_gettop(L) == 1);

            /* local e=B() */
            lc_getupvalue(L, lua_upvalueindex(1), 0, 190);
            lua_call(L, 0, 1);
            assert(lua_gettop(L) == 2);

            /* if e==false then */
            enum { lc962 = 2 };
            lua_pushboolean(L, 0);
            const int lc963 = lua_equal(L, 2, -1);
            lua_pop(L, 1);
            lua_pushboolean(L, lc963);
            const int lc964 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc964) {

              /* return false */
              lua_pushboolean(L, 0);
              return 1;
              assert(lua_gettop(L) == 2);
            }
            lua_settop(L, lc962);
            assert(lua_gettop(L) == 2);

            /* return K(e) */
            const int lc965 = lua_gettop(L);
            lc_getupvalue(L, lua_upvalueindex(1), 0, 175);
            lua_pushvalue(L, 2);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc965);
            assert(lua_gettop(L) == 2);
          }
          lua_settop(L, lc958);
        }
        lua_settop(L, lc954);
      }
      lua_settop(L, lc950);
    }
    lua_settop(L, lc936);
  }
  lua_settop(L, lc926);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: Q
 * function() */
static inline int lcf2_Q(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* local e=G() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 174);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e==false then */
  enum { lc966 = 1 };
  lua_pushboolean(L, 0);
  const int lc967 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc967);
  const int lc968 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc968) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc966);
  assert(lua_gettop(L) == 1);

  /* if p(e) then */
  enum { lc969 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 27, 97);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc970 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc970) {

    /* return e */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc969);
  assert(lua_gettop(L) == 1);

  /* return b(e) */
  const int lc971 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 10, 156);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc971);
  assert(lua_gettop(L) == 1);
}

/* function() */
static inline int lcf991(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc973 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 1, 196);
  lua_call(L, 0, 1);
  const int lc974 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc974) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc973);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 1, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e~=t then */
  enum { lc975 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 200);
  const int lc976 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc976);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc977 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc977) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 1, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc975);
  assert(lua_gettop(L) == 1);

  /* local e=g() */
  lc_getupvalue(L, lua_upvalueindex(1), 1, 189);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* if e==false then */
  enum { lc978 = 2 };
  lua_pushboolean(L, 0);
  const int lc979 = lua_equal(L, 2, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc979);
  const int lc980 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc980) {

    /* return r() */
    const int lc981 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc981);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc978);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc982 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 28, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc983 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc983) {

    /* return r() */
    const int lc984 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc984);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc982);
  assert(lua_gettop(L) == 2);

  /* local t=i(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 28, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 3);

  /* if not(a(t)and h(i(t))) then */
  enum { lc985 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 28, 92);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 28, 88);
    const int lc986 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 28, 90);
    lua_pushvalue(L, 3);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc986), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc987 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc987) {

    /* return r() */
    const int lc988 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc988);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc985);
  assert(lua_gettop(L) == 3);

  /* return n(o(e),o(t)) */
  const int lc989 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 201);
  const int lc990 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 91);
  lua_pushvalue(L, 3);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc990), LUA_MULTRET);
  return (lua_gettop(L) - lc989);
  assert(lua_gettop(L) == 3);
}

/* name: t
 * function(t,n) */
static inline int lcf3_t(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc972 = 3 };
  assert((lua_gettop(L) == lc972));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 200);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 201);

  /* return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local t=i(e)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return n(o(e),o(t))
   * end */
  lua_pushvalue(L, lc972);
  lua_pushcclosure(L, lcf991, 1);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* function() */
static inline int lcf1014(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* if l() then */
  enum { lc993 = 0 };
  lc_getupvalue(L, lua_upvalueindex(1), 1, 196);
  lua_call(L, 0, 1);
  const int lc994 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc994) {

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L, lc993);
  assert(lua_gettop(L) == 0);

  /* local e=d() */
  lc_getupvalue(L, lua_upvalueindex(1), 1, 195);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 1);

  /* if e~=t then */
  enum { lc995 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 202);
  const int lc996 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc996);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc997 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc997) {

    /* c(e) */
    lc_getupvalue(L, lua_upvalueindex(1), 1, 194);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    assert(lua_gettop(L) == 1);

    /* return false */
    lua_pushboolean(L, 0);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc995);
  assert(lua_gettop(L) == 1);

  /* local e=g() */
  lc_getupvalue(L, lua_upvalueindex(1), 1, 189);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* if e==false then */
  enum { lc998 = 2 };
  lua_pushboolean(L, 0);
  const int lc999 = lua_equal(L, 2, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc999);
  const int lc1000 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1000) {

    /* return r() */
    const int lc1001 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1001);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc998);
  assert(lua_gettop(L) == 2);

  /* if not a(e) then */
  enum { lc1002 = 2 };
  lc_getupvalue(L, lua_upvalueindex(1), 28, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1003 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1003) {

    /* return r() */
    const int lc1004 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1004);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc1002);
  assert(lua_gettop(L) == 2);

  /* local n=i(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 28, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 3);

  /* if not a(n) then */
  enum { lc1005 = 3 };
  lc_getupvalue(L, lua_upvalueindex(1), 28, 92);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1006 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1006) {

    /* return r() */
    const int lc1007 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1007);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc1005);
  assert(lua_gettop(L) == 3);

  /* local t=i(n) */
  lc_getupvalue(L, lua_upvalueindex(1), 28, 90);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 4);

  /* if not(a(t)and h(i(t))) then */
  enum { lc1008 = 4 };
  lc_getupvalue(L, lua_upvalueindex(1), 28, 92);
  lua_pushvalue(L, 4);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lua_upvalueindex(1), 28, 88);
    const int lc1009 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 28, 90);
    lua_pushvalue(L, 4);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc1009), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1010 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1010) {

    /* return r() */
    const int lc1011 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1011);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L, lc1008);
  assert(lua_gettop(L) == 4);

  /* return s(o(e),o(n),o(t)) */
  const int lc1012 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 203);
  const int lc1013 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 91);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 28, 91);
  lua_pushvalue(L, 4);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1013), LUA_MULTRET);
  return (lua_gettop(L) - lc1012);
  assert(lua_gettop(L) == 4);
}

/* name: s
 * function(t,s) */
static inline int lcf4_s(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc992 = 3 };
  assert((lua_gettop(L) == lc992));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 202);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 203);

  /* return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local n=i(e)
   * if not a(n)then
   * return r()
   * end
   * local t=i(n)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return s(o(e),o(n),o(t))
   * end */
  lua_pushvalue(L, lc992);
  lua_pushcclosure(L, lcf1014, 1);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* function(e,t) */
static inline int lcf1020(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* local e=he(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 3, 163);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 3);

  /* if e==false then */
  enum { lc1015 = 3 };
  lua_pushboolean(L, 0);
  const int lc1016 = lua_equal(L, 3, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc1016);
  const int lc1017 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1017) {

    /* return r() */
    const int lc1018 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1018);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc1015);
  assert(lua_gettop(L) == 3);

  /* return S(e,t) */
  const int lc1019 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 77);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1019);
  assert(lua_gettop(L) == 3);
}

/* function(e) */
static inline int lcf1021(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* function(e,e) */
static inline int lcf1023(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return r() */
  const int lc1022 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc1022);
  assert(lua_gettop(L) == 2);
}

/* function(t,e) */
static inline int lcf1025(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* local e=ke(e,function(e)return e end,function(e,e)return r()end) */
  lc_getupvalue(L, lua_upvalueindex(1), 6, 160);
  lua_pushvalue(L, 2);
  lua_pushcfunction(L, lcf1021);
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf1023, 1);
  lua_call(L, 3, 1);
  assert(lua_gettop(L) == 3);

  /* return q(t,e) */
  const int lc1024 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 68);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 3);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1024);
  assert(lua_gettop(L) == 3);
}

/* function(e) */
static inline int lcf1026(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* function(e,e) */
static inline int lcf1028(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return r() */
  const int lc1027 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc1027);
  assert(lua_gettop(L) == 2);
}

/* function(o,a,e) */
static inline int lcf1034(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);

  /* local t=ke(e,function(e)return e end,function(e,e)return r()end) */
  lc_getupvalue(L, lua_upvalueindex(1), 6, 160);
  lua_pushvalue(L, 3);
  lua_pushcfunction(L, lcf1026);
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf1028, 1);
  lua_call(L, 3, 1);
  assert(lua_gettop(L) == 4);

  /* local e=he(o) */
  lc_getupvalue(L, lua_upvalueindex(1), 3, 163);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 5);

  /* if e==false then */
  enum { lc1029 = 5 };
  lua_pushboolean(L, 0);
  const int lc1030 = lua_equal(L, 5, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc1030);
  const int lc1031 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1031) {

    /* return r() */
    const int lc1032 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1032);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc1029);
  assert(lua_gettop(L) == 5);

  /* return Oe(e,a,t) */
  const int lc1033 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 73);
  lua_pushvalue(L, 5);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 4);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc1033);
  assert(lua_gettop(L) == 5);
}

/* function(e) */
static inline int lcf1035(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return e */
  lua_pushvalue(L, 1);
  return 1;
  assert(lua_gettop(L) == 1);
}

/* function(e,e) */
static inline int lcf1037(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return r() */
  const int lc1036 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 193);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc1036);
  assert(lua_gettop(L) == 2);
}

/* function(t,e) */
static inline int lcf1039(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* local e=ke(e,function(e)return e end,function(e,e)return r()end) */
  lc_getupvalue(L, lua_upvalueindex(1), 6, 160);
  lua_pushvalue(L, 2);
  lua_pushcfunction(L, lcf1035);
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf1037, 1);
  lua_call(L, 3, 1);
  assert(lua_gettop(L) == 3);

  /* return F(t,e) */
  const int lc1038 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 64);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 3);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1038);
  assert(lua_gettop(L) == 3);
}

/* function(t,e) */
static inline int lcf1041(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return fe(t,e) */
  const int lc1040 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 27, 102);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1040);
  assert(lua_gettop(L) == 2);
}

/* name: ee
 * function(J) */
static inline int lcf1_ee(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local D,w,l,d,c,r,j,E,B,g,O,I,N,V,C,P,R,W,M,A,U,k,f,K,G,Q */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc783 = 2 };
  assert((lua_gettop(L) == lc783));
  lua_settop(L, (lua_gettop(L) + 26));
  lua_rawseti(L, lc783, 173);
  lua_rawseti(L, lc783, 174);
  lua_rawseti(L, lc783, 175);
  lua_rawseti(L, lc783, 176);
  lua_rawseti(L, lc783, 177);
  lua_rawseti(L, lc783, 178);
  lua_rawseti(L, lc783, 179);
  lua_rawseti(L, lc783, 180);
  lua_rawseti(L, lc783, 181);
  lua_rawseti(L, lc783, 182);
  lua_rawseti(L, lc783, 183);
  lua_rawseti(L, lc783, 184);
  lua_rawseti(L, lc783, 185);
  lua_rawseti(L, lc783, 186);
  lua_rawseti(L, lc783, 187);
  lua_rawseti(L, lc783, 188);
  lua_rawseti(L, lc783, 189);
  lua_rawseti(L, lc783, 190);
  lua_rawseti(L, lc783, 191);
  lua_rawseti(L, lc783, 192);
  lua_rawseti(L, lc783, 193);
  lua_rawseti(L, lc783, 194);
  lua_rawseti(L, lc783, 195);
  lua_rawseti(L, lc783, 196);
  lua_rawseti(L, lc783, 197);
  lua_rawseti(L, lc783, 198);
  assert(lua_gettop(L) == 2);

  /* function l()
   * return#D==w
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_l, 1);
  lc_setupvalue(L, lc783, 0, 196);
  assert(lua_gettop(L) == 2);

  /* function d()
   * H(not l())
   * local e=string.sub(D,w+1,w+1)
   * w=w+1
   * return e
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf8_d, 1);
  lc_setupvalue(L, lc783, 0, 195);
  assert(lua_gettop(L) == 2);

  /* function c(e)
   * H(string.sub(D,w,w)==e)
   * w=w-1
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_c, 1);
  lc_setupvalue(L, lc783, 0, 194);
  assert(lua_gettop(L) == 2);

  /* function r(e)
   * if e==nil then
   * e=""
   * end
   * error("TheLanguage parse ERROR!"..tostring(e))
   * end */
  lua_pushcfunction(L, lcf3_r);
  lc_setupvalue(L, lc783, 0, 193);
  assert(lua_gettop(L) == 2);

  /* function j(e)
   * return e==" "or e=="\n"or e=="\t"or e=="\r"
   * end */
  lua_pushcfunction(L, lcf2_j);
  lc_setupvalue(L, lc783, 0, 192);
  assert(lua_gettop(L) == 2);

  /* function E()
   * if l()then
   * return false
   * end
   * local e=d()
   * if not j(e)then
   * c(e)
   * return false
   * end
   * while j(e)and not l()do
   * e=d()
   * end
   * if not j(e)then
   * c(e)
   * end
   * return true
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_E, 1);
  lc_setupvalue(L, lc783, 0, 191);
  assert(lua_gettop(L) == 2);

  /* function B()
   * if l()then
   * return false
   * end
   * local e=d()
   * local t=""
   * if not W(e)then
   * c(e)
   * return false
   * end
   * while W(e)and not l()do
   * t=tostring(t)..tostring(e)
   * e=d()
   * end
   * if W(e)then
   * t=tostring(t)..tostring(e)
   * else
   * c(e)
   * end
   * if Xe(t)then
   * return n(t)
   * else
   * return r("Not Atom"..tostring(t))
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_B, 1);
  lc_setupvalue(L, lc783, 0, 190);
  assert(lua_gettop(L) == 2);

  /* function g()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="("then
   * c(e)
   * return false
   * end
   * local t=ge()
   * local a=t
   * local function o(a)
   * local e=ge()
   * we(t,s(a,e))
   * t=e
   * end
   * while true do
   * E()
   * if l()then
   * return r()
   * end
   * e=d()
   * if e==")"then
   * we(t,y)
   * return a
   * end
   * if e=="."then
   * E()
   * local o=M()
   * we(t,o)
   * E()
   * if l()then
   * return r()
   * end
   * e=d()
   * if e~=")"then
   * return r()
   * end
   * return a
   * end
   * c(e)
   * local e=M()
   * o(e)
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_g, 1);
  lc_setupvalue(L, lc783, 0, 189);
  assert(lua_gettop(L) == 2);

  /* function O()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="#"then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * return T(o(e),i(e))
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_O, 1);
  lc_setupvalue(L, lc783, 0, 188);
  assert(lua_gettop(L) == 2);

  /* function I()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="!"then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * return L(o(e),i(e))
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_I, 1);
  lc_setupvalue(L, lc783, 0, 187);
  assert(lua_gettop(L) == 2);

  /* function W(e)
   * if j(e)then
   * return false
   * end
   * for a,t in ipairs({
   * "(",
   * ")",
   * "!",
   * "#",
   * ".",
   * "$",
   * "%",
   * "^",
   * "@",
   * "~",
   * "/",
   * "-",
   * ">",
   * "_",
   * ":",
   * "?",
   * "[",
   * "]",
   * "&",
   * ";",
   * })do
   * if t==e then
   * return false
   * end
   * end
   * return true
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_W, 1);
  lc_setupvalue(L, lc783, 0, 181);
  assert(lua_gettop(L) == 2);

  /* function M()
   * E()
   * local e={
   * g,
   * Q,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * for t,e in ipairs(e)do
   * local e=e()
   * if e~=false then
   * return e
   * end
   * end
   * return r()
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf3_M, 1);
  lc_setupvalue(L, lc783, 0, 180);
  assert(lua_gettop(L) == 2);

  /* function A(e)
   * if e==false then
   * return r()
   * end
   * return e
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_A, 1);
  lc_setupvalue(L, lc783, 0, 179);
  assert(lua_gettop(L) == 2);

  /* function U()
   * return not l()
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_U, 1);
  lc_setupvalue(L, lc783, 0, 178);
  assert(lua_gettop(L) == 2);

  /* function k(e)
   * A(U())
   * A(d()==e)
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_k, 1);
  lc_setupvalue(L, lc783, 0, 177);
  assert(lua_gettop(L) == 2);

  /* function f(t)
   * if t==nil then
   * t=false
   * end
   * local function a()
   * k("[")
   * local e=f()
   * k("]")
   * return e
   * end
   * local e
   * if t then
   * e={
   * g,
   * B,
   * a,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * else
   * e={
   * g,
   * G,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * end
   * for t,e in ipairs(e)do
   * local e=e()
   * if e~=false then
   * return e
   * end
   * end
   * return r()
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_f, 1);
  lc_setupvalue(L, lc783, 0, 176);
  assert(lua_gettop(L) == 2);

  /* function K(a)
   * if l()then
   * return a
   * end
   * local o=d()
   * if o=="."then
   * local o=f()
   * return e(u,e(t,e(a),m),o)
   * elseif o==":"then
   * local t=f()
   * return e(u,t,a)
   * elseif o=="~"then
   * return e(ae,a)
   * elseif o=="@"then
   * local o=f()
   * return e(u,e(t,s(a,m),m),o)
   * elseif o=="?"then
   * return e(u,t,e(ae,a))
   * elseif o=="/"then
   * local t={a}
   * while true do
   * local e=f(true)
   * v(t,e)
   * if l()then
   * break
   * end
   * local e=d()
   * if e~="/"then
   * c(e)
   * break
   * end
   * end
   * return e(pe,_(t))
   * else
   * c(o)
   * return a
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_K, 1);
  lc_setupvalue(L, lc783, 0, 175);
  assert(lua_gettop(L) == 2);

  /* function G()
   * if l()then
   * return false
   * end
   * local a=d()
   * if a=="&"then
   * A(U())
   * local t=d()
   * if t=="+"then
   * local t=f()
   * return e(x,e(z,t))
   * else
   * c(t)
   * end
   * local t=f()
   * return e(x,t)
   * elseif a==":"then
   * A(U())
   * local a=d()
   * if a=="&"then
   * k(">")
   * local a=f()
   * return e(u,e(x,e(t,m,a)),Y)
   * elseif a==">"then
   * local a=f()
   * return e(u,e(t,m,a),Y)
   * else
   * c(a)
   * end
   * local t=f()
   * return e(u,t,Y)
   * elseif a=="+"then
   * local t=f()
   * return e(z,t)
   * elseif a=="["then
   * local e=f()
   * k("]")
   * return K(e)
   * elseif a=="_"then
   * k(":")
   * local t=f()
   * return e(u,t,m)
   * else
   * c(a)
   * local e=B()
   * if e==false then
   * return false
   * end
   * return K(e)
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_G, 1);
  lc_setupvalue(L, lc783, 0, 174);
  assert(lua_gettop(L) == 2);

  /* function Q()
   * local e=G()
   * if e==false then
   * return false
   * end
   * if p(e)then
   * return e
   * end
   * return b(e)
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf2_Q, 1);
  lc_setupvalue(L, lc783, 0, 173);
  assert(lua_gettop(L) == 2);

  /* D=J */
  lua_pushvalue(L, 1);
  lc_setupvalue(L, lc783, 0, 198);
  assert(lua_gettop(L) == 2);

  /* w=0 */
  lua_pushnumber(L, 0);
  lc_setupvalue(L, lc783, 0, 197);
  assert(lua_gettop(L) == 2);

  /* local function t(t,n)
   * return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local t=i(e)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return n(o(e),o(t))
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf3_t, 1);
  assert(lua_gettop(L) == 3);

  /* local function s(t,s)
   * return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local n=i(e)
   * if not a(n)then
   * return r()
   * end
   * local t=i(n)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return s(o(e),o(n),o(t))
   * end
   * end */
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf4_s, 1);
  assert(lua_gettop(L) == 4);

  /* N=t("$",function(e,t)
   * local e=he(e)
   * if e==false then
   * return r()
   * end
   * return S(e,t)
   * end) */
  lua_pushvalue(L, 3);
  lua_pushliteral(L, "$");
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf1020, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, lc783, 0, 186);
  assert(lua_gettop(L) == 4);

  /* V=t("%",function(t,e)
   * local e=ke(e,function(e)return e end,function(e,e)return r()end)
   * return q(t,e)
   * end) */
  lua_pushvalue(L, 3);
  lua_pushliteral(L, "%");
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf1025, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, lc783, 0, 185);
  assert(lua_gettop(L) == 4);

  /* C=s("@",function(o,a,e)
   * local t=ke(e,function(e)return e end,function(e,e)return r()end)
   * local e=he(o)
   * if e==false then
   * return r()
   * end
   * return Oe(e,a,t)
   * end) */
  lua_pushvalue(L, 4);
  lua_pushliteral(L, "@");
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf1034, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, lc783, 0, 184);
  assert(lua_gettop(L) == 4);

  /* P=t("^",function(t,e)
   * local e=ke(e,function(e)return e end,function(e,e)return r()end)
   * return F(t,e)
   * end) */
  lua_pushvalue(L, 3);
  lua_pushliteral(L, "^");
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf1039, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, lc783, 0, 183);
  assert(lua_gettop(L) == 4);

  /* R=t(";",function(t,e)return fe(t,e)end) */
  lua_pushvalue(L, 3);
  lua_pushliteral(L, ";");
  lua_pushvalue(L, lc783);
  lua_pushcclosure(L, lcf1041, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, lc783, 0, 182);
  assert(lua_gettop(L) == 4);

  /* return M() */
  const int lc1042 = lua_gettop(L);
  lc_getupvalue(L, lc783, 0, 180);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc1042);
  assert(lua_gettop(L) == 4);
}

/* name: s
 * function(e) */
static inline int lcf5_s(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if l then */
  enum { lc1049 = 1 };
  lc_getupvalue(L, lua_upvalueindex(1), 0, 206);
  const int lc1050 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1050) {

    /* return"["..tostring(e).."]" */
    lua_pushliteral(L, "[");
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushliteral(L, "]");
    lua_concat(L, 2);
    lua_concat(L, 2);
    return 1;
    assert(lua_gettop(L) == 1);
  } else {

    /* else
     * return e */
    lua_pushvalue(L, 1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc1049);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: n
 * function(r,l) */
static inline int lcf8_n(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1045 = 3 };
  assert((lua_gettop(L) == lc1045));
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 206);

  /* if p(r) then */
  enum { lc1046 = 3 };
  lc_getupvalue(L, lc1045, 29, 97);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc1047 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1047) {

    /* return de(r) */
    const int lc1048 = lua_gettop(L);
    lc_getupvalue(L, lc1045, 29, 95);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc1048);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc1046);
  assert(lua_gettop(L) == 3);

  /* local function s(e)
   * if l then
   * return"["..tostring(e).."]"
   * else
   * return e
   * end
   * end */
  lua_pushvalue(L, lc1045);
  lua_pushcclosure(L, lcf5_s, 1);
  assert(lua_gettop(L) == 4);

  /* local e=M(r) */
  lc_getupvalue(L, lc1045, 7, 161);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 5);

  /* if e~=false and#e==3 and d(e[1],u) then */
  enum { lc1051 = 5 };
  lua_pushboolean(L, 0);
  const int lc1052 = lua_equal(L, 5, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc1052);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    const double lc1053 = lua_objlen(L, 5);
    lua_pushnumber(L, lc1053);
    lua_pushnumber(L, 3);
    const int lc1054 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc1054);
  }
  if (lua_toboolean(L, -1)) {
    lua_pop(L, 1);
    lc_getupvalue(L, lc1045, 4, 171);
    lua_pushnumber(L, 1);
    lua_gettable(L, 5);
    lc_getupvalue(L, lc1045, 17, 151);
    lua_call(L, 2, 1);
  }
  const int lc1055 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1055) {

    /* local h=M(e[2]) */
    lc_getupvalue(L, lc1045, 7, 161);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 6);

    /* if h~=false and#h==3 and d(h[1],t) then */
    enum { lc1056 = 6 };
    lua_pushboolean(L, 0);
    const int lc1057 = lua_equal(L, 6, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc1057);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      const double lc1058 = lua_objlen(L, 6);
      lua_pushnumber(L, lc1058);
      lua_pushnumber(L, 3);
      const int lc1059 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc1059);
    }
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 1);
      lua_gettable(L, 6);
      lc_getupvalue(L, lc1045, 29, 53);
      lua_call(L, 2, 1);
    }
    const int lc1060 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1060) {

      /* local t=h[2] */
      lua_pushnumber(L, 2);
      lua_gettable(L, 6);
      assert(lua_gettop(L) == 7);

      /* local r=M(t) */
      lc_getupvalue(L, lc1045, 7, 161);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      assert(lua_gettop(L) == 8);

      /* if r~=false and#r==1 and d(h[3],m) then */
      enum { lc1061 = 8 };
      lua_pushboolean(L, 0);
      const int lc1062 = lua_equal(L, 8, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc1062);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      if (lua_toboolean(L, -1)) {
        lua_pop(L, 1);
        const double lc1063 = lua_objlen(L, 8);
        lua_pushnumber(L, lc1063);
        lua_pushnumber(L, 1);
        const int lc1064 = lua_equal(L, -2, -1);
        lua_pop(L, 2);
        lua_pushboolean(L, lc1064);
      }
      if (lua_toboolean(L, -1)) {
        lua_pop(L, 1);
        lc_getupvalue(L, lc1045, 4, 171);
        lua_pushnumber(L, 3);
        lua_gettable(L, 6);
        lc_getupvalue(L, lc1045, 18, 150);
        lua_call(L, 2, 1);
      }
      const int lc1065 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1065) {

        /* return s(tostring(n(r[1],true)).."."..tostring(n(e[3],true))) */
        const int lc1066 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1067 = lua_gettop(L);
        lc_getupvalue(L, lc1045, 1, 205);
        lua_pushnumber(L, 1);
        lua_gettable(L, 8);
        lua_pushboolean(L, 1);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1067), 1);
        lua_pushliteral(L, ".");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1068 = lua_gettop(L);
        lc_getupvalue(L, lc1045, 1, 205);
        lua_pushnumber(L, 3);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1068), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc1066);
        assert(lua_gettop(L) == 8);
      } else {

        /* elseif a(t)and d(i(t),m)and d(h[3],m) then */
        enum { lc1069 = 8 };
        lc_getupvalue(L, lc1045, 29, 92);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          lc_getupvalue(L, lc1045, 4, 171);
          lc_getupvalue(L, lc1045, 29, 90);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lc_getupvalue(L, lc1045, 18, 150);
          lua_call(L, 2, 1);
        }
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          lc_getupvalue(L, lc1045, 4, 171);
          lua_pushnumber(L, 3);
          lua_gettable(L, 6);
          lc_getupvalue(L, lc1045, 18, 150);
          lua_call(L, 2, 1);
        }
        const int lc1070 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1070) {

          /* return s(tostring(n(o(t),true)).."@"..tostring(n(e[3],true))) */
          const int lc1071 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc1072 = lua_gettop(L);
          lc_getupvalue(L, lc1045, 1, 205);
          lc_getupvalue(L, lc1045, 29, 91);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lua_pushboolean(L, 1);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1072), 1);
          lua_pushliteral(L, "@");
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc1073 = lua_gettop(L);
          lc_getupvalue(L, lc1045, 1, 205);
          lua_pushnumber(L, 3);
          lua_gettable(L, 5);
          lua_pushboolean(L, 1);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1073), 1);
          lua_concat(L, 2);
          lua_concat(L, 2);
          lua_call(L, 1, LUA_MULTRET);
          return (lua_gettop(L) - lc1071);
          assert(lua_gettop(L) == 8);
        } else {

          /* elseif d(t,m)and d(e[3],Y) then */
          enum { lc1074 = 8 };
          lc_getupvalue(L, lc1045, 4, 171);
          lua_pushvalue(L, 7);
          lc_getupvalue(L, lc1045, 18, 150);
          lua_call(L, 2, 1);
          if (lua_toboolean(L, -1)) {
            lua_pop(L, 1);
            lc_getupvalue(L, lc1045, 4, 171);
            lua_pushnumber(L, 3);
            lua_gettable(L, 5);
            lc_getupvalue(L, lc1045, 19, 149);
            lua_call(L, 2, 1);
          }
          const int lc1075 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1075) {

            /* return s(":>"..tostring(n(h[3],true))) */
            const int lc1076 = lua_gettop(L);
            lua_pushvalue(L, 4);
            lua_pushliteral(L, ":>");
            lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
            const int lc1077 = lua_gettop(L);
            lc_getupvalue(L, lc1045, 1, 205);
            lua_pushnumber(L, 3);
            lua_gettable(L, 6);
            lua_pushboolean(L, 1);
            lua_call(L, 2, LUA_MULTRET);
            lua_call(L, (lua_gettop(L) - lc1077), 1);
            lua_concat(L, 2);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc1076);
            assert(lua_gettop(L) == 8);
          }
          lua_settop(L, lc1074);
        }
        lua_settop(L, lc1069);
      }
      lua_settop(L, lc1061);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L, lc1056);
    assert(lua_gettop(L) == 6);

    /* local a=M(e[3]) */
    lc_getupvalue(L, lc1045, 7, 161);
    lua_pushnumber(L, 3);
    lua_gettable(L, 5);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 7);

    /* if d(e[2],t)and a~=false and#a==2 and d(a[1],ae) then */
    enum { lc1078 = 7 };
    lc_getupvalue(L, lc1045, 4, 171);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lc_getupvalue(L, lc1045, 29, 53);
    lua_call(L, 2, 1);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lua_pushboolean(L, 0);
      const int lc1079 = lua_equal(L, 7, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc1079);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      const double lc1080 = lua_objlen(L, 7);
      lua_pushnumber(L, lc1080);
      lua_pushnumber(L, 2);
      const int lc1081 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc1081);
    }
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 1);
      lua_gettable(L, 7);
      lc_getupvalue(L, lc1045, 16, 152);
      lua_call(L, 2, 1);
    }
    const int lc1082 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1082) {

      /* return s(tostring(n(a[2],true)).."?") */
      const int lc1083 = lua_gettop(L);
      lua_pushvalue(L, 4);
      lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
      const int lc1084 = lua_gettop(L);
      lc_getupvalue(L, lc1045, 1, 205);
      lua_pushnumber(L, 2);
      lua_gettable(L, 7);
      lua_pushboolean(L, 1);
      lua_call(L, 2, LUA_MULTRET);
      lua_call(L, (lua_gettop(L) - lc1084), 1);
      lua_pushliteral(L, "?");
      lua_concat(L, 2);
      lua_call(L, 1, LUA_MULTRET);
      return (lua_gettop(L) - lc1083);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L, lc1078);
    assert(lua_gettop(L) == 7);

    /* if h~=false and#h==2 and d(e[3],Y)and d(h[1],x) then */
    enum { lc1085 = 7 };
    lua_pushboolean(L, 0);
    const int lc1086 = lua_equal(L, 6, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc1086);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      const double lc1087 = lua_objlen(L, 6);
      lua_pushnumber(L, lc1087);
      lua_pushnumber(L, 2);
      const int lc1088 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc1088);
    }
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 3);
      lua_gettable(L, 5);
      lc_getupvalue(L, lc1045, 19, 149);
      lua_call(L, 2, 1);
    }
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 1);
      lua_gettable(L, 6);
      lc_getupvalue(L, lc1045, 29, 52);
      lua_call(L, 2, 1);
    }
    const int lc1089 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1089) {

      /* local e=M(h[2]) */
      lc_getupvalue(L, lc1045, 7, 161);
      lua_pushnumber(L, 2);
      lua_gettable(L, 6);
      lua_call(L, 1, 1);
      assert(lua_gettop(L) == 8);

      /* if e~=false and#e==3 and d(e[1],t)and d(e[2],m) then */
      enum { lc1090 = 8 };
      lua_pushboolean(L, 0);
      const int lc1091 = lua_equal(L, 8, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc1091);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      if (lua_toboolean(L, -1)) {
        lua_pop(L, 1);
        const double lc1092 = lua_objlen(L, 8);
        lua_pushnumber(L, lc1092);
        lua_pushnumber(L, 3);
        const int lc1093 = lua_equal(L, -2, -1);
        lua_pop(L, 2);
        lua_pushboolean(L, lc1093);
      }
      if (lua_toboolean(L, -1)) {
        lua_pop(L, 1);
        lc_getupvalue(L, lc1045, 4, 171);
        lua_pushnumber(L, 1);
        lua_gettable(L, 8);
        lc_getupvalue(L, lc1045, 29, 53);
        lua_call(L, 2, 1);
      }
      if (lua_toboolean(L, -1)) {
        lua_pop(L, 1);
        lc_getupvalue(L, lc1045, 4, 171);
        lua_pushnumber(L, 2);
        lua_gettable(L, 8);
        lc_getupvalue(L, lc1045, 18, 150);
        lua_call(L, 2, 1);
      }
      const int lc1094 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1094) {

        /* return s(":&>"..tostring(n(e[3],true))) */
        const int lc1095 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_pushliteral(L, ":&>");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1096 = lua_gettop(L);
        lc_getupvalue(L, lc1045, 1, 205);
        lua_pushnumber(L, 3);
        lua_gettable(L, 8);
        lua_pushboolean(L, 1);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1096), 1);
        lua_concat(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc1095);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L, lc1090);
      assert(lua_gettop(L) == 8);
    }
    lua_settop(L, lc1085);
    assert(lua_gettop(L) == 7);

    /* local t */
    lua_settop(L, (lua_gettop(L) + 1));
    assert(lua_gettop(L) == 8);

    /* if d(e[3],m) then */
    enum { lc1097 = 8 };
    lc_getupvalue(L, lc1045, 4, 171);
    lua_pushnumber(L, 3);
    lua_gettable(L, 5);
    lc_getupvalue(L, lc1045, 18, 150);
    lua_call(L, 2, 1);
    const int lc1098 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1098) {

      /* t="_" */
      lua_pushliteral(L, "_");
      lua_replace(L, 8);
      assert(lua_gettop(L) == 8);
    } else {

      /* elseif d(e[3],Y) then */
      enum { lc1099 = 8 };
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 3);
      lua_gettable(L, 5);
      lc_getupvalue(L, lc1045, 19, 149);
      lua_call(L, 2, 1);
      const int lc1100 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1100) {

        /* t="" */
        lua_pushliteral(L, "");
        lua_replace(L, 8);
        assert(lua_gettop(L) == 8);
      } else {

        /* else
         * t=n(e[3],true) */
        lc_getupvalue(L, lc1045, 1, 205);
        lua_pushnumber(L, 3);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, 1);
        lua_replace(L, 8);
        assert(lua_gettop(L) == 8);
      }
      lua_settop(L, lc1099);
    }
    lua_settop(L, lc1097);
    assert(lua_gettop(L) == 8);

    /* return s(tostring(t)..":"..tostring(n(e[2],true))) */
    const int lc1101 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    lua_pushliteral(L, ":");
    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
    const int lc1102 = lua_gettop(L);
    lc_getupvalue(L, lc1045, 1, 205);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lua_pushboolean(L, 1);
    lua_call(L, 2, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc1102), 1);
    lua_concat(L, 2);
    lua_concat(L, 2);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc1101);
    assert(lua_gettop(L) == 8);
  } else {

    /* elseif e~=false and#e==2 then */
    enum { lc1103 = 5 };
    lua_pushboolean(L, 0);
    const int lc1104 = lua_equal(L, 5, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc1104);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_pop(L, 1);
      const double lc1105 = lua_objlen(L, 5);
      lua_pushnumber(L, lc1105);
      lua_pushnumber(L, 2);
      const int lc1106 = lua_equal(L, -2, -1);
      lua_pop(L, 2);
      lua_pushboolean(L, lc1106);
    }
    const int lc1107 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1107) {

      /* if d(e[1],x) then */
      enum { lc1108 = 5 };
      lc_getupvalue(L, lc1045, 4, 171);
      lua_pushnumber(L, 1);
      lua_gettable(L, 5);
      lc_getupvalue(L, lc1045, 29, 52);
      lua_call(L, 2, 1);
      const int lc1109 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1109) {

        /* local t=M(e[2]) */
        lc_getupvalue(L, lc1045, 7, 161);
        lua_pushnumber(L, 2);
        lua_gettable(L, 5);
        lua_call(L, 1, 1);
        assert(lua_gettop(L) == 6);

        /* if t~=false and#t==2 and d(t[1],z) then */
        enum { lc1110 = 6 };
        lua_pushboolean(L, 0);
        const int lc1111 = lua_equal(L, 6, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc1111);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          const double lc1112 = lua_objlen(L, 6);
          lua_pushnumber(L, lc1112);
          lua_pushnumber(L, 2);
          const int lc1113 = lua_equal(L, -2, -1);
          lua_pop(L, 2);
          lua_pushboolean(L, lc1113);
        }
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          lc_getupvalue(L, lc1045, 4, 171);
          lua_pushnumber(L, 1);
          lua_gettable(L, 6);
          lc_getupvalue(L, lc1045, 29, 54);
          lua_call(L, 2, 1);
        }
        const int lc1114 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1114) {

          /* return s("&+"..tostring(n(t[2],true))) */
          const int lc1115 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_pushliteral(L, "&+");
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc1116 = lua_gettop(L);
          lc_getupvalue(L, lc1045, 1, 205);
          lua_pushnumber(L, 2);
          lua_gettable(L, 6);
          lua_pushboolean(L, 1);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1116), 1);
          lua_concat(L, 2);
          lua_call(L, 1, LUA_MULTRET);
          return (lua_gettop(L) - lc1115);
          assert(lua_gettop(L) == 6);
        }
        lua_settop(L, lc1110);
        assert(lua_gettop(L) == 6);

        /* return s("&"..tostring(n(e[2],true))) */
        const int lc1117 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_pushliteral(L, "&");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1118 = lua_gettop(L);
        lc_getupvalue(L, lc1045, 1, 205);
        lua_pushnumber(L, 2);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1118), 1);
        lua_concat(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc1117);
        assert(lua_gettop(L) == 6);
      } else {

        /* elseif d(e[1],ae) then */
        enum { lc1119 = 5 };
        lc_getupvalue(L, lc1045, 4, 171);
        lua_pushnumber(L, 1);
        lua_gettable(L, 5);
        lc_getupvalue(L, lc1045, 16, 152);
        lua_call(L, 2, 1);
        const int lc1120 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1120) {

          /* return s(tostring(n(e[2],true)).."~") */
          const int lc1121 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc1122 = lua_gettop(L);
          lc_getupvalue(L, lc1045, 1, 205);
          lua_pushnumber(L, 2);
          lua_gettable(L, 5);
          lua_pushboolean(L, 1);
          lua_call(L, 2, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1122), 1);
          lua_pushliteral(L, "~");
          lua_concat(L, 2);
          lua_call(L, 1, LUA_MULTRET);
          return (lua_gettop(L) - lc1121);
          assert(lua_gettop(L) == 5);
        } else {

          /* elseif d(e[1],z) then */
          enum { lc1123 = 5 };
          lc_getupvalue(L, lc1045, 4, 171);
          lua_pushnumber(L, 1);
          lua_gettable(L, 5);
          lc_getupvalue(L, lc1045, 29, 54);
          lua_call(L, 2, 1);
          const int lc1124 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1124) {

            /* return s("+"..tostring(n(e[2],true))) */
            const int lc1125 = lua_gettop(L);
            lua_pushvalue(L, 4);
            lua_pushliteral(L, "+");
            lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
            const int lc1126 = lua_gettop(L);
            lc_getupvalue(L, lc1045, 1, 205);
            lua_pushnumber(L, 2);
            lua_gettable(L, 5);
            lua_pushboolean(L, 1);
            lua_call(L, 2, LUA_MULTRET);
            lua_call(L, (lua_gettop(L) - lc1126), 1);
            lua_concat(L, 2);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc1125);
            assert(lua_gettop(L) == 5);
          } else {

            /* elseif d(e[1],pe) then */
            enum { lc1127 = 5 };
            lc_getupvalue(L, lc1045, 4, 171);
            lua_pushnumber(L, 1);
            lua_gettable(L, 5);
            lc_getupvalue(L, lc1045, 15, 153);
            lua_call(L, 2, 1);
            const int lc1128 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc1128) {

              /* local e=M(e[2]) */
              lc_getupvalue(L, lc1045, 7, 161);
              lua_pushnumber(L, 2);
              lua_gettable(L, 5);
              lua_call(L, 1, 1);
              assert(lua_gettop(L) == 6);

              /* if e~=false and#e>1 then */
              enum { lc1129 = 6 };
              lua_pushboolean(L, 0);
              const int lc1130 = lua_equal(L, 6, -1);
              lua_pop(L, 1);
              lua_pushboolean(L, lc1130);
              lua_pushboolean(L, !(lua_toboolean(L, -1)));
              lua_remove(L, -2);
              if (lua_toboolean(L, -1)) {
                lua_pop(L, 1);
                lua_pushnumber(L, 1);
                const double lc1131 = lua_objlen(L, 6);
                lua_pushnumber(L, lc1131);
                const int lc1132 = lua_lessthan(L, -2, -1);
                lua_pop(L, 2);
                lua_pushboolean(L, lc1132);
              }
              const int lc1133 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc1133) {

                /* local a=n(e[1],true) */
                lc_getupvalue(L, lc1045, 1, 205);
                lua_pushnumber(L, 1);
                lua_gettable(L, 6);
                lua_pushboolean(L, 1);
                lua_call(L, 2, 1);
                assert(lua_gettop(L) == 7);

                /* do
                 * local t=1 */
                lua_pushnumber(L, 1);
                assert(lua_gettop(L) == 8);

                /* while t<#e do */
                enum { lc1134 = 8 };
                while (1) {
                  const double lc1135 = lua_objlen(L, 6);
                  lua_pushnumber(L, lc1135);
                  const int lc1136 = lua_lessthan(L, 8, -1);
                  lua_pop(L, 1);
                  lua_pushboolean(L, lc1136);
                  if (!(lua_toboolean(L, -1))) {
                    break;
                  }
                  lua_pop(L, 1);

                  /* a=tostring(a).."/"..tostring(n(e[t+1],true)) */
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  lua_pushvalue(L, 7);
                  lua_call(L, 1, 1);
                  lua_pushliteral(L, "/");
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  const int lc1137 = lua_gettop(L);
                  lc_getupvalue(L, lc1045, 1, 205);
                  lua_pushnumber(L, 1);
                  lc_add(L, 8, -1);
                  lua_remove(L, -2);
                  lua_gettable(L, 6);
                  lua_pushboolean(L, 1);
                  lua_call(L, 2, LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1137), 1);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_replace(L, 7);
                  assert(lua_gettop(L) == 8);

                  /* t=t+1 */
                  lua_pushnumber(L, 1);
                  lc_add(L, 8, -1);
                  lua_remove(L, -2);
                  lua_replace(L, 8);
                  assert(lua_gettop(L) == 8);
                }
                lua_settop(L, lc1134);
                assert(lua_gettop(L) == 8);

                /* internal: stack cleanup on scope exit */
                lua_pop(L, 1);
                assert(lua_gettop(L) == 7);

                /* return s(a) */
                const int lc1138 = lua_gettop(L);
                lua_pushvalue(L, 4);
                lua_pushvalue(L, 7);
                lua_call(L, 1, LUA_MULTRET);
                return (lua_gettop(L) - lc1138);
                assert(lua_gettop(L) == 7);
              }
              lua_settop(L, lc1129);
              assert(lua_gettop(L) == 6);
            }
            lua_settop(L, lc1127);
          }
          lua_settop(L, lc1123);
        }
        lua_settop(L, lc1119);
      }
      lua_settop(L, lc1108);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L, lc1103);
  }
  lua_settop(L, lc1051);
  assert(lua_gettop(L) == 5);

  /* if l then */
  enum { lc1139 = 5 };
  lc_getupvalue(L, lc1045, 0, 206);
  const int lc1140 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1140) {

    /* return f(r) */
    const int lc1141 = lua_gettop(L);
    lc_getupvalue(L, lc1045, 29, 3);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc1141);
    assert(lua_gettop(L) == 5);
  } else {

    /* else
     * return f(b(r)) */
    const int lc1142 = lua_gettop(L);
    lc_getupvalue(L, lc1045, 29, 3);
    const int lc1143 = lua_gettop(L);
    lc_getupvalue(L, lc1045, 12, 156);
    lua_pushvalue(L, 1);
    lua_call(L, 1, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc1143), LUA_MULTRET);
    return (lua_gettop(L) - lc1142);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L, lc1139);
  assert(lua_gettop(L) == 5);
  return 0;
}

/* name: q
 * function(w) */
static inline int lcf2_q(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local function n(r,l)
   * if p(r)then
   * return de(r)
   * end
   * local function s(e)
   * if l then
   * return"["..tostring(e).."]"
   * else
   * return e
   * end
   * end
   * local e=M(r)
   * if e~=false and#e==3 and d(e[1],u)then
   * local h=M(e[2])
   * if h~=false and#h==3 and d(h[1],t)then
   * local t=h[2]
   * local r=M(t)
   * if r~=false and#r==1 and d(h[3],m)then
   * return s(tostring(n(r[1],true)).."."..tostring(n(e[3],true)))
   * elseif a(t)and d(i(t),m)and d(h[3],m)then
   * return s(tostring(n(o(t),true)).."@"..tostring(n(e[3],true)))
   * elseif d(t,m)and d(e[3],Y)then
   * return s(":>"..tostring(n(h[3],true)))
   * end
   * end
   * local a=M(e[3])
   * if d(e[2],t)and a~=false and#a==2 and d(a[1],ae)then
   * return s(tostring(n(a[2],true)).."?")
   * end
   * if h~=false and#h==2 and d(e[3],Y)and d(h[1],x)then
   * local e=M(h[2])
   * if e~=false and#e==3 and d(e[1],t)and d(e[2],m)then
   * return s(":&>"..tostring(n(e[3],true)))
   * end
   * end
   * local t
   * if d(e[3],m)then
   * t="_"
   * elseif d(e[3],Y)then
   * t=""
   * else
   * t=n(e[3],true)
   * end
   * return s(tostring(t)..":"..tostring(n(e[2],true)))
   * elseif e~=false and#e==2 then
   * if d(e[1],x)then
   * local t=M(e[2])
   * if t~=false and#t==2 and d(t[1],z)then
   * return s("&+"..tostring(n(t[2],true)))
   * end
   * return s("&"..tostring(n(e[2],true)))
   * elseif d(e[1],ae)then
   * return s(tostring(n(e[2],true)).."~")
   * elseif d(e[1],z)then
   * return s("+"..tostring(n(e[2],true)))
   * elseif d(e[1],pe)then
   * local e=M(e[2])
   * if e~=false and#e>1 then
   * local a=n(e[1],true)
   * do
   * local t=1
   * while t<#e do
   * a=tostring(a).."/"..tostring(n(e[t+1],true))
   * t=t+1
   * end
   * end
   * return s(a)
   * end
   * end
   * end
   * if l then
   * return f(r)
   * else
   * return f(b(r))
   * end
   * end */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1044 = 2 };
  assert((lua_gettop(L) == lc1044));
  lua_pushvalue(L, lc1044);
  lua_pushcclosure(L, lcf8_n, 1);
  lua_rawseti(L, lc1044, 205);
  assert(lua_gettop(L) == 2);

  /* local e=ee(f(w)) */
  lc_getupvalue(L, lc1044, 2, 172);
  const int lc1144 = lua_gettop(L);
  lc_getupvalue(L, lc1044, 28, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1144), 1);
  assert(lua_gettop(L) == 3);

  /* local t="" */
  lua_pushliteral(L, "");
  assert(lua_gettop(L) == 4);

  /* local r="" */
  lua_pushliteral(L, "");
  assert(lua_gettop(L) == 5);

  /* if h(e) then */
  enum { lc1145 = 5 };
  lc_getupvalue(L, lc1044, 28, 88);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  const int lc1146 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1146) {

    /* return"()" */
    lua_pushliteral(L, "()");
    return 1;
    assert(lua_gettop(L) == 5);
  } else {

    /* elseif a(e) then */
    enum { lc1147 = 5 };
    lc_getupvalue(L, lc1044, 28, 92);
    lua_pushvalue(L, 3);
    lua_call(L, 1, 1);
    const int lc1148 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1148) {

      /* t="(" */
      lua_pushliteral(L, "(");
      lua_replace(L, 4);
      assert(lua_gettop(L) == 5);

      /* r="" */
      lua_pushliteral(L, "");
      lua_replace(L, 5);
      assert(lua_gettop(L) == 5);

      /* while a(e)do */
      enum { lc1149 = 5 };
      while (1) {
        lc_getupvalue(L, lc1044, 28, 92);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* t=tostring(t)..tostring(r)..tostring(q(o(e))) */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 5);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1150 = lua_gettop(L);
        lc_getupvalue(L, lc1044, 1, 204);
        const int lc1151 = lua_gettop(L);
        lc_getupvalue(L, lc1044, 28, 91);
        lua_pushvalue(L, 3);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1151), LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1150), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 4);
        assert(lua_gettop(L) == 5);

        /* r=" " */
        lua_pushliteral(L, " ");
        lua_replace(L, 5);
        assert(lua_gettop(L) == 5);

        /* e=i(e) */
        lc_getupvalue(L, lc1044, 28, 90);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lua_replace(L, 3);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc1149);
      assert(lua_gettop(L) == 5);

      /* if h(e) then */
      enum { lc1152 = 5 };
      lc_getupvalue(L, lc1044, 28, 88);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      const int lc1153 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1153) {

        /* t=tostring(t)..")" */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_pushliteral(L, ")");
        lua_concat(L, 2);
        lua_replace(L, 4);
        assert(lua_gettop(L) == 5);
      } else {

        /* else
         * t=tostring(t).." . "..tostring(q(e))..")" */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_pushliteral(L, " . ");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1154 = lua_gettop(L);
        lc_getupvalue(L, lc1044, 1, 204);
        lua_pushvalue(L, 3);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1154), 1);
        lua_pushliteral(L, ")");
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 4);
        assert(lua_gettop(L) == 5);
      }
      lua_settop(L, lc1152);
      assert(lua_gettop(L) == 5);

      /* return t */
      lua_pushvalue(L, 4);
      return 1;
      assert(lua_gettop(L) == 5);
    } else {

      /* elseif c(e) then */
      enum { lc1155 = 5 };
      lc_getupvalue(L, lc1044, 28, 86);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      const int lc1156 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1156) {

        /* local t=E(e) */
        lc_getupvalue(L, lc1044, 28, 85);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        assert(lua_gettop(L) == 6);

        /* local a=A(e) */
        lc_getupvalue(L, lc1044, 28, 84);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        assert(lua_gettop(L) == 7);

        /* local e=M(a) */
        lc_getupvalue(L, lc1044, 6, 161);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        assert(lua_gettop(L) == 8);

        /* if e~=false and#e==2 and d(t,ye)and d(e[1],z) then */
        enum { lc1157 = 8 };
        lua_pushboolean(L, 0);
        const int lc1158 = lua_equal(L, 8, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc1158);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          const double lc1159 = lua_objlen(L, 8);
          lua_pushnumber(L, lc1159);
          lua_pushnumber(L, 2);
          const int lc1160 = lua_equal(L, -2, -1);
          lua_pop(L, 2);
          lua_pushboolean(L, lc1160);
        }
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          lc_getupvalue(L, lc1044, 3, 171);
          lua_pushvalue(L, 6);
          lc_getupvalue(L, lc1044, 19, 148);
          lua_call(L, 2, 1);
        }
        if (lua_toboolean(L, -1)) {
          lua_pop(L, 1);
          lc_getupvalue(L, lc1044, 3, 171);
          lua_pushnumber(L, 1);
          lua_gettable(L, 8);
          lc_getupvalue(L, lc1044, 28, 54);
          lua_call(L, 2, 1);
        }
        const int lc1161 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1161) {

          /* return n(e[2],false) */
          const int lc1162 = lua_gettop(L);
          lc_getupvalue(L, lc1044, 0, 205);
          lua_pushnumber(L, 2);
          lua_gettable(L, 8);
          lua_pushboolean(L, 0);
          lua_call(L, 2, LUA_MULTRET);
          return (lua_gettop(L) - lc1162);
          assert(lua_gettop(L) == 8);
        }
        lua_settop(L, lc1157);
        assert(lua_gettop(L) == 8);

        /* return"#"..tostring(q(s(t,a))) */
        lua_pushliteral(L, "#");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1163 = lua_gettop(L);
        lc_getupvalue(L, lc1044, 1, 204);
        const int lc1164 = lua_gettop(L);
        lc_getupvalue(L, lc1044, 28, 93);
        lua_pushvalue(L, 6);
        lua_pushvalue(L, 7);
        lua_call(L, 2, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1164), LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1163), 1);
        lua_concat(L, 2);
        return 1;
        assert(lua_gettop(L) == 8);
      } else {

        /* elseif g(e) then */
        enum { lc1165 = 5 };
        lc_getupvalue(L, lc1044, 28, 82);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        const int lc1166 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1166) {

          /* return"!"..tostring(q(s(C(e),U(e)))) */
          lua_pushliteral(L, "!");
          lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
          const int lc1167 = lua_gettop(L);
          lc_getupvalue(L, lc1044, 1, 204);
          const int lc1168 = lua_gettop(L);
          lc_getupvalue(L, lc1044, 28, 93);
          const int lc1169 = lua_gettop(L);
          lc_getupvalue(L, lc1044, 28, 81);
          lua_pushvalue(L, 3);
          lua_call(L, 1, 1);
          lc_getupvalue(L, lc1044, 28, 80);
          lua_pushvalue(L, 3);
          lua_call(L, 1, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1169), LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1168), LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1167), 1);
          lua_concat(L, 2);
          return 1;
          assert(lua_gettop(L) == 5);
        } else {

          /* elseif p(e) then */
          enum { lc1170 = 5 };
          lc_getupvalue(L, lc1044, 28, 97);
          lua_pushvalue(L, 3);
          lua_call(L, 1, 1);
          const int lc1171 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1171) {

            /* return de(e) */
            const int lc1172 = lua_gettop(L);
            lc_getupvalue(L, lc1044, 28, 95);
            lua_pushvalue(L, 3);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc1172);
            assert(lua_gettop(L) == 5);
          } else {

            /* elseif I(e) then */
            enum { lc1173 = 5 };
            lc_getupvalue(L, lc1044, 28, 101);
            lua_pushvalue(L, 3);
            lua_call(L, 1, 1);
            const int lc1174 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc1174) {

              /* return";("..tostring(q(oe(e))).." "..tostring(q(K(e)))..")" */
              lua_pushliteral(L, ";(");
              lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
              const int lc1175 = lua_gettop(L);
              lc_getupvalue(L, lc1044, 1, 204);
              const int lc1176 = lua_gettop(L);
              lc_getupvalue(L, lc1044, 28, 100);
              lua_pushvalue(L, 3);
              lua_call(L, 1, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc1176), LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc1175), 1);
              lua_pushliteral(L, " ");
              lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
              const int lc1177 = lua_gettop(L);
              lc_getupvalue(L, lc1044, 1, 204);
              const int lc1178 = lua_gettop(L);
              lc_getupvalue(L, lc1044, 28, 99);
              lua_pushvalue(L, 3);
              lua_call(L, 1, LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc1178), LUA_MULTRET);
              lua_call(L, (lua_gettop(L) - lc1177), 1);
              lua_pushliteral(L, ")");
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              return 1;
              assert(lua_gettop(L) == 5);
            } else {

              /* elseif Q(e) then */
              enum { lc1179 = 5 };
              lc_getupvalue(L, lc1044, 28, 76);
              lua_pushvalue(L, 3);
              lua_call(L, 1, 1);
              const int lc1180 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc1180) {

                /* return"$("..tostring(q(R(X(e)))).." "..tostring(q(Z(e)))..")"
                 */
                lua_pushliteral(L, "$(");
                lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                const int lc1181 = lua_gettop(L);
                lc_getupvalue(L, lc1044, 1, 204);
                const int lc1182 = lua_gettop(L);
                lc_getupvalue(L, lc1044, 28, 15);
                const int lc1183 = lua_gettop(L);
                lc_getupvalue(L, lc1044, 28, 75);
                lua_pushvalue(L, 3);
                lua_call(L, 1, LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc1183), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc1182), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc1181), 1);
                lua_pushliteral(L, " ");
                lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                const int lc1184 = lua_gettop(L);
                lc_getupvalue(L, lc1044, 1, 204);
                const int lc1185 = lua_gettop(L);
                lc_getupvalue(L, lc1044, 28, 74);
                lua_pushvalue(L, 3);
                lua_call(L, 1, LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc1185), LUA_MULTRET);
                lua_call(L, (lua_gettop(L) - lc1184), 1);
                lua_pushliteral(L, ")");
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                return 1;
                assert(lua_gettop(L) == 5);
              } else {

                /* elseif P(e) then */
                enum { lc1186 = 5 };
                lc_getupvalue(L, lc1044, 28, 67);
                lua_pushvalue(L, 3);
                lua_call(L, 1, 1);
                const int lc1187 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc1187) {

                  /* return"%("..tostring(q(ue(e))).."
                   * "..tostring(q(_(re(e))))..")" */
                  lua_pushliteral(L, "%(");
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  const int lc1188 = lua_gettop(L);
                  lc_getupvalue(L, lc1044, 1, 204);
                  const int lc1189 = lua_gettop(L);
                  lc_getupvalue(L, lc1044, 28, 66);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1189), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1188), 1);
                  lua_pushliteral(L, " ");
                  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                  const int lc1190 = lua_gettop(L);
                  lc_getupvalue(L, lc1044, 1, 204);
                  const int lc1191 = lua_gettop(L);
                  lc_getupvalue(L, lc1044, 28, 28);
                  const int lc1192 = lua_gettop(L);
                  lc_getupvalue(L, lc1044, 28, 65);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1192), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1191), LUA_MULTRET);
                  lua_call(L, (lua_gettop(L) - lc1190), 1);
                  lua_pushliteral(L, ")");
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  return 1;
                  assert(lua_gettop(L) == 5);
                } else {

                  /* elseif G(e) then */
                  enum { lc1193 = 5 };
                  lc_getupvalue(L, lc1044, 28, 72);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, 1);
                  const int lc1194 = lua_toboolean(L, -1);
                  lua_pop(L, 1);
                  if (lc1194) {

                    /* return"@("..tostring(q(R(_e(e)))).."
                     * "..tostring(q(Te(e))).." "..tostring(q(_(ze(e))))..")" */
                    lua_pushliteral(L, "@(");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc1195 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 1, 204);
                    const int lc1196 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 28, 15);
                    const int lc1197 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 28, 71);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1197), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1196), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1195), 1);
                    lua_pushliteral(L, " ");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc1198 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 1, 204);
                    const int lc1199 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 28, 70);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1199), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1198), 1);
                    lua_pushliteral(L, " ");
                    lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                    const int lc1200 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 1, 204);
                    const int lc1201 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 28, 28);
                    const int lc1202 = lua_gettop(L);
                    lc_getupvalue(L, lc1044, 28, 69);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1202), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1201), LUA_MULTRET);
                    lua_call(L, (lua_gettop(L) - lc1200), 1);
                    lua_pushliteral(L, ")");
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    return 1;
                    assert(lua_gettop(L) == 5);
                  } else {

                    /* elseif V(e) then */
                    enum { lc1203 = 5 };
                    lc_getupvalue(L, lc1044, 28, 63);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, 1);
                    const int lc1204 = lua_toboolean(L, -1);
                    lua_pop(L, 1);
                    if (lc1204) {

                      /* return"^("..tostring(q(je(e))).."
                       * "..tostring(q(_(xe(e))))..")" */
                      lua_pushliteral(L, "^(");
                      lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                      const int lc1205 = lua_gettop(L);
                      lc_getupvalue(L, lc1044, 1, 204);
                      const int lc1206 = lua_gettop(L);
                      lc_getupvalue(L, lc1044, 28, 62);
                      lua_pushvalue(L, 3);
                      lua_call(L, 1, LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc1206), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc1205), 1);
                      lua_pushliteral(L, " ");
                      lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
                      const int lc1207 = lua_gettop(L);
                      lc_getupvalue(L, lc1044, 1, 204);
                      const int lc1208 = lua_gettop(L);
                      lc_getupvalue(L, lc1044, 28, 28);
                      const int lc1209 = lua_gettop(L);
                      lc_getupvalue(L, lc1044, 28, 61);
                      lua_pushvalue(L, 3);
                      lua_call(L, 1, LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc1209), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc1208), LUA_MULTRET);
                      lua_call(L, (lua_gettop(L) - lc1207), 1);
                      lua_pushliteral(L, ")");
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      lua_concat(L, 2);
                      return 1;
                      assert(lua_gettop(L) == 5);
                    }
                    lua_settop(L, lc1203);
                  }
                  lua_settop(L, lc1193);
                }
                lua_settop(L, lc1186);
              }
              lua_settop(L, lc1179);
            }
            lua_settop(L, lc1173);
          }
          lua_settop(L, lc1170);
        }
        lua_settop(L, lc1165);
      }
      lua_settop(L, lc1155);
    }
    lua_settop(L, lc1147);
  }
  lua_settop(L, lc1145);
  assert(lua_gettop(L) == 5);

  /* return j() */
  const int lc1210 = lua_gettop(L);
  lc_getupvalue(L, lc1044, 28, 117);
  lua_call(L, 0, LUA_MULTRET);
  return (lua_gettop(L) - lc1210);
  assert(lua_gettop(L) == 5);
}

/* name: n
 * function() */
static inline int lcf9_n(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return e==0 */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 210);
  lua_pushnumber(L, 0);
  const int lc1213 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc1213);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: t
 * function() */
static inline int lcf4_t(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return not n() */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 209);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: a
 * function(e) */
static inline int lcf5_a(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if e==nil then */
  enum { lc1216 = 1 };
  lua_pushnil(L);
  const int lc1217 = lua_equal(L, 1, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc1217);
  const int lc1218 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1218) {

    /* e="" */
    lua_pushliteral(L, "");
    lua_replace(L, 1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc1216);
  assert(lua_gettop(L) == 1);

  /* error("MT parse ERROR "..tostring(e)) */
  lua_getfield(L, LUA_ENVIRONINDEX, "error");
  lua_pushliteral(L, "MT parse ERROR ");
  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: i
 * function(e) */
static inline int lcf2_i(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* if not e then */
  enum { lc1220 = 1 };
  lua_pushboolean(L, !(lua_toboolean(L, 1)));
  const int lc1221 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1221) {

    /* return a() */
    const int lc1222 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 1, 211);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1222);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L, lc1220);
  assert(lua_gettop(L) == 1);
  return 0;
}

/* name: h
 * function() */
static inline int lcf2_h(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* i(t()) */
  lc_getupvalue(L, lua_upvalueindex(1), 0, 212);
  const int lc1223 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 208);
  lua_call(L, 0, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1223), 0);
  assert(lua_gettop(L) == 0);

  /* e=e-1 */
  lc_getupvalue(L, lua_upvalueindex(1), 2, 210);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, lua_upvalueindex(1), 2, 210);
  assert(lua_gettop(L) == 0);

  /* return string.sub(o,e+1,e+1) */
  const int lc1224 = lua_gettop(L);
  lua_getfield(L, LUA_ENVIRONINDEX, "string");
  lua_pushliteral(L, "sub");
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 207);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 210);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 210);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc1224);
  assert(lua_gettop(L) == 0);
}

/* name: o
 * function(i) */
static inline int lcf5_o(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local o=table.remove(e) */
  lua_getfield(L, LUA_ENVIRONINDEX, "table");
  lua_pushliteral(L, "remove");
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 213);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 2);

  /* local t=table.remove(e) */
  lua_getfield(L, LUA_ENVIRONINDEX, "table");
  lua_pushliteral(L, "remove");
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 213);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 3);

  /* if t==nil or o==nil then */
  enum { lc1226 = 3 };
  lua_pushvalue(L, 3);
  lua_pushnil(L);
  const int lc1227 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc1227);
  if (!(lua_toboolean(L, -1))) {
    lua_pop(L, 1);
    lua_pushvalue(L, 2);
    lua_pushnil(L);
    const int lc1228 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc1228);
  }
  const int lc1229 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1229) {

    /* return a() */
    const int lc1230 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 2, 211);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1230);
    assert(lua_gettop(L) == 3);
  } else {

    /* else
     * return Ne(e,i(t,o)) */
    const int lc1231 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 33, 2);
    const int lc1232 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 0, 213);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, LUA_MULTRET);
    lua_call(L, (lua_gettop(L) - lc1232), LUA_MULTRET);
    return (lua_gettop(L) - lc1231);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc1226);
  assert(lua_gettop(L) == 3);
  return 0;
}

/* function(e,t) */
static inline int lcf1262(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* local e=he(e) */
  lc_getupvalue(L, lua_upvalueindex(1), 8, 163);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  assert(lua_gettop(L) == 3);

  /* if e==false then */
  enum { lc1257 = 3 };
  lua_pushboolean(L, 0);
  const int lc1258 = lua_equal(L, 3, -1);
  lua_pop(L, 1);
  lua_pushboolean(L, lc1258);
  const int lc1259 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1259) {

    /* return a() */
    const int lc1260 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 2, 211);
    lua_call(L, 0, LUA_MULTRET);
    return (lua_gettop(L) - lc1260);
    assert(lua_gettop(L) == 3);
  } else {

    /* else
     * return S(e,t) */
    const int lc1261 = lua_gettop(L);
    lc_getupvalue(L, lua_upvalueindex(1), 32, 77);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, LUA_MULTRET);
    return (lua_gettop(L) - lc1261);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L, lc1257);
  assert(lua_gettop(L) == 3);
  return 0;
}

/* name: H
 * function(o) */
static inline int lcf2_H(lua_State *L) {
  lua_checkstack(L, 21);
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1211 = 2 };
  assert((lua_gettop(L) == lc1211));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 207);

  /* local e,n,t */
  lc_newclosuretable(L, lc1211);
  enum { lc1212 = 3 };
  assert((lua_gettop(L) == lc1212));
  lua_settop(L, (lua_gettop(L) + 3));
  lua_rawseti(L, lc1212, 208);
  lua_rawseti(L, lc1212, 209);
  lua_rawseti(L, lc1212, 210);
  assert(lua_gettop(L) == 3);

  /* function n()
   * return e==0
   * end */
  lua_pushvalue(L, lc1212);
  lua_pushcclosure(L, lcf9_n, 1);
  lc_setupvalue(L, lc1212, 0, 209);
  assert(lua_gettop(L) == 3);

  /* function t()
   * return not n()
   * end */
  lua_pushvalue(L, lc1212);
  lua_pushcclosure(L, lcf4_t, 1);
  lc_setupvalue(L, lc1212, 0, 208);
  assert(lua_gettop(L) == 3);

  /* e=#o */
  lc_getupvalue(L, lc1212, 1, 207);
  const double lc1214 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc1214);
  lc_setupvalue(L, lc1212, 0, 210);
  assert(lua_gettop(L) == 3);

  /* local function a(e)
   * if e==nil then
   * e=""
   * end
   * error("MT parse ERROR "..tostring(e))
   * end */
  lc_newclosuretable(L, lc1212);
  enum { lc1215 = 4 };
  assert((lua_gettop(L) == lc1215));
  lua_pushcfunction(L, lcf5_a);
  lua_rawseti(L, lc1215, 211);
  assert(lua_gettop(L) == 4);

  /* local function i(e)
   * if not e then
   * return a()
   * end
   * end */
  lc_newclosuretable(L, lc1215);
  enum { lc1219 = 5 };
  assert((lua_gettop(L) == lc1219));
  lua_pushvalue(L, lc1219);
  lua_pushcclosure(L, lcf2_i, 1);
  lua_rawseti(L, lc1219, 212);
  assert(lua_gettop(L) == 5);

  /* local function h()
   * i(t())
   * e=e-1
   * return string.sub(o,e+1,e+1)
   * end */
  lua_pushvalue(L, lc1219);
  lua_pushcclosure(L, lcf2_h, 1);
  assert(lua_gettop(L) == 6);

  /* local e={} */
  lc_newclosuretable(L, lc1219);
  enum { lc1225 = 7 };
  assert((lua_gettop(L) == lc1225));
  lua_newtable(L);
  lua_rawseti(L, lc1225, 213);
  assert(lua_gettop(L) == 7);

  /* local function o(i)
   * local o=table.remove(e)
   * local t=table.remove(e)
   * if t==nil or o==nil then
   * return a()
   * else
   * return Ne(e,i(t,o))
   * end
   * end */
  lua_pushvalue(L, lc1225);
  lua_pushcclosure(L, lcf5_o, 1);
  assert(lua_gettop(L) == 8);

  /* while t()do */
  enum { lc1233 = 8 };
  while (1) {
    lc_getupvalue(L, lc1225, 3, 208);
    lua_call(L, 0, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* local t=h() */
    lua_pushvalue(L, 6);
    lua_call(L, 0, 1);
    assert(lua_gettop(L) == 9);

    /* if t=="^" then */
    enum { lc1234 = 9 };
    lua_pushliteral(L, "^");
    const int lc1235 = lua_equal(L, 9, -1);
    lua_pop(L, 1);
    lua_pushboolean(L, lc1235);
    const int lc1236 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1236) {

      /* local t="" */
      lua_pushliteral(L, "");
      assert(lua_gettop(L) == 10);

      /* while true do */
      enum { lc1237 = 10 };
      while (1) {
        lua_pushboolean(L, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_pop(L, 1);

        /* local e=h() */
        lua_pushvalue(L, 6);
        lua_call(L, 0, 1);
        assert(lua_gettop(L) == 11);

        /* if e=="^" then */
        enum { lc1238 = 11 };
        lua_pushliteral(L, "^");
        const int lc1239 = lua_equal(L, 11, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc1239);
        const int lc1240 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1240) {

          /* break */
          break;
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L, lc1238);
        assert(lua_gettop(L) == 11);

        /* t=tostring(e)..tostring(t) */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 11);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 10);
        lua_call(L, 1, 1);
        lua_concat(L, 2);
        lua_replace(L, 10);
        assert(lua_gettop(L) == 11);

        /* internal: stack cleanup on scope exit */
        lua_pop(L, 1);
      }
      lua_settop(L, lc1237);
      assert(lua_gettop(L) == 10);

      /* if rt(t) then */
      enum { lc1241 = 10 };
      lc_getupvalue(L, lc1225, 28, 143);
      lua_pushvalue(L, 10);
      lua_call(L, 1, 1);
      const int lc1242 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1242) {

        /* Ne(e,Ze(t)) */
        lc_getupvalue(L, lc1225, 33, 2);
        const int lc1243 = lua_gettop(L);
        lc_getupvalue(L, lc1225, 0, 213);
        lc_getupvalue(L, lc1225, 27, 144);
        lua_pushvalue(L, 10);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1243), 0);
        assert(lua_gettop(L) == 10);
      } else {

        /* else
         * return a("can_new_atom_unicodechar_p(\""..tostring(t).."\") ==
         * false") */
        const int lc1244 = lua_gettop(L);
        lc_getupvalue(L, lc1225, 2, 211);
        lua_pushliteral(L, "can_new_atom_unicodechar_p(\"");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushvalue(L, 10);
        lua_call(L, 1, 1);
        lua_pushliteral(L, "\") == false");
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_call(L, 1, LUA_MULTRET);
        return (lua_gettop(L) - lc1244);
        assert(lua_gettop(L) == 10);
      }
      lua_settop(L, lc1241);
      assert(lua_gettop(L) == 10);
    } else {

      /* elseif t=="." then */
      enum { lc1245 = 9 };
      lua_pushliteral(L, ".");
      const int lc1246 = lua_equal(L, 9, -1);
      lua_pop(L, 1);
      lua_pushboolean(L, lc1246);
      const int lc1247 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1247) {

        /* o(s) */
        lua_pushvalue(L, 8);
        lc_getupvalue(L, lc1225, 32, 93);
        lua_call(L, 1, 0);
        assert(lua_gettop(L) == 9);
      } else {

        /* elseif t=="#" then */
        enum { lc1248 = 9 };
        lua_pushliteral(L, "#");
        const int lc1249 = lua_equal(L, 9, -1);
        lua_pop(L, 1);
        lua_pushboolean(L, lc1249);
        const int lc1250 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1250) {

          /* o(T) */
          lua_pushvalue(L, 8);
          lc_getupvalue(L, lc1225, 32, 87);
          lua_call(L, 1, 0);
          assert(lua_gettop(L) == 9);
        } else {

          /* elseif t=="!" then */
          enum { lc1251 = 9 };
          lua_pushliteral(L, "!");
          const int lc1252 = lua_equal(L, 9, -1);
          lua_pop(L, 1);
          lua_pushboolean(L, lc1252);
          const int lc1253 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1253) {

            /* o(L) */
            lua_pushvalue(L, 8);
            lc_getupvalue(L, lc1225, 32, 83);
            lua_call(L, 1, 0);
            assert(lua_gettop(L) == 9);
          } else {

            /* elseif t=="$" then */
            enum { lc1254 = 9 };
            lua_pushliteral(L, "$");
            const int lc1255 = lua_equal(L, 9, -1);
            lua_pop(L, 1);
            lua_pushboolean(L, lc1255);
            const int lc1256 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc1256) {

              /* o(function(e,t)
               * local e=he(e)
               * if e==false then
               * return a()
               * else
               * return S(e,t)
               * end
               * end) */
              lua_pushvalue(L, 8);
              lua_pushvalue(L, lc1225);
              lua_pushcclosure(L, lcf1262, 1);
              lua_call(L, 1, 0);
              assert(lua_gettop(L) == 9);
            } else {

              /* elseif t=="_" then */
              enum { lc1263 = 9 };
              lua_pushliteral(L, "_");
              const int lc1264 = lua_equal(L, 9, -1);
              lua_pop(L, 1);
              lua_pushboolean(L, lc1264);
              const int lc1265 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc1265) {

                /* Ne(e,y) */
                lc_getupvalue(L, lc1225, 33, 2);
                lc_getupvalue(L, lc1225, 0, 213);
                lc_getupvalue(L, lc1225, 32, 89);
                lua_call(L, 2, 0);
                assert(lua_gettop(L) == 9);
              } else {

                /* else
                 * return a() */
                const int lc1266 = lua_gettop(L);
                lc_getupvalue(L, lc1225, 2, 211);
                lua_call(L, 0, LUA_MULTRET);
                return (lua_gettop(L) - lc1266);
                assert(lua_gettop(L) == 9);
              }
              lua_settop(L, lc1263);
            }
            lua_settop(L, lc1254);
          }
          lua_settop(L, lc1251);
        }
        lua_settop(L, lc1248);
      }
      lua_settop(L, lc1245);
    }
    lua_settop(L, lc1234);
    assert(lua_gettop(L) == 9);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc1233);
  assert(lua_gettop(L) == 8);

  /* i(n()) */
  lc_getupvalue(L, lc1225, 1, 212);
  const int lc1267 = lua_gettop(L);
  lc_getupvalue(L, lc1225, 3, 209);
  lua_call(L, 0, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1267), 0);
  assert(lua_gettop(L) == 8);

  /* i(#e==1) */
  lc_getupvalue(L, lc1225, 1, 212);
  lc_getupvalue(L, lc1225, 0, 213);
  const double lc1268 = lua_objlen(L, -1);
  lua_pop(L, 1);
  lua_pushnumber(L, lc1268);
  lua_pushnumber(L, 1);
  const int lc1269 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc1269);
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 8);

  /* return e[1] */
  lc_getupvalue(L, lc1225, 0, 213);
  lua_pushnumber(L, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  return 1;
  assert(lua_gettop(L) == 8);
}

/* name: n
 * function(e,i,a,o) */
static inline int lcf10_n(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* t=tostring(t)..tostring(i) */
  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
  lc_getupvalue(L, lua_upvalueindex(1), 1, 214);
  lua_call(L, 1, 1);
  lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lc_setupvalue(L, lua_upvalueindex(1), 1, 214);
  assert(lua_gettop(L) == 4);

  /* return v(r,a(e),o(e)) */
  const int lc1276 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 31, 1);
  const int lc1277 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 215);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1277), LUA_MULTRET);
  return (lua_gettop(L) - lc1276);
  assert(lua_gettop(L) == 4);
}

/* function(e) */
static inline int lcf1293(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return R(X(e)) */
  const int lc1291 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 29, 15);
  const int lc1292 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 29, 75);
  lua_pushvalue(L, 1);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1292), LUA_MULTRET);
  return (lua_gettop(L) - lc1291);
  assert(lua_gettop(L) == 1);
}

/* name: O
 * function(e) */
static inline int lcf3_O(lua_State *L) {
  lua_checkstack(L, 21);
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local s={e} */
  lua_createtable(L, 1, 0);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 1);
  assert(lua_gettop(L) == 2);

  /* local t="" */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1270 = 3 };
  assert((lua_gettop(L) == lc1270));
  lua_pushliteral(L, "");
  lua_rawseti(L, lc1270, 214);
  assert(lua_gettop(L) == 3);

  /* while#s~=0 do */
  enum { lc1271 = 3 };
  while (1) {
    const double lc1272 = lua_objlen(L, 2);
    lua_pushnumber(L, lc1272);
    lua_pushnumber(L, 0);
    const int lc1273 = lua_equal(L, -2, -1);
    lua_pop(L, 2);
    lua_pushboolean(L, lc1273);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* local r={} */
    lc_newclosuretable(L, lc1270);
    enum { lc1274 = 4 };
    assert((lua_gettop(L) == lc1274));
    lua_newtable(L);
    lua_rawseti(L, lc1274, 215);
    assert(lua_gettop(L) == 4);

    /* for n,e in ipairs(s)do
     * internal: local f, s, var = explist */
    enum { lc1275 = 4 };
    lua_getfield(L, LUA_ENVIRONINDEX, "ipairs");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 3);
    while (1) {

      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_call(L, 2, 2);
      if (lua_isnil(L, -2)) {
        break;
      }
      lua_pushvalue(L, -2);
      lua_replace(L, -4);

      /* internal: local n with idx 8
       * internal: local e with idx 9 */

      /* e=N(e) */
      lc_getupvalue(L, lc1274, 29, 26);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      lua_replace(L, 9);
      assert(lua_gettop(L) == 9);

      /* local function n(e,i,a,o)
       * t=tostring(t)..tostring(i)
       * return v(r,a(e),o(e))
       * end */
      lua_pushvalue(L, lc1274);
      lua_pushcclosure(L, lcf10_n, 1);
      assert(lua_gettop(L) == 10);

      /* if p(e) then */
      enum { lc1278 = 10 };
      lc_getupvalue(L, lc1274, 29, 97);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      const int lc1279 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1279) {

        /* t=tostring(t)..tostring(("^"..tostring(le(e)).."^")) */
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lc_getupvalue(L, lc1274, 1, 214);
        lua_call(L, 1, 1);
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        lua_pushliteral(L, "^");
        lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
        const int lc1280 = lua_gettop(L);
        lc_getupvalue(L, lc1274, 29, 96);
        lua_pushvalue(L, 9);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1280), 1);
        lua_pushliteral(L, "^");
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_call(L, 1, 1);
        lua_concat(L, 2);
        lc_setupvalue(L, lc1274, 1, 214);
        assert(lua_gettop(L) == 10);
      } else {

        /* elseif a(e) then */
        enum { lc1281 = 10 };
        lc_getupvalue(L, lc1274, 29, 92);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        const int lc1282 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1282) {

          /* n(e,".",o,i) */
          lua_pushvalue(L, 10);
          lua_pushvalue(L, 9);
          lua_pushliteral(L, ".");
          lc_getupvalue(L, lc1274, 29, 91);
          lc_getupvalue(L, lc1274, 29, 90);
          lua_call(L, 4, 0);
          assert(lua_gettop(L) == 10);
        } else {

          /* elseif h(e) then */
          enum { lc1283 = 10 };
          lc_getupvalue(L, lc1274, 29, 88);
          lua_pushvalue(L, 9);
          lua_call(L, 1, 1);
          const int lc1284 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1284) {

            /* t=tostring(t)..tostring(("_")) */
            lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
            lc_getupvalue(L, lc1274, 1, 214);
            lua_call(L, 1, 1);
            lua_getfield(L, LUA_ENVIRONINDEX, "tostring");
            lua_pushliteral(L, "_");
            lua_call(L, 1, 1);
            lua_concat(L, 2);
            lc_setupvalue(L, lc1274, 1, 214);
            assert(lua_gettop(L) == 10);
          } else {

            /* elseif c(e) then */
            enum { lc1285 = 10 };
            lc_getupvalue(L, lc1274, 29, 86);
            lua_pushvalue(L, 9);
            lua_call(L, 1, 1);
            const int lc1286 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc1286) {

              /* n(e,"#",E,A) */
              lua_pushvalue(L, 10);
              lua_pushvalue(L, 9);
              lua_pushliteral(L, "#");
              lc_getupvalue(L, lc1274, 29, 85);
              lc_getupvalue(L, lc1274, 29, 84);
              lua_call(L, 4, 0);
              assert(lua_gettop(L) == 10);
            } else {

              /* elseif g(e) then */
              enum { lc1287 = 10 };
              lc_getupvalue(L, lc1274, 29, 82);
              lua_pushvalue(L, 9);
              lua_call(L, 1, 1);
              const int lc1288 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc1288) {

                /* n(e,"!",C,U) */
                lua_pushvalue(L, 10);
                lua_pushvalue(L, 9);
                lua_pushliteral(L, "!");
                lc_getupvalue(L, lc1274, 29, 81);
                lc_getupvalue(L, lc1274, 29, 80);
                lua_call(L, 4, 0);
                assert(lua_gettop(L) == 10);
              } else {

                /* elseif me(e) then */
                enum { lc1289 = 10 };
                lc_getupvalue(L, lc1274, 29, 25);
                lua_pushvalue(L, 9);
                lua_call(L, 1, 1);
                const int lc1290 = lua_toboolean(L, -1);
                lua_pop(L, 1);
                if (lc1290) {

                  /* local e=Ae(e) */
                  lc_getupvalue(L, lc1274, 6, 162);
                  lua_pushvalue(L, 9);
                  lua_call(L, 1, 1);
                  assert(lua_gettop(L) == 11);

                  /* n(e,"$",(function(e)return R(X(e))end),Z) */
                  lua_pushvalue(L, 10);
                  lua_pushvalue(L, 11);
                  lua_pushliteral(L, "$");
                  lua_pushvalue(L, lc1274);
                  lua_pushcclosure(L, lcf1293, 1);
                  lc_getupvalue(L, lc1274, 29, 74);
                  lua_call(L, 4, 0);
                  assert(lua_gettop(L) == 11);
                } else {

                  /* else
                   * return j() */
                  const int lc1294 = lua_gettop(L);
                  lc_getupvalue(L, lc1274, 29, 117);
                  lua_call(L, 0, LUA_MULTRET);
                  return (lua_gettop(L) - lc1294);
                  assert(lua_gettop(L) == 10);
                }
                lua_settop(L, lc1289);
              }
              lua_settop(L, lc1287);
            }
            lua_settop(L, lc1285);
          }
          lua_settop(L, lc1283);
        }
        lua_settop(L, lc1281);
      }
      lua_settop(L, lc1278);
      assert(lua_gettop(L) == 10);

      /* internal: stack cleanup on scope exit */
      lua_pop(L, 3);
    }
    lua_settop(L, lc1275);
    assert(lua_gettop(L) == 4);

    /* s=r */
    lc_getupvalue(L, lc1274, 0, 215);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 4);

    /* internal: stack cleanup on scope exit */
    lua_pop(L, 1);
  }
  lua_settop(L, lc1271);
  assert(lua_gettop(L) == 3);

  /* return t */
  lc_getupvalue(L, lc1270, 0, 214);
  return 1;
  assert(lua_gettop(L) == 3);
}

/* function() */
static inline int lcf1297(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return{
   * false,
   * e,
   * } */
  lua_createtable(L, 2, 0);
  lua_pushboolean(L, 0);
  lua_rawseti(L, -2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 217);
  lua_rawseti(L, -2, 2);
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: j
 * function(e) */
static inline int lcf3_j(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1296 = 2 };
  assert((lua_gettop(L) == lc1296));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 217);

  /* return function()return{
   * false,
   * e,
   * }end */
  lua_pushvalue(L, lc1296);
  lua_pushcclosure(L, lcf1297, 1);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* function() */
static inline int lcf1301(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return{
   * true,
   * e(),
   * } */
  lua_createtable(L, 2, 0);
  lua_pushboolean(L, 1);
  lua_rawseti(L, -2, 1);
  const int lc1300 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 219);
  lua_call(L, 0, LUA_MULTRET);
  while ((lua_gettop(L) > lc1300)) {
    lua_rawseti(L, lc1300, (1 + (lua_gettop(L) - lc1300)));
  }
  return 1;
  assert(lua_gettop(L) == 0);
}

/* name: d
 * function(e) */
static inline int lcf9_d(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1299 = 2 };
  assert((lua_gettop(L) == lc1299));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 219);

  /* return function()return{
   * true,
   * e(),
   * }end */
  lua_pushvalue(L, lc1299);
  lua_pushcclosure(L, lcf1301, 1);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: z
 * function(e) */
static inline int lcf1_z(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* local e=e() */
  lua_pushvalue(L, 1);
  lua_call(L, 0, 1);
  assert(lua_gettop(L) == 2);

  /* while e[1]do */
  enum { lc1303 = 2 };
  while (1) {
    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_pop(L, 1);

    /* e=e[2]() */
    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    lua_call(L, 0, 1);
    lua_replace(L, 2);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L, lc1303);
  assert(lua_gettop(L) == 2);

  /* return e[2] */
  lua_pushnumber(L, 2);
  lua_gettable(L, 2);
  return 1;
  assert(lua_gettop(L) == 2);
}

/* name: P
 * function(a,t) */
static inline int lcf2_P(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return T(b,e(a,t)) */
  const int lc1314 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 32, 87);
  const int lc1315 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 222);
  lc_getupvalue(L, lua_upvalueindex(1), 32, 27);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1315), LUA_MULTRET);
  return (lua_gettop(L) - lc1314);
  assert(lua_gettop(L) == 2);
}

/* name: Y
 * function(e) */
static inline int lcf1_Y(lua_State *L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L, 1);

  /* return T(x,e) */
  const int lc1316 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 32, 87);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 221);
  lua_pushvalue(L, 1);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1316);
  assert(lua_gettop(L) == 1);
}

/* name: p
 * function(e,e) */
static inline int lcf2_p(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* error("WIP") */
  lua_getfield(L, LUA_ENVIRONINDEX, "error");
  lua_pushliteral(L, "WIP");
  lua_call(L, 1, 0);
  assert(lua_gettop(L) == 2);
  return 0;
}

/* name: e
 * function() */
static inline int lcf2_e(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return f(t,a) */
  const int lc1337 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 224);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 230);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 231);
  lua_call(L, 2, LUA_MULTRET);
  return (lua_gettop(L) - lc1337);
  assert(lua_gettop(L) == 0);
}

/* name: o
 * function() */
static inline int lcf6_o(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return v(t,e,F(u,i),a) */
  const int lc1343 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 223);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 232);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 233);
  lc_getupvalue(L, lua_upvalueindex(1), 39, 64);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 228);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 234);
  lua_call(L, 2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 235);
  lua_call(L, 4, LUA_MULTRET);
  return (lua_gettop(L) - lc1343);
  assert(lua_gettop(L) == 0);
}

/* name: a
 * function() */
static inline int lcf6_a(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return v(e,t,n,i,o) */
  const int lc1363 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 7, 223);
  lc_getupvalue(L, lua_upvalueindex(1), 4, 236);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 237);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 238);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 240);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 239);
  lua_call(L, 5, LUA_MULTRET);
  return (lua_gettop(L) - lc1363);
  assert(lua_gettop(L) == 0);
}

/* name: n
 * function() */
static inline int lcf11_n(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return v(i,o,r,s,T(t,e(e(a),p(e(ce(h),a),ce(l))))) */
  const int lc1372 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 9, 223);
  const int lc1373 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 241);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 242);
  lc_getupvalue(L, lua_upvalueindex(1), 4, 243);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 245);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 87);
  const int lc1374 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 53);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 27);
  const int lc1375 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 247);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 7, 229);
  const int lc1376 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 27);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 6);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 244);
  lua_call(L, 1, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 247);
  lua_call(L, 2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 42, 6);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 246);
  lua_call(L, 1, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1376), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1375), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1374), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1373), LUA_MULTRET);
  return (lua_gettop(L) - lc1372);
  assert(lua_gettop(L) == 0);
}

/* function() */
static inline int lcf1383(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return y(m,w,f) */
  const int lc1382 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 225);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 226);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 227);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 224);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc1382);
  assert(lua_gettop(L) == 0);
}

/* function() */
static inline int lcf1389(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return v(f,y,F(u,{e}),t) */
  const int lc1388 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 3, 223);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 224);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 225);
  lc_getupvalue(L, lua_upvalueindex(1), 36, 64);
  lc_getupvalue(L, lua_upvalueindex(1), 2, 228);
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 248);
  lua_rawseti(L, -2, 1);
  lua_call(L, 2, 1);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 249);
  lua_call(L, 4, LUA_MULTRET);
  return (lua_gettop(L) - lc1388);
  assert(lua_gettop(L) == 0);
}

/* function(e,t) */
static inline int lcf1390(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1386 = 3 };
  assert((lua_gettop(L) == lc1386));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 248);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 249);

  /* return d(function()return v(f,y,F(u,{e}),t)end) */
  const int lc1387 = lua_gettop(L);
  lc_getupvalue(L, lc1386, 7, 218);
  lua_pushvalue(L, lc1386);
  lua_pushcclosure(L, lcf1389, 1);
  lua_call(L, 1, LUA_MULTRET);
  return (lua_gettop(L) - lc1387);
  assert(lua_gettop(L) == 3);
}

/* function() */
static inline int lcf1391(lua_State *L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L, 0);

  /* return y(m,w,function(e,t)return d(function()return
   * v(f,y,F(u,{e}),t)end)end) */
  const int lc1385 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 225);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 226);
  lc_getupvalue(L, lua_upvalueindex(1), 1, 227);
  lua_pushvalue(L, lua_upvalueindex(1));
  lua_pushcclosure(L, lcf1390, 1);
  lua_call(L, 3, LUA_MULTRET);
  return (lua_gettop(L) - lc1385);
  assert(lua_gettop(L) == 0);
}

/* name: v
 * function(f,y,m,w,u) */
static inline int lcf2_v(lua_State *L) {
  lua_checkstack(L, 31);
  enum { lc_nformalargs = 5 };
  lua_settop(L, 5);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1318 = 6 };
  assert((lua_gettop(L) == lc1318));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 224);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 225);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 226);
  lua_pushvalue(L, 4);
  lua_rawseti(L, -2, 227);
  lua_pushvalue(L, 5);
  lua_rawseti(L, -2, 228);

  /* if u==nil then */
  enum { lc1319 = 6 };
  lc_getupvalue(L, lc1318, 0, 228);
  lua_pushnil(L);
  const int lc1320 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc1320);
  const int lc1321 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1321) {

    /* u=false */
    lua_pushboolean(L, 0);
    lc_setupvalue(L, lc1318, 0, 228);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L, lc1319);
  assert(lua_gettop(L) == 6);

  /* local function p(e,e)
   * error("WIP")
   * end */
  lc_newclosuretable(L, lc1318);
  enum { lc1322 = 7 };
  assert((lua_gettop(L) == lc1322));
  lua_pushcfunction(L, lcf2_p);
  lua_rawseti(L, lc1322, 229);
  assert(lua_gettop(L) == 7);

  /* m=r(m) */
  lc_getupvalue(L, lc1322, 35, 21);
  lc_getupvalue(L, lc1322, 1, 226);
  lua_call(L, 1, 1);
  lc_setupvalue(L, lc1322, 1, 226);
  assert(lua_gettop(L) == 7);

  /* if c(m) then */
  enum { lc1323 = 7 };
  lc_getupvalue(L, lc1322, 35, 86);
  lc_getupvalue(L, lc1322, 1, 226);
  lua_call(L, 1, 1);
  const int lc1324 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1324) {

    /* local c=E(m) */
    lc_getupvalue(L, lc1322, 35, 85);
    lc_getupvalue(L, lc1322, 1, 226);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 8);

    /* local s=A(m) */
    lc_getupvalue(L, lc1322, 35, 84);
    lc_getupvalue(L, lc1322, 1, 226);
    lua_call(L, 1, 1);
    assert(lua_gettop(L) == 9);

    /* if l(c,x) then */
    enum { lc1325 = 9 };
    lc_getupvalue(L, lc1322, 35, 4);
    lua_pushvalue(L, 8);
    lc_getupvalue(L, lc1322, 4, 221);
    lua_call(L, 2, 1);
    const int lc1326 = lua_toboolean(L, -1);
    lua_pop(L, 1);
    if (lc1326) {

      /* s=r(s) */
      lc_getupvalue(L, lc1322, 35, 21);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      lua_replace(L, 9);
      assert(lua_gettop(L) == 9);

      /* if a(s) then */
      enum { lc1327 = 9 };
      lc_getupvalue(L, lc1322, 35, 92);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      const int lc1328 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1328) {

        /* local a=o(s) */
        lc_getupvalue(L, lc1322, 35, 91);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        assert(lua_gettop(L) == 10);

        /* local e=r(i(s)) */
        lc_getupvalue(L, lc1322, 35, 21);
        const int lc1329 = lua_gettop(L);
        lc_getupvalue(L, lc1322, 35, 90);
        lua_pushvalue(L, 9);
        lua_call(L, 1, LUA_MULTRET);
        lua_call(L, (lua_gettop(L) - lc1329), 1);
        assert(lua_gettop(L) == 11);

        /* if h(e) then */
        enum { lc1330 = 11 };
        lc_getupvalue(L, lc1322, 35, 88);
        lua_pushvalue(L, 11);
        lua_call(L, 1, 1);
        const int lc1331 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1331) {

          /* if u==false then */
          enum { lc1332 = 11 };
          lc_getupvalue(L, lc1322, 1, 228);
          lua_pushboolean(L, 0);
          const int lc1333 = lua_equal(L, -2, -1);
          lua_pop(L, 2);
          lua_pushboolean(L, lc1333);
          const int lc1334 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1334) {

            /* local t=a */
            lc_newclosuretable(L, lc1322);
            enum { lc1335 = 12 };
            assert((lua_gettop(L) == lc1335));
            lua_pushvalue(L, 10);
            lua_rawseti(L, lc1335, 230);
            assert(lua_gettop(L) == 12);

            /* local a=w */
            lc_newclosuretable(L, lc1335);
            enum { lc1336 = 13 };
            assert((lua_gettop(L) == lc1336));
            lc_getupvalue(L, lc1335, 2, 227);
            lua_rawseti(L, lc1336, 231);
            assert(lua_gettop(L) == 13);

            /* local function e()return f(t,a)end */
            lua_pushvalue(L, lc1336);
            lua_pushcclosure(L, lcf2_e, 1);
            assert(lua_gettop(L) == 14);

            /* return d(e) */
            const int lc1338 = lua_gettop(L);
            lc_getupvalue(L, lc1336, 8, 218);
            lua_pushvalue(L, 14);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc1338);
            assert(lua_gettop(L) == 14);
          } else {

            /* else
             * local t */
            lc_newclosuretable(L, lc1322);
            enum { lc1339 = 12 };
            assert((lua_gettop(L) == lc1339));
            lua_settop(L, (lua_gettop(L) + 1));
            lua_rawseti(L, lc1339, 232);
            assert(lua_gettop(L) == 12);

            /* t=f */
            lc_getupvalue(L, lc1339, 2, 224);
            lc_setupvalue(L, lc1339, 0, 232);
            assert(lua_gettop(L) == 12);

            /* local e */
            lc_newclosuretable(L, lc1339);
            enum { lc1340 = 13 };
            assert((lua_gettop(L) == lc1340));
            lua_settop(L, (lua_gettop(L) + 1));
            lua_rawseti(L, lc1340, 233);
            assert(lua_gettop(L) == 13);

            /* e=y */
            lc_getupvalue(L, lc1340, 3, 225);
            lc_setupvalue(L, lc1340, 0, 233);
            assert(lua_gettop(L) == 13);

            /* local i=a */
            lc_newclosuretable(L, lc1340);
            enum { lc1341 = 14 };
            assert((lua_gettop(L) == lc1341));
            lua_pushvalue(L, 10);
            lua_rawseti(L, lc1341, 234);
            assert(lua_gettop(L) == 14);

            /* local a=w */
            lc_newclosuretable(L, lc1341);
            enum { lc1342 = 15 };
            assert((lua_gettop(L) == lc1342));
            lc_getupvalue(L, lc1341, 4, 227);
            lua_rawseti(L, lc1342, 235);
            assert(lua_gettop(L) == 15);

            /* local function o()return v(t,e,F(u,i),a)end */
            lua_pushvalue(L, lc1342);
            lua_pushcclosure(L, lcf6_o, 1);
            assert(lua_gettop(L) == 16);

            /* return d(o) */
            const int lc1344 = lua_gettop(L);
            lc_getupvalue(L, lc1342, 10, 218);
            lua_pushvalue(L, 16);
            lua_call(L, 1, LUA_MULTRET);
            return (lua_gettop(L) - lc1344);
            assert(lua_gettop(L) == 16);
          }
          lua_settop(L, lc1332);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L, lc1330);
        assert(lua_gettop(L) == 11);
      }
      lua_settop(L, lc1327);
      assert(lua_gettop(L) == 9);
    } else {

      /* elseif l(c,b) then */
      enum { lc1345 = 9 };
      lc_getupvalue(L, lc1322, 35, 4);
      lua_pushvalue(L, 8);
      lc_getupvalue(L, lc1322, 3, 222);
      lua_call(L, 2, 1);
      const int lc1346 = lua_toboolean(L, -1);
      lua_pop(L, 1);
      if (lc1346) {

        /* s=r(s) */
        lc_getupvalue(L, lc1322, 35, 21);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        lua_replace(L, 9);
        assert(lua_gettop(L) == 9);

        /* if a(s) then */
        enum { lc1347 = 9 };
        lc_getupvalue(L, lc1322, 35, 92);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        const int lc1348 = lua_toboolean(L, -1);
        lua_pop(L, 1);
        if (lc1348) {

          /* local l=o(s) */
          lc_getupvalue(L, lc1322, 35, 91);
          lua_pushvalue(L, 9);
          lua_call(L, 1, 1);
          assert(lua_gettop(L) == 10);

          /* local s=r(i(s)) */
          lc_getupvalue(L, lc1322, 35, 21);
          const int lc1349 = lua_gettop(L);
          lc_getupvalue(L, lc1322, 35, 90);
          lua_pushvalue(L, 9);
          lua_call(L, 1, LUA_MULTRET);
          lua_call(L, (lua_gettop(L) - lc1349), 1);
          assert(lua_gettop(L) == 11);

          /* if a(s) then */
          enum { lc1350 = 11 };
          lc_getupvalue(L, lc1322, 35, 92);
          lua_pushvalue(L, 11);
          lua_call(L, 1, 1);
          const int lc1351 = lua_toboolean(L, -1);
          lua_pop(L, 1);
          if (lc1351) {

            /* local a=o(s) */
            lc_getupvalue(L, lc1322, 35, 91);
            lua_pushvalue(L, 11);
            lua_call(L, 1, 1);
            assert(lua_gettop(L) == 12);

            /* local o=r(i(s)) */
            lc_getupvalue(L, lc1322, 35, 21);
            const int lc1352 = lua_gettop(L);
            lc_getupvalue(L, lc1322, 35, 90);
            lua_pushvalue(L, 11);
            lua_call(L, 1, LUA_MULTRET);
            lua_call(L, (lua_gettop(L) - lc1352), 1);
            assert(lua_gettop(L) == 13);

            /* if h(o) then */
            enum { lc1353 = 13 };
            lc_getupvalue(L, lc1322, 35, 88);
            lua_pushvalue(L, 13);
            lua_call(L, 1, 1);
            const int lc1354 = lua_toboolean(L, -1);
            lua_pop(L, 1);
            if (lc1354) {

              /* if u==false then */
              enum { lc1355 = 13 };
              lc_getupvalue(L, lc1322, 1, 228);
              lua_pushboolean(L, 0);
              const int lc1356 = lua_equal(L, -2, -1);
              lua_pop(L, 2);
              lua_pushboolean(L, lc1356);
              const int lc1357 = lua_toboolean(L, -1);
              lua_pop(L, 1);
              if (lc1357) {

                /* local e */
                lc_newclosuretable(L, lc1322);
                enum { lc1358 = 14 };
                assert((lua_gettop(L) == lc1358));
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, lc1358, 236);
                assert(lua_gettop(L) == 14);

                /* e=f */
                lc_getupvalue(L, lc1358, 2, 224);
                lc_setupvalue(L, lc1358, 0, 236);
                assert(lua_gettop(L) == 14);

                /* local t */
                lc_newclosuretable(L, lc1358);
                enum { lc1359 = 15 };
                assert((lua_gettop(L) == lc1359));
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, lc1359, 237);
                assert(lua_gettop(L) == 15);

                /* t=y */
                lc_getupvalue(L, lc1359, 3, 225);
                lc_setupvalue(L, lc1359, 0, 237);
                assert(lua_gettop(L) == 15);

                /* local n=l */
                lc_newclosuretable(L, lc1359);
                enum { lc1360 = 16 };
                assert((lua_gettop(L) == lc1360));
                lua_pushvalue(L, 10);
                lua_rawseti(L, lc1360, 238);
                assert(lua_gettop(L) == 16);

                /* local o=a */
                lc_newclosuretable(L, lc1360);
                enum { lc1361 = 17 };
                assert((lua_gettop(L) == lc1361));
                lua_pushvalue(L, 12);
                lua_rawseti(L, lc1361, 239);
                assert(lua_gettop(L) == 17);

                /* local i=w */
                lc_newclosuretable(L, lc1361);
                enum { lc1362 = 18 };
                assert((lua_gettop(L) == lc1362));
                lc_getupvalue(L, lc1361, 5, 227);
                lua_rawseti(L, lc1362, 240);
                assert(lua_gettop(L) == 18);

                /* local function a()return v(e,t,n,i,o)end */
                lua_pushvalue(L, lc1362);
                lua_pushcclosure(L, lcf6_a, 1);
                assert(lua_gettop(L) == 19);

                /* return d(a) */
                const int lc1364 = lua_gettop(L);
                lc_getupvalue(L, lc1362, 11, 218);
                lua_pushvalue(L, 19);
                lua_call(L, 1, LUA_MULTRET);
                return (lua_gettop(L) - lc1364);
                assert(lua_gettop(L) == 19);
              } else {

                /* else
                 * local i */
                lc_newclosuretable(L, lc1322);
                enum { lc1365 = 14 };
                assert((lua_gettop(L) == lc1365));
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, lc1365, 241);
                assert(lua_gettop(L) == 14);

                /* i=f */
                lc_getupvalue(L, lc1365, 2, 224);
                lc_setupvalue(L, lc1365, 0, 241);
                assert(lua_gettop(L) == 14);

                /* local o */
                lc_newclosuretable(L, lc1365);
                enum { lc1366 = 15 };
                assert((lua_gettop(L) == lc1366));
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, lc1366, 242);
                assert(lua_gettop(L) == 15);

                /* o=y */
                lc_getupvalue(L, lc1366, 3, 225);
                lc_setupvalue(L, lc1366, 0, 242);
                assert(lua_gettop(L) == 15);

                /* local r=l */
                lc_newclosuretable(L, lc1366);
                enum { lc1367 = 16 };
                assert((lua_gettop(L) == lc1367));
                lua_pushvalue(L, 10);
                lua_rawseti(L, lc1367, 243);
                assert(lua_gettop(L) == 16);

                /* local h=a */
                lc_newclosuretable(L, lc1367);
                enum { lc1368 = 17 };
                assert((lua_gettop(L) == lc1368));
                lua_pushvalue(L, 12);
                lua_rawseti(L, lc1368, 244);
                assert(lua_gettop(L) == 17);

                /* local s=w */
                lc_newclosuretable(L, lc1368);
                enum { lc1369 = 18 };
                assert((lua_gettop(L) == lc1369));
                lc_getupvalue(L, lc1368, 5, 227);
                lua_rawseti(L, lc1369, 245);
                assert(lua_gettop(L) == 18);

                /* local l=u */
                lc_newclosuretable(L, lc1369);
                enum { lc1370 = 19 };
                assert((lua_gettop(L) == lc1370));
                lc_getupvalue(L, lc1369, 6, 228);
                lua_rawseti(L, lc1370, 246);
                assert(lua_gettop(L) == 19);

                /* local a=n("序甲") */
                lc_newclosuretable(L, lc1370);
                enum { lc1371 = 20 };
                assert((lua_gettop(L) == lc1371));
                lc_getupvalue(L, lc1370, 34, 146);
                lua_pushliteral(L, "序甲");
                lua_call(L, 1, 1);
                lua_rawseti(L, lc1371, 247);
                assert(lua_gettop(L) == 20);

                /* local function n()return
                 * v(i,o,r,s,T(t,e(e(a),p(e(ce(h),a),ce(l)))))end */
                lua_pushvalue(L, lc1371);
                lua_pushcclosure(L, lcf11_n, 1);
                assert(lua_gettop(L) == 21);

                /* return d(n) */
                const int lc1377 = lua_gettop(L);
                lc_getupvalue(L, lc1371, 13, 218);
                lua_pushvalue(L, 21);
                lua_call(L, 1, LUA_MULTRET);
                return (lua_gettop(L) - lc1377);
                assert(lua_gettop(L) == 21);
              }
              lua_settop(L, lc1355);
              assert(lua_gettop(L) == 13);
            }
            lua_settop(L, lc1353);
            assert(lua_gettop(L) == 13);
          }
          lua_settop(L, lc1350);
          assert(lua_gettop(L) == 11);
        }
        lua_settop(L, lc1347);
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L, lc1345);
    }
    lua_settop(L, lc1325);
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L, lc1323);
  assert(lua_gettop(L) == 7);

  /* if u==false then */
  enum { lc1378 = 7 };
  lc_getupvalue(L, lc1322, 1, 228);
  lua_pushboolean(L, 0);
  const int lc1379 = lua_equal(L, -2, -1);
  lua_pop(L, 2);
  lua_pushboolean(L, lc1379);
  const int lc1380 = lua_toboolean(L, -1);
  lua_pop(L, 1);
  if (lc1380) {

    /* return d(function()return y(m,w,f)end) */
    const int lc1381 = lua_gettop(L);
    lc_getupvalue(L, lc1322, 6, 218);
    lua_pushvalue(L, lc1322);
    lua_pushcclosure(L, lcf1383, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc1381);
    assert(lua_gettop(L) == 7);
  } else {

    /* else
     * return d(function()return y(m,w,function(e,t)return d(function()return
     * v(f,y,F(u,{e}),t)end)end)end) */
    const int lc1384 = lua_gettop(L);
    lc_getupvalue(L, lc1322, 6, 218);
    lua_pushvalue(L, lc1322);
    lua_pushcclosure(L, lcf1391, 1);
    lua_call(L, 1, LUA_MULTRET);
    return (lua_gettop(L) - lc1384);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L, lc1378);
  assert(lua_gettop(L) == 7);
  return 0;
}

/* name: l
 * function(t,e,a,o) */
static inline int lcf3_l(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);

  /* return v(t,e,a,o) */
  const int lc1392 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 223);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_call(L, 4, LUA_MULTRET);
  return (lua_gettop(L) - lc1392);
  assert(lua_gettop(L) == 4);
}

/* function(t,e) */
static inline int lcf1398(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return j(a(t,e)) */
  const int lc1396 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 6, 216);
  const int lc1397 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 250);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1397), LUA_MULTRET);
  return (lua_gettop(L) - lc1396);
  assert(lua_gettop(L) == 2);
}

/* function(e,t) */
static inline int lcf1404(lua_State *L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L, 2);

  /* return z(a(e,t)) */
  const int lc1402 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 5, 220);
  const int lc1403 = lua_gettop(L);
  lc_getupvalue(L, lua_upvalueindex(1), 0, 252);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1403), LUA_MULTRET);
  return (lua_gettop(L) - lc1402);
  assert(lua_gettop(L) == 2);
}

/* function(e,t,a) */
static inline int lcf1405(lua_State *L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L, 3);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1399 = 4 };
  assert((lua_gettop(L) == lc1399));
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 252);

  /* return j(i(e,t,function(e,t)return z(a(e,t))end)) */
  const int lc1400 = lua_gettop(L);
  lc_getupvalue(L, lc1399, 7, 216);
  const int lc1401 = lua_gettop(L);
  lc_getupvalue(L, lc1399, 1, 251);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, lc1399);
  lua_pushcclosure(L, lcf1404, 1);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1401), LUA_MULTRET);
  return (lua_gettop(L) - lc1400);
  assert(lua_gettop(L) == 4);
}

/* name: u
 * function(a,i,n,o) */
static inline int lcf3_u(lua_State *L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L, 4);
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1393 = 5 };
  assert((lua_gettop(L) == lc1393));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 250);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 251);

  /* return z(v((function(t,e)return j(a(t,e))end),(function(e,t,a)return
   * j(i(e,t,function(e,t)return z(a(e,t))end))end),n,o)) */
  const int lc1394 = lua_gettop(L);
  lc_getupvalue(L, lc1393, 4, 220);
  const int lc1395 = lua_gettop(L);
  lc_getupvalue(L, lc1393, 1, 223);
  lua_pushvalue(L, lc1393);
  lua_pushcclosure(L, lcf1398, 1);
  lua_pushvalue(L, lc1393);
  lua_pushcclosure(L, lcf1405, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_call(L, 4, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1395), LUA_MULTRET);
  return (lua_gettop(L) - lc1394);
  assert(lua_gettop(L) == 5);
}

/* name: (main)
 * function(...) */
static inline int lcf_main(lua_State *L) {
  lua_checkstack(L, 84);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);

  /* local function v(e,...)
   * local t=({...})
   * for a,t in ipairs(t)do
   * e[#e+1]=t
   * end
   * return#e
   * end */
  lc_newclosuretable(L, lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushcfunction(L, lcf1_v);
  lua_rawseti(L, (lc1 + lc_nextra), 1);
  assert(lua_gettop(L) - lc_nextra == 1);

  /* local function Ne(a,...)
   * local t=({...})
   * do
   * local e=#t-1
   * while e>=0 do
   * table.insert(a,1,t[e+1])
   * e=e-1
   * end
   * end
   * return#a
   * end */
  lc_newclosuretable(L, (lc1 + lc_nextra));
  enum { lc6 = 2 };
  assert((lua_gettop(L) == (lc6 + lc_nextra)));
  lua_pushcfunction(L, lcf1_Ne);
  lua_rawseti(L, (lc6 + lc_nextra), 2);
  assert(lua_gettop(L) - lc_nextra == 2);

  /* local
   * j,H,m,Ve,Ie,Ae,b,M,Y,ne,ae,pe,he,ye,se,fe,I,oe,K,qe,p,le,de,D,s,a,o,i,y,h,T,c,E,A,L,g,C,U,B,rt,S,Q,X,Z,Oe,G,_e,Te,ze,q,P,ue,re,F,V,je,xe,W,ge,d,O,we,lt,z,t,x,Se,dt,He,We,Fe,Ye,Pe,Me,De,Re,Le,Ue,Ce,te,be,ve,ee,ke,st,J,ie,nt,tt,_,e,N,me,w,n,k,r,Qe,Be,Ee,Ge,et,R,Ke,ot,it,u,at,ht,Ze,Xe,ce,Je,l,f
   */
  lc_newclosuretable(L, (lc6 + lc_nextra));
  enum { lc12 = 3 };
  assert((lua_gettop(L) == (lc12 + lc_nextra)));
  lua_settop(L, (lua_gettop(L) + 115));
  lua_rawseti(L, (lc12 + lc_nextra), 3);
  lua_rawseti(L, (lc12 + lc_nextra), 4);
  lua_rawseti(L, (lc12 + lc_nextra), 5);
  lua_rawseti(L, (lc12 + lc_nextra), 6);
  lua_rawseti(L, (lc12 + lc_nextra), 7);
  lua_rawseti(L, (lc12 + lc_nextra), 8);
  lua_rawseti(L, (lc12 + lc_nextra), 9);
  lua_rawseti(L, (lc12 + lc_nextra), 10);
  lua_rawseti(L, (lc12 + lc_nextra), 11);
  lua_rawseti(L, (lc12 + lc_nextra), 12);
  lua_rawseti(L, (lc12 + lc_nextra), 13);
  lua_rawseti(L, (lc12 + lc_nextra), 14);
  lua_rawseti(L, (lc12 + lc_nextra), 15);
  lua_rawseti(L, (lc12 + lc_nextra), 16);
  lua_rawseti(L, (lc12 + lc_nextra), 17);
  lua_rawseti(L, (lc12 + lc_nextra), 18);
  lua_rawseti(L, (lc12 + lc_nextra), 19);
  lua_rawseti(L, (lc12 + lc_nextra), 20);
  lua_rawseti(L, (lc12 + lc_nextra), 21);
  lua_rawseti(L, (lc12 + lc_nextra), 22);
  lua_rawseti(L, (lc12 + lc_nextra), 23);
  lua_rawseti(L, (lc12 + lc_nextra), 24);
  lua_rawseti(L, (lc12 + lc_nextra), 25);
  lua_rawseti(L, (lc12 + lc_nextra), 26);
  lua_rawseti(L, (lc12 + lc_nextra), 27);
  lua_rawseti(L, (lc12 + lc_nextra), 28);
  lua_rawseti(L, (lc12 + lc_nextra), 29);
  lua_rawseti(L, (lc12 + lc_nextra), 30);
  lua_rawseti(L, (lc12 + lc_nextra), 31);
  lua_rawseti(L, (lc12 + lc_nextra), 32);
  lua_rawseti(L, (lc12 + lc_nextra), 33);
  lua_rawseti(L, (lc12 + lc_nextra), 34);
  lua_rawseti(L, (lc12 + lc_nextra), 35);
  lua_rawseti(L, (lc12 + lc_nextra), 36);
  lua_rawseti(L, (lc12 + lc_nextra), 37);
  lua_rawseti(L, (lc12 + lc_nextra), 38);
  lua_rawseti(L, (lc12 + lc_nextra), 39);
  lua_rawseti(L, (lc12 + lc_nextra), 40);
  lua_rawseti(L, (lc12 + lc_nextra), 41);
  lua_rawseti(L, (lc12 + lc_nextra), 42);
  lua_rawseti(L, (lc12 + lc_nextra), 43);
  lua_rawseti(L, (lc12 + lc_nextra), 44);
  lua_rawseti(L, (lc12 + lc_nextra), 45);
  lua_rawseti(L, (lc12 + lc_nextra), 46);
  lua_rawseti(L, (lc12 + lc_nextra), 47);
  lua_rawseti(L, (lc12 + lc_nextra), 48);
  lua_rawseti(L, (lc12 + lc_nextra), 49);
  lua_rawseti(L, (lc12 + lc_nextra), 50);
  lua_rawseti(L, (lc12 + lc_nextra), 51);
  lua_rawseti(L, (lc12 + lc_nextra), 52);
  lua_rawseti(L, (lc12 + lc_nextra), 53);
  lua_rawseti(L, (lc12 + lc_nextra), 54);
  lua_rawseti(L, (lc12 + lc_nextra), 55);
  lua_rawseti(L, (lc12 + lc_nextra), 56);
  lua_rawseti(L, (lc12 + lc_nextra), 57);
  lua_rawseti(L, (lc12 + lc_nextra), 58);
  lua_rawseti(L, (lc12 + lc_nextra), 59);
  lua_rawseti(L, (lc12 + lc_nextra), 60);
  lua_rawseti(L, (lc12 + lc_nextra), 61);
  lua_rawseti(L, (lc12 + lc_nextra), 62);
  lua_rawseti(L, (lc12 + lc_nextra), 63);
  lua_rawseti(L, (lc12 + lc_nextra), 64);
  lua_rawseti(L, (lc12 + lc_nextra), 65);
  lua_rawseti(L, (lc12 + lc_nextra), 66);
  lua_rawseti(L, (lc12 + lc_nextra), 67);
  lua_rawseti(L, (lc12 + lc_nextra), 68);
  lua_rawseti(L, (lc12 + lc_nextra), 69);
  lua_rawseti(L, (lc12 + lc_nextra), 70);
  lua_rawseti(L, (lc12 + lc_nextra), 71);
  lua_rawseti(L, (lc12 + lc_nextra), 72);
  lua_rawseti(L, (lc12 + lc_nextra), 73);
  lua_rawseti(L, (lc12 + lc_nextra), 74);
  lua_rawseti(L, (lc12 + lc_nextra), 75);
  lua_rawseti(L, (lc12 + lc_nextra), 76);
  lua_rawseti(L, (lc12 + lc_nextra), 77);
  lua_rawseti(L, (lc12 + lc_nextra), 78);
  lua_rawseti(L, (lc12 + lc_nextra), 79);
  lua_rawseti(L, (lc12 + lc_nextra), 80);
  lua_rawseti(L, (lc12 + lc_nextra), 81);
  lua_rawseti(L, (lc12 + lc_nextra), 82);
  lua_rawseti(L, (lc12 + lc_nextra), 83);
  lua_rawseti(L, (lc12 + lc_nextra), 84);
  lua_rawseti(L, (lc12 + lc_nextra), 85);
  lua_rawseti(L, (lc12 + lc_nextra), 86);
  lua_rawseti(L, (lc12 + lc_nextra), 87);
  lua_rawseti(L, (lc12 + lc_nextra), 88);
  lua_rawseti(L, (lc12 + lc_nextra), 89);
  lua_rawseti(L, (lc12 + lc_nextra), 90);
  lua_rawseti(L, (lc12 + lc_nextra), 91);
  lua_rawseti(L, (lc12 + lc_nextra), 92);
  lua_rawseti(L, (lc12 + lc_nextra), 93);
  lua_rawseti(L, (lc12 + lc_nextra), 94);
  lua_rawseti(L, (lc12 + lc_nextra), 95);
  lua_rawseti(L, (lc12 + lc_nextra), 96);
  lua_rawseti(L, (lc12 + lc_nextra), 97);
  lua_rawseti(L, (lc12 + lc_nextra), 98);
  lua_rawseti(L, (lc12 + lc_nextra), 99);
  lua_rawseti(L, (lc12 + lc_nextra), 100);
  lua_rawseti(L, (lc12 + lc_nextra), 101);
  lua_rawseti(L, (lc12 + lc_nextra), 102);
  lua_rawseti(L, (lc12 + lc_nextra), 103);
  lua_rawseti(L, (lc12 + lc_nextra), 104);
  lua_rawseti(L, (lc12 + lc_nextra), 105);
  lua_rawseti(L, (lc12 + lc_nextra), 106);
  lua_rawseti(L, (lc12 + lc_nextra), 107);
  lua_rawseti(L, (lc12 + lc_nextra), 108);
  lua_rawseti(L, (lc12 + lc_nextra), 109);
  lua_rawseti(L, (lc12 + lc_nextra), 110);
  lua_rawseti(L, (lc12 + lc_nextra), 111);
  lua_rawseti(L, (lc12 + lc_nextra), 112);
  lua_rawseti(L, (lc12 + lc_nextra), 113);
  lua_rawseti(L, (lc12 + lc_nextra), 114);
  lua_rawseti(L, (lc12 + lc_nextra), 115);
  lua_rawseti(L, (lc12 + lc_nextra), 116);
  lua_rawseti(L, (lc12 + lc_nextra), 117);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function j()
   * error("TheLanguage PANIC")
   * end */
  lua_pushcfunction(L, lcf1_j);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 117);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function H(e)
   * if not e then
   * return j()
   * end
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_H, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 116);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function fe(e,t)
   * return{
   * ye,
   * e,
   * t,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_fe, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 102);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function I(e)
   * return e[1]==ye
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_I, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 101);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function oe(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_oe);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 100);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function K(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_K);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 99);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function qe(e)
   * while I(e)do
   * e=K(e)
   * end
   * return e
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_qe, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 98);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function p(e)
   * return e[1]==Ve
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_p, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 97);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function le(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_le);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 96);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function de(e)
   * return m()[le(e)]
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_de, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 95);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function D(t,e)
   * if t==e then
   * return true
   * end
   * if le(t)==le(e)then
   * O(t,e)
   * return true
   * else
   * return false
   * end
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_D, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 94);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function s(t,e)
   * return{
   * Ie,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_s, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 93);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function a(e)
   * return e[1]==Ie
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_a, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 92);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function o(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_o);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 91);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function i(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_i);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 90);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function h(e)
   * return e[1]==Ae
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_h, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 88);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function T(t,e)
   * return{
   * b,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_T, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 87);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function c(e)
   * return e[1]==b
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_c, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 86);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function E(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_E);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 85);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function A(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_A);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 84);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function L(t,e)
   * return{
   * M,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_L, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 83);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function g(e)
   * return e[1]==M
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_g, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 82);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function C(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_C);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 81);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function U(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_U);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 80);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function B(e)
   * return e[1]==Y
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_B, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 79);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function rt(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_rt);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 78);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function S(t,e)
   * return{
   * ne,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_S, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 77);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Q(e)
   * return e[1]==ne
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Q, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 76);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function X(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_X);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 75);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Z(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_Z);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 74);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Oe(e,a,t)
   * return{
   * pe,
   * e,
   * a,
   * t,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Oe, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 73);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function G(e)
   * return e[1]==pe
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_G, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 72);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function _e(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1__e);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 71);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Te(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_Te);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 70);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ze(e)
   * return e[4]
   * end */
  lua_pushcfunction(L, lcf1_ze);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 69);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function q(t,e)
   * return{
   * ae,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_q, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 68);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function P(e)
   * return e[1]==ae
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_P, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 67);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ue(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_ue);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 66);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function re(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_re);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 65);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function F(t,e)
   * return{
   * he,
   * t,
   * e,
   * }
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_F, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 64);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function V(e)
   * return e[1]==he
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_V, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 63);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function je(e)
   * return e[2]
   * end */
  lua_pushcfunction(L, lcf1_je);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 62);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function xe(e)
   * return e[3]
   * end */
  lua_pushcfunction(L, lcf1_xe);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 61);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function W(e)
   * local e=r(e)
   * local function t(e)
   * e[2]=W(e[2])
   * e[3]=W(e[3])
   * return e
   * end
   * if c(e)then
   * return t(e)
   * elseif g(e)then
   * return t(e)
   * elseif a(e)then
   * return t(e)
   * elseif I(e)then
   * return t(e)
   * end
   * return e
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_W, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 60);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ge()
   * return{se}
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_ge, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 59);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function d(e)
   * return e[1]==se
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_d, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 58);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function O(e,t)
   * if e==t then
   * return
   * end
   * e[1]=Y
   * e[2]=t
   * e[3]=false
   * e[4]=false
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_O, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 57);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function we(e,t)
   * H(d(e))
   * H(not d(t))
   * local e=e
   * local t=t
   * e[1]=t[1]
   * e[2]=t[2]
   * e[3]=t[3]
   * e[4]=t[4]
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_we, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 56);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function lt(t)
   * local e=ge()
   * we(e,t)
   * return e
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_lt, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 55);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function _(a)
   * local t=y
   * do
   * local e=#a-1
   * while e>=0 do
   * t=s(a[e+1],t)
   * e=e-1
   * end
   * end
   * return t
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1__, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 28);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function e(...)
   * local e=({...})
   * return _(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_e, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 27);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function N(e)
   * if not B(e)then
   * return e
   * end
   * local e=e
   * local t={}
   * while B(e)do
   * v(t,e)
   * e=rt(e)
   * end
   * for a,t in ipairs(t)do
   * O(t,e)
   * end
   * return e
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_N, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 26);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function me(e)
   * return Q(e)or G(e)or P(e)or V(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_me, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 25);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function w(e)
   * return B(e)or me(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_w, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 24);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function n(o,i,t,a)
   * if i==nil then
   * i={}
   * end
   * if t==nil then
   * t={
   * false,
   * false,
   * }
   * end
   * if a==nil then
   * a={}
   * end
   * local e,r,s
   * function r(t)
   * O(e,t)
   * do
   * local e=0
   * while e<#a do
   * O(a[e+1],t)
   * e=e+1
   * end
   * end
   * return t
   * end
   * function s(t)
   * r(t)
   * if w(t)then
   * v(a,e)
   * return n(t,i,{
   * false,
   * false,
   * },a)
   * end
   * return t
   * end
   * local h={}
   * e=o
   * local function o()
   * t[2]=true
   * return s(dt)
   * end
   * local function d()
   * local e={}
   * for t in pairs(h)do
   * e[t]=true
   * end
   * for t in pairs(i)do
   * e[t]=true
   * end
   * return e
   * end
   * do
   * local t=0
   * while w(e)and t<32 do
   * v(a,e)
   * e=k(e)
   * t=t+1
   * end
   * end
   * while w(e)do
   * local r=f(e)
   * if i[r]==true then
   * return o()
   * end
   * if h[r]==true then
   * t[1]=true
   * if Q(e)then
   * return o()
   * elseif P(e)then
   * local a=ue(e)
   * local e=re(e)
   * local h={
   * He,
   * We,
   * Fe,
   * Ye,
   * Pe,
   * Me,
   * De,
   * Re,
   * Le,
   * Ue,
   * Ce,
   * }
   * local i=false
   * for t,e in ipairs(h)do
   * if l(e,a)then
   * i=true
   * break
   * end
   * end
   * if i then
   * H(#e==1)
   * H(t[2]==false)
   * local e=n(e[1],d(),t)
   * if t[2]then
   * return s(q(a,{e}))
   * else
   * return j()
   * end
   * end
   * if l(a,te)then
   * return o()
   * elseif l(a,be)then
   * return o()
   * elseif l(a,ve)then
   * return o()
   * elseif l(a,ee)then
   * H(#e==3)
   * H(t[2]==false)
   * local a=n(e[1],d(),t)
   * if t[2]then
   * return s(q(ee,{
   * a,
   * e[2],
   * e[3],
   * }))
   * else
   * return j()
   * end
   * end
   * return j()
   * elseif G(e)then
   * return o()
   * elseif V(e)then
   * return o()
   * end
   * return j()
   * end
   * h[r]=true
   * v(a,e)
   * e=k(e)
   * end
   * return r(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_n, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 23);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function k(a)
   * local e=N(a)
   * local t
   * H(not B(e))
   * if Q(e)then
   * t=it(X(e),Z(e),a)
   * elseif G(e)then
   * t=Xe(_e(e),Te(e),ze(e),a)
   * elseif P(e)then
   * t=Ze(ue(e),re(e),a)
   * elseif V(e)then
   * t=ht(je(e),xe(e),a)
   * else
   * t=e
   * end
   * t=N(t)
   * O(e,t)
   * return t
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_k, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 22);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function r(e)
   * return n(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf2_r, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 21);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Qe(e)
   * while w(e)or I(e)do
   * e=r(qe(e))
   * end
   * return e
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Qe, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 20);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Ee(a,o,i)
   * local t={}
   * do
   * local e=0
   * while e<#a do
   * if l(a[(e+0)+1],o)then
   * t[(e+0)+1]=o
   * t[(e+1)+1]=i
   * do
   * e=e+2
   * while e<#a do
   * t[(e+0)+1]=a[(e+0)+1]
   * t[(e+1)+1]=a[(e+1)+1]
   * e=e+2
   * end
   * end
   * return t
   * else
   * t[(e+0)+1]=a[(e+0)+1]
   * t[(e+1)+1]=a[(e+1)+1]
   * end
   * e=e+2
   * end
   * end
   * t[(#a+0)+1]=o
   * t[(#a+1)+1]=i
   * return t
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ee, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 18);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Ge(t,a,o)
   * do
   * local e=0
   * while e<#t do
   * if l(t[(e+0)+1],a)then
   * return t[(e+1)+1]
   * end
   * e=e+2
   * end
   * end
   * return o
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ge, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 17);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function et(t,a)
   * do
   * local e=0
   * while e<#t do
   * if l(t[(e+0)+1],a)then
   * return t[(e+1)+1]
   * end
   * e=e+2
   * end
   * end
   * return j()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_et, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 16);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function R(o)
   * local a=y
   * do
   * local t=0
   * while t<#o do
   * a=s(e(o[(t+0)+1],o[(t+1)+1]),a)
   * t=t+2
   * end
   * end
   * return T(Se,e(a))
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_R, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 15);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Ke(t,a)
   * do
   * local e=0
   * while e<#t do
   * a(t[(e+0)+1],t[(e+1)+1])
   * e=e+2
   * end
   * end
   * end */
  lua_pushcfunction(L, lcf1_Ke);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 14);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ot(e,d,r,l)
   * local s={}
   * local t={}
   * local e=N(e)
   * local n=true
   * while true do
   * if h(e)then
   * return l(t,s)
   * elseif I(e)then
   * v(t,oe(e))
   * e=K(e)
   * elseif a(e)then
   * v(s,o(e))
   * e=i(e)
   * elseif w(e)then
   * if n then
   * n=false
   * e=k(e)
   * else
   * return r()
   * end
   * else
   * return d()
   * end
   * end
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_ot, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 13);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function it(s,t,d)
   * local n=k(t)
   * if w(n)then
   * return d
   * end
   * local function t()return L(z,e(J,e(ve,e(R(s),n))))end
   * if a(n)then
   * return ot(n,t,function()return d end,function(n,e)
   * if#n~=0 then
   * error("WIP")
   * end
   * if l(e[1],ie)then
   * if#e==1 then
   * return t()
   * end
   * local o=e[2]
   * local a={}
   * do
   * local t=2
   * while t<#e do
   * v(a,e[t+1])
   * t=t+1
   * end
   * end
   * return Oe(s,o,a)
   * elseif l(e[1],nt)then
   * if#e==1 then
   * return t()
   * end
   * local n=r(S(s,e[2]))
   * if not c(n)then
   * return t()
   * end
   * local r=k(E(n))
   * if w(r)then
   * return d
   * end
   * if not p(r)then
   * return t()
   * end
   * if not D(r,x)then
   * return t()
   * end
   * local n=k(A(n))
   * if w(n)then
   * return d
   * end
   * if not a(n)then
   * return t()
   * end
   * local o=o(n)
   * local a=k(i(n))
   * if w(a)then
   * return d
   * end
   * if not h(a)then
   * return t()
   * end
   * local a={R(s)}
   * do
   * local t=2
   * while t<#e do
   * v(a,e[t+1])
   * t=t+1
   * end
   * end
   * return F(o,a)
   * elseif l(e[1],J)then
   * if#e==1 then
   * return t()
   * end
   * local o=e[2]
   * local a={}
   * do
   * local t=2
   * while t<#e do
   * v(a,S(s,e[t+1]))
   * t=t+1
   * end
   * end
   * return q(o,a)
   * else
   * local o=S(s,e[1])
   * local a={}
   * do
   * local t=1
   * while t<#e do
   * v(a,S(s,e[t+1]))
   * t=t+1
   * end
   * end
   * return F(o,a)
   * end
   * end)
   * elseif h(n)then
   * return n
   * elseif u(n)then
   * return Ge(s,n,t())
   * elseif g(n)then
   * return t()
   * end
   * return j()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_it, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 12);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function u(e)
   * return p(e)or c(e)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_u, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 11);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ht(l,n,m)
   * local function d()return L(z,e(J,e(be,e(l,_(n)))))end
   * l=k(l)
   * if w(l)then
   * return m
   * end
   * if not c(l)then
   * return d()
   * end
   * local e=r(E(l))
   * if not(p(e)and D(e,t))then
   * return d()
   * end
   * local t=r(A(l))
   * if not a(t)then
   * return d()
   * end
   * local e=W(o(t))
   * local t=r(i(t))
   * if not(a(t)and h(r(i(t))))then
   * return d()
   * end
   * local l=o(t)
   * local r=Be
   * local t=0
   * while not h(e)do
   * if u(e)then
   * local a=y
   * do
   * local e=#n-1
   * while e>=t do
   * a=s(n[e+1],a)
   * e=e-1
   * end
   * end
   * r=Ee(r,e,a)
   * t=#n
   * e=y
   * elseif a(e)then
   * if t<#n then
   * local a=n[t+1]
   * t=t+1
   * r=Ee(r,o(e),a)
   * e=i(e)
   * else
   * return d()
   * end
   * else
   * return d()
   * end
   * end
   * if#n~=t then
   * return d()
   * end
   * return S(r,l)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_ht, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 9);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Ze(i,t,o)
   * local function a()return L(z,e(J,e(i,_(t))))end
   * for n,e in ipairs(at)do
   * if l(i,e[1])then
   * if#t~=e[2]then
   * return a()
   * end
   * if e[2]==1 then
   * return e[3](t[1],a,o)
   * elseif e[2]==2 then
   * return e[3](t[1],t[2],a,o)
   * elseif e[2]==3 then
   * return e[3](t[1],t[2],t[3],a,o)
   * end
   * return j()
   * end
   * end
   * return a()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ze, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 8);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Xe(i,o,t,a)
   * local function a()return L(z,e(ie,e(R(i),o,_(t))))end
   * if l(o,ke)then
   * if#t~=1 then
   * return a()
   * end
   * return t[1]
   * elseif l(o,st)then
   * if#t~=2 then
   * return a()
   * end
   * return Je(i,t[1],t[2],a)
   * elseif l(o,tt)then
   * if#t~=2 then
   * return a()
   * end
   * return fe(t[1],S(i,t[2]))
   * end
   * return a()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Xe, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 7);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function ce(t)
   * return e(ie,ke,t)
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_ce, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 6);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function Je(m,d,f,w)
   * d=W(d)
   * local r={}
   * local c=false
   * local n=d
   * while not h(n)do
   * if u(n)then
   * v(r,n)
   * c=true
   * n=y
   * elseif a(n)then
   * v(r,o(n))
   * n=i(n)
   * else
   * return w()
   * end
   * end
   * local o
   * if c then
   * o=_(r)
   * else
   * o=d
   * end
   * local a={}
   * Ke(m,function(t,e)
   * do
   * local e=0
   * while e<#r do
   * if l(r[e+1],t)then
   * return
   * end
   * e=e+1
   * end
   * end
   * v(a,t)
   * end)
   * local i=o
   * do
   * local e=#a-1
   * while e>=0 do
   * i=s(a[e+1],i)
   * e=e-1
   * end
   * end
   * local o=o
   * do
   * local e=#a-1
   * while e>=0 do
   * o=s(ce(et(m,a[e+1])),o)
   * e=e-1
   * end
   * end
   * return T(t,e(d,s(ce(T(t,e(i,f))),o)))
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_Je, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 5);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function l(e,t)
   * if e==t then
   * return true
   * end
   * e=r(e)
   * t=r(t)
   * if e==t then
   * return true
   * end
   * local function n(t,e,o,a)
   * if l(o(t),o(e))and l(a(t),a(e))then
   * O(t,e)
   * return true
   * else
   * return false
   * end
   * end
   * if h(e)then
   * if not h(t)then
   * return false
   * end
   * O(e,y)
   * O(t,y)
   * return true
   * elseif p(e)then
   * if not p(t)then
   * return false
   * end
   * return D(e,t)
   * elseif a(e)then
   * if not a(t)then
   * return false
   * end
   * return n(e,t,o,i)
   * elseif g(e)then
   * if not g(t)then
   * return false
   * end
   * return n(e,t,C,U)
   * elseif c(e)then
   * if not c(t)then
   * return false
   * end
   * return n(e,t,E,A)
   * end
   * return j()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_l, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 4);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* function f(e)
   * e=N(e)
   * local t=""
   * local n=""
   * if h(e)then
   * return"()"
   * elseif a(e)then
   * t="("
   * n=""
   * while a(e)do
   * t=tostring(t)..tostring(n)..tostring(f(o(e)))
   * n=" "
   * e=N(i(e))
   * end
   * if h(e)then
   * t=tostring(t)..")"
   * else
   * t=tostring(t).." . "..tostring(f(e))..")"
   * end
   * return t
   * elseif c(e)then
   * return"#"..tostring(f(s(E(e),A(e))))
   * elseif g(e)then
   * return"!"..tostring(f(s(C(e),U(e))))
   * elseif p(e)then
   * return de(e)
   * elseif I(e)then
   * return";("..tostring(f(oe(e))).." "..tostring(f(K(e)))..")"
   * elseif Q(e)then
   * return"$("..tostring(f(R(X(e)))).." "..tostring(f(Z(e)))..")"
   * elseif P(e)then
   * return"%("..tostring(f(ue(e))).." "..tostring(f(_(re(e))))..")"
   * elseif G(e)then
   * return"@("..tostring(f(R(_e(e)))).." "..tostring(f(Te(e))).."
   * "..tostring(f(_(ze(e))))..")" elseif V(e)then
   * return"^("..tostring(f(je(e))).." "..tostring(f(_(xe(e))))..")"
   * end
   * return j()
   * end */
  lua_pushvalue(L, (lc12 + lc_nextra));
  lua_pushcclosure(L, lcf1_f, 1);
  lc_setupvalue(L, (lc12 + lc_nextra), 0, 3);
  assert(lua_gettop(L) - lc_nextra == 3);

  /* local function n()
   * return{
   * ["0"]="0",
   * ["1"]="1",
   * ["2"]="2",
   * ["3"]="3",
   * ["4"]="4",
   * ["5"]="5",
   * ["6"]="6",
   * ["7"]="7",
   * ["8"]="8",
   * ["9"]="9",
   * A="A",
   * B="B",
   * C="C",
   * D="D",
   * E="E",
   * F="F",
   * G="G",
   * H="H",
   * I="I",
   * J="J",
   * K="K",
   * L="L",
   * M="M",
   * N="N",
   * O="O",
   * P="P",
   * Q="Q",
   * R="R",
   * S="S",
   * T="T",
   * U="U",
   * V="V",
   * W="W",
   * X="X",
   * Y="Y",
   * Z="Z",
   * a="a",
   * b="b",
   * c="c",
   * d="d",
   * e="e",
   * f="f",
   * g="g",
   * h="h",
   * i="i",
   * j="j",
   * k="k",
   * l="l",
   * m="m",
   * n="n",
   * o="o",
   * p="p",
   * q="q",
   * r="r",
   * s="s",
   * t="t",
   * u="u",
   * v="v",
   * w="w",
   * x="x",
   * y="y",
   * z="z",
   * ["一類何物"]="㝉",
   * ["之物"]="𫙦",
   * ["其子"]="𦮪",
   * ["出入改滅"]="𢒟",
   * ["列序"]="𠜺",
   * ["化滅"]="𠏁",
   * ["參形"]="𠫰",
   * ["吾自"]="𦣹",
   * ["太始初核"]="𣝗",
   * ["如若"]="𦱡",
   * ["宇宙亡矣"]="𨹹",
   * ["尾末"]="𡲵",
   * ["序丁"]="𠆤",
   * ["序丙"]="𠇮",
   * ["序乙"]="㐈",
   * ["序甲"]="𠇚",
   * ["式形"]="佱",
   * ["引用"]="㧈",
   * ["應用"]="𤰆",
   * ["效應"]="効",
   * ["映表"]="𤅔",
   * ["是非"]="欤",
   * ["構物"]="𡒫",
   * ["為符名連"]="‐",
   * ["爻陰"]="侌",
   * ["爻陽"]="𣆄",
   * ["特定其物"]="亓",
   * ["省略一物"]="畧",
   * ["符名"]="謼",
   * ["等同"]="弌",
   * ["解算"]="筭",
   * ["註疏"]="疎",
   * ["詞素"]="𧥝",
   * ["謬誤"]="䥘",
   * ["連頸"]="丩",
   * ["間空"]="𣣓",
   * ["首始"]="𩠐",
   * }
   * end */
  lc_newclosuretable(L, (lc12 + lc_nextra));
  enum { lc513 = 4 };
  assert((lua_gettop(L) == (lc513 + lc_nextra)));
  lua_pushcfunction(L, lcf3_n);
  lua_rawseti(L, (lc513 + lc_nextra), 138);
  assert(lua_gettop(L) - lc_nextra == 4);

  /* local function u()
   * return{
   * ["0"]="0",
   * ["1"]="1",
   * ["2"]="2",
   * ["3"]="3",
   * ["4"]="4",
   * ["5"]="5",
   * ["6"]="6",
   * ["7"]="7",
   * ["8"]="8",
   * ["9"]="9",
   * A="A",
   * B="B",
   * C="C",
   * D="D",
   * E="E",
   * F="F",
   * G="G",
   * H="H",
   * I="I",
   * J="J",
   * K="K",
   * L="L",
   * M="M",
   * N="N",
   * O="O",
   * P="P",
   * Q="Q",
   * R="R",
   * S="S",
   * T="T",
   * U="U",
   * V="V",
   * W="W",
   * X="X",
   * Y="Y",
   * Z="Z",
   * a="a",
   * b="b",
   * c="c",
   * d="d",
   * e="e",
   * f="f",
   * g="g",
   * h="h",
   * i="i",
   * j="j",
   * k="k",
   * l="l",
   * m="m",
   * n="n",
   * o="o",
   * p="p",
   * q="q",
   * r="r",
   * s="s",
   * t="t",
   * u="u",
   * v="v",
   * w="w",
   * x="x",
   * y="y",
   * z="z",
   * ["㝉"]="一類何物",
   * ["𫙦"]="之物",
   * ["𦮪"]="其子",
   * ["𢒟"]="出入改滅",
   * ["𠜺"]="列序",
   * ["𠏁"]="化滅",
   * ["𠫰"]="參形",
   * ["𦣹"]="吾自",
   * ["𣝗"]="太始初核",
   * ["𦱡"]="如若",
   * ["𨹹"]="宇宙亡矣",
   * ["𡲵"]="尾末",
   * ["𠆤"]="序丁",
   * ["𠇮"]="序丙",
   * ["㐈"]="序乙",
   * ["𠇚"]="序甲",
   * ["佱"]="式形",
   * ["㧈"]="引用",
   * ["𤰆"]="應用",
   * ["効"]="效應",
   * ["𤅔"]="映表",
   * ["欤"]="是非",
   * ["𡒫"]="構物",
   * ["‐"]="為符名連",
   * ["侌"]="爻陰",
   * ["𣆄"]="爻陽",
   * ["亓"]="特定其物",
   * ["畧"]="省略一物",
   * ["謼"]="符名",
   * ["弌"]="等同",
   * ["筭"]="解算",
   * ["疎"]="註疏",
   * ["𧥝"]="詞素",
   * ["䥘"]="謬誤",
   * ["丩"]="連頸",
   * ["𣣓"]="間空",
   * ["𩠐"]="首始",
   * }
   * end */
  lc_newclosuretable(L, (lc513 + lc_nextra));
  enum { lc514 = 5 };
  assert((lua_gettop(L) == (lc514 + lc_nextra)));
  lua_pushcfunction(L, lcf2_u);
  lua_rawseti(L, (lc514 + lc_nextra), 139);
  assert(lua_gettop(L) - lc_nextra == 5);

  /* local function d()
   * local e=n()
   * function d()return e end
   * return e
   * end */
  lc_newclosuretable(L, (lc514 + lc_nextra));
  enum { lc515 = 6 };
  assert((lua_gettop(L) == (lc515 + lc_nextra)));
  lua_pushvalue(L, (lc515 + lc_nextra));
  lua_pushcclosure(L, lcf5_d, 1);
  lua_rawseti(L, (lc515 + lc_nextra), 140);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* function m()
   * local e=u()
   * function m()return e end
   * return e
   * end */
  lua_pushvalue(L, (lc515 + lc_nextra));
  lua_pushcclosure(L, lcf2_m, 1);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 115);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* Ve=0 */
  lua_pushnumber(L, 0);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 114);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* Ie=1 */
  lua_pushnumber(L, 1);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 113);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* Ae=2 */
  lua_pushnumber(L, 2);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 112);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* b=3 */
  lua_pushnumber(L, 3);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 111);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* M=4 */
  lua_pushnumber(L, 4);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 110);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* Y=5 */
  lua_pushnumber(L, 5);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 109);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* ne=6 */
  lua_pushnumber(L, 6);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 108);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* ae=7 */
  lua_pushnumber(L, 7);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 107);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* pe=8 */
  lua_pushnumber(L, 8);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 106);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* he=9 */
  lua_pushnumber(L, 9);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 105);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* ye=11 */
  lua_pushnumber(L, 11);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 104);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* se=10 */
  lua_pushnumber(L, 10);
  lc_setupvalue(L, (lc515 + lc_nextra), 3, 103);
  assert(lua_gettop(L) - lc_nextra == 6);

  /* local function rt(e)
   * return m()[e]~=nil
   * end */
  lc_newclosuretable(L, (lc515 + lc_nextra));
  enum { lc518 = 7 };
  assert((lua_gettop(L) == (lc518 + lc_nextra)));
  lua_pushvalue(L, (lc518 + lc_nextra));
  lua_pushcclosure(L, lcf2_rt, 1);
  lua_rawseti(L, (lc518 + lc_nextra), 143);
  assert(lua_gettop(L) - lc_nextra == 7);

  /* local function Ze(e)
   * return{
   * Ve,
   * e,
   * }
   * end */
  lc_newclosuretable(L, (lc518 + lc_nextra));
  enum { lc520 = 8 };
  assert((lua_gettop(L) == (lc520 + lc_nextra)));
  lua_pushvalue(L, (lc520 + lc_nextra));
  lua_pushcclosure(L, lcf2_Ze, 1);
  lua_rawseti(L, (lc520 + lc_nextra), 144);
  assert(lua_gettop(L) - lc_nextra == 8);

  /* local function Xe(e)
   * return d()[e]~=nil
   * end */
  lc_newclosuretable(L, (lc520 + lc_nextra));
  enum { lc521 = 9 };
  assert((lua_gettop(L) == (lc521 + lc_nextra)));
  lua_pushvalue(L, (lc521 + lc_nextra));
  lua_pushcclosure(L, lcf2_Xe, 1);
  lua_rawseti(L, (lc521 + lc_nextra), 145);
  assert(lua_gettop(L) - lc_nextra == 9);

  /* local function n(e)
   * return Ze(d()[e])
   * end */
  lc_newclosuretable(L, (lc521 + lc_nextra));
  enum { lc523 = 10 };
  assert((lua_gettop(L) == (lc523 + lc_nextra)));
  lua_pushvalue(L, (lc523 + lc_nextra));
  lua_pushcclosure(L, lcf4_n, 1);
  lua_rawseti(L, (lc523 + lc_nextra), 146);
  assert(lua_gettop(L) - lc_nextra == 10);

  /* y={Ae} */
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, (lc523 + lc_nextra), 7, 112);
  lua_rawseti(L, -2, 1);
  lc_setupvalue(L, (lc523 + lc_nextra), 7, 89);
  assert(lua_gettop(L) - lc_nextra == 10);

  /* local function Ve(e)
   * local t=Qe(e)
   * local function o(e)
   * e[2]=W(e[2])
   * e[3]=W(e[3])
   * if I(e[2])or I(e[3])then
   * local t=lt(e)
   * local a=e[2]
   * local e=e[3]
   * local a=Ve(a)
   * local e=Ve(e)
   * t[2]=a
   * t[3]=e
   * return t
   * else
   * return e
   * end
   * end
   * if c(t)then
   * return o(t)
   * elseif g(t)then
   * return o(t)
   * elseif a(t)then
   * return o(t)
   * end
   * return t
   * end */
  lc_newclosuretable(L, (lc523 + lc_nextra));
  enum { lc525 = 11 };
  assert((lua_gettop(L) == (lc525 + lc_nextra)));
  lua_pushvalue(L, (lc525 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ve, 1);
  lua_rawseti(L, (lc525 + lc_nextra), 147);
  assert(lua_gettop(L) - lc_nextra == 11);

  /* z=n("太始初核") */
  lc_getupvalue(L, (lc525 + lc_nextra), 1, 146);
  lua_pushliteral(L, "太始初核");
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc525 + lc_nextra), 8, 54);
  assert(lua_gettop(L) - lc_nextra == 11);

  /* local ye=n("符名") */
  lc_newclosuretable(L, (lc525 + lc_nextra));
  enum { lc537 = 12 };
  assert((lua_gettop(L) == (lc537 + lc_nextra)));
  lc_getupvalue(L, (lc525 + lc_nextra), 1, 146);
  lua_pushliteral(L, "符名");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc537 + lc_nextra), 148);
  assert(lua_gettop(L) - lc_nextra == 12);

  /* t=n("化滅") */
  lc_getupvalue(L, (lc537 + lc_nextra), 2, 146);
  lua_pushliteral(L, "化滅");
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc537 + lc_nextra), 9, 53);
  assert(lua_gettop(L) - lc_nextra == 12);

  /* x=n("式形") */
  lc_getupvalue(L, (lc537 + lc_nextra), 2, 146);
  lua_pushliteral(L, "式形");
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc537 + lc_nextra), 9, 52);
  assert(lua_gettop(L) - lc_nextra == 12);

  /* local pt=n("等同") */
  lc_getupvalue(L, (lc537 + lc_nextra), 2, 146);
  lua_pushliteral(L, "等同");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 13);

  /* local vt=n("解算") */
  lc_getupvalue(L, (lc537 + lc_nextra), 2, 146);
  lua_pushliteral(L, "解算");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 14);

  /* local Y=n("特定其物") */
  lc_newclosuretable(L, (lc537 + lc_nextra));
  enum { lc538 = 15 };
  assert((lua_gettop(L) == (lc538 + lc_nextra)));
  lc_getupvalue(L, (lc537 + lc_nextra), 2, 146);
  lua_pushliteral(L, "特定其物");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc538 + lc_nextra), 149);
  assert(lua_gettop(L) - lc_nextra == 15);

  /* local m=n("省略一物") */
  lc_newclosuretable(L, (lc538 + lc_nextra));
  enum { lc539 = 16 };
  assert((lua_gettop(L) == (lc539 + lc_nextra)));
  lc_getupvalue(L, (lc538 + lc_nextra), 3, 146);
  lua_pushliteral(L, "省略一物");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc539 + lc_nextra), 150);
  assert(lua_gettop(L) - lc_nextra == 16);

  /* Se=n("映表") */
  lc_getupvalue(L, (lc539 + lc_nextra), 4, 146);
  lua_pushliteral(L, "映表");
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc539 + lc_nextra), 11, 51);
  assert(lua_gettop(L) - lc_nextra == 16);

  /* local yt=n("如若") */
  lc_getupvalue(L, (lc539 + lc_nextra), 4, 146);
  lua_pushliteral(L, "如若");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 17);

  /* local u=n("一類何物") */
  lc_newclosuretable(L, (lc539 + lc_nextra));
  enum { lc540 = 18 };
  assert((lua_gettop(L) == (lc540 + lc_nextra)));
  lc_getupvalue(L, (lc539 + lc_nextra), 4, 146);
  lua_pushliteral(L, "一類何物");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc540 + lc_nextra), 151);
  assert(lua_gettop(L) - lc_nextra == 18);

  /* local ae=n("是非") */
  lc_newclosuretable(L, (lc540 + lc_nextra));
  enum { lc541 = 19 };
  assert((lua_gettop(L) == (lc541 + lc_nextra)));
  lc_getupvalue(L, (lc540 + lc_nextra), 5, 146);
  lua_pushliteral(L, "是非");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc541 + lc_nextra), 152);
  assert(lua_gettop(L) - lc_nextra == 19);

  /* local pe=n("其子") */
  lc_newclosuretable(L, (lc541 + lc_nextra));
  enum { lc542 = 20 };
  assert((lua_gettop(L) == (lc542 + lc_nextra)));
  lc_getupvalue(L, (lc541 + lc_nextra), 6, 146);
  lua_pushliteral(L, "其子");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc542 + lc_nextra), 153);
  assert(lua_gettop(L) - lc_nextra == 20);

  /* local Je=n("爻陽") */
  lc_newclosuretable(L, (lc542 + lc_nextra));
  enum { lc543 = 21 };
  assert((lua_gettop(L) == (lc543 + lc_nextra)));
  lc_getupvalue(L, (lc542 + lc_nextra), 7, 146);
  lua_pushliteral(L, "爻陽");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc543 + lc_nextra), 154);
  assert(lua_gettop(L) - lc_nextra == 21);

  /* local et=n("爻陰") */
  lc_newclosuretable(L, (lc543 + lc_nextra));
  enum { lc544 = 22 };
  assert((lua_gettop(L) == (lc544 + lc_nextra)));
  lc_getupvalue(L, (lc543 + lc_nextra), 8, 146);
  lua_pushliteral(L, "爻陰");
  lua_call(L, 1, 1);
  lua_rawseti(L, (lc544 + lc_nextra), 155);
  assert(lua_gettop(L) - lc_nextra == 22);

  /* local gt=n("引用") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "引用");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 23);

  /* local wt=n("應用") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "應用");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 24);

  /* local bt=n("間空") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "間空");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 25);

  /* local ne=n("連頸") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "連頸");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 26);

  /* local se=n("構物") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "構物");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 27);

  /* local he=n("謬誤") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "謬誤");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 28);

  /* local ft=n("詞素") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "詞素");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 29);

  /* local Ie=n("列序") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "列序");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 30);

  /* local ct=n("首始") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "首始");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 31);

  /* local mt=n("尾末") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "尾末");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 32);

  /* local ht=n("之物") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "之物");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 33);

  /* local d=n("宇宙亡矣") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "宇宙亡矣");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 34);

  /* local ot=n("效應") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "效應");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 35);

  /* local it=n("註疏") */
  lc_getupvalue(L, (lc544 + lc_nextra), 9, 146);
  lua_pushliteral(L, "註疏");
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 36);

  /* dt=L(z,e(d,m)) */
  lc_getupvalue(L, (lc544 + lc_nextra), 16, 83);
  const int lc545 = lua_gettop(L);
  lc_getupvalue(L, (lc544 + lc_nextra), 16, 54);
  lc_getupvalue(L, (lc544 + lc_nextra), 16, 27);
  lua_pushvalue(L, (34 + lc_nextra));
  lc_getupvalue(L, (lc544 + lc_nextra), 5, 150);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc545), 1);
  lc_setupvalue(L, (lc544 + lc_nextra), 16, 50);
  assert(lua_gettop(L) - lc_nextra == 36);

  /* local function b(e)
   * return T(ye,s(z,s(e,y)))
   * end */
  lc_newclosuretable(L, (lc544 + lc_nextra));
  enum { lc546 = 37 };
  assert((lua_gettop(L) == (lc546 + lc_nextra)));
  lua_pushvalue(L, (lc546 + lc_nextra));
  lua_pushcclosure(L, lcf1_b, 1);
  lua_rawseti(L, (lc546 + lc_nextra), 156);
  assert(lua_gettop(L) - lc_nextra == 37);

  /* local function Ae(a)
   * return b(e(u,e(t,m,a),Y))
   * end */
  lua_pushvalue(L, (lc546 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ae, 1);
  assert(lua_gettop(L) - lc_nextra == 38);

  /* local function d(a,o)
   * return b(e(u,e(t,e(a),m),o))
   * end */
  lua_pushvalue(L, (lc546 + lc_nextra));
  lua_pushcclosure(L, lcf6_d, 1);
  assert(lua_gettop(L) - lc_nextra == 39);

  /* local function M(a)
   * return b(e(u,t,e(ae,e(u,a,m))))
   * end */
  lua_pushvalue(L, (lc546 + lc_nextra));
  lua_pushcclosure(L, lcf1_M, 1);
  assert(lua_gettop(L) - lc_nextra == 40);

  /* local dt=Ae(se) */
  lua_pushvalue(L, (38 + lc_nextra));
  lua_pushvalue(L, (27 + lc_nextra));
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 41);

  /* He=d(se,ye) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (27 + lc_nextra));
  lc_getupvalue(L, (lc546 + lc_nextra), 8, 148);
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 49);
  assert(lua_gettop(L) - lc_nextra == 41);

  /* We=d(se,Ie) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (27 + lc_nextra));
  lua_pushvalue(L, (30 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 48);
  assert(lua_gettop(L) - lc_nextra == 41);

  /* Fe=M(se) */
  lua_pushvalue(L, (40 + lc_nextra));
  lua_pushvalue(L, (27 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 47);
  assert(lua_gettop(L) - lc_nextra == 41);

  /* local lt=Ae(he) */
  lua_pushvalue(L, (38 + lc_nextra));
  lua_pushvalue(L, (28 + lc_nextra));
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 42);

  /* Ye=d(he,ye) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (28 + lc_nextra));
  lc_getupvalue(L, (lc546 + lc_nextra), 8, 148);
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 46);
  assert(lua_gettop(L) - lc_nextra == 42);

  /* Pe=d(he,Ie) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (28 + lc_nextra));
  lua_pushvalue(L, (30 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 45);
  assert(lua_gettop(L) - lc_nextra == 42);

  /* Me=M(he) */
  lua_pushvalue(L, (40 + lc_nextra));
  lua_pushvalue(L, (28 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 44);
  assert(lua_gettop(L) - lc_nextra == 42);

  /* local ut=Ae(ne) */
  lua_pushvalue(L, (38 + lc_nextra));
  lua_pushvalue(L, (26 + lc_nextra));
  lua_call(L, 1, 1);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* De=M(ne) */
  lua_pushvalue(L, (40 + lc_nextra));
  lua_pushvalue(L, (26 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 43);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* Re=d(ne,ct) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (26 + lc_nextra));
  lua_pushvalue(L, (31 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 42);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* Le=d(ne,mt) */
  lua_pushvalue(L, (39 + lc_nextra));
  lua_pushvalue(L, (26 + lc_nextra));
  lua_pushvalue(L, (32 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 41);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* Ue=M(ft) */
  lua_pushvalue(L, (40 + lc_nextra));
  lua_pushvalue(L, (29 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 40);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* Ce=M(bt) */
  lua_pushvalue(L, (40 + lc_nextra));
  lua_pushvalue(L, (25 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 39);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* te=b(e(u,t,e(ae,pt))) */
  lc_getupvalue(L, (lc546 + lc_nextra), 0, 156);
  const int lc558 = lua_gettop(L);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  const int lc559 = lua_gettop(L);
  lc_getupvalue(L, (lc546 + lc_nextra), 5, 151);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 53);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  lc_getupvalue(L, (lc546 + lc_nextra), 4, 152);
  lua_pushvalue(L, (13 + lc_nextra));
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc559), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc558), 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 38);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* be=b(e(u,e(t,s(t,m),m),wt)) */
  lc_getupvalue(L, (lc546 + lc_nextra), 0, 156);
  const int lc560 = lua_gettop(L);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  lc_getupvalue(L, (lc546 + lc_nextra), 5, 151);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 53);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 93);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 53);
  lc_getupvalue(L, (lc546 + lc_nextra), 6, 150);
  lua_call(L, 2, 1);
  lc_getupvalue(L, (lc546 + lc_nextra), 6, 150);
  lua_call(L, 3, 1);
  lua_pushvalue(L, (24 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc560), 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 37);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* ve=b(e(u,t,vt)) */
  lc_getupvalue(L, (lc546 + lc_nextra), 0, 156);
  const int lc561 = lua_gettop(L);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  lc_getupvalue(L, (lc546 + lc_nextra), 5, 151);
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 53);
  lua_pushvalue(L, (14 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc561), 1);
  lc_setupvalue(L, (lc546 + lc_nextra), 17, 36);
  assert(lua_gettop(L) - lc_nextra == 43);

  /* local Ie=d(Ie,e(u,ht,m)) */
  lc_newclosuretable(L, (lc546 + lc_nextra));
  enum { lc562 = 44 };
  assert((lua_gettop(L) == (lc562 + lc_nextra)));
  lua_pushvalue(L, (39 + lc_nextra));
  const int lc563 = lua_gettop(L);
  lua_pushvalue(L, (30 + lc_nextra));
  lc_getupvalue(L, (lc546 + lc_nextra), 17, 27);
  lc_getupvalue(L, (lc546 + lc_nextra), 5, 151);
  lua_pushvalue(L, (33 + lc_nextra));
  lc_getupvalue(L, (lc546 + lc_nextra), 6, 150);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc563), 1);
  lua_rawseti(L, (lc562 + lc_nextra), 157);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* ee=b(e(u,t,yt)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc564 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 6, 151);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 53);
  lua_pushvalue(L, (17 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc564), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 35);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* ke=b(e(u,x,gt)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc565 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 6, 151);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lua_pushvalue(L, (23 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc565), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 34);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* st=b(e(u,e(x,e(t,m,t)),Y)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc566 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 6, 151);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  const int lc567 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 53);
  lc_getupvalue(L, (lc562 + lc_nextra), 7, 150);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 53);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc567), 1);
  lc_getupvalue(L, (lc562 + lc_nextra), 8, 149);
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc566), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 33);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* J=b(e(x,e(z,t))) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc568 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  const int lc569 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 54);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 53);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc569), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc568), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 32);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* ie=b(e(x,e(z,x))) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc570 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  const int lc571 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 54);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc571), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc570), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 31);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* nt=b(e(x,x)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc572 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc572), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 30);
  assert(lua_gettop(L) - lc_nextra == 44);

  /* local nt=b(e(u,t,it)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc573 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 6, 151);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 53);
  lua_pushvalue(L, (36 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc573), 1);
  assert(lua_gettop(L) - lc_nextra == 45);

  /* tt=b(e(u,x,it)) */
  lc_getupvalue(L, (lc562 + lc_nextra), 1, 156);
  const int lc574 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lc_getupvalue(L, (lc562 + lc_nextra), 6, 151);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 52);
  lua_pushvalue(L, (36 + lc_nextra));
  lua_call(L, 3, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc574), 1);
  lc_setupvalue(L, (lc562 + lc_nextra), 18, 29);
  assert(lua_gettop(L) - lc_nextra == 45);

  /* local d=T(et,e()) */
  lc_newclosuretable(L, (lc562 + lc_nextra));
  enum { lc575 = 46 };
  assert((lua_gettop(L) == (lc575 + lc_nextra)));
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 87);
  const int lc576 = lua_gettop(L);
  lc_getupvalue(L, (lc562 + lc_nextra), 2, 155);
  lc_getupvalue(L, (lc562 + lc_nextra), 18, 27);
  lua_call(L, 0, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc576), 1);
  lua_rawseti(L, (lc575 + lc_nextra), 158);
  assert(lua_gettop(L) - lc_nextra == 46);

  /* local se=T(Je,e()) */
  lc_newclosuretable(L, (lc575 + lc_nextra));
  enum { lc577 = 47 };
  assert((lua_gettop(L) == (lc577 + lc_nextra)));
  lc_getupvalue(L, (lc575 + lc_nextra), 19, 87);
  const int lc578 = lua_gettop(L);
  lc_getupvalue(L, (lc575 + lc_nextra), 4, 154);
  lc_getupvalue(L, (lc575 + lc_nextra), 19, 27);
  lua_call(L, 0, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc578), 1);
  lua_rawseti(L, (lc577 + lc_nextra), 159);
  assert(lua_gettop(L) - lc_nextra == 47);

  /* local function ke(e,n,s)
   * local t={}
   * while a(e)do
   * v(t,o(e))
   * e=i(e)
   * end
   * if h(e)then
   * return n(t)
   * end
   * return s(t,e)
   * end */
  lc_newclosuretable(L, (lc577 + lc_nextra));
  enum { lc579 = 48 };
  assert((lua_gettop(L) == (lc579 + lc_nextra)));
  lua_pushvalue(L, (lc579 + lc_nextra));
  lua_pushcclosure(L, lcf1_ke, 1);
  lua_rawseti(L, (lc579 + lc_nextra), 160);
  assert(lua_gettop(L) - lc_nextra == 48);

  /* local function M(e)
   * return ke(e,function(e)return e end,function(e,e)return false end)
   * end */
  lc_newclosuretable(L, (lc579 + lc_nextra));
  enum { lc586 = 49 };
  assert((lua_gettop(L) == (lc586 + lc_nextra)));
  lua_pushvalue(L, (lc586 + lc_nextra));
  lua_pushcclosure(L, lcf2_M, 1);
  lua_rawseti(L, (lc586 + lc_nextra), 161);
  assert(lua_gettop(L) - lc_nextra == 49);

  /* local function tt(e)
   * while B(e)or I(e)do
   * e=N(qe(e))
   * end
   * return e
   * end */
  lua_pushvalue(L, (lc586 + lc_nextra));
  lua_pushcclosure(L, lcf1_tt, 1);
  assert(lua_gettop(L) - lc_nextra == 50);

  /* local function Ae(e)
   * if Q(e)then
   * return e
   * elseif G(e)then
   * error("WIP")
   * elseif P(e)then
   * error("WIP")
   * elseif V(e)then
   * error("WIP")
   * end
   * return j()
   * end */
  lc_newclosuretable(L, (lc586 + lc_nextra));
  enum { lc592 = 51 };
  assert((lua_gettop(L) == (lc592 + lc_nextra)));
  lua_pushvalue(L, (lc592 + lc_nextra));
  lua_pushcclosure(L, lcf2_Ae, 1);
  lua_rawseti(L, (lc592 + lc_nextra), 162);
  assert(lua_gettop(L) - lc_nextra == 51);

  /* local function it(e)
   * return X(Ae(e))
   * end */
  lua_pushvalue(L, (lc592 + lc_nextra));
  lua_pushcclosure(L, lcf2_it, 1);
  assert(lua_gettop(L) - lc_nextra == 52);

  /* local function ct(e)
   * return Z(Ae(e))
   * end */
  lua_pushvalue(L, (lc592 + lc_nextra));
  lua_pushcclosure(L, lcf1_ct, 1);
  assert(lua_gettop(L) - lc_nextra == 53);

  /* local function st(e)
   * if I(e)then
   * return K(e)
   * else
   * return k(e)
   * end
   * end */
  lua_pushvalue(L, (lc592 + lc_nextra));
  lua_pushcclosure(L, lcf1_st, 1);
  assert(lua_gettop(L) - lc_nextra == 54);

  /* Be={} */
  lua_newtable(L);
  lc_setupvalue(L, (lc592 + lc_nextra), 23, 19);
  assert(lua_gettop(L) - lc_nextra == 54);

  /* local function he(t)
   * t=r(t)
   * if not c(t)then
   * return false
   * end
   * local e=r(E(t))
   * if not p(e)then
   * return false
   * end
   * if not D(e,Se)then
   * return false
   * end
   * e=r(A(t))
   * if not a(e)then
   * return false
   * end
   * if not h(r(i(e)))then
   * return false
   * end
   * local t={}
   * local n=r(o(e))
   * while not h(n)do
   * if not a(n)then
   * return false
   * end
   * local e=r(o(n))
   * n=r(i(n))
   * if not a(e)then
   * return false
   * end
   * local n=o(e)
   * e=r(i(e))
   * if not a(e)then
   * return false
   * end
   * local o=o(e)
   * if not h(r(i(e)))then
   * return false
   * end
   * local a=true
   * do
   * local e=0
   * while e<#t do
   * if l(t[(e+0)+1],n)then
   * t[(e+1)+1]=o
   * a=false
   * break
   * end
   * e=e+2
   * end
   * end
   * if a then
   * v(t,n)
   * v(t,o)
   * end
   * end
   * return t
   * end */
  lc_newclosuretable(L, (lc592 + lc_nextra));
  enum { lc610 = 55 };
  assert((lua_gettop(L) == (lc610 + lc_nextra)));
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf1_he, 1);
  lua_rawseti(L, (lc610 + lc_nextra), 163);
  assert(lua_gettop(L) - lc_nextra == 55);

  /* local function ie(t,a)
   * return{
   * t,
   * 1,
   * function(e)
   * e=k(e)
   * if w(e)then
   * return q(t,{e})
   * end
   * if a(e)then
   * return se
   * end
   * return d
   * end,
   * }
   * end */
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf1_ie, 1);
  assert(lua_gettop(L) - lc_nextra == 56);

  /* local function J(t,a,o)
   * return{
   * t,
   * 1,
   * function(e,i)
   * e=k(e)
   * if w(e)then
   * return q(t,{e})
   * end
   * if a(e)then
   * return o(e)
   * end
   * return i()
   * end,
   * }
   * end */
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf1_J, 1);
  assert(lua_gettop(L) - lc_nextra == 57);

  /* at={
   * ie(Fe,c),
   * {
   * dt,
   * 2,
   * T,
   * },
   * J(He,c,E),
   * J(We,c,A),
   * ie(Me,g),
   * {
   * lt,
   * 2,
   * L,
   * },
   * J(Ye,g,C),
   * J(Pe,g,U),
   * ie(Ce,h),
   * {
   * ut,
   * 2,
   * s,
   * },
   * ie(De,a),
   * J(Re,a,o),
   * J(Le,a,i),
   * {
   * te,
   * 2,
   * function(e,t,n)
   * if e==t then
   * return se
   * end
   * e=k(e)
   * t=k(t)
   * if w(e)or w(t)then
   * return q(te,{
   * e,
   * t,
   * })
   * end
   * if e==t then
   * return se
   * end
   * local function n(a,t,e)
   * return q(ee,{
   * a,
   * t,
   * e,
   * })
   * end
   * local function s(t,e)
   * return n(t,e,d)
   * end
   * H(not w(e))
   * local function n(e,o,t,a)
   * return s(q(te,{
   * t(e),
   * t(o),
   * }),q(te,{
   * a(e),
   * a(o),
   * }))
   * end
   * if h(e)then
   * if not h(e)then
   * return d
   * end
   * return se
   * elseif p(e)then
   * if not p(t)then
   * return d
   * end
   * if D(e,t)then
   * return se
   * else
   * return d
   * end
   * elseif c(e)then
   * if not c(t)then
   * return d
   * end
   * return n(e,t,E,A)
   * elseif a(e)then
   * if not a(t)then
   * return d
   * end
   * return n(e,t,o,i)
   * elseif g(e)then
   * if not g(t)then
   * return d
   * end
   * return n(e,t,C,U)
   * end
   * return j()
   * end,
   * },
   * {
   * be,
   * 2,
   * function(n,e,s)
   * local t={}
   * local e=r(e)
   * while a(e)do
   * v(t,o(e))
   * e=r(i(e))
   * end
   * if not h(e)then
   * return s()
   * end
   * return F(n,t)
   * end,
   * },
   * {
   * ve,
   * 2,
   * function(e,a,t)
   * local e=he(e)
   * if e==false then
   * return t()
   * end
   * return S(e,a)
   * end,
   * },
   * ie(Ue,p),
   * {
   * Ie,
   * 1,
   * function(e,t)
   * e=k(e)
   * if w(e)then
   * return q(Ie,{e})
   * end
   * if not a(e)then
   * return t()
   * end
   * return o(e)
   * end,
   * },
   * {
   * ee,
   * 3,
   * function(e,a,o,t)
   * e=k(e)
   * if w(e)then
   * return q(ee,{
   * e,
   * a,
   * o,
   * })
   * end
   * if not c(e)then
   * return t()
   * end
   * local e=r(E(e))
   * if not p(e)then
   * return t()
   * end
   * if D(e,Je)then
   * return a
   * end
   * if D(e,et)then
   * return o
   * end
   * return t()
   * end,
   * },
   * {
   * nt,
   * 2,
   * fe,
   * },
   * } */
  lua_createtable(L, 20, 0);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 47);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 86);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 1);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (41 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 87);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 49);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 86);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 85);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 3);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 48);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 86);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 84);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 4);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 44);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 82);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 5);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (42 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 83);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 6);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 46);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 82);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 81);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 7);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 45);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 82);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 80);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 8);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 39);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 88);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 9);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (43 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 93);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 10);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 43);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 92);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 11);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 42);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 92);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 91);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 12);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 41);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 92);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 90);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 13);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 38);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf705, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 14);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 37);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf713, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 15);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 36);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf719, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 16);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 40);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 97);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 17);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (lc610 + lc_nextra), 6, 157);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf727, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 18);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 35);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 3);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (lc610 + lc_nextra));
  lua_pushcclosure(L, lcf743, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 19);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (45 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 102);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 20);
  lc_setupvalue(L, (lc610 + lc_nextra), 24, 10);
  assert(lua_gettop(L) - lc_nextra == 57);

  /* local J */
  lua_settop(L, (lua_gettop(L) + 1));
  assert(lua_gettop(L) - lc_nextra == 58);

  /* J=l */
  lc_getupvalue(L, (lc610 + lc_nextra), 24, 4);
  lua_replace(L, (58 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 58);

  /* local function d(e,t)
   * if e==t then
   * return true
   * end
   * e=N(e)
   * t=N(t)
   * if e==t then
   * return true
   * end
   * local function n(e,t,a,o)
   * if d(a(e),a(t))and d(o(e),o(t))then
   * O(e,t)
   * return true
   * else
   * return false
   * end
   * end
   * if h(e)then
   * if not h(t)then
   * return false
   * end
   * O(e,y)
   * O(t,y)
   * return true
   * elseif p(e)then
   * if not p(t)then
   * return false
   * end
   * return D(e,t)
   * elseif a(e)then
   * if not a(t)then
   * return false
   * end
   * return n(e,t,o,i)
   * elseif g(e)then
   * if not g(t)then
   * return false
   * end
   * return n(e,t,C,U)
   * elseif c(e)then
   * if not c(t)then
   * return false
   * end
   * return n(e,t,E,A)
   * elseif me(e)then
   * return false
   * end
   * return j()
   * end */
  lc_newclosuretable(L, (lc610 + lc_nextra));
  enum { lc744 = 59 };
  assert((lua_gettop(L) == (lc744 + lc_nextra)));
  lua_pushvalue(L, (lc744 + lc_nextra));
  lua_pushcclosure(L, lcf7_d, 1);
  lua_rawseti(L, (lc744 + lc_nextra), 171);
  assert(lua_gettop(L) - lc_nextra == 59);

  /* local function ee(J)
   * local D,w,l,d,c,r,j,E,B,g,O,I,N,V,C,P,R,W,M,A,U,k,f,K,G,Q
   * function l()
   * return#D==w
   * end
   * function d()
   * H(not l())
   * local e=string.sub(D,w+1,w+1)
   * w=w+1
   * return e
   * end
   * function c(e)
   * H(string.sub(D,w,w)==e)
   * w=w-1
   * end
   * function r(e)
   * if e==nil then
   * e=""
   * end
   * error("TheLanguage parse ERROR!"..tostring(e))
   * end
   * function j(e)
   * return e==" "or e=="\n"or e=="\t"or e=="\r"
   * end
   * function E()
   * if l()then
   * return false
   * end
   * local e=d()
   * if not j(e)then
   * c(e)
   * return false
   * end
   * while j(e)and not l()do
   * e=d()
   * end
   * if not j(e)then
   * c(e)
   * end
   * return true
   * end
   * function B()
   * if l()then
   * return false
   * end
   * local e=d()
   * local t=""
   * if not W(e)then
   * c(e)
   * return false
   * end
   * while W(e)and not l()do
   * t=tostring(t)..tostring(e)
   * e=d()
   * end
   * if W(e)then
   * t=tostring(t)..tostring(e)
   * else
   * c(e)
   * end
   * if Xe(t)then
   * return n(t)
   * else
   * return r("Not Atom"..tostring(t))
   * end
   * end
   * function g()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="("then
   * c(e)
   * return false
   * end
   * local t=ge()
   * local a=t
   * local function o(a)
   * local e=ge()
   * we(t,s(a,e))
   * t=e
   * end
   * while true do
   * E()
   * if l()then
   * return r()
   * end
   * e=d()
   * if e==")"then
   * we(t,y)
   * return a
   * end
   * if e=="."then
   * E()
   * local o=M()
   * we(t,o)
   * E()
   * if l()then
   * return r()
   * end
   * e=d()
   * if e~=")"then
   * return r()
   * end
   * return a
   * end
   * c(e)
   * local e=M()
   * o(e)
   * end
   * end
   * function O()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="#"then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * return T(o(e),i(e))
   * end
   * function I()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~="!"then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * return L(o(e),i(e))
   * end
   * function W(e)
   * if j(e)then
   * return false
   * end
   * for a,t in ipairs({
   * "(",
   * ")",
   * "!",
   * "#",
   * ".",
   * "$",
   * "%",
   * "^",
   * "@",
   * "~",
   * "/",
   * "-",
   * ">",
   * "_",
   * ":",
   * "?",
   * "[",
   * "]",
   * "&",
   * ";",
   * })do
   * if t==e then
   * return false
   * end
   * end
   * return true
   * end
   * function M()
   * E()
   * local e={
   * g,
   * Q,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * for t,e in ipairs(e)do
   * local e=e()
   * if e~=false then
   * return e
   * end
   * end
   * return r()
   * end
   * function A(e)
   * if e==false then
   * return r()
   * end
   * return e
   * end
   * function U()
   * return not l()
   * end
   * function k(e)
   * A(U())
   * A(d()==e)
   * end
   * function f(t)
   * if t==nil then
   * t=false
   * end
   * local function a()
   * k("[")
   * local e=f()
   * k("]")
   * return e
   * end
   * local e
   * if t then
   * e={
   * g,
   * B,
   * a,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * else
   * e={
   * g,
   * G,
   * O,
   * I,
   * N,
   * V,
   * C,
   * P,
   * R,
   * }
   * end
   * for t,e in ipairs(e)do
   * local e=e()
   * if e~=false then
   * return e
   * end
   * end
   * return r()
   * end
   * function K(a)
   * if l()then
   * return a
   * end
   * local o=d()
   * if o=="."then
   * local o=f()
   * return e(u,e(t,e(a),m),o)
   * elseif o==":"then
   * local t=f()
   * return e(u,t,a)
   * elseif o=="~"then
   * return e(ae,a)
   * elseif o=="@"then
   * local o=f()
   * return e(u,e(t,s(a,m),m),o)
   * elseif o=="?"then
   * return e(u,t,e(ae,a))
   * elseif o=="/"then
   * local t={a}
   * while true do
   * local e=f(true)
   * v(t,e)
   * if l()then
   * break
   * end
   * local e=d()
   * if e~="/"then
   * c(e)
   * break
   * end
   * end
   * return e(pe,_(t))
   * else
   * c(o)
   * return a
   * end
   * end
   * function G()
   * if l()then
   * return false
   * end
   * local a=d()
   * if a=="&"then
   * A(U())
   * local t=d()
   * if t=="+"then
   * local t=f()
   * return e(x,e(z,t))
   * else
   * c(t)
   * end
   * local t=f()
   * return e(x,t)
   * elseif a==":"then
   * A(U())
   * local a=d()
   * if a=="&"then
   * k(">")
   * local a=f()
   * return e(u,e(x,e(t,m,a)),Y)
   * elseif a==">"then
   * local a=f()
   * return e(u,e(t,m,a),Y)
   * else
   * c(a)
   * end
   * local t=f()
   * return e(u,t,Y)
   * elseif a=="+"then
   * local t=f()
   * return e(z,t)
   * elseif a=="["then
   * local e=f()
   * k("]")
   * return K(e)
   * elseif a=="_"then
   * k(":")
   * local t=f()
   * return e(u,t,m)
   * else
   * c(a)
   * local e=B()
   * if e==false then
   * return false
   * end
   * return K(e)
   * end
   * end
   * function Q()
   * local e=G()
   * if e==false then
   * return false
   * end
   * if p(e)then
   * return e
   * end
   * return b(e)
   * end
   * D=J
   * w=0
   * local function t(t,n)
   * return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local t=i(e)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return n(o(e),o(t))
   * end
   * end
   * local function s(t,s)
   * return function()
   * if l()then
   * return false
   * end
   * local e=d()
   * if e~=t then
   * c(e)
   * return false
   * end
   * local e=g()
   * if e==false then
   * return r()
   * end
   * if not a(e)then
   * return r()
   * end
   * local n=i(e)
   * if not a(n)then
   * return r()
   * end
   * local t=i(n)
   * if not(a(t)and h(i(t)))then
   * return r()
   * end
   * return s(o(e),o(n),o(t))
   * end
   * end
   * N=t("$",function(e,t)
   * local e=he(e)
   * if e==false then
   * return r()
   * end
   * return S(e,t)
   * end)
   * V=t("%",function(t,e)
   * local e=ke(e,function(e)return e end,function(e,e)return r()end)
   * return q(t,e)
   * end)
   * C=s("@",function(o,a,e)
   * local t=ke(e,function(e)return e end,function(e,e)return r()end)
   * local e=he(o)
   * if e==false then
   * return r()
   * end
   * return Oe(e,a,t)
   * end)
   * P=t("^",function(t,e)
   * local e=ke(e,function(e)return e end,function(e,e)return r()end)
   * return F(t,e)
   * end)
   * R=t(";",function(t,e)return fe(t,e)end)
   * return M()
   * end */
  lc_newclosuretable(L, (lc744 + lc_nextra));
  enum { lc782 = 60 };
  assert((lua_gettop(L) == (lc782 + lc_nextra)));
  lua_pushvalue(L, (lc782 + lc_nextra));
  lua_pushcclosure(L, lcf1_ee, 1);
  lua_rawseti(L, (lc782 + lc_nextra), 172);
  assert(lua_gettop(L) - lc_nextra == 60);

  /* local function q(w)
   * local function n(r,l)
   * if p(r)then
   * return de(r)
   * end
   * local function s(e)
   * if l then
   * return"["..tostring(e).."]"
   * else
   * return e
   * end
   * end
   * local e=M(r)
   * if e~=false and#e==3 and d(e[1],u)then
   * local h=M(e[2])
   * if h~=false and#h==3 and d(h[1],t)then
   * local t=h[2]
   * local r=M(t)
   * if r~=false and#r==1 and d(h[3],m)then
   * return s(tostring(n(r[1],true)).."."..tostring(n(e[3],true)))
   * elseif a(t)and d(i(t),m)and d(h[3],m)then
   * return s(tostring(n(o(t),true)).."@"..tostring(n(e[3],true)))
   * elseif d(t,m)and d(e[3],Y)then
   * return s(":>"..tostring(n(h[3],true)))
   * end
   * end
   * local a=M(e[3])
   * if d(e[2],t)and a~=false and#a==2 and d(a[1],ae)then
   * return s(tostring(n(a[2],true)).."?")
   * end
   * if h~=false and#h==2 and d(e[3],Y)and d(h[1],x)then
   * local e=M(h[2])
   * if e~=false and#e==3 and d(e[1],t)and d(e[2],m)then
   * return s(":&>"..tostring(n(e[3],true)))
   * end
   * end
   * local t
   * if d(e[3],m)then
   * t="_"
   * elseif d(e[3],Y)then
   * t=""
   * else
   * t=n(e[3],true)
   * end
   * return s(tostring(t)..":"..tostring(n(e[2],true)))
   * elseif e~=false and#e==2 then
   * if d(e[1],x)then
   * local t=M(e[2])
   * if t~=false and#t==2 and d(t[1],z)then
   * return s("&+"..tostring(n(t[2],true)))
   * end
   * return s("&"..tostring(n(e[2],true)))
   * elseif d(e[1],ae)then
   * return s(tostring(n(e[2],true)).."~")
   * elseif d(e[1],z)then
   * return s("+"..tostring(n(e[2],true)))
   * elseif d(e[1],pe)then
   * local e=M(e[2])
   * if e~=false and#e>1 then
   * local a=n(e[1],true)
   * do
   * local t=1
   * while t<#e do
   * a=tostring(a).."/"..tostring(n(e[t+1],true))
   * t=t+1
   * end
   * end
   * return s(a)
   * end
   * end
   * end
   * if l then
   * return f(r)
   * else
   * return f(b(r))
   * end
   * end
   * local e=ee(f(w))
   * local t=""
   * local r=""
   * if h(e)then
   * return"()"
   * elseif a(e)then
   * t="("
   * r=""
   * while a(e)do
   * t=tostring(t)..tostring(r)..tostring(q(o(e)))
   * r=" "
   * e=i(e)
   * end
   * if h(e)then
   * t=tostring(t)..")"
   * else
   * t=tostring(t).." . "..tostring(q(e))..")"
   * end
   * return t
   * elseif c(e)then
   * local t=E(e)
   * local a=A(e)
   * local e=M(a)
   * if e~=false and#e==2 and d(t,ye)and d(e[1],z)then
   * return n(e[2],false)
   * end
   * return"#"..tostring(q(s(t,a)))
   * elseif g(e)then
   * return"!"..tostring(q(s(C(e),U(e))))
   * elseif p(e)then
   * return de(e)
   * elseif I(e)then
   * return";("..tostring(q(oe(e))).." "..tostring(q(K(e)))..")"
   * elseif Q(e)then
   * return"$("..tostring(q(R(X(e)))).." "..tostring(q(Z(e)))..")"
   * elseif P(e)then
   * return"%("..tostring(q(ue(e))).." "..tostring(q(_(re(e))))..")"
   * elseif G(e)then
   * return"@("..tostring(q(R(_e(e)))).." "..tostring(q(Te(e))).."
   * "..tostring(q(_(ze(e))))..")" elseif V(e)then
   * return"^("..tostring(q(je(e))).." "..tostring(q(_(xe(e))))..")"
   * end
   * return j()
   * end */
  lc_newclosuretable(L, (lc782 + lc_nextra));
  enum { lc1043 = 61 };
  assert((lua_gettop(L) == (lc1043 + lc_nextra)));
  lua_pushvalue(L, (lc1043 + lc_nextra));
  lua_pushcclosure(L, lcf2_q, 1);
  lua_rawseti(L, (lc1043 + lc_nextra), 204);
  assert(lua_gettop(L) - lc_nextra == 61);

  /* local function H(o)
   * local e,n,t
   * function n()
   * return e==0
   * end
   * function t()
   * return not n()
   * end
   * e=#o
   * local function a(e)
   * if e==nil then
   * e=""
   * end
   * error("MT parse ERROR "..tostring(e))
   * end
   * local function i(e)
   * if not e then
   * return a()
   * end
   * end
   * local function h()
   * i(t())
   * e=e-1
   * return string.sub(o,e+1,e+1)
   * end
   * local e={}
   * local function o(i)
   * local o=table.remove(e)
   * local t=table.remove(e)
   * if t==nil or o==nil then
   * return a()
   * else
   * return Ne(e,i(t,o))
   * end
   * end
   * while t()do
   * local t=h()
   * if t=="^"then
   * local t=""
   * while true do
   * local e=h()
   * if e=="^"then
   * break
   * end
   * t=tostring(e)..tostring(t)
   * end
   * if rt(t)then
   * Ne(e,Ze(t))
   * else
   * return a("can_new_atom_unicodechar_p(\""..tostring(t).."\") == false")
   * end
   * elseif t=="."then
   * o(s)
   * elseif t=="#"then
   * o(T)
   * elseif t=="!"then
   * o(L)
   * elseif t=="$"then
   * o(function(e,t)
   * local e=he(e)
   * if e==false then
   * return a()
   * else
   * return S(e,t)
   * end
   * end)
   * elseif t=="_"then
   * Ne(e,y)
   * else
   * return a()
   * end
   * end
   * i(n())
   * i(#e==1)
   * return e[1]
   * end */
  lua_pushvalue(L, (lc1043 + lc_nextra));
  lua_pushcclosure(L, lcf2_H, 1);
  assert(lua_gettop(L) - lc_nextra == 62);

  /* local function O(e)
   * local s={e}
   * local t=""
   * while#s~=0 do
   * local r={}
   * for n,e in ipairs(s)do
   * e=N(e)
   * local function n(e,i,a,o)
   * t=tostring(t)..tostring(i)
   * return v(r,a(e),o(e))
   * end
   * if p(e)then
   * t=tostring(t)..tostring(("^"..tostring(le(e)).."^"))
   * elseif a(e)then
   * n(e,".",o,i)
   * elseif h(e)then
   * t=tostring(t)..tostring(("_"))
   * elseif c(e)then
   * n(e,"#",E,A)
   * elseif g(e)then
   * n(e,"!",C,U)
   * elseif me(e)then
   * local e=Ae(e)
   * n(e,"$",(function(e)return R(X(e))end),Z)
   * else
   * return j()
   * end
   * end
   * s=r
   * end
   * return t
   * end */
  lua_pushvalue(L, (lc1043 + lc_nextra));
  lua_pushcclosure(L, lcf3_O, 1);
  assert(lua_gettop(L) - lc_nextra == 63);

  /* local function j(e)
   * return function()return{
   * false,
   * e,
   * }end
   * end */
  lc_newclosuretable(L, (lc1043 + lc_nextra));
  enum { lc1295 = 64 };
  assert((lua_gettop(L) == (lc1295 + lc_nextra)));
  lua_pushcfunction(L, lcf3_j);
  lua_rawseti(L, (lc1295 + lc_nextra), 216);
  assert(lua_gettop(L) - lc_nextra == 64);

  /* local function d(e)
   * return function()return{
   * true,
   * e(),
   * }end
   * end */
  lc_newclosuretable(L, (lc1295 + lc_nextra));
  enum { lc1298 = 65 };
  assert((lua_gettop(L) == (lc1298 + lc_nextra)));
  lua_pushcfunction(L, lcf9_d);
  lua_rawseti(L, (lc1298 + lc_nextra), 218);
  assert(lua_gettop(L) - lc_nextra == 65);

  /* local function z(e)
   * local e=e()
   * while e[1]do
   * e=e[2]()
   * end
   * return e[2]
   * end */
  lc_newclosuretable(L, (lc1298 + lc_nextra));
  enum { lc1302 = 66 };
  assert((lua_gettop(L) == (lc1302 + lc_nextra)));
  lua_pushcfunction(L, lcf1_z);
  lua_rawseti(L, (lc1302 + lc_nextra), 220);
  assert(lua_gettop(L) - lc_nextra == 66);

  /* local x=b(s(pe,s(s(ot,s(s(u,s(ht,s(m,y))),y)),y))) */
  lc_newclosuretable(L, (lc1302 + lc_nextra));
  enum { lc1304 = 67 };
  assert((lua_gettop(L) == (lc1304 + lc_nextra)));
  lc_getupvalue(L, (lc1302 + lc_nextra), 13, 156);
  const int lc1305 = lua_gettop(L);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  const int lc1306 = lua_gettop(L);
  lc_getupvalue(L, (lc1302 + lc_nextra), 16, 153);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  const int lc1307 = lua_gettop(L);
  lua_pushvalue(L, (35 + lc_nextra));
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  const int lc1308 = lua_gettop(L);
  lc_getupvalue(L, (lc1302 + lc_nextra), 18, 151);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  const int lc1309 = lua_gettop(L);
  lua_pushvalue(L, (33 + lc_nextra));
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 93);
  lc_getupvalue(L, (lc1302 + lc_nextra), 19, 150);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1309), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1308), 1);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1307), 1);
  lc_getupvalue(L, (lc1302 + lc_nextra), 30, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1306), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1305), 1);
  lua_rawseti(L, (lc1304 + lc_nextra), 221);
  assert(lua_gettop(L) - lc_nextra == 67);

  /* local b=b(s(pe,s(s(ot,s(ne,y)),y))) */
  lc_newclosuretable(L, (lc1304 + lc_nextra));
  enum { lc1310 = 68 };
  assert((lua_gettop(L) == (lc1310 + lc_nextra)));
  lc_getupvalue(L, (lc1304 + lc_nextra), 14, 156);
  const int lc1311 = lua_gettop(L);
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 93);
  const int lc1312 = lua_gettop(L);
  lc_getupvalue(L, (lc1304 + lc_nextra), 17, 153);
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 93);
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 93);
  const int lc1313 = lua_gettop(L);
  lua_pushvalue(L, (35 + lc_nextra));
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 93);
  lua_pushvalue(L, (26 + lc_nextra));
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1313), 1);
  lc_getupvalue(L, (lc1304 + lc_nextra), 31, 89);
  lua_call(L, 2, LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1312), LUA_MULTRET);
  lua_call(L, (lua_gettop(L) - lc1311), 1);
  lua_rawseti(L, (lc1310 + lc_nextra), 222);
  assert(lua_gettop(L) - lc_nextra == 68);

  /* local function P(a,t)
   * return T(b,e(a,t))
   * end */
  lua_pushvalue(L, (lc1310 + lc_nextra));
  lua_pushcclosure(L, lcf2_P, 1);
  assert(lua_gettop(L) - lc_nextra == 69);

  /* local function Y(e)
   * return T(x,e)
   * end */
  lua_pushvalue(L, (lc1310 + lc_nextra));
  lua_pushcclosure(L, lcf1_Y, 1);
  assert(lua_gettop(L) - lc_nextra == 70);

  /* local function v(f,y,m,w,u)
   * if u==nil then
   * u=false
   * end
   * local function p(e,e)
   * error("WIP")
   * end
   * m=r(m)
   * if c(m)then
   * local c=E(m)
   * local s=A(m)
   * if l(c,x)then
   * s=r(s)
   * if a(s)then
   * local a=o(s)
   * local e=r(i(s))
   * if h(e)then
   * if u==false then
   * local t=a
   * local a=w
   * local function e()return f(t,a)end
   * return d(e)
   * else
   * local t
   * t=f
   * local e
   * e=y
   * local i=a
   * local a=w
   * local function o()return v(t,e,F(u,i),a)end
   * return d(o)
   * end
   * end
   * end
   * elseif l(c,b)then
   * s=r(s)
   * if a(s)then
   * local l=o(s)
   * local s=r(i(s))
   * if a(s)then
   * local a=o(s)
   * local o=r(i(s))
   * if h(o)then
   * if u==false then
   * local e
   * e=f
   * local t
   * t=y
   * local n=l
   * local o=a
   * local i=w
   * local function a()return v(e,t,n,i,o)end
   * return d(a)
   * else
   * local i
   * i=f
   * local o
   * o=y
   * local r=l
   * local h=a
   * local s=w
   * local l=u
   * local a=n("序甲")
   * local function n()return v(i,o,r,s,T(t,e(e(a),p(e(ce(h),a),ce(l)))))end
   * return d(n)
   * end
   * end
   * end
   * end
   * end
   * end
   * if u==false then
   * return d(function()return y(m,w,f)end)
   * else
   * return d(function()return y(m,w,function(e,t)return d(function()return
   * v(f,y,F(u,{e}),t)end)end)end) end end */
  lc_newclosuretable(L, (lc1310 + lc_nextra));
  enum { lc1317 = 71 };
  assert((lua_gettop(L) == (lc1317 + lc_nextra)));
  lua_pushvalue(L, (lc1317 + lc_nextra));
  lua_pushcclosure(L, lcf2_v, 1);
  lua_rawseti(L, (lc1317 + lc_nextra), 223);
  assert(lua_gettop(L) - lc_nextra == 71);

  /* local function l(t,e,a,o)
   * return v(t,e,a,o)
   * end */
  lua_pushvalue(L, (lc1317 + lc_nextra));
  lua_pushcclosure(L, lcf3_l, 1);
  assert(lua_gettop(L) - lc_nextra == 72);

  /* local function u(a,i,n,o)
   * return z(v((function(t,e)return j(a(t,e))end),(function(e,t,a)return
   * j(i(e,t,function(e,t)return z(a(e,t))end))end),n,o)) end */
  lua_pushvalue(L, (lc1317 + lc_nextra));
  lua_pushcclosure(L, lcf3_u, 1);
  assert(lua_gettop(L) - lc_nextra == 73);

  /* local t={} */
  lua_newtable(L);
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_comment=fe */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 102);
  lua_pushliteral(L, "new_comment");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.comment_p=I */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 101);
  lua_pushliteral(L, "comment_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.comment_comment=oe */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 100);
  lua_pushliteral(L, "comment_comment");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.comment_x=K */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 99);
  lua_pushliteral(L, "comment_x");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.un_comment_all=qe */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 98);
  lua_pushliteral(L, "un_comment_all");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.can_new_atom_p=Xe */
  lc_getupvalue(L, (lc1317 + lc_nextra), 27, 145);
  lua_pushliteral(L, "can_new_atom_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_atom=n */
  lc_getupvalue(L, (lc1317 + lc_nextra), 26, 146);
  lua_pushliteral(L, "new_atom");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.atom_p=p */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 97);
  lua_pushliteral(L, "atom_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.un_atom=de */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 95);
  lua_pushliteral(L, "un_atom");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.atom_equal_p=D */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 94);
  lua_pushliteral(L, "atom_equal_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_construction=s */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 93);
  lua_pushliteral(L, "new_construction");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.construction_p=a */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 92);
  lua_pushliteral(L, "construction_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.construction_head=o */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 91);
  lua_pushliteral(L, "construction_head");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.construction_tail=i */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 90);
  lua_pushliteral(L, "construction_tail");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.null_v=y */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 89);
  lua_pushliteral(L, "null_v");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.null_p=h */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 88);
  lua_pushliteral(L, "null_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_data=T */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 87);
  lua_pushliteral(L, "new_data");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.data_p=c */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 86);
  lua_pushliteral(L, "data_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.data_name=E */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 85);
  lua_pushliteral(L, "data_name");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.data_list=A */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 84);
  lua_pushliteral(L, "data_list");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_error=L */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 83);
  lua_pushliteral(L, "new_error");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.error_p=g */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 82);
  lua_pushliteral(L, "error_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.error_name=C */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 81);
  lua_pushliteral(L, "error_name");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.error_list=U */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 80);
  lua_pushliteral(L, "error_list");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.just_p=B */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 79);
  lua_pushliteral(L, "just_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.evaluate=S */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 77);
  lua_pushliteral(L, "evaluate");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.apply=F */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 64);
  lua_pushliteral(L, "apply");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force_all_rec=W */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 60);
  lua_pushliteral(L, "force_all_rec");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force_uncomment_all_rec=Ve */
  lc_getupvalue(L, (lc1317 + lc_nextra), 25, 147);
  lua_pushliteral(L, "force_uncomment_all_rec");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.jsArray_to_list=_ */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 28);
  lua_pushliteral(L, "jsArray_to_list");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.maybe_list_to_jsArray=M */
  lc_getupvalue(L, (lc1317 + lc_nextra), 11, 161);
  lua_pushliteral(L, "maybe_list_to_jsArray");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_list=e */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 27);
  lua_pushliteral(L, "new_list");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.un_just_all=N */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 26);
  lua_pushliteral(L, "un_just_all");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.un_just_comment_all=tt */
  lua_pushvalue(L, (50 + lc_nextra));
  lua_pushliteral(L, "un_just_comment_all");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.delay_p=me */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 25);
  lua_pushliteral(L, "delay_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.delay_just_p=w */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 24);
  lua_pushliteral(L, "delay_just_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.delay_env=it */
  lua_pushvalue(L, (52 + lc_nextra));
  lua_pushliteral(L, "delay_env");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.delay_x=ct */
  lua_pushvalue(L, (53 + lc_nextra));
  lua_pushliteral(L, "delay_x");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force_all=r */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 21);
  lua_pushliteral(L, "force_all");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force1=k */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 22);
  lua_pushliteral(L, "force1");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force_uncomment1=st */
  lua_pushvalue(L, (54 + lc_nextra));
  lua_pushliteral(L, "force_uncomment1");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.force_uncomment_all=Qe */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 20);
  lua_pushliteral(L, "force_uncomment_all");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.env_null_v=Be */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 19);
  lua_pushliteral(L, "env_null_v");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.env_set=Ee */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 18);
  lua_pushliteral(L, "env_set");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.env_get=Ge */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 17);
  lua_pushliteral(L, "env_get");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.env2val=R */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 15);
  lua_pushliteral(L, "env2val");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.env_foreach=Ke */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 14);
  lua_pushliteral(L, "env_foreach");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.val2env=he */
  lc_getupvalue(L, (lc1317 + lc_nextra), 9, 163);
  lua_pushliteral(L, "val2env");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.equal_p=J */
  lua_pushvalue(L, (58 + lc_nextra));
  lua_pushliteral(L, "equal_p");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.simple_print=f */
  lc_getupvalue(L, (lc1317 + lc_nextra), 33, 3);
  lua_pushliteral(L, "simple_print");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.complex_parse=ee */
  lc_getupvalue(L, (lc1317 + lc_nextra), 7, 172);
  lua_pushliteral(L, "complex_parse");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.complex_print=q */
  lc_getupvalue(L, (lc1317 + lc_nextra), 6, 204);
  lua_pushliteral(L, "complex_print");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.machinetext_parse=H */
  lua_pushvalue(L, (62 + lc_nextra));
  lua_pushliteral(L, "machinetext_parse");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.machinetext_print=O */
  lua_pushvalue(L, (63 + lc_nextra));
  lua_pushliteral(L, "machinetext_print");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.trampoline_return=j */
  lc_getupvalue(L, (lc1317 + lc_nextra), 5, 216);
  lua_pushliteral(L, "trampoline_return");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.trampoline_delay=d */
  lc_getupvalue(L, (lc1317 + lc_nextra), 4, 218);
  lua_pushliteral(L, "trampoline_delay");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.run_trampoline=z */
  lc_getupvalue(L, (lc1317 + lc_nextra), 3, 220);
  lua_pushliteral(L, "run_trampoline");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.return_effect_systemName=x */
  lc_getupvalue(L, (lc1317 + lc_nextra), 2, 221);
  lua_pushliteral(L, "return_effect_systemName");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.bind_effect_systemName=b */
  lc_getupvalue(L, (lc1317 + lc_nextra), 1, 222);
  lua_pushliteral(L, "bind_effect_systemName");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_effect_bind=P */
  lua_pushvalue(L, (69 + lc_nextra));
  lua_pushliteral(L, "new_effect_bind");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.new_effect_return=Y */
  lua_pushvalue(L, (70 + lc_nextra));
  lua_pushliteral(L, "new_effect_return");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.run_monad_trampoline=l */
  lua_pushvalue(L, (72 + lc_nextra));
  lua_pushliteral(L, "run_monad_trampoline");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* t.run_monad_stackoverflow=u */
  lua_pushvalue(L, (73 + lc_nextra));
  lua_pushliteral(L, "run_monad_stackoverflow");
  lua_insert(L, -2);
  lua_settable(L, (74 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 74);

  /* return t */
  lua_pushvalue(L, (74 + lc_nextra));
  return 1;
  assert(lua_gettop(L) - lc_nextra == 74);
}
/*-- #include "src.cpp/lang.h" start --*/


/* TODO: Lua 錯誤處理 */

struct lang_state {
  lua_State *L;
  int exports_ref;
};
struct lang_value {
  int lua_ref;
};

extern lang_state *lang_state_new_orNULL(void) {
  lang_state *L = malloc(sizeof(lang_state));
  if (NULL != L) {
    L->L = luaL_newstate();
    if (NULL == L->L) {
      free(L);
      return NULL;
    }
    luaL_openlibs(L->L);
    lua_newtable(L->L);
    lua_pushcclosure(L->L, lcf_main, 1);
    lua_call(L->L, 0, 1);
    assert(lua_istable(L->L, -1));
    L->exports_ref = luaL_ref(L->L, LUA_REGISTRYINDEX);
    assert(lua_gettop(L->L) == 0);
  }
  return L;
}
extern void lang_state_delete(lang_state *L) {
  assert(lua_gettop(L->L) == 0);
  lua_close(L->L);
  L->L = NULL;
  free(L);
}

extern void lang_value_delete(lang_state *L, lang_value *val) {
  assert(lua_gettop(L->L) == 0);
  luaL_unref(L->L, LUA_REGISTRYINDEX, val->lua_ref);
  free(val);
  assert(lua_gettop(L->L) == 0);
}
extern lang_value *lang_value_copy_orNULL(lang_state *L, lang_value *val) {
  assert(lua_gettop(L->L) == 0);
  lang_value *ret = malloc(sizeof(lang_value));
  if (NULL == ret) {
    return NULL;
  }
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, val->lua_ref);
  ret->lua_ref = luaL_ref(L->L, LUA_REGISTRYINDEX);
  assert(lua_gettop(L->L) == 0);
  return ret;
}
static inline lang_value *lang_value_from_lua_orNULL(lang_state *L) {
  lang_value *ret = malloc(sizeof(lang_value));
  if (NULL == ret) {
    return NULL;
  }
  assert(lua_istable(L->L, -1));
  ret->lua_ref = luaL_ref(L->L, LUA_REGISTRYINDEX);
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, ret->lua_ref);
  assert(lua_istable(L->L, -1));
  lua_remove(L->L, -1);
  return ret;
}
#define _DEF_lang_a_parse(name) \
extern lang_value *lang_##name##_orNULL(lang_state *L, const char *str) { \
  assert(lua_gettop(L->L) == 0); \
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, L->exports_ref); \
  lua_getfield(L->L, -1, #name); \
  lua_remove(L->L, -2); \
  lua_pushstring(L->L, str); \
  lua_call(L->L, 1, 1); \
  lang_value *ret = lang_value_from_lua_orNULL(L); \
  if (NULL == ret) { \
    lua_settop(L->L, 0); \
    return NULL; \
  } \
  assert(lua_gettop(L->L) == 0); \
  return ret; \
}

#define _DEF_lang_a_print(name) \
extern char *lang_##name##_retMalloc_orNULL(lang_state *L, lang_value *val) { \
  assert(lua_gettop(L->L) == 0); \
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, L->exports_ref); \
  lua_getfield(L->L, -1, #name); \
  lua_remove(L->L, -2); \
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, val->lua_ref); \
  lua_call(L->L, 1, 1); \
  assert(lua_isstring(L->L, -1)); \
  const char *rawret = lua_tostring(L->L, -1); \
  lua_remove(L->L, -1); \
  size_t len = strlen(rawret); \
  char *ret = malloc(len + 1); \
  if (NULL == ret) { \
    return NULL; \
  } \
  memcpy(ret, rawret, len + 1); \
  assert(lua_gettop(L->L) == 0); \
  return ret; \
}

#define _DEF_lang_a_func(name) \
extern lang_value *lang_##name##_orNULL(lang_state *L, lang_value *val) { \
  assert(lua_gettop(L->L) == 0); \
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, L->exports_ref); \
  lua_getfield(L->L, -1, #name); \
  lua_remove(L->L, -2); \
  lua_rawgeti(L->L, LUA_REGISTRYINDEX, val->lua_ref); \
  lua_call(L->L, 1, 1); \
  lang_value *ret = lang_value_from_lua_orNULL(L); \
  if (NULL == ret) { \
    lua_settop(L->L, 0); \
    return NULL; \
  } \
  assert(lua_gettop(L->L) == 0); \
  return ret; \
}

_DEF_lang_a_parse(complex_parse);
_DEF_lang_a_parse(machinetext_parse);

_DEF_lang_a_print(complex_print);
_DEF_lang_a_print(simple_print);
_DEF_lang_a_print(machinetext_print);

_DEF_lang_a_func(force1);
_DEF_lang_a_func(force_all);
_DEF_lang_a_func(force_all_rec);
/*-- File: src.cpp/lang.cpp end --*/
/*-- #include "src.cpp/lang.h" start --*/
/*-- File: src.cpp/lapi.cpp start --*/
/*
** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
** Lua API
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/assert.h" start --*/
/*-- #include "src.cpp/math.h" start --*/
/*-- #include "src.cpp/stdarg.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define lapi_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lapi.h" start --*/
/*
** $Id: lapi.h,v 2.2.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/

#ifndef lapi_h
#define lapi_h


/*-- #include "src.cpp/lobject.h" start --*/
/*
** $Id: lobject.h,v 2.20.1.2 2008/08/06 13:29:48 roberto Exp $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/


#ifndef lobject_h
#define lobject_h


/*-- #include "src.cpp/stdarg.h" start --*/


/*-- #include "src.cpp/llimits.h" start --*/
/*
** $Id: llimits.h,v 1.69.1.1 2007/12/27 13:02:25 roberto Exp $
** Limits, basic types, and some other `installation-dependent' definitions
** See Copyright Notice in lua.h
*/

#ifndef llimits_h
#define llimits_h


/*-- #include "src.cpp/limits.h" start --*/
/*-- #include "src.cpp/stddef.h" start --*/


/*-- #include "src.cpp/lua.h" start --*/


typedef LUAI_UINT32 lu_int32;

typedef LUAI_UMEM lu_mem;

typedef LUAI_MEM l_mem;



/* chars used as small naturals (so that `char' is reserved for characters) */
typedef unsigned char lu_byte;


#define MAX_SIZET	((size_t)(~(size_t)0)-2)

#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)


#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */

/*
** conversion of pointer to integer
** this is for hashing only; there is no problem if the integer
** cannot hold the whole pointer value
*/
#define IntPoint(p)  ((unsigned int)(lu_mem)(p))



/* type to ensure maximum alignment */
typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;


/* result of a `usual argument conversion' over lua_Number */
typedef LUAI_UACNUMBER l_uacNumber;


/* internal assertions for in-house debugging */
#ifdef lua_assert

#define check_exp(c,e)		(lua_assert(c), (e))
#define api_check(l,e)		lua_assert(e)

#else

#define lua_assert(c)		((void)0)
#define check_exp(c,e)		(e)
#define api_check		luai_apicheck

#endif


#ifndef UNUSED
#define UNUSED(x)	((void)(x))	/* to avoid warnings */
#endif


#ifndef cast
#define cast(t, exp)	((t)(exp))
#endif

#define cast_byte(i)	cast(lu_byte, (i))
#define cast_num(i)	cast(lua_Number, (i))
#define cast_int(i)	cast(int, (i))



/*
** type for virtual-machine instructions
** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
*/
typedef lu_int32 Instruction;



/* maximum stack for a Lua function */
#define MAXSTACK	250



/* minimum size for the string table (must be power of 2) */
#ifndef MINSTRTABSIZE
#define MINSTRTABSIZE	32
#endif


/* minimum size for string buffer */
#ifndef LUA_MINBUFFER
#define LUA_MINBUFFER	32
#endif


#ifndef lua_lock
#define lua_lock(L)     ((void) 0) 
#define lua_unlock(L)   ((void) 0)
#endif

#ifndef luai_threadyield
#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
#endif


/*
** macro to control inclusion of some hard tests on stack reallocation
*/ 
#ifndef HARDSTACKTESTS
#define condhardstacktests(x)	((void)0)
#else
#define condhardstacktests(x)	x
#endif

#endif

/*-- #include "src.cpp/lua.h" start --*/


/* tags for values visible from Lua */
#define LAST_TAG	LUA_TTHREAD

#define NUM_TAGS	(LAST_TAG+1)


/*
** Extra tags for non-values
*/
#define LUA_TPROTO	(LAST_TAG+1)
#define LUA_TUPVAL	(LAST_TAG+2)
#define LUA_TDEADKEY	(LAST_TAG+3)


/*
** Union of all collectable objects
*/
typedef union GCObject GCObject;


/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked


/*
** Common header in struct form
*/
typedef struct GCheader {
  CommonHeader;
} GCheader;




/*
** Union of all Lua values
*/
typedef union {
  GCObject *gc;
  void *p;
  lua_Number n;
  int b;
} Value;


/*
** Tagged Values
*/

#define TValuefields	Value value; int tt

typedef struct lua_TValue {
  TValuefields;
} TValue;


/* Macros to test type */
#define ttisnil(o)	(ttype(o) == LUA_TNIL)
#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
#define ttistable(o)	(ttype(o) == LUA_TTABLE)
#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)

/* Macros to access values */
#define ttype(o)	((o)->tt)
#define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)
#define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)
#define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)
#define rawtsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)
#define tsvalue(o)	(&rawtsvalue(o)->tsv)
#define rawuvalue(o)	check_exp(ttisuserdata(o), &(o)->value.gc->u)
#define uvalue(o)	(&rawuvalue(o)->uv)
#define clvalue(o)	check_exp(ttisfunction(o), &(o)->value.gc->cl)
#define hvalue(o)	check_exp(ttistable(o), &(o)->value.gc->h)
#define bvalue(o)	check_exp(ttisboolean(o), (o)->value.b)
#define thvalue(o)	check_exp(ttisthread(o), &(o)->value.gc->th)

#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))

/*
** for internal debug only
*/
#define checkconsistency(obj) \
  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))

#define checkliveness(g,obj) \
  lua_assert(!iscollectable(obj) || \
  ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))


/* Macros to set values */
#define setnilvalue(obj) ((obj)->tt=LUA_TNIL)

#define setnvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }

#define setpvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }

#define setbvalue(obj,x) \
  { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }

#define setsvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; \
    checkliveness(G(L),i_o); }

#define setuvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; \
    checkliveness(G(L),i_o); }

#define setthvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; \
    checkliveness(G(L),i_o); }

#define setclvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; \
    checkliveness(G(L),i_o); }

#define sethvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; \
    checkliveness(G(L),i_o); }

#define setptvalue(L,obj,x) \
  { TValue *i_o=(obj); \
    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; \
    checkliveness(G(L),i_o); }




#define setobj(L,obj1,obj2) \
  { const TValue *o2=(obj2); TValue *o1=(obj1); \
    o1->value = o2->value; o1->tt=o2->tt; \
    checkliveness(G(L),o1); }


/*
** different types of sets, according to destination
*/

/* from stack to (same) stack */
#define setobjs2s	setobj
/* to stack (not from same stack) */
#define setobj2s	setobj
#define setsvalue2s	setsvalue
#define sethvalue2s	sethvalue
#define setptvalue2s	setptvalue
/* from table to same table */
#define setobjt2t	setobj
/* to table */
#define setobj2t	setobj
/* to new object */
#define setobj2n	setobj
#define setsvalue2n	setsvalue

#define setttype(obj, tt) (ttype(obj) = (tt))


#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)



typedef TValue *StkId;  /* index to stack elements */


/*
** String headers for string table
*/
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    unsigned int hash;
    size_t len;
  } tsv;
} TString;


#define getstr(ts)	cast(const char *, (ts) + 1)
#define svalue(o)       getstr(rawtsvalue(o))



typedef union Udata {
  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
  struct {
    CommonHeader;
    struct Table *metatable;
    struct Table *env;
    size_t len;
  } uv;
} Udata;




/*
** Function Prototypes
*/
typedef struct Proto {
  CommonHeader;
  TValue *k;  /* constants used by the function */
  Instruction *code;
  struct Proto **p;  /* functions defined inside the function */
  int *lineinfo;  /* map from opcodes to source lines */
  struct LocVar *locvars;  /* information about local variables */
  TString **upvalues;  /* upvalue names */
  TString  *source;
  int sizeupvalues;
  int sizek;  /* size of `k' */
  int sizecode;
  int sizelineinfo;
  int sizep;  /* size of `p' */
  int sizelocvars;
  int linedefined;
  int lastlinedefined;
  GCObject *gclist;
  lu_byte nups;  /* number of upvalues */
  lu_byte numparams;
  lu_byte is_vararg;
  lu_byte maxstacksize;
} Proto;


/* masks for new-style vararg */
#define VARARG_HASARG		1
#define VARARG_ISVARARG		2
#define VARARG_NEEDSARG		4


typedef struct LocVar {
  TString *varname;
  int startpc;  /* first point where variable is active */
  int endpc;    /* first point where variable is dead */
} LocVar;



/*
** Upvalues
*/

typedef struct UpVal {
  CommonHeader;
  TValue *v;  /* points to stack or to its own value */
  union {
    TValue value;  /* the value (when closed) */
    struct {  /* double linked list (when open) */
      struct UpVal *prev;
      struct UpVal *next;
    } l;
  } u;
} UpVal;


/*
** Closures
*/

#define ClosureHeader \
	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \
	struct Table *env

typedef struct CClosure {
  ClosureHeader;
  lua_CFunction f;
  TValue upvalue[1];
} CClosure;


typedef struct LClosure {
  ClosureHeader;
  struct Proto *p;
  UpVal *upvals[1];
} LClosure;


typedef union Closure {
  CClosure c;
  LClosure l;
} Closure;


#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)


/*
** Tables
*/

typedef union TKey {
  struct {
    TValuefields;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;



/*
** `module' operation for hashing (size is always a power of 2)
*/
#define lmod(s,size) \
	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))


#define twoto(x)	(1<<(x))
#define sizenode(t)	(twoto((t)->lsizenode))


#define luaO_nilobject		(&luaO_nilobject_)

static LUAI_DATA const TValue luaO_nilobject_;

#define ceillog2(x)	(luaO_log2((x)-1) + 1)

LUAI_FUNC int luaO_log2 (unsigned int x);
LUAI_FUNC int luaO_int2fb (unsigned int x);
LUAI_FUNC int luaO_fb2int (int x);
LUAI_FUNC int luaO_rawequalObj (const TValue *t1, const TValue *t2);
LUAI_FUNC int luaO_str2d (const char *s, lua_Number *result);
LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                       va_list argp);
LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);


#endif




LUAI_FUNC void luaA_pushobject (lua_State *L, const TValue *o);

#endif

/*-- #include "src.cpp/ldebug.h" start --*/
/*
** $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/

#ifndef ldebug_h
#define ldebug_h


/*-- #include "src.cpp/lstate.h" start --*/
/*
** $Id: lstate.h,v 2.24.1.2 2008/01/03 15:20:39 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/

#ifndef lstate_h
#define lstate_h

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/
/*
** $Id: ltm.h,v 2.6.1.1 2007/12/27 13:02:25 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/

#ifndef ltm_h
#define ltm_h


/*-- #include "src.cpp/lobject.h" start --*/


/*
* WARNING: if you change the order of this enumeration,
* grep "ORDER TM"
*/
typedef enum {
  TM_INDEX,
  TM_NEWINDEX,
  TM_GC,
  TM_MODE,
  TM_EQ,  /* last tag method with `fast' access */
  TM_ADD,
  TM_SUB,
  TM_MUL,
  TM_DIV,
  TM_MOD,
  TM_POW,
  TM_UNM,
  TM_LEN,
  TM_LT,
  TM_LE,
  TM_CONCAT,
  TM_CALL,
  TM_N		/* number of elements in the enum */
} TMS;



#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))

#define fasttm(l,et,e)	gfasttm(G(l), et, e)

static LUAI_DATA const char *const luaT_typenames[];


LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
                                                       TMS event);
LUAI_FUNC void luaT_init (lua_State *L);

#endif

/*-- #include "src.cpp/lzio.h" start --*/
/*
** $Id: lzio.h,v 1.21.1.1 2007/12/27 13:02:25 roberto Exp $
** Buffered streams
** See Copyright Notice in lua.h
*/


#ifndef lzio_h
#define lzio_h

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lmem.h" start --*/
/*
** $Id: lmem.h,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

#ifndef lmem_h
#define lmem_h


/*-- #include "src.cpp/stddef.h" start --*/

/*-- #include "src.cpp/llimits.h" start --*/
/*-- #include "src.cpp/lua.h" start --*/

#define MEMERRMSG	"not enough memory"


#define luaM_reallocv(L,b,on,n,e) \
	((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ?  /* +1 to avoid warnings */ \
		luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : \
		luaM_toobig(L))

#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
#define luaM_freearray(L, b, n, t)   luaM_reallocv(L, (b), n, 0, sizeof(t))

#define luaM_malloc(L,t)	luaM_realloc_(L, NULL, 0, (t))
#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
#define luaM_newvector(L,n,t) \
		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

#define luaM_growvector(L,v,nelems,size,t,limit,e) \
          if ((nelems)+1 > (size)) \
            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))

#define luaM_reallocvector(L, v,oldn,n,t) \
   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))


LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
                                                          size_t size);
LUAI_FUNC void *luaM_toobig (lua_State *L);
LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
                               size_t size_elem, int limit,
                               const char *errormsg);

#endif




#define EOZ	(-1)			/* end of stream */

typedef struct Zio ZIO;

#define char2int(c)	cast(int, cast(unsigned char, (c)))

#define zgetc(z)  (((z)->n--)>0 ?  char2int(*(z)->p++) : luaZ_fill(z))

typedef struct Mbuffer {
  char *buffer;
  size_t n;
  size_t buffsize;
} Mbuffer;

#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)

#define luaZ_buffer(buff)	((buff)->buffer)
#define luaZ_sizebuffer(buff)	((buff)->buffsize)
#define luaZ_bufflen(buff)	((buff)->n)

#define luaZ_resetbuffer(buff) ((buff)->n = 0)


#define luaZ_resizebuffer(L, buff, size) \
	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
	(buff)->buffsize = size)

#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)


LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
                                        void *data);
LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
LUAI_FUNC int luaZ_lookahead (ZIO *z);



/* --------- Private Part ------------------ */

struct Zio {
  size_t n;			/* bytes still unread */
  const char *p;		/* current position in buffer */
  lua_Reader reader;
  void* data;			/* additional data */
  lua_State *L;			/* Lua state (for reader) */
};


LUAI_FUNC int luaZ_fill (ZIO *z);

#endif




struct lua_longjmp;  /* defined in ldo.c */


/* table of globals */
#define gt(L)	(&L->l_gt)

/* registry */
#define registry(L)	(&G(L)->l_registry)


/* extra stack space to handle TM calls and some other extras */
#define EXTRA_STACK   5


#define BASIC_CI_SIZE           8

#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)



typedef struct stringtable {
  GCObject **hash;
  lu_int32 nuse;  /* number of elements */
  int size;
} stringtable;


/*
** informations about a call
*/
typedef struct CallInfo {
  StkId base;  /* base for this function */
  StkId func;  /* function index in the stack */
  StkId	top;  /* top for this function */
  const Instruction *savedpc;
  int nresults;  /* expected number of results from this function */
  int tailcalls;  /* number of tail calls lost under this entry */
} CallInfo;



#define curr_func(L)	(clvalue(L->ci->func))
#define ci_func(ci)	(clvalue((ci)->func))
#define f_isLua(ci)	(!ci_func(ci)->c.isC)
#define isLua(ci)	(ttisfunction((ci)->func) && f_isLua(ci))


/*
** `global state', shared by all threads of this state
*/
typedef struct global_State {
  stringtable strt;  /* hash table for strings */
  lua_Alloc frealloc;  /* function to reallocate memory */
  void *ud;         /* auxiliary data to `frealloc' */
  lu_byte currentwhite;
  lu_byte gcstate;  /* state of garbage collector */
  int sweepstrgc;  /* position of sweep in `strt' */
  GCObject *rootgc;  /* list of all collectable objects */
  GCObject **sweepgc;  /* position of sweep in `rootgc' */
  GCObject *gray;  /* list of gray objects */
  GCObject *grayagain;  /* list of objects to be traversed atomically */
  GCObject *weak;  /* list of weak tables (to be cleared) */
  GCObject *tmudata;  /* last element of list of userdata to be GC */
  Mbuffer buff;  /* temporary buffer for string concatentation */
  lu_mem GCthreshold;
  lu_mem totalbytes;  /* number of bytes currently allocated */
  lu_mem estimate;  /* an estimate of number of bytes actually in use */
  lu_mem gcdept;  /* how much GC is `behind schedule' */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC `granularity' */
  lua_CFunction panic;  /* to be called in unprotected errors */
  TValue l_registry;
  struct lua_State *mainthread;
  UpVal uvhead;  /* head of double-linked list of all open upvalues */
  struct Table *mt[NUM_TAGS];  /* metatables for basic types */
  TString *tmname[TM_N];  /* array with tag-method names */
} global_State;


/*
** `per thread' state
*/
struct lua_State {
  CommonHeader;
  lu_byte status;
  StkId top;  /* first free slot in the stack */
  StkId base;  /* base of current function */
  global_State *l_G;
  CallInfo *ci;  /* call info for current function */
  const Instruction *savedpc;  /* `savedpc' of current function */
  StkId stack_last;  /* last free slot in the stack */
  StkId stack;  /* stack base */
  CallInfo *end_ci;  /* points after end of ci array*/
  CallInfo *base_ci;  /* array of CallInfo's */
  int stacksize;
  int size_ci;  /* size of array `base_ci' */
  unsigned short nCcalls;  /* number of nested C calls */
  unsigned short baseCcalls;  /* nested C calls when resuming coroutine */
  lu_byte hookmask;
  lu_byte allowhook;
  int basehookcount;
  int hookcount;
  lua_Hook hook;
  TValue l_gt;  /* table of globals */
  TValue env;  /* temporary place for environments */
  GCObject *openupval;  /* list of open upvalues in this stack */
  GCObject *gclist;
  struct lua_longjmp *errorJmp;  /* current error recover point */
  ptrdiff_t errfunc;  /* current error handling function (stack index) */
};


#define G(L)	(L->l_G)


/*
** Union of all collectable objects
*/
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};


/* macros to convert a GCObject into a specific value */
#define rawgco2ts(o)	check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
#define gco2ts(o)	(&rawgco2ts(o)->tsv)
#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
#define gco2u(o)	(&rawgco2u(o)->uv)
#define gco2cl(o)	check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
#define gco2h(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
#define ngcotouv(o) \
	check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))

/* macro to convert any Lua object into a GCObject */
#define obj2gco(v)	(cast(GCObject *, (v)))


LUAI_FUNC lua_State *luaE_newthread (lua_State *L);
LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);

#endif




#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)

#define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)

#define resethookcount(L)	(L->hookcount = L->basehookcount)


LUAI_FUNC void luaG_typeerror (lua_State *L, const TValue *o,
                                             const char *opname);
LUAI_FUNC void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
LUAI_FUNC void luaG_aritherror (lua_State *L, const TValue *p1,
                                              const TValue *p2);
LUAI_FUNC int luaG_ordererror (lua_State *L, const TValue *p1,
                                             const TValue *p2);
LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);
LUAI_FUNC void luaG_errormsg (lua_State *L);
LUAI_FUNC int luaG_checkcode (const Proto *pt);
LUAI_FUNC int luaG_checkopenop (Instruction i);

#endif

/*-- #include "src.cpp/ldo.h" start --*/
/*
** $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

#ifndef ldo_h
#define ldo_h


/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/


#define luaD_checkstack(L,n)	\
  if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) \
    luaD_growstack(L, n); \
  else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));


#define incr_top(L) {luaD_checkstack(L,1); L->top++;}

#define savestack(L,p)		((char *)(p) - (char *)L->stack)
#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))

#define saveci(L,p)		((char *)(p) - (char *)L->base_ci)
#define restoreci(L,n)		((CallInfo *)((char *)L->base_ci + (n)))


/* results from luaD_precall */
#define PCRLUA		0	/* initiated a call to a Lua function */
#define PCRC		1	/* did a call to a C function */
#define PCRYIELD	2	/* C funtion yielded */


/* type of protected functions, to be ran by `runprotected' */
typedef void (*Pfunc) (lua_State *L, void *ud);

LUAI_FUNC void luaD_callhook (lua_State *L, int event, int line);
LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);
LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
                                        ptrdiff_t oldtop, ptrdiff_t ef);
LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
LUAI_FUNC void luaD_reallocCI (lua_State *L, int newsize);
LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
LUAI_FUNC void luaD_growstack (lua_State *L, int n);

LUAI_FUNC void luaD_throw (lua_State *L, int errcode);
LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);

LUAI_FUNC void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop);

#endif

/*-- #include "src.cpp/lfunc.h" start --*/
/*
** $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

#ifndef lfunc_h
#define lfunc_h


/*-- #include "src.cpp/lobject.h" start --*/


#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
                         cast(int, sizeof(TValue)*((n)-1)))

#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
                         cast(int, sizeof(TValue *)*((n)-1)))


LUAI_FUNC Proto *luaF_newproto (lua_State *L);
LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e);
LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e);
LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
LUAI_FUNC void luaF_close (lua_State *L, StkId level);
LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
LUAI_FUNC void luaF_freeclosure (lua_State *L, Closure *c);
LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
                                         int pc);


#endif

/*-- #include "src.cpp/lgc.h" start --*/
/*
** $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#ifndef lgc_h
#define lgc_h


/*-- #include "src.cpp/lobject.h" start --*/


/*
** Possible states of the Garbage Collector
*/
#define GCSpause	0
#define GCSpropagate	1
#define GCSsweepstring	2
#define GCSsweep	3
#define GCSfinalize	4


/*
** some userful bit tricks
*/
#define resetbits(x,m)	((x) &= cast(lu_byte, ~(m)))
#define setbits(x,m)	((x) |= (m))
#define testbits(x,m)	((x) & (m))
#define bitmask(b)	(1<<(b))
#define bit2mask(b1,b2)	(bitmask(b1) | bitmask(b2))
#define l_setbit(x,b)	setbits(x, bitmask(b))
#define resetbit(x,b)	resetbits(x, bitmask(b))
#define testbit(x,b)	testbits(x, bitmask(b))
#define set2bits(x,b1,b2)	setbits(x, (bit2mask(b1, b2)))
#define reset2bits(x,b1,b2)	resetbits(x, (bit2mask(b1, b2)))
#define test2bits(x,b1,b2)	testbits(x, (bit2mask(b1, b2)))



/*
** Layout for bit use in `marked' field:
** bit 0 - object is white (type 0)
** bit 1 - object is white (type 1)
** bit 2 - object is black
** bit 3 - for userdata: has been finalized
** bit 3 - for tables: has weak keys
** bit 4 - for tables: has weak values
** bit 5 - object is fixed (should not be collected)
** bit 6 - object is "super" fixed (only the main thread)
*/


#define WHITE0BIT	0
#define WHITE1BIT	1
#define BLACKBIT	2
#define FINALIZEDBIT	3
#define KEYWEAKBIT	3
#define VALUEWEAKBIT	4
#define FIXEDBIT	5
#define SFIXEDBIT	6
#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)


#define iswhite(x)      test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
#define isgray(x)	(!isblack(x) && !iswhite(x))

#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
#define isdead(g,v)	((v)->gch.marked & otherwhite(g) & WHITEBITS)

#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)

#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))

#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)


#define luaC_checkGC(L) { \
  condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); \
  if (G(L)->totalbytes >= G(L)->GCthreshold) \
	luaC_step(L); }


#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
	luaC_barrierf(L,obj2gco(p),gcvalue(v)); }

#define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t)))  \
	luaC_barrierback(L,t); }

#define luaC_objbarrier(L,p,o)  \
	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
		luaC_barrierf(L,obj2gco(p),obj2gco(o)); }

#define luaC_objbarriert(L,t,o)  \
   { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }

LUAI_FUNC size_t luaC_separateudata (lua_State *L, int all);
LUAI_FUNC void luaC_callGCTM (lua_State *L);
LUAI_FUNC void luaC_freeall (lua_State *L);
LUAI_FUNC void luaC_step (lua_State *L);
LUAI_FUNC void luaC_fullgc (lua_State *L);
LUAI_FUNC void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
LUAI_FUNC void luaC_linkupval (lua_State *L, UpVal *uv);
LUAI_FUNC void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);
LUAI_FUNC void luaC_barrierback (lua_State *L, Table *t);


#endif

/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*
** $Id: lstring.h,v 1.43.1.1 2007/12/27 13:02:25 roberto Exp $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/

#ifndef lstring_h
#define lstring_h


/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/


#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))

#define sizeudata(u)	(sizeof(union Udata)+(u)->len)

#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
                                 (sizeof(s)/sizeof(char))-1))

#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)

LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);


#endif

/*-- #include "src.cpp/ltable.h" start --*/
/*
** $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

#ifndef ltable_h
#define ltable_h

/*-- #include "src.cpp/lobject.h" start --*/


#define gnode(t,i)	(&(t)->node[i])
#define gkey(n)		(&(n)->i_key.nk)
#define gval(n)		(&(n)->i_val)
#define gnext(n)	((n)->i_key.nk.next)

#define key2tval(n)	(&(n)->i_key.tvk)


LUAI_FUNC const TValue *luaH_getnum (Table *t, int key);
LUAI_FUNC TValue *luaH_setnum (lua_State *L, Table *t, int key);
LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
LUAI_FUNC TValue *luaH_setstr (lua_State *L, Table *t, TString *key);
LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
LUAI_FUNC Table *luaH_new (lua_State *L, int narray, int lnhash);
LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
LUAI_FUNC void luaH_free (lua_State *L, Table *t);
LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
LUAI_FUNC int luaH_getn (Table *t);


#if defined(LUA_DEBUG)
LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
LUAI_FUNC int luaH_isdummy (Node *n);
#endif


#endif

/*-- #include "src.cpp/ltm.h" start --*/
/*-- #include "src.cpp/lundump.h" start --*/
/*
** $Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#ifndef lundump_h
#define lundump_h

/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/

/* load one chunk; from lundump.c */
LUAI_FUNC Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);

/* make header; from lundump.c */
LUAI_FUNC void luaU_header (char* h);

/* dump one chunk; from ldump.c */
LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);

#ifdef luac_c
/* print one chunk; from print.c */
LUAI_FUNC void luaU_print (const Proto* f, int full);
#endif

/* for header of binary files -- this is Lua 5.1 */
#define LUAC_VERSION		0x51

/* for header of binary files -- this is the official format */
#define LUAC_FORMAT		0

/* size of header of binary files */
#define LUAC_HEADERSIZE		12

#endif

/*-- #include "src.cpp/lvm.h" start --*/
/*
** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lvm_h
#define lvm_h


/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/


#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))

#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
                         (((o) = luaV_tonumber(o,n)) != NULL))

#define equalobj(L,o1,o2) \
	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))


LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
LUAI_FUNC int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2);
LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);
LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
                                            StkId val);
LUAI_FUNC void luaV_execute (lua_State *L, int nexeccalls);
LUAI_FUNC void luaV_concat (lua_State *L, int total, int last);

#endif




static const char lua_ident[] =
  "$Lua: " LUA_RELEASE " " LUA_COPYRIGHT " $\n"
  "$Authors: " LUA_AUTHORS " $\n"
  "$URL: www.lua.org $\n";



#define api_checknelems(L, n)	api_check(L, (n) <= (L->top - L->base))

#define api_checkvalidindex(L, i)	api_check(L, (i) != luaO_nilobject)

#define api_incr_top(L)   {api_check(L, L->top < L->ci->top); L->top++;}



static inline TValue *index2adr (lua_State *L, int idx) {
  if (idx > 0) {
    TValue *o = L->base + (idx - 1);
    api_check(L, idx <= L->ci->top - L->base);
    if (o >= L->top) return cast(TValue *, luaO_nilobject);
    else return o;
  }
  else if (idx > LUA_REGISTRYINDEX) {
    api_check(L, idx != 0 && -idx <= L->top - L->base);
    return L->top + idx;
  }
  else switch (idx) {  /* pseudo-indices */
    case LUA_REGISTRYINDEX: return registry(L);
    case LUA_ENVIRONINDEX: {
      Closure *func = curr_func(L);
      sethvalue(L, &L->env, func->c.env);
      return &L->env;
    }
    case LUA_GLOBALSINDEX: return gt(L);
    default: {
      Closure *func = curr_func(L);
      idx = LUA_GLOBALSINDEX - idx;
      return (idx <= func->c.nupvalues)
                ? &func->c.upvalue[idx-1]
                : cast(TValue *, luaO_nilobject);
    }
  }
}


static inline Table *getcurrenv (lua_State *L) {
  if (L->ci == L->base_ci)  /* no enclosing function? */
    return hvalue(gt(L));  /* use global table as environment */
  else {
    Closure *func = curr_func(L);
    return func->c.env;
  }
}


static inline void luaA_pushobject (lua_State *L, const TValue *o) {
  setobj2s(L, L->top, o);
  api_incr_top(L);
}


LUA_API int lua_checkstack (lua_State *L, int size) {
  int res = 1;
  lua_lock(L);
  if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)
    res = 0;  /* stack overflow */
  else if (size > 0) {
    luaD_checkstack(L, size);
    if (L->ci->top < L->top + size)
      L->ci->top = L->top + size;
  }
  lua_unlock(L);
  return res;
}


LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to) return;
  lua_lock(to);
  api_checknelems(from, n);
  api_check(from, G(from) == G(to));
  api_check(from, to->ci->top - to->top >= n);
  from->top -= n;
  for (i = 0; i < n; i++) {
    setobj2s(to, to->top++, from->top + i);
  }
  lua_unlock(to);
}


LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
  to->nCcalls = from->nCcalls;
}


LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  lua_lock(L);
  old = G(L)->panic;
  G(L)->panic = panicf;
  lua_unlock(L);
  return old;
}


LUA_API lua_State *lua_newthread (lua_State *L) {
  lua_State *L1;
  lua_lock(L);
  luaC_checkGC(L);
  L1 = luaE_newthread(L);
  setthvalue(L, L->top, L1);
  api_incr_top(L);
  lua_unlock(L);
  luai_userstatethread(L, L1);
  return L1;
}



/*
** basic stack manipulation
*/


LUA_API int lua_gettop (lua_State *L) {
  return cast_int(L->top - L->base);
}


LUA_API void lua_settop (lua_State *L, int idx) {
  lua_lock(L);
  if (idx >= 0) {
    api_check(L, idx <= L->stack_last - L->base);
    while (L->top < L->base + idx)
      setnilvalue(L->top++);
    L->top = L->base + idx;
  }
  else {
    api_check(L, -(idx+1) <= (L->top - L->base));
    L->top += idx+1;  /* `subtract' index (index is negative) */
  }
  lua_unlock(L);
}


LUA_API void lua_remove (lua_State *L, int idx) {
  StkId p;
  lua_lock(L);
  p = index2adr(L, idx);
  api_checkvalidindex(L, p);
  while (++p < L->top) setobjs2s(L, p-1, p);
  L->top--;
  lua_unlock(L);
}


LUA_API void lua_insert (lua_State *L, int idx) {
  StkId p;
  StkId q;
  lua_lock(L);
  p = index2adr(L, idx);
  api_checkvalidindex(L, p);
  for (q = L->top; q>p; q--) setobjs2s(L, q, q-1);
  setobjs2s(L, p, L->top);
  lua_unlock(L);
}


LUA_API void lua_replace (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  /* explicit test for incompatible code */
  if (idx == LUA_ENVIRONINDEX && L->ci == L->base_ci)
    luaG_runerror(L, "no calling environment");
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  if (idx == LUA_ENVIRONINDEX) {
    Closure *func = curr_func(L);
    api_check(L, ttistable(L->top - 1));
    func->c.env = hvalue(L->top - 1);
    luaC_barrier(L, func, L->top - 1);
  }
  else {
    setobj(L, o, L->top - 1);
    if (idx < LUA_GLOBALSINDEX)  /* function upvalue? */
      luaC_barrier(L, curr_func(L), L->top - 1);
  }
  L->top--;
  lua_unlock(L);
}


LUA_API void lua_pushvalue (lua_State *L, int idx) {
  lua_lock(L);
  setobj2s(L, L->top, index2adr(L, idx));
  api_incr_top(L);
  lua_unlock(L);
}



/*
** access functions (stack -> C)
*/


LUA_API int lua_type (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);
}


LUA_API const char *lua_typename (lua_State *L, int t) {
  UNUSED(L);
  return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
}


LUA_API int lua_iscfunction (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return iscfunction(o);
}


LUA_API int lua_isnumber (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  return tonumber(o, &n);
}


LUA_API int lua_isstring (lua_State *L, int idx) {
  int t = lua_type(L, idx);
  return (t == LUA_TSTRING || t == LUA_TNUMBER);
}


LUA_API int lua_isuserdata (lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return (ttisuserdata(o) || ttislightuserdata(o));
}


LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
  StkId o1 = index2adr(L, index1);
  StkId o2 = index2adr(L, index2);
  return (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
         : luaO_rawequalObj(o1, o2);
}


LUA_API int lua_equal (lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  lua_lock(L);  /* may call tag method */
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0 : equalobj(L, o1, o2);
  lua_unlock(L);
  return i;
}


LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  lua_lock(L);  /* may call tag method */
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
       : luaV_lessthan(L, o1, o2);
  lua_unlock(L);
  return i;
}



LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if (tonumber(o, &n))
    return nvalue(o);
  else
    return 0;
}


LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if (tonumber(o, &n)) {
    lua_Integer res;
    lua_Number num = nvalue(o);
    lua_number2integer(res, num);
    return res;
  }
  else
    return 0;
}


LUA_API int lua_toboolean (lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return !l_isfalse(o);
}


LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
  StkId o = index2adr(L, idx);
  if (!ttisstring(o)) {
    lua_lock(L);  /* `luaV_tostring' may create a new string */
    if (!luaV_tostring(L, o)) {  /* conversion failed? */
      if (len != NULL) *len = 0;
      lua_unlock(L);
      return NULL;
    }
    luaC_checkGC(L);
    o = index2adr(L, idx);  /* previous call may reallocate the stack */
    lua_unlock(L);
  }
  if (len != NULL) *len = tsvalue(o)->len;
  return svalue(o);
}


LUA_API size_t lua_objlen (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TSTRING: return tsvalue(o)->len;
    case LUA_TUSERDATA: return uvalue(o)->len;
    case LUA_TTABLE: return luaH_getn(hvalue(o));
    case LUA_TNUMBER: {
      size_t l;
      lua_lock(L);  /* `luaV_tostring' may create a new string */
      l = (luaV_tostring(L, o) ? tsvalue(o)->len : 0);
      lua_unlock(L);
      return l;
    }
    default: return 0;
  }
}


LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!iscfunction(o)) ? NULL : clvalue(o)->c.f;
}


LUA_API void *lua_touserdata (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
    case LUA_TLIGHTUSERDATA: return pvalue(o);
    default: return NULL;
  }
}


LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!ttisthread(o)) ? NULL : thvalue(o);
}


LUA_API const void *lua_topointer (lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (ttype(o)) {
    case LUA_TTABLE: return hvalue(o);
    case LUA_TFUNCTION: return clvalue(o);
    case LUA_TTHREAD: return thvalue(o);
    case LUA_TUSERDATA:
    case LUA_TLIGHTUSERDATA:
      return lua_touserdata(L, idx);
    default: return NULL;
  }
}



/*
** push functions (C -> stack)
*/


LUA_API void lua_pushnil (lua_State *L) {
  lua_lock(L);
  setnilvalue(L->top);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
  lua_lock(L);
  setnvalue(L->top, n);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
  lua_lock(L);
  setnvalue(L->top, cast_num(n));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
  lua_lock(L);
  luaC_checkGC(L);
  setsvalue2s(L, L->top, luaS_newlstr(L, s, len));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushstring (lua_State *L, const char *s) {
  if (s == NULL)
    lua_pushnil(L);
  else
    lua_pushlstring(L, s, strlen(s));
}


LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
                                      va_list argp) {
  const char *ret;
  lua_lock(L);
  luaC_checkGC(L);
  ret = luaO_pushvfstring(L, fmt, argp);
  lua_unlock(L);
  return ret;
}


LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  lua_lock(L);
  luaC_checkGC(L);
  va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_unlock(L);
  return ret;
}


LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
  Closure *cl;
  lua_lock(L);
  luaC_checkGC(L);
  api_checknelems(L, n);
  cl = luaF_newCclosure(L, n, getcurrenv(L));
  cl->c.f = fn;
  L->top -= n;
  while (n--)
    setobj2n(L, &cl->c.upvalue[n], L->top+n);
  setclvalue(L, L->top, cl);
  lua_assert(iswhite(obj2gco(cl)));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushboolean (lua_State *L, int b) {
  lua_lock(L);
  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
  lua_lock(L);
  setpvalue(L->top, p);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_pushthread (lua_State *L) {
  lua_lock(L);
  setthvalue(L, L->top, L);
  api_incr_top(L);
  lua_unlock(L);
  return (G(L)->mainthread == L);
}



/*
** get functions (Lua -> stack)
*/


LUA_API void lua_gettable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  luaV_gettable(L, t, L->top - 1, L->top - 1);
  lua_unlock(L);
}


LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  lua_lock(L);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  setsvalue(L, &key, luaS_new(L, k));
  luaV_gettable(L, t, &key, L->top);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_rawget (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
  lua_unlock(L);
}


LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
  StkId o;
  lua_lock(L);
  o = index2adr(L, idx);
  api_check(L, ttistable(o));
  setobj2s(L, L->top, luaH_getnum(hvalue(o), n));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
  lua_lock(L);
  luaC_checkGC(L);
  sethvalue(L, L->top, luaH_new(L, narray, nrec));
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_getmetatable (lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt = NULL;
  int res;
  lua_lock(L);
  obj = index2adr(L, objindex);
  switch (ttype(obj)) {
    case LUA_TTABLE:
      mt = hvalue(obj)->metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(obj)->metatable;
      break;
    default:
      mt = G(L)->mt[ttype(obj)];
      break;
  }
  if (mt == NULL)
    res = 0;
  else {
    sethvalue(L, L->top, mt);
    api_incr_top(L);
    res = 1;
  }
  lua_unlock(L);
  return res;
}


LUA_API void lua_getfenv (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  switch (ttype(o)) {
    case LUA_TFUNCTION:
      sethvalue(L, L->top, clvalue(o)->c.env);
      break;
    case LUA_TUSERDATA:
      sethvalue(L, L->top, uvalue(o)->env);
      break;
    case LUA_TTHREAD:
      setobj2s(L, L->top,  gt(thvalue(o)));
      break;
    default:
      setnilvalue(L->top);
      break;
  }
  api_incr_top(L);
  lua_unlock(L);
}


/*
** set functions (stack -> Lua)
*/


LUA_API void lua_settable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  luaV_settable(L, t, L->top - 2, L->top - 1);
  L->top -= 2;  /* pop index and value */
  lua_unlock(L);
}


LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  lua_lock(L);
  api_checknelems(L, 1);
  t = index2adr(L, idx);
  api_checkvalidindex(L, t);
  setsvalue(L, &key, luaS_new(L, k));
  luaV_settable(L, t, &key, L->top - 1);
  L->top--;  /* pop value */
  lua_unlock(L);
}


LUA_API void lua_rawset (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
  luaC_barriert(L, hvalue(t), L->top-1);
  L->top -= 2;
  lua_unlock(L);
}


LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
  StkId o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_check(L, ttistable(o));
  setobj2t(L, luaH_setnum(L, hvalue(o), n), L->top-1);
  luaC_barriert(L, hvalue(o), L->top-1);
  L->top--;
  lua_unlock(L);
}


LUA_API int lua_setmetatable (lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  lua_lock(L);
  api_checknelems(L, 1);
  obj = index2adr(L, objindex);
  api_checkvalidindex(L, obj);
  if (ttisnil(L->top - 1))
    mt = NULL;
  else {
    api_check(L, ttistable(L->top - 1));
    mt = hvalue(L->top - 1);
  }
  switch (ttype(obj)) {
    case LUA_TTABLE: {
      hvalue(obj)->metatable = mt;
      if (mt)
        luaC_objbarriert(L, hvalue(obj), mt);
      break;
    }
    case LUA_TUSERDATA: {
      uvalue(obj)->metatable = mt;
      if (mt)
        luaC_objbarrier(L, rawuvalue(obj), mt);
      break;
    }
    default: {
      G(L)->mt[ttype(obj)] = mt;
      break;
    }
  }
  L->top--;
  lua_unlock(L);
  return 1;
}


LUA_API int lua_setfenv (lua_State *L, int idx) {
  StkId o;
  int res = 1;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2adr(L, idx);
  api_checkvalidindex(L, o);
  api_check(L, ttistable(L->top - 1));
  switch (ttype(o)) {
    case LUA_TFUNCTION:
      clvalue(o)->c.env = hvalue(L->top - 1);
      break;
    case LUA_TUSERDATA:
      uvalue(o)->env = hvalue(L->top - 1);
      break;
    case LUA_TTHREAD:
      sethvalue(L, gt(thvalue(o)), hvalue(L->top - 1));
      break;
    default:
      res = 0;
      break;
  }
  if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
  L->top--;
  lua_unlock(L);
  return res;
}


/*
** `load' and `call' functions (run Lua code)
*/


#define adjustresults(L,nres) \
    { if (nres == LUA_MULTRET && L->top >= L->ci->top) L->ci->top = L->top; }


#define checkresults(L,na,nr) \
     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)))


LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
  StkId func;
  lua_lock(L);
  api_checknelems(L, nargs+1);
  checkresults(L, nargs, nresults);
  func = L->top - (nargs+1);
  luaD_call(L, func, nresults);
  adjustresults(L, nresults);
  lua_unlock(L);
}



/*
** Execute a protected call.
*/
struct CallS {  /* data to `f_call' */
  StkId func;
  int nresults;
};


static inline void f_call (lua_State *L, void *ud) {
  struct CallS *c = cast(struct CallS *, ud);
  luaD_call(L, c->func, c->nresults);
}



LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  lua_lock(L);
  api_checknelems(L, nargs+1);
  checkresults(L, nargs, nresults);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2adr(L, errfunc);
    api_checkvalidindex(L, o);
    func = savestack(L, o);
  }
  c.func = L->top - (nargs+1);  /* function to be called */
  c.nresults = nresults;
  status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
  adjustresults(L, nresults);
  lua_unlock(L);
  return status;
}


/*
** Execute a protected C call.
*/
struct CCallS {  /* data to `f_Ccall' */
  lua_CFunction func;
  void *ud;
};


static inline void f_Ccall (lua_State *L, void *ud) {
  struct CCallS *c = cast(struct CCallS *, ud);
  Closure *cl;
  cl = luaF_newCclosure(L, 0, getcurrenv(L));
  cl->c.f = c->func;
  setclvalue(L, L->top, cl);  /* push function */
  api_incr_top(L);
  setpvalue(L->top, c->ud);  /* push only argument */
  api_incr_top(L);
  luaD_call(L, L->top - 2, 0);
}


LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
  struct CCallS c;
  int status;
  lua_lock(L);
  c.func = func;
  c.ud = ud;
  status = luaD_pcall(L, f_Ccall, &c, savestack(L, L->top), 0);
  lua_unlock(L);
  return status;
}



LUA_API int  lua_status (lua_State *L) {
  return L->status;
}





/*
** miscellaneous functions
*/


LUA_API int lua_error (lua_State *L) {
  lua_lock(L);
  api_checknelems(L, 1);
  luaG_errormsg(L);
  lua_unlock(L);
  return 0;  /* to avoid warnings */
}


LUA_API int lua_next (lua_State *L, int idx) {
  StkId t;
  int more;
  lua_lock(L);
  t = index2adr(L, idx);
  api_check(L, ttistable(t));
  more = luaH_next(L, hvalue(t), L->top - 1);
  if (more) {
    api_incr_top(L);
  }
  else  /* no more elements */
    L->top -= 1;  /* remove key */
  lua_unlock(L);
  return more;
}


LUA_API void lua_concat (lua_State *L, int n) {
  lua_lock(L);
  api_checknelems(L, n);
  if (n >= 2) {
    luaC_checkGC(L);
    luaV_concat(L, n, cast_int(L->top - L->base) - 1);
    L->top -= (n-1);
  }
  else if (n == 0) {  /* push empty string */
    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
    api_incr_top(L);
  }
  /* else n == 1; nothing to do */
  lua_unlock(L);
}


LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
  lua_Alloc f;
  lua_lock(L);
  if (ud) *ud = G(L)->ud;
  f = G(L)->frealloc;
  lua_unlock(L);
  return f;
}


LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
  lua_lock(L);
  G(L)->ud = ud;
  G(L)->frealloc = f;
  lua_unlock(L);
}


LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
  Udata *u;
  lua_lock(L);
  luaC_checkGC(L);
  u = luaS_newudata(L, size, getcurrenv(L));
  setuvalue(L, L->top, u);
  api_incr_top(L);
  lua_unlock(L);
  return u + 1;
}




static const char *aux_upvalue (StkId fi, int n, TValue **val) {
  Closure *f;
  if (!ttisfunction(fi)) return NULL;
  f = clvalue(fi);
  if (f->c.isC) {
    if (!(1 <= n && n <= f->c.nupvalues)) return NULL;
    *val = &f->c.upvalue[n-1];
    return "";
  }
  else {
    Proto *p = f->l.p;
    if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
    *val = f->l.upvals[n-1]->v;
    return getstr(p->upvalues[n-1]);
  }
}


LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  lua_lock(L);
  name = aux_upvalue(index2adr(L, funcindex), n, &val);
  if (name) {
    setobj2s(L, L->top, val);
    api_incr_top(L);
  }
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  StkId fi;
  lua_lock(L);
  fi = index2adr(L, funcindex);
  api_checknelems(L, 1);
  name = aux_upvalue(fi, n, &val);
  if (name) {
    L->top--;
    setobj(L, val, L->top);
    luaC_barrier(L, clvalue(fi), L->top);
  }
  lua_unlock(L);
  return name;
}

/*-- File: src.cpp/lapi.cpp end --*/
/*-- #include "src.cpp/lapi.h" start --*/
/*-- File: src.cpp/lauxlib.cpp start --*/
/*
** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/ctype.h" start --*/
/*-- #include "src.cpp/errno.h" start --*/
/*-- #include "src.cpp/stdarg.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/


/* This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
*/

#define lauxlib_c
#define LUA_LIB

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lauxlib.h" start --*/


#define FREELIST_REF	0	/* free list of references */


/* convert a stack index to positive */
#define abs_index(L, i)		((i) > 0 || (i) <= LUA_REGISTRYINDEX ? (i) : \
					lua_gettop(L) + (i) + 1)


/*
** {======================================================
** Error-report functions
** =======================================================
*/


LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
  lua_getinfo(L, "n", &ar);
  if (strcmp(ar.namewhat, "method") == 0) {
    narg--;  /* do not count `self' */
    if (narg == 0)  /* error is in the self argument itself? */
      return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
                           ar.name, extramsg);
  }
  if (ar.name == NULL)
    ar.name = "?";
  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
                        narg, ar.name, extramsg);
}


LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
  const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                    tname, luaL_typename(L, narg));
  return luaL_argerror(L, narg, msg);
}


static inline void tag_error (lua_State *L, int narg, int tag) {
  luaL_typerror(L, narg, lua_typename(L, tag));
}


LUALIB_API void luaL_where (lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &ar)) {  /* check function at level */
    lua_getinfo(L, "Sl", &ar);  /* get info about it */
    if (ar.currentline > 0) {  /* is there info? */
      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushliteral(L, "");  /* else, no information available... */
}


LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}

/* }====================================================== */


LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
                                 const char *const lst[]) {
  const char *name = (def) ? luaL_optstring(L, narg, def) :
                             luaL_checkstring(L, narg);
  int i;
  for (i=0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, narg,
                       lua_pushfstring(L, "invalid option " LUA_QS, name));
}


LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
  lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get registry.name */
  if (!lua_isnil(L, -1))  /* name already in use? */
    return 0;  /* leave previous value on top, but return 0 */
  lua_pop(L, 1);
  lua_newtable(L);  /* create metatable */
  lua_pushvalue(L, -1);
  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
  return 1;
}


LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {  /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
      lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */
      if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
        lua_pop(L, 2);  /* remove both metatables */
        return p;
      }
    }
  }
  luaL_typerror(L, ud, tname);  /* else error */
  return NULL;  /* to avoid warnings */
}


LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
  if (!lua_checkstack(L, space))
    luaL_error(L, "stack overflow (%s)", mes);
}


LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
  if (lua_type(L, narg) != t)
    tag_error(L, narg, t);
}


LUALIB_API void luaL_checkany (lua_State *L, int narg) {
  if (lua_type(L, narg) == LUA_TNONE)
    luaL_argerror(L, narg, "value expected");
}


LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
  const char *s = lua_tolstring(L, narg, len);
  if (!s) tag_error(L, narg, LUA_TSTRING);
  return s;
}


LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
                                        const char *def, size_t *len) {
  if (lua_isnoneornil(L, narg)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  }
  else return luaL_checklstring(L, narg, len);
}


LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
  lua_Number d = lua_tonumber(L, narg);
  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
    tag_error(L, narg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
  return luaL_opt(L, luaL_checknumber, narg, def);
}


LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
  lua_Integer d = lua_tointeger(L, narg);
  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
    tag_error(L, narg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
                                                      lua_Integer def) {
  return luaL_opt(L, luaL_checkinteger, narg, def);
}


LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj))  /* no metatable? */
    return 0;
  lua_pushstring(L, event);
  lua_rawget(L, -2);
  if (lua_isnil(L, -1)) {
    lua_pop(L, 2);  /* remove metatable and metafield */
    return 0;
  }
  else {
    lua_remove(L, -2);  /* remove only metatable */
    return 1;
  }
}


LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
  obj = abs_index(L, obj);
  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
    return 0;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return 1;
}


LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l) {
  luaI_openlib(L, libname, l, 0);
}


static inline int libsize (const luaL_Reg *l) {
  int size = 0;
  for (; l->name; l++) size++;
  return size;
}


LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
                              const luaL_Reg *l, int nup) {
  if (libname) {
    int size = libsize(l);
    /* check whether lib already exists */
    luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);
    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */
    if (!lua_istable(L, -1)) {  /* not found? */
      lua_pop(L, 1);  /* remove previous result */
      /* try global variable (and create one if it does not exist) */
      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)
        luaL_error(L, "name conflict for module " LUA_QS, libname);
      lua_pushvalue(L, -1);
      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */
    }
    lua_remove(L, -2);  /* remove _LOADED table */
    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
  }
  for (; l->name; l++) {
    int i;
    for (i=0; i<nup; i++)  /* copy upvalues to the top */
      lua_pushvalue(L, -nup);
    lua_pushcclosure(L, l->func, nup);
    lua_setfield(L, -(nup+2), l->name);
  }
  lua_pop(L, nup);  /* remove upvalues */
}



/*
** {======================================================
** getn-setn: size for arrays
** =======================================================
*/

#if defined(LUA_COMPAT_GETN)

static inline int checkint (lua_State *L, int topop) {
  int n = (lua_type(L, -1) == LUA_TNUMBER) ? lua_tointeger(L, -1) : -1;
  lua_pop(L, topop);
  return n;
}


static inline void getsizes (lua_State *L) {
  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_SIZES");
  if (lua_isnil(L, -1)) {  /* no `size' table? */
    lua_pop(L, 1);  /* remove nil */
    lua_newtable(L);  /* create it */
    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
    lua_setmetatable(L, -2);
    lua_pushliteral(L, "kv");
    lua_setfield(L, -2, "__mode");  /* metatable(N).__mode = "kv" */
    lua_pushvalue(L, -1);
    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_SIZES");  /* store in register */
  }
}


LUALIB_API void luaL_setn (lua_State *L, int t, int n) {
  t = abs_index(L, t);
  lua_pushliteral(L, "n");
  lua_rawget(L, t);
  if (checkint(L, 1) >= 0) {  /* is there a numeric field `n'? */
    lua_pushliteral(L, "n");  /* use it */
    lua_pushinteger(L, n);
    lua_rawset(L, t);
  }
  else {  /* use `sizes' */
    getsizes(L);
    lua_pushvalue(L, t);
    lua_pushinteger(L, n);
    lua_rawset(L, -3);  /* sizes[t] = n */
    lua_pop(L, 1);  /* remove `sizes' */
  }
}


LUALIB_API int luaL_getn (lua_State *L, int t) {
  int n;
  t = abs_index(L, t);
  lua_pushliteral(L, "n");  /* try t.n */
  lua_rawget(L, t);
  if ((n = checkint(L, 1)) >= 0) return n;
  getsizes(L);  /* else try sizes[t] */
  lua_pushvalue(L, t);
  lua_rawget(L, -2);
  if ((n = checkint(L, 2)) >= 0) return n;
  return (int)lua_objlen(L, t);
}

#endif

/* }====================================================== */



LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
                                                               const char *r) {
  const char *wild;
  size_t l = strlen(p);
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while ((wild = strstr(s, p)) != NULL) {
    luaL_addlstring(&b, s, wild - s);  /* push prefix */
    luaL_addstring(&b, r);  /* push replacement in place of pattern */
    s = wild + l;  /* continue after `p' */
  }
  luaL_addstring(&b, s);  /* push last suffix */
  luaL_pushresult(&b);
  return lua_tostring(L, -1);
}


LUALIB_API const char *luaL_findtable (lua_State *L, int idx,
                                       const char *fname, int szhint) {
  const char *e;
  lua_pushvalue(L, idx);
  do {
    e = strchr(fname, '.');
    if (e == NULL) e = fname + strlen(fname);
    lua_pushlstring(L, fname, e - fname);
    lua_rawget(L, -2);
    if (lua_isnil(L, -1)) {  /* no such field? */
      lua_pop(L, 1);  /* remove this nil */
      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
      lua_pushlstring(L, fname, e - fname);
      lua_pushvalue(L, -2);
      lua_settable(L, -4);  /* set new table into field */
    }
    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
      lua_pop(L, 2);  /* remove table and value */
      return fname;  /* return problematic part of the name */
    }
    lua_remove(L, -2);  /* remove previous table */
    fname = e + 1;
  } while (*e == '.');
  return NULL;
}



/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/


#define bufflen(B)	((B)->p - (B)->buffer)
#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))

#define LIMIT	(LUA_MINSTACK/2)


static inline int emptybuffer (luaL_Buffer *B) {
  size_t l = bufflen(B);
  if (l == 0) return 0;  /* put nothing on stack */
  else {
    lua_pushlstring(B->L, B->buffer, l);
    B->p = B->buffer;
    B->lvl++;
    return 1;
  }
}


static inline void adjuststack (luaL_Buffer *B) {
  if (B->lvl > 1) {
    lua_State *L = B->L;
    int toget = 1;  /* number of levels to concat */
    size_t toplen = lua_strlen(L, -1);
    do {
      size_t l = lua_strlen(L, -(toget+1));
      if (B->lvl - toget + 1 >= LIMIT || toplen > l) {
        toplen += l;
        toget++;
      }
      else break;
    } while (toget < B->lvl);
    lua_concat(L, toget);
    B->lvl = B->lvl - toget + 1;
  }
}


LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
  if (emptybuffer(B))
    adjuststack(B);
  return B->buffer;
}


LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
  while (l--)
    luaL_addchar(B, *s++);
}


LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}


LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
  emptybuffer(B);
  lua_concat(B->L, B->lvl);
  B->lvl = 1;
}


LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
  lua_State *L = B->L;
  size_t vl;
  const char *s = lua_tolstring(L, -1, &vl);
  if (vl <= bufffree(B)) {  /* fit into buffer? */
    memcpy(B->p, s, vl);  /* put it there */
    B->p += vl;
    lua_pop(L, 1);  /* remove from stack */
  }
  else {
    if (emptybuffer(B))
      lua_insert(L, -2);  /* put buffer before new value */
    B->lvl++;  /* add new value into B stack */
    adjuststack(B);
  }
}


LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
  B->L = L;
  B->p = B->buffer;
  B->lvl = 0;
}

/* }====================================================== */


LUALIB_API int luaL_ref (lua_State *L, int t) {
  int ref;
  t = abs_index(L, t);
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* remove from stack */
    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
  }
  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */
  lua_pop(L, 1);  /* remove it from stack */
  if (ref != 0) {  /* any free element? */
    lua_rawgeti(L, t, ref);  /* remove it from list */
    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
  }
  else {  /* no free elements */
    ref = (int)lua_objlen(L, t);
    ref++;  /* create new reference */
  }
  lua_rawseti(L, t, ref);
  return ref;
}


LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
  if (ref >= 0) {
    t = abs_index(L, t);
    lua_rawgeti(L, t, FREELIST_REF);
    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
  }
}



static inline void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud;
  (void)osize;
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}


static inline int panic (lua_State *L) {
  (void)L;  /* to avoid warnings */
  fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
                   lua_tostring(L, -1));
  return 0;
}


LUALIB_API lua_State *luaL_newstate (void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (L) lua_atpanic(L, &panic);
  return L;
}

/*-- File: src.cpp/lauxlib.cpp end --*/
/*-- #include "src.cpp/lauxlib.h" start --*/
/*-- File: src.cpp/lbaselib.cpp start --*/
/*
** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
** Basic library
** See Copyright Notice in lua.h
*/



/*-- #include "src.cpp/ctype.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define lbaselib_c
#define LUA_LIB

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lauxlib.h" start --*/
/*-- #include "src.cpp/lualib.h" start --*/




static inline int luaB_tonumber (lua_State *L) {
  int base = luaL_optint(L, 2, 10);
  if (base == 10) {  /* standard conversion */
    luaL_checkany(L, 1);
    if (lua_isnumber(L, 1)) {
      lua_pushnumber(L, lua_tonumber(L, 1));
      return 1;
    }
  }
  else {
    const char *s1 = luaL_checkstring(L, 1);
    char *s2;
    unsigned long n;
    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
    n = strtoul(s1, &s2, base);
    if (s1 != s2) {  /* at least one valid digit? */
      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
      if (*s2 == '\0') {  /* no invalid trailing characters? */
        lua_pushnumber(L, (lua_Number)n);
        return 1;
      }
    }
  }
  lua_pushnil(L);  /* else not a number */
  return 1;
}


static inline int luaB_error (lua_State *L) {
  int level = luaL_optint(L, 2, 1);
  lua_settop(L, 1);
  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
    luaL_where(L, level);
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}


static inline int luaB_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;  /* no metatable */
  }
  luaL_getmetafield(L, 1, "__metatable");
  return 1;  /* returns either __metatable field (if present) or metatable */
}


static inline int luaB_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                    "nil or table expected");
  if (luaL_getmetafield(L, 1, "__metatable"))
    luaL_error(L, "cannot change a protected metatable");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}


static inline void getfunc (lua_State *L, int opt) {
  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
  else {
    lua_Debug ar;
    int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
    luaL_argcheck(L, level >= 0, 1, "level must be non-negative");
    if (lua_getstack(L, level, &ar) == 0)
      luaL_argerror(L, 1, "invalid level");
    lua_getinfo(L, "f", &ar);
    if (lua_isnil(L, -1))
      luaL_error(L, "no function environment for tail call at level %d",
                    level);
  }
}


static inline int luaB_rawequal (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}


static inline int luaB_rawget (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}

static inline int luaB_rawset (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}


static inline int luaB_type (lua_State *L) {
  luaL_checkany(L, 1);
  lua_pushstring(L, luaL_typename(L, 1));
  return 1;
}


static inline int luaB_next (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}


static inline int luaB_pairs (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
  lua_pushvalue(L, 1);  /* state, */
  lua_pushnil(L);  /* and initial value */
  return 3;
}


static inline int ipairsaux (lua_State *L) {
  int i = luaL_checkint(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  i++;  /* next value */
  lua_pushinteger(L, i);
  lua_rawgeti(L, 1, i);
  return (lua_isnil(L, -1)) ? 0 : 2;
}


static inline int luaB_ipairs (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
  lua_pushvalue(L, 1);  /* state, */
  lua_pushinteger(L, 0);  /* and initial value */
  return 3;
}


static inline int load_aux (lua_State *L, int status) {
  if (status == 0)  /* OK? */
    return 1;
  else {
    lua_pushnil(L);
    lua_insert(L, -2);  /* put before error message */
    return 2;  /* return nil plus error message */
  }
}



static inline int luaB_assert (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_toboolean(L, 1))
    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
  return lua_gettop(L);
}


static inline int luaB_unpack (lua_State *L) {
  int i, e, n;
  luaL_checktype(L, 1, LUA_TTABLE);
  i = luaL_optint(L, 2, 1);
  e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
  if (i > e) return 0;  /* empty range */
  n = e - i + 1;  /* number of elements */
  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
    return luaL_error(L, "too many results to unpack");
  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
  while (i++ < e)  /* push arg[i + 1...e] */
    lua_rawgeti(L, 1, i);
  return n;
}


static inline int luaB_select (lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
    lua_pushinteger(L, n-1);
    return 1;
  }
  else {
    int i = luaL_checkint(L, 1);
    if (i < 0) i = n + i;
    else if (i > n) i = n;
    luaL_argcheck(L, 1 <= i, 1, "index out of range");
    return n - i;
  }
}


static inline int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
  lua_pushboolean(L, (status == 0));
  lua_insert(L, 1);
  return lua_gettop(L);  /* return status + all results */
}


static inline int luaB_xpcall (lua_State *L) {
  int status;
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_insert(L, 1);  /* put error function under function to be called */
  status = lua_pcall(L, 0, LUA_MULTRET, 1);
  lua_pushboolean(L, (status == 0));
  lua_replace(L, 1);
  return lua_gettop(L);  /* return status + all results */
}


static inline int luaB_tostring (lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
    return 1;  /* use its value */
  switch (lua_type(L, 1)) {
    case LUA_TNUMBER:
      lua_pushstring(L, lua_tostring(L, 1));
      break;
    case LUA_TSTRING:
      lua_pushvalue(L, 1);
      break;
    case LUA_TBOOLEAN:
      lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
      break;
    case LUA_TNIL:
      lua_pushliteral(L, "nil");
      break;
    default:
      lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
      break;
  }
  return 1;
}


static inline int luaB_newproxy (lua_State *L) {
  lua_settop(L, 1);
  lua_newuserdata(L, 0);  /* create proxy */
  if (lua_toboolean(L, 1) == 0)
    return 1;  /* no metatable */
  else if (lua_isboolean(L, 1)) {
    lua_newtable(L);  /* create a new metatable `m' ... */
    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
    lua_pushboolean(L, 1);
    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
  }
  else {
    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
    if (lua_getmetatable(L, 1)) {
      lua_rawget(L, lua_upvalueindex(1));
      validproxy = lua_toboolean(L, -1);
      lua_pop(L, 1);  /* remove value */
    }
    luaL_argcheck(L, validproxy, 1, "boolean or proxy expected");
    lua_getmetatable(L, 1);  /* metatable is valid; get it */
  }
  lua_setmetatable(L, 2);
  return 1;
}


static const luaL_Reg base_funcs[] = {
  {"assert", luaB_assert},
  {"error", luaB_error},
  {"getmetatable", luaB_getmetatable},
  {"next", luaB_next},
  {"pcall", luaB_pcall},
  {"rawequal", luaB_rawequal},
  {"rawget", luaB_rawget},
  {"rawset", luaB_rawset},
  {"select", luaB_select},
  {"setmetatable", luaB_setmetatable},
  {"tonumber", luaB_tonumber},
  {"tostring", luaB_tostring},
  {"type", luaB_type},
  {"unpack", luaB_unpack},
  {"xpcall", luaB_xpcall},
  {NULL, NULL}
};


/*
** {======================================================
** Coroutine library
** =======================================================
*/

#define CO_RUN	0	/* running */
#define CO_SUS	1	/* suspended */
#define CO_NOR	2	/* 'normal' (it resumed another coroutine) */
#define CO_DEAD	3

static const char *const statnames[] =
    {"running", "suspended", "normal", "dead"};

static inline int costatus (lua_State *L, lua_State *co) {
  if (L == co) return CO_RUN;
  switch (lua_status(co)) {
    case LUA_YIELD:
      return CO_SUS;
    case 0: {
      lua_Debug ar;
      if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
        return CO_NOR;  /* it is running */
      else if (lua_gettop(co) == 0)
          return CO_DEAD;
      else
        return CO_SUS;  /* initial state */
    }
    default:  /* some error occured */
      return CO_DEAD;
  }
}


static inline int luaB_costatus (lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  luaL_argcheck(L, co, 1, "coroutine expected");
  lua_pushstring(L, statnames[costatus(L, co)]);
  return 1;
}


static inline int auxresume (lua_State *L, lua_State *co, int narg) {
  int status = costatus(L, co);
  if (!lua_checkstack(co, narg))
    luaL_error(L, "too many arguments to resume");
  if (status != CO_SUS) {
    lua_pushfstring(L, "cannot resume %s coroutine", statnames[status]);
    return -1;  /* error flag */
  }
  lua_xmove(L, co, narg);
  lua_setlevel(L, co);
  status = lua_resume(co, narg);
  if (status == 0 || status == LUA_YIELD) {
    int nres = lua_gettop(co);
    if (!lua_checkstack(L, nres + 1))
      luaL_error(L, "too many results to resume");
    lua_xmove(co, L, nres);  /* move yielded values */
    return nres;
  }
  else {
    lua_xmove(co, L, 1);  /* move error message */
    return -1;  /* error flag */
  }
}


static inline int luaB_coresume (lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  int r;
  luaL_argcheck(L, co, 1, "coroutine expected");
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (r < 0) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;  /* return false + error message */
  }
  else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;  /* return true + `resume' returns */
  }
}


static inline int luaB_auxwrap (lua_State *L) {
  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
  int r = auxresume(L, co, lua_gettop(L));
  if (r < 0) {
    if (lua_isstring(L, -1)) {  /* error object is a string? */
      luaL_where(L, 1);  /* add extra info */
      lua_insert(L, -2);
      lua_concat(L, 2);
    }
    lua_error(L);  /* propagate error */
  }
  return r;
}


static inline int luaB_cocreate (lua_State *L) {
  lua_State *NL = lua_newthread(L);
  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
    "Lua function expected");
  lua_pushvalue(L, 1);  /* move function to top */
  lua_xmove(L, NL, 1);  /* move function from L to NL */
  return 1;
}


static inline int luaB_cowrap (lua_State *L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
}


static inline int luaB_yield (lua_State *L) {
  return lua_yield(L, lua_gettop(L));
}


static inline int luaB_corunning (lua_State *L) {
  if (lua_pushthread(L))
    lua_pushnil(L);  /* main thread is not a coroutine */
  return 1;
}


static const luaL_Reg co_funcs[] = {
  {"create", luaB_cocreate},
  {"resume", luaB_coresume},
  {"running", luaB_corunning},
  {"status", luaB_costatus},
  {"wrap", luaB_cowrap},
  {"yield", luaB_yield},
  {NULL, NULL}
};

/* }====================================================== */


static inline void auxopen (lua_State *L, const char *name,
                     lua_CFunction f, lua_CFunction u) {
  lua_pushcfunction(L, u);
  lua_pushcclosure(L, f, 1);
  lua_setfield(L, -2, name);
}


static inline void base_open (lua_State *L) {
  /* set global _G */
  lua_pushvalue(L, LUA_GLOBALSINDEX);
  lua_setglobal(L, "_G");
  /* open lib into global table */
  luaL_register(L, "_G", base_funcs);
  lua_pushliteral(L, LUA_VERSION);
  lua_setglobal(L, "_VERSION");  /* set global _VERSION */
  /* `ipairs' and `pairs' need auxiliary functions as upvalues */
  auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
  auxopen(L, "pairs", luaB_pairs, luaB_next);
  /* `newproxy' needs a weaktable as upvalue */
  lua_createtable(L, 0, 1);  /* new table `w' */
  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
  lua_setmetatable(L, -2);
  lua_pushliteral(L, "kv");
  lua_setfield(L, -2, "__mode");  /* metatable(w).__mode = "kv" */
  lua_pushcclosure(L, luaB_newproxy, 1);
  lua_setglobal(L, "newproxy");  /* set global `newproxy' */
}


LUALIB_API int luaopen_base (lua_State *L) {
  base_open(L);
  luaL_register(L, LUA_COLIBNAME, co_funcs);
  return 2;
}

/*-- File: src.cpp/lbaselib.cpp end --*/
/*-- File: src.cpp/lcode.cpp start --*/

/*-- File: src.cpp/lcode.cpp end --*/
/*-- #include "src.cpp/lcode.h" start --*/

/*-- File: src.cpp/ldebug.cpp start --*/
/*
** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
** Debug Interface
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stdarg.h" start --*/
/*-- #include "src.cpp/stddef.h" start --*/
/*-- #include "src.cpp/string.h" start --*/


#define ldebug_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lapi.h" start --*/
/*-- #include "src.cpp/lcode.h" start --*/
/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lopcodes.h" start --*/
/*
** $Id: lopcodes.h,v 1.125.1.1 2007/12/27 13:02:25 roberto Exp $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lopcodes_h
#define lopcodes_h

/*-- #include "src.cpp/llimits.h" start --*/


/*===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
	`A' : 8 bits
	`B' : 9 bits
	`C' : 9 bits
	`Bx' : 18 bits (`B' and `C' together)
	`sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================*/


enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */


/*
** size and position of opcode arguments.
*/
#define SIZE_C		9
#define SIZE_B		9
#define SIZE_Bx		(SIZE_C + SIZE_B)
#define SIZE_A		8

#define SIZE_OP		6

#define POS_OP		0
#define POS_A		(POS_OP + SIZE_OP)
#define POS_C		(POS_A + SIZE_A)
#define POS_B		(POS_C + SIZE_C)
#define POS_Bx		POS_C


/*
** limits for opcode arguments.
** we use (signed) int to manipulate most arguments,
** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
*/
#if SIZE_Bx < LUAI_BITSINT-1
#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
#else
#define MAXARG_Bx        MAX_INT
#define MAXARG_sBx        MAX_INT
#endif


#define MAXARG_A        ((1<<SIZE_A)-1)
#define MAXARG_B        ((1<<SIZE_B)-1)
#define MAXARG_C        ((1<<SIZE_C)-1)


/* creates a mask with `n' 1 bits at position `p' */
#define MASK1(n,p)	((~((~(Instruction)0)<<n))<<p)

/* creates a mask with `n' 0 bits at position `p' */
#define MASK0(n,p)	(~MASK1(n,p))

/*
** the following macros help to manipulate instructions
*/

#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

#define GETARG_A(i)	(cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))
#define SETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
		((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))

#define GETARG_B(i)	(cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
#define SETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
		((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))

#define GETARG_C(i)	(cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
#define SETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
		((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))

#define GETARG_Bx(i)	(cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
#define SETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
		((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))

#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))


#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, b)<<POS_B) \
			| (cast(Instruction, c)<<POS_C))

#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, bc)<<POS_Bx))


/*
** Macros to operate RK indices
*/

/* this bit 1 means constant (0 means register) */
#define BITRK		(1 << (SIZE_B - 1))

/* test whether value is a constant */
#define ISK(x)		((x) & BITRK)

/* gets the index of the constant */
#define INDEXK(r)	((int)(r) & ~BITRK)

#define MAXINDEXRK	(BITRK - 1)

/* code a constant index as a RK value */
#define RKASK(x)	((x) | BITRK)


/*
** invalid register that fits in 8 bits
*/
#define NO_REG		MAXARG_A


/*
** R(x) - register
** Kst(x) - constant (in constant table)
** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
*/


/*
** grep "ORDER OP" if you change these enums
*/

typedef enum {
/*----------------------------------------------------------------------
name		args	description
------------------------------------------------------------------------*/
OP_MOVE,/*	A B	R(A) := R(B)					*/
OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/

OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/

OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/

OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/

OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/

OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
OP_UNM,/*	A B	R(A) := -R(B)					*/
OP_NOT,/*	A B	R(A) := not R(B)				*/
OP_LEN,/*	A B	R(A) := length of R(B)				*/

OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/

OP_JMP,/*	sBx	pc+=sBx					*/

OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*/
OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*/

OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/ 
OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/ 

OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/

OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/

OP_TFORLOOP,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++	*/ 
OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/

OP_CLOSE,/*	A 	close all variables in the stack up to (>=) R(A)*/
OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/

OP_VARARG/*	A B	R(A), R(A+1), ..., R(A+B-1) = vararg		*/
} OpCode;


#define NUM_OPCODES	(cast(int, OP_VARARG) + 1)



/*===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets `top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.

  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).

  (*) In OP_RETURN, if (B == 0) then return up to `top'

  (*) In OP_SETLIST, if (B == 0) then B = `top';
      if (C == 0) then next `instruction' is real C

  (*) For comparisons, A specifies what condition the test should accept
      (true or false).

  (*) All `skips' (pc++) assume that next instruction is a jump
===========================================================================*/


/*
** masks for instruction properties. The format is:
** bits 0-1: op mode
** bits 2-3: C arg mode
** bits 4-5: B arg mode
** bit 6: instruction set register A
** bit 7: operator is a test
*/  

enum OpArgMask {
  OpArgN,  /* argument is not used */
  OpArgU,  /* argument is used */
  OpArgR,  /* argument is a register or a jump offset */
  OpArgK   /* argument is a constant or register/constant */
};

static LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];

#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))


static LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */


/* number of list items to accumulate before a SETLIST instruction */
#define LFIELDS_PER_FLUSH	50


#endif

/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/
/*-- #include "src.cpp/lvm.h" start --*/



static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);


static inline int currentpc (lua_State *L, CallInfo *ci) {
  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
  if (ci == L->ci)
    ci->savedpc = L->savedpc;
  return pcRel(ci->savedpc, ci_func(ci)->l.p);
}


static inline int currentline (lua_State *L, CallInfo *ci) {
  int pc = currentpc(L, ci);
  if (pc < 0)
    return -1;  /* only active lua functions have current-line information */
  else
    return getline(ci_func(ci)->l.p, pc);
}


/*
** this function can be called asynchronous (e.g. during a signal)
*/
LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
  if (func == NULL || mask == 0) {  /* turn off hooks? */
    mask = 0;
    func = NULL;
  }
  L->hook = func;
  L->basehookcount = count;
  resethookcount(L);
  L->hookmask = cast_byte(mask);
  return 1;
}


LUA_API lua_Hook lua_gethook (lua_State *L) {
  return L->hook;
}


LUA_API int lua_gethookmask (lua_State *L) {
  return L->hookmask;
}


LUA_API int lua_gethookcount (lua_State *L) {
  return L->basehookcount;
}


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  lua_lock(L);
  for (ci = L->ci; level > 0 && ci > L->base_ci; ci--) {
    level--;
    if (f_isLua(ci))  /* Lua function? */
      level -= ci->tailcalls;  /* skip lost tail calls */
  }
  if (level == 0 && ci > L->base_ci) {  /* level found? */
    status = 1;
    ar->i_ci = cast_int(ci - L->base_ci);
  }
  else if (level < 0) {  /* level is of a lost tail call? */
    status = 1;
    ar->i_ci = 0;
  }
  else status = 0;  /* no such level */
  lua_unlock(L);
  return status;
}


static inline Proto *getluaproto (CallInfo *ci) {
  return (isLua(ci) ? ci_func(ci)->l.p : NULL);
}


static const char *findlocal (lua_State *L, CallInfo *ci, int n) {
  const char *name;
  Proto *fp = getluaproto(ci);
  if (fp && (name = luaF_getlocalname(fp, n, currentpc(L, ci))) != NULL)
    return name;  /* is a local variable in a Lua function */
  else {
    StkId limit = (ci == L->ci) ? L->top : (ci+1)->func;
    if (limit - ci->base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
      return "(*temporary)";
    else
      return NULL;
  }
}


LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
  CallInfo *ci = L->base_ci + ar->i_ci;
  const char *name = findlocal(L, ci, n);
  lua_lock(L);
  if (name)
      luaA_pushobject(L, ci->base + (n - 1));
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
  CallInfo *ci = L->base_ci + ar->i_ci;
  const char *name = findlocal(L, ci, n);
  lua_lock(L);
  if (name)
      setobjs2s(L, ci->base + (n - 1), L->top - 1);
  L->top--;  /* pop value */
  lua_unlock(L);
  return name;
}


static inline void funcinfo (lua_Debug *ar, Closure *cl) {
  if (cl->c.isC) {
    ar->source = "=[C]";
    ar->linedefined = -1;
    ar->lastlinedefined = -1;
    ar->what = "C";
  }
  else {
    ar->source = getstr(cl->l.p->source);
    ar->linedefined = cl->l.p->linedefined;
    ar->lastlinedefined = cl->l.p->lastlinedefined;
    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
  }
  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
}


static inline void info_tailcall (lua_Debug *ar) {
  ar->name = ar->namewhat = "";
  ar->what = "tail";
  ar->lastlinedefined = ar->linedefined = ar->currentline = -1;
  ar->source = "=(tail call)";
  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
  ar->nups = 0;
}


static inline void collectvalidlines (lua_State *L, Closure *f) {
  if (f == NULL || f->c.isC) {
    setnilvalue(L->top);
  }
  else {
    Table *t = luaH_new(L, 0, 0);
    int *lineinfo = f->l.p->lineinfo;
    int i;
    for (i=0; i<f->l.p->sizelineinfo; i++)
      setbvalue(luaH_setnum(L, t, lineinfo[i]), 1);
    sethvalue(L, L->top, t); 
  }
  incr_top(L);
}


static inline int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
                    Closure *f, CallInfo *ci) {
  int status = 1;
  if (f == NULL) {
    info_tailcall(ar);
    return status;
  }
  for (; *what; what++) {
    switch (*what) {
      case 'S': {
        funcinfo(ar, f);
        break;
      }
      case 'l': {
        ar->currentline = (ci) ? currentline(L, ci) : -1;
        break;
      }
      case 'u': {
        ar->nups = f->c.nupvalues;
        break;
      }
      case 'n': {
        ar->namewhat = (ci) ? getfuncname(L, ci, &ar->name) : NULL;
        if (ar->namewhat == NULL) {
          ar->namewhat = "";  /* not found */
          ar->name = NULL;
        }
        break;
      }
      case 'L':
      case 'f':  /* handled by lua_getinfo */
        break;
      default: status = 0;  /* invalid option */
    }
  }
  return status;
}


LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *f = NULL;
  CallInfo *ci = NULL;
  lua_lock(L);
  if (*what == '>') {
    StkId func = L->top - 1;
    luai_apicheck(L, ttisfunction(func));
    what++;  /* skip the '>' */
    f = clvalue(func);
    L->top--;  /* pop function */
  }
  else if (ar->i_ci != 0) {  /* no tail call? */
    ci = L->base_ci + ar->i_ci;
    lua_assert(ttisfunction(ci->func));
    f = clvalue(ci->func);
  }
  status = auxgetinfo(L, what, ar, f, ci);
  if (strchr(what, 'f')) {
    if (f == NULL) setnilvalue(L->top);
    else setclvalue(L, L->top, f);
    incr_top(L);
  }
  if (strchr(what, 'L'))
    collectvalidlines(L, f);
  lua_unlock(L);
  return status;
}


/*
** {======================================================
** Symbolic Execution and code checker
** =======================================================
*/

#define check(x)		if (!(x)) return 0;

#define checkjump(pt,pc)	check(0 <= pc && pc < pt->sizecode)

#define checkreg(pt,reg)	check((reg) < (pt)->maxstacksize)



static inline int precheck (const Proto *pt) {
  check(pt->maxstacksize <= MAXSTACK);
  check(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);
  check(!(pt->is_vararg & VARARG_NEEDSARG) ||
              (pt->is_vararg & VARARG_HASARG));
  check(pt->sizeupvalues <= pt->nups);
  check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
  check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
  return 1;
}


#define checkopenop(pt,pc)	luaG_checkopenop((pt)->code[(pc)+1])

static inline int luaG_checkopenop (Instruction i) {
  switch (GET_OPCODE(i)) {
    case OP_CALL:
    case OP_TAILCALL:
    case OP_RETURN:
    case OP_SETLIST: {
      check(GETARG_B(i) == 0);
      return 1;
    }
    default: return 0;  /* invalid instruction after an open call */
  }
}


static inline int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {
  switch (mode) {
    case OpArgN: check(r == 0); break;
    case OpArgU: break;
    case OpArgR: checkreg(pt, r); break;
    case OpArgK:
      check(ISK(r) ? INDEXK(r) < pt->sizek : r < pt->maxstacksize);
      break;
  }
  return 1;
}


static inline Instruction symbexec (const Proto *pt, int lastpc, int reg) {
  int pc;
  int last;  /* stores position of last instruction that changed `reg' */
  last = pt->sizecode-1;  /* points to final return (a `neutral' instruction) */
  check(precheck(pt));
  for (pc = 0; pc < lastpc; pc++) {
    Instruction i = pt->code[pc];
    OpCode op = GET_OPCODE(i);
    int a = GETARG_A(i);
    int b = 0;
    int c = 0;
    check(op < NUM_OPCODES);
    checkreg(pt, a);
    switch (getOpMode(op)) {
      case iABC: {
        b = GETARG_B(i);
        c = GETARG_C(i);
        check(checkArgMode(pt, b, getBMode(op)));
        check(checkArgMode(pt, c, getCMode(op)));
        break;
      }
      case iABx: {
        b = GETARG_Bx(i);
        if (getBMode(op) == OpArgK) check(b < pt->sizek);
        break;
      }
      case iAsBx: {
        b = GETARG_sBx(i);
        if (getBMode(op) == OpArgR) {
          int dest = pc+1+b;
          check(0 <= dest && dest < pt->sizecode);
          if (dest > 0) {
            int j;
            /* check that it does not jump to a setlist count; this
               is tricky, because the count from a previous setlist may
               have the same value of an invalid setlist; so, we must
               go all the way back to the first of them (if any) */
            for (j = 0; j < dest; j++) {
              Instruction d = pt->code[dest-1-j];
              if (!(GET_OPCODE(d) == OP_SETLIST && GETARG_C(d) == 0)) break;
            }
            /* if 'j' is even, previous value is not a setlist (even if
               it looks like one) */
            check((j&1) == 0);
          }
        }
        break;
      }
    }
    if (testAMode(op)) {
      if (a == reg) last = pc;  /* change register `a' */
    }
    if (testTMode(op)) {
      check(pc+2 < pt->sizecode);  /* check skip */
      check(GET_OPCODE(pt->code[pc+1]) == OP_JMP);
    }
    switch (op) {
      case OP_LOADBOOL: {
        if (c == 1) {  /* does it jump? */
          check(pc+2 < pt->sizecode);  /* check its jump */
          check(GET_OPCODE(pt->code[pc+1]) != OP_SETLIST ||
                GETARG_C(pt->code[pc+1]) != 0);
        }
        break;
      }
      case OP_LOADNIL: {
        if (a <= reg && reg <= b)
          last = pc;  /* set registers from `a' to `b' */
        break;
      }
      case OP_GETUPVAL:
      case OP_SETUPVAL: {
        check(b < pt->nups);
        break;
      }
      case OP_GETGLOBAL:
      case OP_SETGLOBAL: {
        check(ttisstring(&pt->k[b]));
        break;
      }
      case OP_SELF: {
        checkreg(pt, a+1);
        if (reg == a+1) last = pc;
        break;
      }
      case OP_CONCAT: {
        check(b < c);  /* at least two operands */
        break;
      }
      case OP_TFORLOOP: {
        check(c >= 1);  /* at least one result (control variable) */
        checkreg(pt, a+2+c);  /* space for results */
        if (reg >= a+2) last = pc;  /* affect all regs above its base */
        break;
      }
      case OP_FORLOOP:
      case OP_FORPREP:
        checkreg(pt, a+3);
        /* go through */
      case OP_JMP: {
        int dest = pc+1+b;
        /* not full check and jump is forward and do not skip `lastpc'? */
        if (reg != NO_REG && pc < dest && dest <= lastpc)
          pc += b;  /* do the jump */
        break;
      }
      case OP_CALL:
      case OP_TAILCALL: {
        if (b != 0) {
          checkreg(pt, a+b-1);
        }
        c--;  /* c = num. returns */
        if (c == LUA_MULTRET) {
          check(checkopenop(pt, pc));
        }
        else if (c != 0)
          checkreg(pt, a+c-1);
        if (reg >= a) last = pc;  /* affect all registers above base */
        break;
      }
      case OP_RETURN: {
        b--;  /* b = num. returns */
        if (b > 0) checkreg(pt, a+b-1);
        break;
      }
      case OP_SETLIST: {
        if (b > 0) checkreg(pt, a + b);
        if (c == 0) {
          pc++;
          check(pc < pt->sizecode - 1);
        }
        break;
      }
      case OP_CLOSURE: {
        int nup, j;
        check(b < pt->sizep);
        nup = pt->p[b]->nups;
        check(pc + nup < pt->sizecode);
        for (j = 1; j <= nup; j++) {
          OpCode op1 = GET_OPCODE(pt->code[pc + j]);
          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
        }
        if (reg != NO_REG)  /* tracing? */
          pc += nup;  /* do not 'execute' these pseudo-instructions */
        break;
      }
      case OP_VARARG: {
        check((pt->is_vararg & VARARG_ISVARARG) &&
             !(pt->is_vararg & VARARG_NEEDSARG));
        b--;
        if (b == LUA_MULTRET) check(checkopenop(pt, pc));
        checkreg(pt, a+b-1);
        break;
      }
      default: break;
    }
  }
  return pt->code[last];
}

#undef check
#undef checkjump
#undef checkreg

/* }====================================================== */


static inline int luaG_checkcode (const Proto *pt) {
  return (symbexec(pt, pt->sizecode, NO_REG) != 0);
}


static const char *kname (Proto *p, int c) {
  if (ISK(c) && ttisstring(&p->k[INDEXK(c)]))
    return svalue(&p->k[INDEXK(c)]);
  else
    return "?";
}


static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
                               const char **name) {
  if (isLua(ci)) {  /* a Lua function? */
    Proto *p = ci_func(ci)->l.p;
    int pc = currentpc(L, ci);
    Instruction i;
    *name = luaF_getlocalname(p, stackpos+1, pc);
    if (*name)  /* is a local? */
      return "local";
    i = symbexec(p, pc, stackpos);  /* try symbolic execution */
    lua_assert(pc != -1);
    switch (GET_OPCODE(i)) {
      case OP_GETGLOBAL: {
        int g = GETARG_Bx(i);  /* global index */
        lua_assert(ttisstring(&p->k[g]));
        *name = svalue(&p->k[g]);
        return "global";
      }
      case OP_MOVE: {
        int a = GETARG_A(i);
        int b = GETARG_B(i);  /* move from `b' to `a' */
        if (b < a)
          return getobjname(L, ci, b, name);  /* get name for `b' */
        break;
      }
      case OP_GETTABLE: {
        int k = GETARG_C(i);  /* key index */
        *name = kname(p, k);
        return "field";
      }
      case OP_GETUPVAL: {
        int u = GETARG_B(i);  /* upvalue index */
        *name = p->upvalues ? getstr(p->upvalues[u]) : "?";
        return "upvalue";
      }
      case OP_SELF: {
        int k = GETARG_C(i);  /* key index */
        *name = kname(p, k);
        return "method";
      }
      default: break;
    }
  }
  return NULL;  /* no useful name found */
}


static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
  Instruction i;
  if ((isLua(ci) && ci->tailcalls > 0) || !isLua(ci - 1))
    return NULL;  /* calling function is not Lua (or is unknown) */
  ci--;  /* calling function */
  i = ci_func(ci)->l.p->code[currentpc(L, ci)];
  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL ||
      GET_OPCODE(i) == OP_TFORLOOP)
    return getobjname(L, ci, GETARG_A(i), name);
  else
    return NULL;  /* no useful name can be found */
}


/* only ANSI way to check whether a pointer points to an array */
static inline int isinstack (CallInfo *ci, const TValue *o) {
  StkId p;
  for (p = ci->base; p < ci->top; p++)
    if (o == p) return 1;
  return 0;
}


static inline void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
  const char *name = NULL;
  const char *t = luaT_typenames[ttype(o)];
  const char *kind = (isinstack(L->ci, o)) ?
                         getobjname(L, L->ci, cast_int(o - L->base), &name) :
                         NULL;
  if (kind)
    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
                op, kind, name, t);
  else
    luaG_runerror(L, "attempt to %s a %s value", op, t);
}


static inline void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
  lua_assert(!ttisstring(p1) && !ttisnumber(p1));
  luaG_typeerror(L, p1, "concatenate");
}


static inline void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
  TValue temp;
  if (luaV_tonumber(p1, &temp) == NULL)
    p2 = p1;  /* first operand is wrong */
  luaG_typeerror(L, p2, "perform arithmetic on");
}


static inline int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
  const char *t1 = luaT_typenames[ttype(p1)];
  const char *t2 = luaT_typenames[ttype(p2)];
  if (t1[2] == t2[2])
    luaG_runerror(L, "attempt to compare two %s values", t1);
  else
    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
  return 0;
}


static inline void addinfo (lua_State *L, const char *msg) {
  CallInfo *ci = L->ci;
  if (isLua(ci)) {  /* is Lua code? */
    char buff[LUA_IDSIZE];  /* add file:line information */
    int line = currentline(L, ci);
    luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
  }
}


static inline void luaG_errormsg (lua_State *L) {
  if (L->errfunc != 0) {  /* is there an error handling function? */
    StkId errfunc = restorestack(L, L->errfunc);
    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
    setobjs2s(L, L->top, L->top - 1);  /* move argument */
    setobjs2s(L, L->top - 1, errfunc);  /* push function */
    incr_top(L);
    luaD_call(L, L->top - 2, 1);  /* call it */
  }
  luaD_throw(L, LUA_ERRRUN);
}


static inline void luaG_runerror (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  addinfo(L, luaO_pushvfstring(L, fmt, argp));
  va_end(argp);
  luaG_errormsg(L);
}


/*-- File: src.cpp/ldebug.cpp end --*/
/*-- #include "src.cpp/ldebug.h" start --*/
/*-- File: src.cpp/ldo.cpp start --*/
/*
** $Id: ldo.c,v 2.38.1.4 2012/01/18 02:27:10 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/setjmp.h" start --*/
#include <setjmp.h>

/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define ldo_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lopcodes.h" start --*/
/*-- #include "src.cpp/lparser.h" start --*/
/*
** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/

#ifndef lparser_h
#define lparser_h

/*-- #include "src.cpp/llimits.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/


/*
** Expression descriptor
*/

typedef enum {
  VVOID,	/* no value */
  VNIL,
  VTRUE,
  VFALSE,
  VK,		/* info = index of constant in `k' */
  VKNUM,	/* nval = numerical value */
  VLOCAL,	/* info = local register */
  VUPVAL,       /* info = index of upvalue in `upvalues' */
  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
  VINDEXED,	/* info = table register; aux = index register (or `k') */
  VJMP,		/* info = instruction pc */
  VRELOCABLE,	/* info = instruction pc */
  VNONRELOC,	/* info = result register */
  VCALL,	/* info = instruction pc */
  VVARARG	/* info = instruction pc */
} expkind;

typedef struct expdesc {
  expkind k;
  union {
    struct { int info, aux; } s;
    lua_Number nval;
  } u;
  int t;  /* patch list of `exit when true' */
  int f;  /* patch list of `exit when false' */
} expdesc;


typedef struct upvaldesc {
  lu_byte k;
  lu_byte info;
} upvaldesc;


struct BlockCnt;  /* defined in lparser.c */


/* state needed to generate code for a given function */
typedef struct FuncState {
  Proto *f;  /* current function header */
  Table *h;  /* table to find (and reuse) elements in `k' */
  struct FuncState *prev;  /* enclosing function */
  struct LexState *ls;  /* lexical state */
  struct lua_State *L;  /* copy of the Lua state */
  struct BlockCnt *bl;  /* chain of current blocks */
  int pc;  /* next position to code (equivalent to `ncode') */
  int lasttarget;   /* `pc' of last `jump target' */
  int jpc;  /* list of pending jumps to `pc' */
  int freereg;  /* first free register */
  int nk;  /* number of elements in `k' */
  int np;  /* number of elements in `p' */
  short nlocvars;  /* number of elements in `locvars' */
  lu_byte nactvar;  /* number of active local variables */
  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */
  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */
} FuncState;


#endif

/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/
/*-- #include "src.cpp/lundump.h" start --*/
/*-- #include "src.cpp/lvm.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/




/*
** {======================================================
** Error-recovery functions
** =======================================================
*/


/* chain list of long jump buffers */
struct lua_longjmp {
  struct lua_longjmp *previous;
  luai_jmpbuf b;
  volatile int status;  /* error code */
};


static inline void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
  switch (errcode) {
    case LUA_ERRMEM: {
      setsvalue2s(L, oldtop, luaS_newliteral(L, MEMERRMSG));
      break;
    }
    case LUA_ERRERR: {
      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
      break;
    }
    case LUA_ERRSYNTAX:
    case LUA_ERRRUN: {
      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
      break;
    }
  }
  L->top = oldtop + 1;
}


static inline void restore_stack_limit (lua_State *L) {
  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);
  if (L->size_ci > LUAI_MAXCALLS) {  /* there was an overflow? */
    int inuse = cast_int(L->ci - L->base_ci);
    if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */
      luaD_reallocCI(L, LUAI_MAXCALLS);
  }
}


static inline void resetstack (lua_State *L, int status) {
  L->ci = L->base_ci;
  L->base = L->ci->base;
  luaF_close(L, L->base);  /* close eventual pending closures */
  luaD_seterrorobj(L, status, L->base);
  L->nCcalls = L->baseCcalls;
  L->allowhook = 1;
  restore_stack_limit(L);
  L->errfunc = 0;
  L->errorJmp = NULL;
}


static inline void luaD_throw (lua_State *L, int errcode) {
  if (L->errorJmp) {
    L->errorJmp->status = errcode;
    LUAI_THROW(L, L->errorJmp);
  }
  else {
    L->status = cast_byte(errcode);
    if (G(L)->panic) {
      resetstack(L, errcode);
      lua_unlock(L);
      G(L)->panic(L);
    }
    exit(EXIT_FAILURE);
  }
}


static inline int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
  struct lua_longjmp lj;
  lj.status = 0;
  lj.previous = L->errorJmp;  /* chain new error handler */
  L->errorJmp = &lj;
  LUAI_TRY(L, &lj,
    (*f)(L, ud);
  );
  L->errorJmp = lj.previous;  /* restore old error handler */
  return lj.status;
}

/* }====================================================== */


static inline void correctstack (lua_State *L, TValue *oldstack) {
  CallInfo *ci;
  GCObject *up;
  L->top = (L->top - oldstack) + L->stack;
  for (up = L->openupval; up != NULL; up = up->gch.next)
    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
  for (ci = L->base_ci; ci <= L->ci; ci++) {
    ci->top = (ci->top - oldstack) + L->stack;
    ci->base = (ci->base - oldstack) + L->stack;
    ci->func = (ci->func - oldstack) + L->stack;
  }
  L->base = (L->base - oldstack) + L->stack;
}


static inline void luaD_reallocstack (lua_State *L, int newsize) {
  TValue *oldstack = L->stack;
  int realsize = newsize + 1 + EXTRA_STACK;
  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);
  luaM_reallocvector(L, L->stack, L->stacksize, realsize, TValue);
  L->stacksize = realsize;
  L->stack_last = L->stack+newsize;
  correctstack(L, oldstack);
}


static inline void luaD_reallocCI (lua_State *L, int newsize) {
  CallInfo *oldci = L->base_ci;
  luaM_reallocvector(L, L->base_ci, L->size_ci, newsize, CallInfo);
  L->size_ci = newsize;
  L->ci = (L->ci - oldci) + L->base_ci;
  L->end_ci = L->base_ci + L->size_ci - 1;
}


static inline void luaD_growstack (lua_State *L, int n) {
  if (n <= L->stacksize)  /* double size is enough? */
    luaD_reallocstack(L, 2*L->stacksize);
  else
    luaD_reallocstack(L, L->stacksize + n);
}


static inline CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, "stack overflow");
  }
  return ++L->ci;
}


static inline void luaD_callhook (lua_State *L, int event, int line) {
  lua_Hook hook = L->hook;
  if (hook && L->allowhook) {
    ptrdiff_t top = savestack(L, L->top);
    ptrdiff_t ci_top = savestack(L, L->ci->top);
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    if (event == LUA_HOOKTAILRET)
      ar.i_ci = 0;  /* tail call; no debug information about it */
    else
      ar.i_ci = cast_int(L->ci - L->base_ci);
    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
    L->ci->top = L->top + LUA_MINSTACK;
    lua_assert(L->ci->top <= L->stack_last);
    L->allowhook = 0;  /* cannot call hooks inside a hook */
    lua_unlock(L);
    (*hook)(L, &ar);
    lua_lock(L);
    lua_assert(!L->allowhook);
    L->allowhook = 1;
    L->ci->top = restorestack(L, ci_top);
    L->top = restorestack(L, top);
  }
}


static inline StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
  int i;
  int nfixargs = p->numparams;
  Table *htab = NULL;
  StkId base, fixed;
  for (; actual < nfixargs; ++actual)
    setnilvalue(L->top++);
#if defined(LUA_COMPAT_VARARG)
  if (p->is_vararg & VARARG_NEEDSARG) { /* compat. with old-style vararg? */
    int nvar = actual - nfixargs;  /* number of extra arguments */
    lua_assert(p->is_vararg & VARARG_HASARG);
    luaC_checkGC(L);
    luaD_checkstack(L, p->maxstacksize);
    htab = luaH_new(L, nvar, 1);  /* create `arg' table */
    for (i=0; i<nvar; i++)  /* put extra arguments into `arg' table */
      setobj2n(L, luaH_setnum(L, htab, i+1), L->top - nvar + i);
    /* store counter in field `n' */
    setnvalue(luaH_setstr(L, htab, luaS_newliteral(L, "n")), cast_num(nvar));
  }
#endif
  /* move fixed parameters to final position */
  fixed = L->top - actual;  /* first fixed argument */
  base = L->top;  /* final position of first argument */
  for (i=0; i<nfixargs; i++) {
    setobjs2s(L, L->top++, fixed+i);
    setnilvalue(fixed+i);
  }
  /* add `arg' parameter */
  if (htab) {
    sethvalue(L, L->top++, htab);
    lua_assert(iswhite(obj2gco(htab)));
  }
  return base;
}


static inline StkId tryfuncTM (lua_State *L, StkId func) {
  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
  StkId p;
  ptrdiff_t funcr = savestack(L, func);
  if (!ttisfunction(tm))
    luaG_typeerror(L, func, "call");
  /* Open a hole inside the stack at `func' */
  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
  incr_top(L);
  func = restorestack(L, funcr);  /* previous call may change stack */
  setobj2s(L, func, tm);  /* tag method is the new function to be called */
  return func;
}



#define inc_ci(L) \
  ((L->ci == L->end_ci) ? growCI(L) : \
   (condhardstacktests(luaD_reallocCI(L, L->size_ci)), ++L->ci))


static inline int luaD_precall (lua_State *L, StkId func, int nresults) {
  LClosure *cl;
  ptrdiff_t funcr;
  if (!ttisfunction(func)) /* `func' is not a function? */
    func = tryfuncTM(L, func);  /* check the `function' tag method */
  funcr = savestack(L, func);
  cl = &clvalue(func)->l;
  L->ci->savedpc = L->savedpc;
  if (!cl->isC) {  /* Lua function? prepare its call */
    CallInfo *ci;
    StkId st, base;
    Proto *p = cl->p;
    luaD_checkstack(L, p->maxstacksize);
    func = restorestack(L, funcr);
    if (!p->is_vararg) {  /* no varargs? */
      base = func + 1;
      if (L->top > base + p->numparams)
        L->top = base + p->numparams;
    }
    else {  /* vararg function */
      int nargs = cast_int(L->top - func) - 1;
      base = adjust_varargs(L, p, nargs);
      func = restorestack(L, funcr);  /* previous call may change the stack */
    }
    ci = inc_ci(L);  /* now `enter' new function */
    ci->func = func;
    L->base = ci->base = base;
    ci->top = L->base + p->maxstacksize;
    lua_assert(ci->top <= L->stack_last);
    L->savedpc = p->code;  /* starting point */
    ci->tailcalls = 0;
    ci->nresults = nresults;
    for (st = L->top; st < ci->top; st++)
      setnilvalue(st);
    L->top = ci->top;
    if (L->hookmask & LUA_MASKCALL) {
      L->savedpc++;  /* hooks assume 'pc' is already incremented */
      luaD_callhook(L, LUA_HOOKCALL, -1);
      L->savedpc--;  /* correct 'pc' */
    }
    return PCRLUA;
  }
  else {  /* if is a C function, call it */
    CallInfo *ci;
    int n;
    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
    ci = inc_ci(L);  /* now `enter' new function */
    ci->func = restorestack(L, funcr);
    L->base = ci->base = ci->func + 1;
    ci->top = L->top + LUA_MINSTACK;
    lua_assert(ci->top <= L->stack_last);
    ci->nresults = nresults;
    if (L->hookmask & LUA_MASKCALL)
      luaD_callhook(L, LUA_HOOKCALL, -1);
    lua_unlock(L);
    n = (*curr_func(L)->c.f)(L);  /* do the actual call */
    lua_lock(L);
    if (n < 0)  /* yielding? */
      return PCRYIELD;
    else {
      luaD_poscall(L, L->top - n);
      return PCRC;
    }
  }
}


static inline StkId callrethooks (lua_State *L, StkId firstResult) {
  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
  luaD_callhook(L, LUA_HOOKRET, -1);
  if (f_isLua(L->ci)) {  /* Lua function? */
    while ((L->hookmask & LUA_MASKRET) && L->ci->tailcalls--) /* tail calls */
      luaD_callhook(L, LUA_HOOKTAILRET, -1);
  }
  return restorestack(L, fr);
}


static inline int luaD_poscall (lua_State *L, StkId firstResult) {
  StkId res;
  int wanted, i;
  CallInfo *ci;
  if (L->hookmask & LUA_MASKRET)
    firstResult = callrethooks(L, firstResult);
  ci = L->ci--;
  res = ci->func;  /* res == final position of 1st result */
  wanted = ci->nresults;
  L->base = (ci - 1)->base;  /* restore base */
  L->savedpc = (ci - 1)->savedpc;  /* restore savedpc */
  /* move results to correct place */
  for (i = wanted; i != 0 && firstResult < L->top; i--)
    setobjs2s(L, res++, firstResult++);
  while (i-- > 0)
    setnilvalue(res++);
  L->top = res;
  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
}


/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/
static inline void luaD_call (lua_State *L, StkId func, int nResults) {
  if (++L->nCcalls >= LUAI_MAXCCALLS) {
    if (L->nCcalls == LUAI_MAXCCALLS)
      luaG_runerror(L, "C stack overflow");
    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
  }
  if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */
    luaV_execute(L, 1);  /* call it */
  L->nCcalls--;
  luaC_checkGC(L);
}


static inline void resume (lua_State *L, void *ud) {
  StkId firstArg = cast(StkId, ud);
  CallInfo *ci = L->ci;
  if (L->status == 0) {  /* start coroutine? */
    lua_assert(ci == L->base_ci && firstArg > L->base);
    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)
      return;
  }
  else {  /* resuming from previous yield */
    lua_assert(L->status == LUA_YIELD);
    L->status = 0;
    if (!f_isLua(ci)) {  /* `common' yield? */
      /* finish interrupted execution of `OP_CALL' */
      lua_assert(GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_CALL ||
                 GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_TAILCALL);
      if (luaD_poscall(L, firstArg))  /* complete it... */
        L->top = L->ci->top;  /* and correct top if not multiple results */
    }
    else  /* yielded inside a hook: just continue its execution */
      L->base = L->ci->base;
  }
  luaV_execute(L, cast_int(L->ci - L->base_ci));
}


static inline int resume_error (lua_State *L, const char *msg) {
  L->top = L->ci->base;
  setsvalue2s(L, L->top, luaS_new(L, msg));
  incr_top(L);
  lua_unlock(L);
  return LUA_ERRRUN;
}


LUA_API int lua_resume (lua_State *L, int nargs) {
  int status;
  lua_lock(L);
  if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
      return resume_error(L, "cannot resume non-suspended coroutine");
  if (L->nCcalls >= LUAI_MAXCCALLS)
    return resume_error(L, "C stack overflow");
  luai_userstateresume(L, nargs);
  lua_assert(L->errfunc == 0);
  L->baseCcalls = ++L->nCcalls;
  status = luaD_rawrunprotected(L, resume, L->top - nargs);
  if (status != 0) {  /* error? */
    L->status = cast_byte(status);  /* mark thread as `dead' */
    luaD_seterrorobj(L, status, L->top);
    L->ci->top = L->top;
  }
  else {
    lua_assert(L->nCcalls == L->baseCcalls);
    status = L->status;
  }
  --L->nCcalls;
  lua_unlock(L);
  return status;
}


LUA_API int lua_yield (lua_State *L, int nresults) {
  luai_userstateyield(L, nresults);
  lua_lock(L);
  if (L->nCcalls > L->baseCcalls)
    luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
  L->base = L->top - nresults;  /* protect stack slots below */
  L->status = LUA_YIELD;
  lua_unlock(L);
  return -1;
}


static inline int luaD_pcall (lua_State *L, Pfunc func, void *u,
                ptrdiff_t old_top, ptrdiff_t ef) {
  int status;
  unsigned short oldnCcalls = L->nCcalls;
  ptrdiff_t old_ci = saveci(L, L->ci);
  lu_byte old_allowhooks = L->allowhook;
  ptrdiff_t old_errfunc = L->errfunc;
  L->errfunc = ef;
  status = luaD_rawrunprotected(L, func, u);
  if (status != 0) {  /* an error occurred? */
    StkId oldtop = restorestack(L, old_top);
    luaF_close(L, oldtop);  /* close eventual pending closures */
    luaD_seterrorobj(L, status, oldtop);
    L->nCcalls = oldnCcalls;
    L->ci = restoreci(L, old_ci);
    L->base = L->ci->base;
    L->savedpc = L->ci->savedpc;
    L->allowhook = old_allowhooks;
    restore_stack_limit(L);
  }
  L->errfunc = old_errfunc;
  return status;
}



/*
** Execute a protected parser.
*/
struct SParser {  /* data to `f_parser' */
  ZIO *z;
  Mbuffer buff;  /* buffer to be used by the scanner */
  const char *name;
};

/*-- File: src.cpp/ldo.cpp end --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- File: src.cpp/ldump.cpp start --*/
/*
** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/

/*-- #include "src.cpp/stddef.h" start --*/

#define ldump_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lundump.h" start --*/

typedef struct {
 lua_State* L;
 lua_Writer writer;
 void* data;
 int strip;
 int status;
} DumpState;

#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
#define DumpVar(x,D)	 	DumpMem(&x,1,sizeof(x),D)

static inline void DumpBlock(const void* b, size_t size, DumpState* D)
{
 if (D->status==0)
 {
  lua_unlock(D->L);
  D->status=(*D->writer)(D->L,b,size,D->data);
  lua_lock(D->L);
 }
}

static inline void DumpChar(int y, DumpState* D)
{
 char x=(char)y;
 DumpVar(x,D);
}

static inline void DumpInt(int x, DumpState* D)
{
 DumpVar(x,D);
}

static inline void DumpNumber(lua_Number x, DumpState* D)
{
 DumpVar(x,D);
}

static inline void DumpVector(const void* b, int n, size_t size, DumpState* D)
{
 DumpInt(n,D);
 DumpMem(b,n,size,D);
}

static inline void DumpString(const TString* s, DumpState* D)
{
 if (s==NULL || getstr(s)==NULL)
 {
  size_t size=0;
  DumpVar(size,D);
 }
 else
 {
  size_t size=s->tsv.len+1;		/* include trailing '\0' */
  DumpVar(size,D);
  DumpBlock(getstr(s),size,D);
 }
}

#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)

static inline void DumpFunction(const Proto* f, const TString* p, DumpState* D);

static inline void DumpConstants(const Proto* f, DumpState* D)
{
 int i,n=f->sizek;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  const TValue* o=&f->k[i];
  DumpChar(ttype(o),D);
  switch (ttype(o))
  {
   case LUA_TNIL:
	break;
   case LUA_TBOOLEAN:
	DumpChar(bvalue(o),D);
	break;
   case LUA_TNUMBER:
	DumpNumber(nvalue(o),D);
	break;
   case LUA_TSTRING:
	DumpString(rawtsvalue(o),D);
	break;
   default:
	lua_assert(0);			/* cannot happen */
	break;
  }
 }
 n=f->sizep;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
}

static inline void DumpDebug(const Proto* f, DumpState* D)
{
 int i,n;
 n= (D->strip) ? 0 : f->sizelineinfo;
 DumpVector(f->lineinfo,n,sizeof(int),D);
 n= (D->strip) ? 0 : f->sizelocvars;
 DumpInt(n,D);
 for (i=0; i<n; i++)
 {
  DumpString(f->locvars[i].varname,D);
  DumpInt(f->locvars[i].startpc,D);
  DumpInt(f->locvars[i].endpc,D);
 }
 n= (D->strip) ? 0 : f->sizeupvalues;
 DumpInt(n,D);
 for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
}

static inline void DumpFunction(const Proto* f, const TString* p, DumpState* D)
{
 DumpString((f->source==p || D->strip) ? NULL : f->source,D);
 DumpInt(f->linedefined,D);
 DumpInt(f->lastlinedefined,D);
 DumpChar(f->nups,D);
 DumpChar(f->numparams,D);
 DumpChar(f->is_vararg,D);
 DumpChar(f->maxstacksize,D);
 DumpCode(f,D);
 DumpConstants(f,D);
 DumpDebug(f,D);
}

static inline void DumpHeader(DumpState* D)
{
 char h[LUAC_HEADERSIZE];
 luaU_header(h);
 DumpBlock(h,LUAC_HEADERSIZE,D);
}

/*
** dump Lua function as precompiled chunk
*/
static inline int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
{
 DumpState D;
 D.L=L;
 D.writer=w;
 D.data=data;
 D.strip=strip;
 D.status=0;
 DumpHeader(&D);
 DumpFunction(f,NULL,&D);
 return D.status;
}

/*-- File: src.cpp/ldump.cpp end --*/
/*-- File: src.cpp/lfunc.cpp start --*/
/*
** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stddef.h" start --*/

#define lfunc_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/



Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
  luaC_link(L, obj2gco(c), LUA_TFUNCTION);
  c->c.isC = 1;
  c->c.env = e;
  c->c.nupvalues = cast_byte(nelems);
  return c;
}


Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
  luaC_link(L, obj2gco(c), LUA_TFUNCTION);
  c->l.isC = 0;
  c->l.env = e;
  c->l.nupvalues = cast_byte(nelems);
  while (nelems--) c->l.upvals[nelems] = NULL;
  return c;
}


UpVal *luaF_newupval (lua_State *L) {
  UpVal *uv = luaM_new(L, UpVal);
  luaC_link(L, obj2gco(uv), LUA_TUPVAL);
  uv->v = &uv->u.value;
  setnilvalue(uv->v);
  return uv;
}


UpVal *luaF_findupval (lua_State *L, StkId level) {
  global_State *g = G(L);
  GCObject **pp = &L->openupval;
  UpVal *p;
  UpVal *uv;
  while (*pp != NULL && (p = ngcotouv(*pp))->v >= level) {
    lua_assert(p->v != &p->u.value);
    if (p->v == level) {  /* found a corresponding upvalue? */
      if (isdead(g, obj2gco(p)))  /* is it dead? */
        changewhite(obj2gco(p));  /* ressurect it */
      return p;
    }
    pp = &p->next;
  }
  uv = luaM_new(L, UpVal);  /* not found: create a new one */
  uv->tt = LUA_TUPVAL;
  uv->marked = luaC_white(g);
  uv->v = level;  /* current value lives in the stack */
  uv->next = *pp;  /* chain it in the proper position */
  *pp = obj2gco(uv);
  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
  uv->u.l.next = g->uvhead.u.l.next;
  uv->u.l.next->u.l.prev = uv;
  g->uvhead.u.l.next = uv;
  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
  return uv;
}


static inline void unlinkupval (UpVal *uv) {
  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
  uv->u.l.prev->u.l.next = uv->u.l.next;
}


static inline void luaF_freeupval (lua_State *L, UpVal *uv) {
  if (uv->v != &uv->u.value)  /* is it open? */
    unlinkupval(uv);  /* remove from open list */
  luaM_free(L, uv);  /* free upvalue */
}


static inline void luaF_close (lua_State *L, StkId level) {
  UpVal *uv;
  global_State *g = G(L);
  while (L->openupval != NULL && (uv = ngcotouv(L->openupval))->v >= level) {
    GCObject *o = obj2gco(uv);
    lua_assert(!isblack(o) && uv->v != &uv->u.value);
    L->openupval = uv->next;  /* remove from `open' list */
    if (isdead(g, o))
      luaF_freeupval(L, uv);  /* free upvalue */
    else {
      unlinkupval(uv);
      setobj(L, &uv->u.value, uv->v);
      uv->v = &uv->u.value;  /* now current value lives here */
      luaC_linkupval(L, uv);  /* link upvalue into `gcroot' list */
    }
  }
}


Proto *luaF_newproto (lua_State *L) {
  Proto *f = luaM_new(L, Proto);
  luaC_link(L, obj2gco(f), LUA_TPROTO);
  f->k = NULL;
  f->sizek = 0;
  f->p = NULL;
  f->sizep = 0;
  f->code = NULL;
  f->sizecode = 0;
  f->sizelineinfo = 0;
  f->sizeupvalues = 0;
  f->nups = 0;
  f->upvalues = NULL;
  f->numparams = 0;
  f->is_vararg = 0;
  f->maxstacksize = 0;
  f->lineinfo = NULL;
  f->sizelocvars = 0;
  f->locvars = NULL;
  f->linedefined = 0;
  f->lastlinedefined = 0;
  f->source = NULL;
  return f;
}


static inline void luaF_freeproto (lua_State *L, Proto *f) {
  luaM_freearray(L, f->code, f->sizecode, Instruction);
  luaM_freearray(L, f->p, f->sizep, Proto *);
  luaM_freearray(L, f->k, f->sizek, TValue);
  luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
  luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
  luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
  luaM_free(L, f);
}


static inline void luaF_freeclosure (lua_State *L, Closure *c) {
  int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
                          sizeLclosure(c->l.nupvalues);
  luaM_freemem(L, c, size);
}


/*
** Look for n-th local variable at line `line' in function `func'.
** Returns NULL if not found.
*/
const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
  int i;
  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
    if (pc < f->locvars[i].endpc) {  /* is variable active? */
      local_number--;
      if (local_number == 0)
        return getstr(f->locvars[i].varname);
    }
  }
  return NULL;  /* not found */
}


/*-- File: src.cpp/lfunc.cpp end --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- File: src.cpp/lgc.cpp start --*/
/*
** $Id: lgc.c,v 2.38.1.2 2011/03/18 18:05:38 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

/*-- #include "src.cpp/string.h" start --*/

#define lgc_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/


#define GCSTEPSIZE	1024u
#define GCSWEEPMAX	40
#define GCSWEEPCOST	10
#define GCFINALIZECOST	100


#define maskmarks	cast_byte(~(bitmask(BLACKBIT)|WHITEBITS))

#define makewhite(g,x)	\
   ((x)->gch.marked = cast_byte(((x)->gch.marked & maskmarks) | luaC_white(g)))

#define white2gray(x)	reset2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
#define black2gray(x)	resetbit((x)->gch.marked, BLACKBIT)

#define stringmark(s)	reset2bits((s)->tsv.marked, WHITE0BIT, WHITE1BIT)


#define isfinalized(u)		testbit((u)->marked, FINALIZEDBIT)
#define markfinalized(u)	l_setbit((u)->marked, FINALIZEDBIT)


#define KEYWEAK         bitmask(KEYWEAKBIT)
#define VALUEWEAK       bitmask(VALUEWEAKBIT)



#define markvalue(g,o) { checkconsistency(o); \
  if (iscollectable(o) && iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); }

#define markobject(g,t) { if (iswhite(obj2gco(t))) \
		reallymarkobject(g, obj2gco(t)); }


#define setthreshold(g)  (g->GCthreshold = (g->estimate/100) * g->gcpause)


static inline void removeentry (Node *n) {
  lua_assert(ttisnil(gval(n)));
  if (iscollectable(gkey(n)))
    setttype(gkey(n), LUA_TDEADKEY);  /* dead key; remove it */
}


static inline void reallymarkobject (global_State *g, GCObject *o) {
  lua_assert(iswhite(o) && !isdead(g, o));
  white2gray(o);
  switch (o->gch.tt) {
    case LUA_TSTRING: {
      return;
    }
    case LUA_TUSERDATA: {
      Table *mt = gco2u(o)->metatable;
      gray2black(o);  /* udata are never gray */
      if (mt) markobject(g, mt);
      markobject(g, gco2u(o)->env);
      return;
    }
    case LUA_TUPVAL: {
      UpVal *uv = gco2uv(o);
      markvalue(g, uv->v);
      if (uv->v == &uv->u.value)  /* closed? */
        gray2black(o);  /* open upvalues are never black */
      return;
    }
    case LUA_TFUNCTION: {
      gco2cl(o)->c.gclist = g->gray;
      g->gray = o;
      break;
    }
    case LUA_TTABLE: {
      gco2h(o)->gclist = g->gray;
      g->gray = o;
      break;
    }
    case LUA_TTHREAD: {
      gco2th(o)->gclist = g->gray;
      g->gray = o;
      break;
    }
    case LUA_TPROTO: {
      gco2p(o)->gclist = g->gray;
      g->gray = o;
      break;
    }
    default: lua_assert(0);
  }
}


static inline void marktmu (global_State *g) {
  GCObject *u = g->tmudata;
  if (u) {
    do {
      u = u->gch.next;
      makewhite(g, u);  /* may be marked, if left from previous GC */
      reallymarkobject(g, u);
    } while (u != g->tmudata);
  }
}


/* move `dead' udata that need finalization to list `tmudata' */
static inline size_t luaC_separateudata (lua_State *L, int all) {
  global_State *g = G(L);
  size_t deadmem = 0;
  GCObject **p = &g->mainthread->next;
  GCObject *curr;
  while ((curr = *p) != NULL) {
    if (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))
      p = &curr->gch.next;  /* don't bother with them */
    else if (fasttm(L, gco2u(curr)->metatable, TM_GC) == NULL) {
      markfinalized(gco2u(curr));  /* don't need finalization */
      p = &curr->gch.next;
    }
    else {  /* must call its gc method */
      deadmem += sizeudata(gco2u(curr));
      markfinalized(gco2u(curr));
      *p = curr->gch.next;
      /* link `curr' at the end of `tmudata' list */
      if (g->tmudata == NULL)  /* list is empty? */
        g->tmudata = curr->gch.next = curr;  /* creates a circular list */
      else {
        curr->gch.next = g->tmudata->gch.next;
        g->tmudata->gch.next = curr;
        g->tmudata = curr;
      }
    }
  }
  return deadmem;
}


static inline int traversetable (global_State *g, Table *h) {
  int i;
  int weakkey = 0;
  int weakvalue = 0;
  const TValue *mode;
  if (h->metatable)
    markobject(g, h->metatable);
  mode = gfasttm(g, h->metatable, TM_MODE);
  if (mode && ttisstring(mode)) {  /* is there a weak mode? */
    weakkey = (strchr(svalue(mode), 'k') != NULL);
    weakvalue = (strchr(svalue(mode), 'v') != NULL);
    if (weakkey || weakvalue) {  /* is really weak? */
      h->marked &= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
      h->marked |= cast_byte((weakkey << KEYWEAKBIT) |
                             (weakvalue << VALUEWEAKBIT));
      h->gclist = g->weak;  /* must be cleared after GC, ... */
      g->weak = obj2gco(h);  /* ... so put in the appropriate list */
    }
  }
  if (weakkey && weakvalue) return 1;
  if (!weakvalue) {
    i = h->sizearray;
    while (i--)
      markvalue(g, &h->array[i]);
  }
  i = sizenode(h);
  while (i--) {
    Node *n = gnode(h, i);
    lua_assert(ttype(gkey(n)) != LUA_TDEADKEY || ttisnil(gval(n)));
    if (ttisnil(gval(n)))
      removeentry(n);  /* remove empty entries */
    else {
      lua_assert(!ttisnil(gkey(n)));
      if (!weakkey) markvalue(g, gkey(n));
      if (!weakvalue) markvalue(g, gval(n));
    }
  }
  return weakkey || weakvalue;
}


/*
** All marks are conditional because a GC may happen while the
** prototype is still being created
*/
static inline void traverseproto (global_State *g, Proto *f) {
  int i;
  if (f->source) stringmark(f->source);
  for (i=0; i<f->sizek; i++)  /* mark literals */
    markvalue(g, &f->k[i]);
  for (i=0; i<f->sizeupvalues; i++) {  /* mark upvalue names */
    if (f->upvalues[i])
      stringmark(f->upvalues[i]);
  }
  for (i=0; i<f->sizep; i++) {  /* mark nested protos */
    if (f->p[i])
      markobject(g, f->p[i]);
  }
  for (i=0; i<f->sizelocvars; i++) {  /* mark local-variable names */
    if (f->locvars[i].varname)
      stringmark(f->locvars[i].varname);
  }
}



static inline void traverseclosure (global_State *g, Closure *cl) {
  markobject(g, cl->c.env);
  if (cl->c.isC) {
    int i;
    for (i=0; i<cl->c.nupvalues; i++)  /* mark its upvalues */
      markvalue(g, &cl->c.upvalue[i]);
  }
  else {
    int i;
    lua_assert(cl->l.nupvalues == cl->l.p->nups);
    markobject(g, cl->l.p);
    for (i=0; i<cl->l.nupvalues; i++)  /* mark its upvalues */
      markobject(g, cl->l.upvals[i]);
  }
}


static inline void checkstacksizes (lua_State *L, StkId max) {
  int ci_used = cast_int(L->ci - L->base_ci);  /* number of `ci' in use */
  int s_used = cast_int(max - L->stack);  /* part of stack in use */
  if (L->size_ci > LUAI_MAXCALLS)  /* handling overflow? */
    return;  /* do not touch the stacks */
  if (4*ci_used < L->size_ci && 2*BASIC_CI_SIZE < L->size_ci)
    luaD_reallocCI(L, L->size_ci/2);  /* still big enough... */
  condhardstacktests(luaD_reallocCI(L, ci_used + 1));
  if (4*s_used < L->stacksize &&
      2*(BASIC_STACK_SIZE+EXTRA_STACK) < L->stacksize)
    luaD_reallocstack(L, L->stacksize/2);  /* still big enough... */
  condhardstacktests(luaD_reallocstack(L, s_used));
}


static inline void traversestack (global_State *g, lua_State *l) {
  StkId o, lim;
  CallInfo *ci;
  markvalue(g, gt(l));
  lim = l->top;
  for (ci = l->base_ci; ci <= l->ci; ci++) {
    lua_assert(ci->top <= l->stack_last);
    if (lim < ci->top) lim = ci->top;
  }
  for (o = l->stack; o < l->top; o++)
    markvalue(g, o);
  for (; o <= lim; o++)
    setnilvalue(o);
  checkstacksizes(l, lim);
}


/*
** traverse one gray object, turning it to black.
** Returns `quantity' traversed.
*/
static inline l_mem propagatemark (global_State *g) {
  GCObject *o = g->gray;
  lua_assert(isgray(o));
  gray2black(o);
  switch (o->gch.tt) {
    case LUA_TTABLE: {
      Table *h = gco2h(o);
      g->gray = h->gclist;
      if (traversetable(g, h))  /* table is weak? */
        black2gray(o);  /* keep it gray */
      return sizeof(Table) + sizeof(TValue) * h->sizearray +
                             sizeof(Node) * sizenode(h);
    }
    case LUA_TFUNCTION: {
      Closure *cl = gco2cl(o);
      g->gray = cl->c.gclist;
      traverseclosure(g, cl);
      return (cl->c.isC) ? sizeCclosure(cl->c.nupvalues) :
                           sizeLclosure(cl->l.nupvalues);
    }
    case LUA_TTHREAD: {
      lua_State *th = gco2th(o);
      g->gray = th->gclist;
      th->gclist = g->grayagain;
      g->grayagain = o;
      black2gray(o);
      traversestack(g, th);
      return sizeof(lua_State) + sizeof(TValue) * th->stacksize +
                                 sizeof(CallInfo) * th->size_ci;
    }
    case LUA_TPROTO: {
      Proto *p = gco2p(o);
      g->gray = p->gclist;
      traverseproto(g, p);
      return sizeof(Proto) + sizeof(Instruction) * p->sizecode +
                             sizeof(Proto *) * p->sizep +
                             sizeof(TValue) * p->sizek + 
                             sizeof(int) * p->sizelineinfo +
                             sizeof(LocVar) * p->sizelocvars +
                             sizeof(TString *) * p->sizeupvalues;
    }
    default: lua_assert(0); return 0;
  }
}


static inline size_t propagateall (global_State *g) {
  size_t m = 0;
  while (g->gray) m += propagatemark(g);
  return m;
}


/*
** The next function tells whether a key or value can be cleared from
** a weak table. Non-collectable objects are never removed from weak
** tables. Strings behave as `values', so are never removed too. for
** other objects: if really collected, cannot keep them; for userdata
** being finalized, keep them in keys, but not in values
*/
static inline int iscleared (const TValue *o, int iskey) {
  if (!iscollectable(o)) return 0;
  if (ttisstring(o)) {
    stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */
    return 0;
  }
  return iswhite(gcvalue(o)) ||
    (ttisuserdata(o) && (!iskey && isfinalized(uvalue(o))));
}


/*
** clear collected entries from weaktables
*/
static inline void cleartable (GCObject *l) {
  while (l) {
    Table *h = gco2h(l);
    int i = h->sizearray;
    lua_assert(testbit(h->marked, VALUEWEAKBIT) ||
               testbit(h->marked, KEYWEAKBIT));
    if (testbit(h->marked, VALUEWEAKBIT)) {
      while (i--) {
        TValue *o = &h->array[i];
        if (iscleared(o, 0))  /* value was collected? */
          setnilvalue(o);  /* remove value */
      }
    }
    i = sizenode(h);
    while (i--) {
      Node *n = gnode(h, i);
      if (!ttisnil(gval(n)) &&  /* non-empty entry? */
          (iscleared(key2tval(n), 1) || iscleared(gval(n), 0))) {
        setnilvalue(gval(n));  /* remove value ... */
        removeentry(n);  /* remove entry from table */
      }
    }
    l = h->gclist;
  }
}


static inline void freeobj (lua_State *L, GCObject *o) {
  switch (o->gch.tt) {
    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
    case LUA_TFUNCTION: luaF_freeclosure(L, gco2cl(o)); break;
    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
    case LUA_TTABLE: luaH_free(L, gco2h(o)); break;
    case LUA_TTHREAD: {
      lua_assert(gco2th(o) != L && gco2th(o) != G(L)->mainthread);
      luaE_freethread(L, gco2th(o));
      break;
    }
    case LUA_TSTRING: {
      G(L)->strt.nuse--;
      luaM_freemem(L, o, sizestring(gco2ts(o)));
      break;
    }
    case LUA_TUSERDATA: {
      luaM_freemem(L, o, sizeudata(gco2u(o)));
      break;
    }
    default: lua_assert(0);
  }
}



#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)


static inline GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
  GCObject *curr;
  global_State *g = G(L);
  int deadmask = otherwhite(g);
  while ((curr = *p) != NULL && count-- > 0) {
    if (curr->gch.tt == LUA_TTHREAD)  /* sweep open upvalues of each thread */
      sweepwholelist(L, &gco2th(curr)->openupval);
    if ((curr->gch.marked ^ WHITEBITS) & deadmask) {  /* not dead? */
      lua_assert(!isdead(g, curr) || testbit(curr->gch.marked, FIXEDBIT));
      makewhite(g, curr);  /* make it white (for next cycle) */
      p = &curr->gch.next;
    }
    else {  /* must erase `curr' */
      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));
      *p = curr->gch.next;
      if (curr == g->rootgc)  /* is the first element of the list? */
        g->rootgc = curr->gch.next;  /* adjust first */
      freeobj(L, curr);
    }
  }
  return p;
}


static inline void checkSizes (lua_State *L) {
  global_State *g = G(L);
  /* check size of string hash */
  if (g->strt.nuse < cast(lu_int32, g->strt.size/4) &&
      g->strt.size > MINSTRTABSIZE*2)
    luaS_resize(L, g->strt.size/2);  /* table is too big */
  /* check size of buffer */
  if (luaZ_sizebuffer(&g->buff) > LUA_MINBUFFER*2) {  /* buffer too big? */
    size_t newsize = luaZ_sizebuffer(&g->buff) / 2;
    luaZ_resizebuffer(L, &g->buff, newsize);
  }
}


static inline void GCTM (lua_State *L) {
  global_State *g = G(L);
  GCObject *o = g->tmudata->gch.next;  /* get first element */
  Udata *udata = rawgco2u(o);
  const TValue *tm;
  /* remove udata from `tmudata' */
  if (o == g->tmudata)  /* last element? */
    g->tmudata = NULL;
  else
    g->tmudata->gch.next = udata->uv.next;
  udata->uv.next = g->mainthread->next;  /* return it to `root' list */
  g->mainthread->next = o;
  makewhite(g, o);
  tm = fasttm(L, udata->uv.metatable, TM_GC);
  if (tm != NULL) {
    lu_byte oldah = L->allowhook;
    lu_mem oldt = g->GCthreshold;
    L->allowhook = 0;  /* stop debug hooks during GC tag method */
    g->GCthreshold = 2*g->totalbytes;  /* avoid GC steps */
    setobj2s(L, L->top, tm);
    setuvalue(L, L->top+1, udata);
    L->top += 2;
    luaD_call(L, L->top - 2, 0);
    L->allowhook = oldah;  /* restore hooks */
    g->GCthreshold = oldt;  /* restore threshold */
  }
}


/*
** Call all GC tag methods
*/
static inline void luaC_callGCTM (lua_State *L) {
  while (G(L)->tmudata)
    GCTM(L);
}


static inline void luaC_freeall (lua_State *L) {
  global_State *g = G(L);
  int i;
  g->currentwhite = WHITEBITS | bitmask(SFIXEDBIT);  /* mask to collect all elements */
  sweepwholelist(L, &g->rootgc);
  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
    sweepwholelist(L, &g->strt.hash[i]);
}


static inline void markmt (global_State *g) {
  int i;
  for (i=0; i<NUM_TAGS; i++)
    if (g->mt[i]) markobject(g, g->mt[i]);
}


/* mark root set */
static inline void markroot (lua_State *L) {
  global_State *g = G(L);
  g->gray = NULL;
  g->grayagain = NULL;
  g->weak = NULL;
  markobject(g, g->mainthread);
  /* make global table be traversed before main stack */
  markvalue(g, gt(g->mainthread));
  markvalue(g, registry(L));
  markmt(g);
  g->gcstate = GCSpropagate;
}


static inline void remarkupvals (global_State *g) {
  UpVal *uv;
  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
    lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
    if (isgray(obj2gco(uv)))
      markvalue(g, uv->v);
  }
}


static inline void atomic (lua_State *L) {
  global_State *g = G(L);
  size_t udsize;  /* total size of userdata to be finalized */
  /* remark occasional upvalues of (maybe) dead threads */
  remarkupvals(g);
  /* traverse objects cautch by write barrier and by 'remarkupvals' */
  propagateall(g);
  /* remark weak tables */
  g->gray = g->weak;
  g->weak = NULL;
  lua_assert(!iswhite(obj2gco(g->mainthread)));
  markobject(g, L);  /* mark running thread */
  markmt(g);  /* mark basic metatables (again) */
  propagateall(g);
  /* remark gray again */
  g->gray = g->grayagain;
  g->grayagain = NULL;
  propagateall(g);
  udsize = luaC_separateudata(L, 0);  /* separate userdata to be finalized */
  marktmu(g);  /* mark `preserved' userdata */
  udsize += propagateall(g);  /* remark, to propagate `preserveness' */
  cleartable(g->weak);  /* remove collected objects from weak tables */
  /* flip current white */
  g->currentwhite = cast_byte(otherwhite(g));
  g->sweepstrgc = 0;
  g->sweepgc = &g->rootgc;
  g->gcstate = GCSsweepstring;
  g->estimate = g->totalbytes - udsize;  /* first estimate */
}


static inline l_mem singlestep (lua_State *L) {
  global_State *g = G(L);
  /*lua_checkmemory(L);*/
  switch (g->gcstate) {
    case GCSpause: {
      markroot(L);  /* start a new collection */
      return 0;
    }
    case GCSpropagate: {
      if (g->gray)
        return propagatemark(g);
      else {  /* no more `gray' objects */
        atomic(L);  /* finish mark phase */
        return 0;
      }
    }
    case GCSsweepstring: {
      lu_mem old = g->totalbytes;
      sweepwholelist(L, &g->strt.hash[g->sweepstrgc++]);
      if (g->sweepstrgc >= g->strt.size)  /* nothing more to sweep? */
        g->gcstate = GCSsweep;  /* end sweep-string phase */
      lua_assert(old >= g->totalbytes);
      g->estimate -= old - g->totalbytes;
      return GCSWEEPCOST;
    }
    case GCSsweep: {
      lu_mem old = g->totalbytes;
      g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
      if (*g->sweepgc == NULL) {  /* nothing more to sweep? */
        checkSizes(L);
        g->gcstate = GCSfinalize;  /* end sweep phase */
      }
      lua_assert(old >= g->totalbytes);
      g->estimate -= old - g->totalbytes;
      return GCSWEEPMAX*GCSWEEPCOST;
    }
    case GCSfinalize: {
      if (g->tmudata) {
        GCTM(L);
        if (g->estimate > GCFINALIZECOST)
          g->estimate -= GCFINALIZECOST;
        return GCFINALIZECOST;
      }
      else {
        g->gcstate = GCSpause;  /* end collection */
        g->gcdept = 0;
        return 0;
      }
    }
    default: lua_assert(0); return 0;
  }
}


static inline void luaC_step (lua_State *L) {
  global_State *g = G(L);
  l_mem lim = (GCSTEPSIZE/100) * g->gcstepmul;
  if (lim == 0)
    lim = (MAX_LUMEM-1)/2;  /* no limit */
  g->gcdept += g->totalbytes - g->GCthreshold;
  do {
    lim -= singlestep(L);
    if (g->gcstate == GCSpause)
      break;
  } while (lim > 0);
  if (g->gcstate != GCSpause) {
    if (g->gcdept < GCSTEPSIZE)
      g->GCthreshold = g->totalbytes + GCSTEPSIZE;  /* - lim/g->gcstepmul;*/
    else {
      g->gcdept -= GCSTEPSIZE;
      g->GCthreshold = g->totalbytes;
    }
  }
  else {
    setthreshold(g);
  }
}


static inline void luaC_fullgc (lua_State *L) {
  global_State *g = G(L);
  if (g->gcstate <= GCSpropagate) {
    /* reset sweep marks to sweep all elements (returning them to white) */
    g->sweepstrgc = 0;
    g->sweepgc = &g->rootgc;
    /* reset other collector lists */
    g->gray = NULL;
    g->grayagain = NULL;
    g->weak = NULL;
    g->gcstate = GCSsweepstring;
  }
  lua_assert(g->gcstate != GCSpause && g->gcstate != GCSpropagate);
  /* finish any pending sweep phase */
  while (g->gcstate != GCSfinalize) {
    lua_assert(g->gcstate == GCSsweepstring || g->gcstate == GCSsweep);
    singlestep(L);
  }
  markroot(L);
  while (g->gcstate != GCSpause) {
    singlestep(L);
  }
  setthreshold(g);
}


static inline void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
  lua_assert(ttype(&o->gch) != LUA_TTABLE);
  /* must keep invariant? */
  if (g->gcstate == GCSpropagate)
    reallymarkobject(g, v);  /* restore invariant */
  else  /* don't mind */
    makewhite(g, o);  /* mark as white just to avoid other barriers */
}


static inline void luaC_barrierback (lua_State *L, Table *t) {
  global_State *g = G(L);
  GCObject *o = obj2gco(t);
  lua_assert(isblack(o) && !isdead(g, o));
  lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
  black2gray(o);  /* make table gray (again) */
  t->gclist = g->grayagain;
  g->grayagain = o;
}


static inline void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
  global_State *g = G(L);
  o->gch.next = g->rootgc;
  g->rootgc = o;
  o->gch.marked = luaC_white(g);
  o->gch.tt = tt;
}


static inline void luaC_linkupval (lua_State *L, UpVal *uv) {
  global_State *g = G(L);
  GCObject *o = obj2gco(uv);
  o->gch.next = g->rootgc;  /* link upvalue into `rootgc' list */
  g->rootgc = o;
  if (isgray(o)) { 
    if (g->gcstate == GCSpropagate) {
      gray2black(o);  /* closed upvalues need barrier */
      luaC_barrier(L, uv, uv->v);
    }
    else {  /* sweep phase: sweep it (turning it into white) */
      makewhite(g, o);
      lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
    }
  }
}


/*-- File: src.cpp/lgc.cpp end --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/limits.h" start --*/
/*-- File: src.cpp/linit.cpp start --*/
/*
** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
** Initialization of libraries for lua.c
** See Copyright Notice in lua.h
*/


#define linit_c
#define LUA_LIB

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lualib.h" start --*/
/*-- #include "src.cpp/lauxlib.h" start --*/


static const luaL_Reg lualibs[] = {
  {"", luaopen_base},
  {LUA_TABLIBNAME, luaopen_table},
  {LUA_STRLIBNAME, luaopen_string},
  {NULL, NULL}
};


LUALIB_API void luaL_openlibs (lua_State *L) {
  const luaL_Reg *lib = lualibs;
  for (; lib->func; lib++) {
    lua_pushcfunction(L, lib->func);
    lua_pushstring(L, lib->name);
    lua_call(L, 1, 0);
  }
}


/*-- File: src.cpp/linit.cpp end --*/
/*-- File: src.cpp/llex.cpp start --*/

/*-- File: src.cpp/llex.cpp end --*/
/*-- #include "src.cpp/llex.h" start --*/

/*-- #include "src.cpp/llimits.h" start --*/
/*-- File: src.cpp/lmem.cpp start --*/
/*
** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stddef.h" start --*/

#define lmem_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/



/*
** About the realloc function:
** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
** (`osize' is the old size, `nsize' is the new size)
**
** Lua ensures that (ptr == NULL) iff (osize == 0).
**
** * frealloc(ud, NULL, 0, x) creates a new block of size `x'
**
** * frealloc(ud, p, x, 0) frees the block `p'
** (in this specific case, frealloc must return NULL).
** particularly, frealloc(ud, NULL, 0, 0) does nothing
** (which is equivalent to free(NULL) in ANSI C)
**
** frealloc returns NULL if it cannot create or reallocate the area
** (any reallocation to an equal or smaller size cannot fail!)
*/



#define MINSIZEARRAY	4


static inline void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
                     int limit, const char *errormsg) {
  void *newblock;
  int newsize;
  if (*size >= limit/2) {  /* cannot double it? */
    if (*size >= limit)  /* cannot grow even a little? */
      luaG_runerror(L, errormsg);
    newsize = limit;  /* still have at least one free place */
  }
  else {
    newsize = (*size)*2;
    if (newsize < MINSIZEARRAY)
      newsize = MINSIZEARRAY;  /* minimum size */
  }
  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
  *size = newsize;  /* update only when everything else is OK */
  return newblock;
}


static inline void *luaM_toobig (lua_State *L) {
  luaG_runerror(L, "memory allocation error: block too big");
  return NULL;  /* to avoid warnings */
}



/*
** generic allocation routine.
*/
static inline void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
  global_State *g = G(L);
  lua_assert((osize == 0) == (block == NULL));
  block = (*g->frealloc)(g->ud, block, osize, nsize);
  if (block == NULL && nsize > 0)
    luaD_throw(L, LUA_ERRMEM);
  lua_assert((nsize == 0) == (block == NULL));
  g->totalbytes = (g->totalbytes - osize) + nsize;
  return block;
}


/*-- File: src.cpp/lmem.cpp end --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- File: src.cpp/lobject.cpp start --*/
/*
** $Id: lobject.c,v 2.22.1.1 2007/12/27 13:02:25 roberto Exp $
** Some generic functions over Lua objects
** See Copyright Notice in lua.h
*/

/*-- #include "src.cpp/ctype.h" start --*/
/*-- #include "src.cpp/stdarg.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define lobject_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/lvm.h" start --*/



static const TValue luaO_nilobject_ = {{NULL}, LUA_TNIL};


/*
** converts an integer to a "floating point byte", represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee != 0 and (xxx) otherwise.
*/
static inline int luaO_int2fb (unsigned int x) {
  int e = 0;  /* expoent */
  while (x >= 16) {
    x = (x+1) >> 1;
    e++;
  }
  if (x < 8) return x;
  else return ((e+1) << 3) | (cast_int(x) - 8);
}


/* converts back */
static inline int luaO_fb2int (int x) {
  int e = (x >> 3) & 31;
  if (e == 0) return x;
  else return ((x & 7)+8) << (e - 1);
}


static inline int luaO_log2 (unsigned int x) {
  static const lu_byte log_2[256] = {
    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
  };
  int l = -1;
  while (x >= 256) { l += 8; x >>= 8; }
  return l + log_2[x];

}


static inline int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
  if (ttype(t1) != ttype(t2)) return 0;
  else switch (ttype(t1)) {
    case LUA_TNIL:
      return 1;
    case LUA_TNUMBER:
      return luai_numeq(nvalue(t1), nvalue(t2));
    case LUA_TBOOLEAN:
      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
    case LUA_TLIGHTUSERDATA:
      return pvalue(t1) == pvalue(t2);
    default:
      lua_assert(iscollectable(t1));
      return gcvalue(t1) == gcvalue(t2);
  }
}


static inline int luaO_str2d (const char *s, lua_Number *result) {
  char *endptr;
  *result = lua_str2number(s, &endptr);
  if (endptr == s) return 0;  /* conversion failed */
  if (*endptr == 'x' || *endptr == 'X')  /* maybe an hexadecimal constant? */
    *result = cast_num(strtoul(s, &endptr, 16));
  if (*endptr == '\0') return 1;  /* most common case */
  while (isspace(cast(unsigned char, *endptr))) endptr++;
  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
  return 1;
}



static inline void pushstr (lua_State *L, const char *str) {
  setsvalue2s(L, L->top, luaS_new(L, str));
  incr_top(L);
}


/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
  int n = 1;
  pushstr(L, "");
  for (;;) {
    const char *e = strchr(fmt, '%');
    if (e == NULL) break;
    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));
    incr_top(L);
    switch (*(e+1)) {
      case 's': {
        const char *s = va_arg(argp, char *);
        if (s == NULL) s = "(null)";
        pushstr(L, s);
        break;
      }
      case 'c': {
        char buff[2];
        buff[0] = cast(char, va_arg(argp, int));
        buff[1] = '\0';
        pushstr(L, buff);
        break;
      }
      case 'd': {
        setnvalue(L->top, cast_num(va_arg(argp, int)));
        incr_top(L);
        break;
      }
      case 'f': {
        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));
        incr_top(L);
        break;
      }
      case 'p': {
        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
        sprintf(buff, "%p", va_arg(argp, void *));
        pushstr(L, buff);
        break;
      }
      case '%': {
        pushstr(L, "%");
        break;
      }
      default: {
        char buff[3];
        buff[0] = '%';
        buff[1] = *(e+1);
        buff[2] = '\0';
        pushstr(L, buff);
        break;
      }
    }
    n += 2;
    fmt = e+2;
  }
  pushstr(L, fmt);
  luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);
  L->top -= n;
  return svalue(L->top - 1);
}


const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  return msg;
}


static inline void luaO_chunkid (char *out, const char *source, size_t bufflen) {
  if (*source == '=') {
    strncpy(out, source+1, bufflen);  /* remove first char */
    out[bufflen-1] = '\0';  /* ensures null termination */
  }
  else {  /* out = "source", or "...source" */
    if (*source == '@') {
      size_t l;
      source++;  /* skip the `@' */
      bufflen -= sizeof(" '...' ");
      l = strlen(source);
      strcpy(out, "");
      if (l > bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, "...");
      }
      strcat(out, source);
    }
    else {  /* out = [string "string"] */
      size_t len = strcspn(source, "\n\r");  /* stop at first newline */
      bufflen -= sizeof(" [string \"...\"] ");
      if (len > bufflen) len = bufflen;
      strcpy(out, "[string \"");
      if (source[len] != '\0') {  /* must truncate? */
        strncat(out, source, len);
        strcat(out, "...");
      }
      else
        strcat(out, source);
      strcat(out, "\"]");
    }
  }
}

/*-- File: src.cpp/lobject.cpp end --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/locale.h" start --*/

/*-- File: src.cpp/lopcodes.cpp start --*/
/*
** $Id: lopcodes.c,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
** See Copyright Notice in lua.h
*/


#define lopcodes_c
#define LUA_CORE


/*-- #include "src.cpp/lopcodes.h" start --*/


/* ORDER OP */

static const char *const luaP_opnames[NUM_OPCODES+1] = {
  "MOVE",
  "LOADK",
  "LOADBOOL",
  "LOADNIL",
  "GETUPVAL",
  "GETGLOBAL",
  "GETTABLE",
  "SETGLOBAL",
  "SETUPVAL",
  "SETTABLE",
  "NEWTABLE",
  "SELF",
  "ADD",
  "SUB",
  "MUL",
  "DIV",
  "MOD",
  "POW",
  "UNM",
  "NOT",
  "LEN",
  "CONCAT",
  "JMP",
  "EQ",
  "LT",
  "LE",
  "TEST",
  "TESTSET",
  "CALL",
  "TAILCALL",
  "RETURN",
  "FORLOOP",
  "FORPREP",
  "TFORLOOP",
  "SETLIST",
  "CLOSE",
  "CLOSURE",
  "VARARG",
  NULL
};


#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))

static const lu_byte luaP_opmodes[NUM_OPCODES] = {
/*       T  A    B       C     mode		   opcode	*/
  opmode(0, 1, OpArgR, OpArgN, iABC) 		/* OP_MOVE */
 ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LOADNIL */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
 ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_GETGLOBAL */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
 ,opmode(0, 0, OpArgK, OpArgN, iABx)		/* OP_SETGLOBAL */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
 ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
 ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
 ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
 ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TEST */
 ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
 ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TFORLOOP */
 ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
 ,opmode(0, 0, OpArgN, OpArgN, iABC)		/* OP_CLOSE */
 ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
};


/*-- File: src.cpp/lopcodes.cpp end --*/
/*-- #include "src.cpp/lopcodes.h" start --*/
/*-- File: src.cpp/lparser.cpp start --*/

/*-- File: src.cpp/lparser.cpp end --*/
/*-- #include "src.cpp/lparser.h" start --*/
/*-- File: src.cpp/lstate.cpp start --*/
/*
** $Id: lstate.c,v 2.36.1.2 2008/01/03 15:20:39 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stddef.h" start --*/

#define lstate_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/llex.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/


#define state_size(x)	(sizeof(x) + LUAI_EXTRASPACE)
#define fromstate(l)	(cast(lu_byte *, (l)) - LUAI_EXTRASPACE)
#define tostate(l)   (cast(lua_State *, cast(lu_byte *, l) + LUAI_EXTRASPACE))


/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  lua_State l;
  global_State g;
} LG;



static inline void stack_init (lua_State *L1, lua_State *L) {
  /* initialize CallInfo array */
  L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
  L1->ci = L1->base_ci;
  L1->size_ci = BASIC_CI_SIZE;
  L1->end_ci = L1->base_ci + L1->size_ci - 1;
  /* initialize stack array */
  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);
  L1->stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
  L1->top = L1->stack;
  L1->stack_last = L1->stack+(L1->stacksize - EXTRA_STACK)-1;
  /* initialize first ci */
  L1->ci->func = L1->top;
  setnilvalue(L1->top++);  /* `function' entry for this `ci' */
  L1->base = L1->ci->base = L1->top;
  L1->ci->top = L1->top + LUA_MINSTACK;
}


static inline void freestack (lua_State *L, lua_State *L1) {
  luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
  luaM_freearray(L, L1->stack, L1->stacksize, TValue);
}


/*
** open parts that may cause memory-allocation errors
*/
static inline void f_luaopen (lua_State *L, void *ud) {
  global_State *g = G(L);
  UNUSED(ud);
  stack_init(L, L);  /* init stack */
  sethvalue(L, gt(L), luaH_new(L, 0, 2));  /* table of globals */
  sethvalue(L, registry(L), luaH_new(L, 0, 2));  /* registry */
  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
  luaT_init(L);
  luaS_fix(luaS_newliteral(L, MEMERRMSG));
  g->GCthreshold = 4*g->totalbytes;
}


static inline void preinit_state (lua_State *L, global_State *g) {
  G(L) = g;
  L->stack = NULL;
  L->stacksize = 0;
  L->errorJmp = NULL;
  L->hook = NULL;
  L->hookmask = 0;
  L->basehookcount = 0;
  L->allowhook = 1;
  resethookcount(L);
  L->openupval = NULL;
  L->size_ci = 0;
  L->nCcalls = L->baseCcalls = 0;
  L->status = 0;
  L->base_ci = L->ci = NULL;
  L->savedpc = NULL;
  L->errfunc = 0;
  setnilvalue(gt(L));
}


static inline void close_state (lua_State *L) {
  global_State *g = G(L);
  luaF_close(L, L->stack);  /* close all upvalues for this thread */
  luaC_freeall(L);  /* collect all objects */
  lua_assert(g->rootgc == obj2gco(L));
  lua_assert(g->strt.nuse == 0);
  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size, TString *);
  luaZ_freebuffer(L, &g->buff);
  freestack(L, L);
  lua_assert(g->totalbytes == sizeof(LG));
  (*g->frealloc)(g->ud, fromstate(L), state_size(LG), 0);
}


static inline lua_State *luaE_newthread (lua_State *L) {
  lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));
  luaC_link(L, obj2gco(L1), LUA_TTHREAD);
  preinit_state(L1, G(L));
  stack_init(L1, L);  /* init stack */
  setobj2n(L, gt(L1), gt(L));  /* share table of globals */
  L1->hookmask = L->hookmask;
  L1->basehookcount = L->basehookcount;
  L1->hook = L->hook;
  resethookcount(L1);
  lua_assert(iswhite(obj2gco(L1)));
  return L1;
}


static inline void luaE_freethread (lua_State *L, lua_State *L1) {
  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
  lua_assert(L1->openupval == NULL);
  luai_userstatefree(L1);
  freestack(L, L1);
  luaM_freemem(L, fromstate(L1), state_size(lua_State));
}


LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  void *l = (*f)(ud, NULL, 0, state_size(LG));
  if (l == NULL) return NULL;
  L = tostate(l);
  g = &((LG *)L)->g;
  L->next = NULL;
  L->tt = LUA_TTHREAD;
  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
  L->marked = luaC_white(g);
  set2bits(L->marked, FIXEDBIT, SFIXEDBIT);
  preinit_state(L, g);
  g->frealloc = f;
  g->ud = ud;
  g->mainthread = L;
  g->uvhead.u.l.prev = &g->uvhead;
  g->uvhead.u.l.next = &g->uvhead;
  g->GCthreshold = 0;  /* mark it as unfinished state */
  g->strt.size = 0;
  g->strt.nuse = 0;
  g->strt.hash = NULL;
  setnilvalue(registry(L));
  luaZ_initbuffer(L, &g->buff);
  g->panic = NULL;
  g->gcstate = GCSpause;
  g->rootgc = obj2gco(L);
  g->sweepstrgc = 0;
  g->sweepgc = &g->rootgc;
  g->gray = NULL;
  g->grayagain = NULL;
  g->weak = NULL;
  g->tmudata = NULL;
  g->totalbytes = sizeof(LG);
  g->gcpause = LUAI_GCPAUSE;
  g->gcstepmul = LUAI_GCMUL;
  g->gcdept = 0;
  for (i=0; i<NUM_TAGS; i++) g->mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = NULL;
  }
  else
    luai_userstateopen(L);
  return L;
}


static inline void callallgcTM (lua_State *L, void *ud) {
  UNUSED(ud);
  luaC_callGCTM(L);  /* call GC metamethods for all udata */
}


LUA_API void lua_close (lua_State *L) {
  L = G(L)->mainthread;  /* only the main thread can be closed */
  lua_lock(L);
  luaF_close(L, L->stack);  /* close all upvalues for this thread */
  luaC_separateudata(L, 1);  /* separate udata that have GC metamethods */
  L->errfunc = 0;  /* no error function during GC metamethods */
  do {  /* repeat until no more errors */
    L->ci = L->base_ci;
    L->base = L->top = L->ci->base;
    L->nCcalls = L->baseCcalls = 0;
  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
  lua_assert(G(L)->tmudata == NULL);
  luai_userstateclose(L);
  close_state(L);
}

/*-- File: src.cpp/lstate.cpp end --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- File: src.cpp/lstring.cpp start --*/
/*
** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** String table (keeps all strings handled by Lua)
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/string.h" start --*/

#define lstring_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/



static inline void luaS_resize (lua_State *L, int newsize) {
  GCObject **newhash;
  stringtable *tb;
  int i;
  if (G(L)->gcstate == GCSsweepstring)
    return;  /* cannot resize during GC traverse */
  newhash = luaM_newvector(L, newsize, GCObject *);
  tb = &G(L)->strt;
  for (i=0; i<newsize; i++) newhash[i] = NULL;
  /* rehash */
  for (i=0; i<tb->size; i++) {
    GCObject *p = tb->hash[i];
    while (p) {  /* for each node in the list */
      GCObject *next = p->gch.next;  /* save next */
      unsigned int h = gco2ts(p)->hash;
      int h1 = lmod(h, newsize);  /* new position */
      lua_assert(cast_int(h%newsize) == lmod(h, newsize));
      p->gch.next = newhash[h1];  /* chain it */
      newhash[h1] = p;
      p = next;
    }
  }
  luaM_freearray(L, tb->hash, tb->size, TString *);
  tb->size = newsize;
  tb->hash = newhash;
}


static inline TString *newlstr (lua_State *L, const char *str, size_t l,
                                       unsigned int h) {
  TString *ts;
  stringtable *tb;
  if (l+1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
    luaM_toobig(L);
  ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString)));
  ts->tsv.len = l;
  ts->tsv.hash = h;
  ts->tsv.marked = luaC_white(G(L));
  ts->tsv.tt = LUA_TSTRING;
  ts->tsv.reserved = 0;
  memcpy(ts+1, str, l*sizeof(char));
  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
  tb = &G(L)->strt;
  h = lmod(h, tb->size);
  ts->tsv.next = tb->hash[h];  /* chain new entry */
  tb->hash[h] = obj2gco(ts);
  tb->nuse++;
  if (tb->nuse > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
    luaS_resize(L, tb->size*2);  /* too crowded */
  return ts;
}


TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
  GCObject *o;
  unsigned int h = cast(unsigned int, l);  /* seed */
  size_t step = (l>>5)+1;  /* if string is too long, don't hash all its chars */
  size_t l1;
  for (l1=l; l1>=step; l1-=step)  /* compute hash */
    h = h ^ ((h<<5)+(h>>2)+cast(unsigned char, str[l1-1]));
  for (o = G(L)->strt.hash[lmod(h, G(L)->strt.size)];
       o != NULL;
       o = o->gch.next) {
    TString *ts = rawgco2ts(o);
    if (ts->tsv.len == l && (memcmp(str, getstr(ts), l) == 0)) {
      /* string may be dead */
      if (isdead(G(L), o)) changewhite(o);
      return ts;
    }
  }
  return newlstr(L, str, l, h);  /* not found */
}


Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
  Udata *u;
  if (s > MAX_SIZET - sizeof(Udata))
    luaM_toobig(L);
  u = cast(Udata *, luaM_malloc(L, s + sizeof(Udata)));
  u->uv.marked = luaC_white(G(L));  /* is not finalized */
  u->uv.tt = LUA_TUSERDATA;
  u->uv.len = s;
  u->uv.metatable = NULL;
  u->uv.env = e;
  /* chain it on udata list (after main thread) */
  u->uv.next = G(L)->mainthread->next;
  G(L)->mainthread->next = obj2gco(u);
  return u;
}


/*-- File: src.cpp/lstring.cpp end --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- File: src.cpp/lstrlib.cpp start --*/
/*
** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/ctype.h" start --*/
/*-- #include "src.cpp/stddef.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define lstrlib_c
#define LUA_LIB

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lauxlib.h" start --*/
/*-- #include "src.cpp/lualib.h" start --*/


/* macro to `unsign' a character */
#define uchar(c)        ((unsigned char)(c))



static inline int str_len (lua_State *L) {
  size_t l;
  luaL_checklstring(L, 1, &l);
  lua_pushinteger(L, l);
  return 1;
}


static inline ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
  /* relative string position: negative means back from end */
  if (pos < 0) pos += (ptrdiff_t)len + 1;
  return (pos >= 0) ? pos : 0;
}


static inline int str_sub (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
  ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
  if (start < 1) start = 1;
  if (end > (ptrdiff_t)l) end = (ptrdiff_t)l;
  if (start <= end)
    lua_pushlstring(L, s+start-1, end-start+1);
  else lua_pushliteral(L, "");
  return 1;
}


static inline int str_byte (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
  ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
  int n, i;
  if (posi <= 0) posi = 1;
  if ((size_t)pose > l) pose = l;
  if (posi > pose) return 0;  /* empty interval; return no values */
  n = (int)(pose -  posi + 1);
  if (posi + n <= pose)  /* overflow? */
    luaL_error(L, "string slice too long");
  luaL_checkstack(L, n, "string slice too long");
  for (i=0; i<n; i++)
    lua_pushinteger(L, uchar(s[posi+i-1]));
  return n;
}



static const luaL_Reg strlib[] = {
  {"byte", str_byte},
  {"len", str_len},
  {"sub", str_sub},
  {NULL, NULL}
};


static inline void createmetatable (lua_State *L) {
  lua_createtable(L, 0, 1);  /* create metatable for strings */
  lua_pushliteral(L, "");  /* dummy string */
  lua_pushvalue(L, -2);
  lua_setmetatable(L, -2);  /* set string metatable */
  lua_pop(L, 1);  /* pop dummy string */
  lua_pushvalue(L, -2);  /* string library... */
  lua_setfield(L, -2, "__index");  /* ...is the __index metamethod */
  lua_pop(L, 1);  /* pop metatable */
}


/*
** Open string library
*/
LUALIB_API int luaopen_string (lua_State *L) {
  luaL_register(L, LUA_STRLIBNAME, strlib);
  createmetatable(L);
  return 1;
}

/*-- File: src.cpp/lstrlib.cpp end --*/
/*-- File: src.cpp/ltable.cpp start --*/
/*
** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/


/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest `n' such that at
** least half the slots between 0 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, if an element is not
** in its main position (i.e. the `original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/

/*-- #include "src.cpp/math.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define ltable_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/


/*
** max size of array part is 2^MAXBITS
*/
#if LUAI_BITSINT > 26
#define MAXBITS		26
#else
#define MAXBITS		(LUAI_BITSINT-2)
#endif

#define MAXASIZE	(1 << MAXBITS)


#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
  
#define hashstr(t,str)  hashpow2(t, (str)->tsv.hash)
#define hashboolean(t,p)        hashpow2(t, p)


/*
** for some types, it is better to avoid modulus by power of 2, as
** they tend to have many 2 factors.
*/
#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))


#define hashpointer(t,p)	hashmod(t, IntPoint(p))


/*
** number of ints inside a lua_Number
*/
#define numints		cast_int(sizeof(lua_Number)/sizeof(int))



#define dummynode		(&dummynode_)

static const Node dummynode_ = {
  {{NULL}, LUA_TNIL},  /* value */
  {{{NULL}, LUA_TNIL, NULL}}  /* key */
};


/*
** hash for lua_Numbers
*/
static inline Node *hashnum (const Table *t, lua_Number n) {
  unsigned int a[numints];
  int i;
  if (luai_numeq(n, 0))  /* avoid problems with -0 */
    return gnode(t, 0);
  memcpy(a, &n, sizeof(a));
  for (i = 1; i < numints; i++) a[0] += a[i];
  return hashmod(t, a[0]);
}



/*
** returns the `main' position of an element in a table (that is, the index
** of its hash value)
*/
static inline Node *mainposition (const Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TNUMBER:
      return hashnum(t, nvalue(key));
    case LUA_TSTRING:
      return hashstr(t, rawtsvalue(key));
    case LUA_TBOOLEAN:
      return hashboolean(t, bvalue(key));
    case LUA_TLIGHTUSERDATA:
      return hashpointer(t, pvalue(key));
    default:
      return hashpointer(t, gcvalue(key));
  }
}


/*
** returns the index for `key' if `key' is an appropriate key to live in
** the array part of the table, -1 otherwise.
*/
static inline int arrayindex (const TValue *key) {
  if (ttisnumber(key)) {
    lua_Number n = nvalue(key);
    int k;
    lua_number2int(k, n);
    if (luai_numeq(cast_num(k), n))
      return k;
  }
  return -1;  /* `key' did not match some condition */
}


/*
** returns the index of a `key' for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signalled by -1.
*/
static inline int findindex (lua_State *L, Table *t, StkId key) {
  int i;
  if (ttisnil(key)) return -1;  /* first iteration */
  i = arrayindex(key);
  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
    return i-1;  /* yes; that's the index (corrected to C) */
  else {
    Node *n = mainposition(t, key);
    do {  /* check whether `key' is somewhere in the chain */
      /* key may be dead already, but it is ok to use it in `next' */
      if (luaO_rawequalObj(key2tval(n), key) ||
            (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&
             gcvalue(gkey(n)) == gcvalue(key))) {
        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
        /* hash elements are numbered after array ones */
        return i + t->sizearray;
      }
      else n = gnext(n);
    } while (n);
    luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
    return 0;  /* to avoid warnings */
  }
}


static inline int luaH_next (lua_State *L, Table *t, StkId key) {
  int i = findindex(L, t, key);  /* find original element */
  for (i++; i < t->sizearray; i++) {  /* try first array part */
    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
      setnvalue(key, cast_num(i+1));
      setobj2s(L, key+1, &t->array[i]);
      return 1;
    }
  }
  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
      setobj2s(L, key, key2tval(gnode(t, i)));
      setobj2s(L, key+1, gval(gnode(t, i)));
      return 1;
    }
  }
  return 0;  /* no more elements */
}


/*
** {=============================================================
** Rehash
** ==============================================================
*/


static inline int computesizes (int nums[], int *narray) {
  int i;
  int twotoi;  /* 2^i */
  int a = 0;  /* number of elements smaller than 2^i */
  int na = 0;  /* number of elements to go to array part */
  int n = 0;  /* optimal size for array part */
  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
    if (nums[i] > 0) {
      a += nums[i];
      if (a > twotoi/2) {  /* more than half elements present? */
        n = twotoi;  /* optimal size (till now) */
        na = a;  /* all elements smaller than n will go to array part */
      }
    }
    if (a == *narray) break;  /* all elements already counted */
  }
  *narray = n;
  lua_assert(*narray/2 <= na && na <= *narray);
  return na;
}


static inline int countint (const TValue *key, int *nums) {
  int k = arrayindex(key);
  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
    nums[ceillog2(k)]++;  /* count as such */
    return 1;
  }
  else
    return 0;
}


static inline int numusearray (const Table *t, int *nums) {
  int lg;
  int ttlg;  /* 2^lg */
  int ause = 0;  /* summation of `nums' */
  int i = 1;  /* count to traverse all array keys */
  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
    int lc = 0;  /* counter */
    int lim = ttlg;
    if (lim > t->sizearray) {
      lim = t->sizearray;  /* adjust upper limit */
      if (i > lim)
        break;  /* no more elements to count */
    }
    /* count elements in range (2^(lg-1), 2^lg] */
    for (; i <= lim; i++) {
      if (!ttisnil(&t->array[i-1]))
        lc++;
    }
    nums[lg] += lc;
    ause += lc;
  }
  return ause;
}


static inline int numusehash (const Table *t, int *nums, int *pnasize) {
  int totaluse = 0;  /* total number of elements */
  int ause = 0;  /* summation of `nums' */
  int i = sizenode(t);
  while (i--) {
    Node *n = &t->node[i];
    if (!ttisnil(gval(n))) {
      ause += countint(key2tval(n), nums);
      totaluse++;
    }
  }
  *pnasize += ause;
  return totaluse;
}


static inline void setarrayvector (lua_State *L, Table *t, int size) {
  int i;
  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
  for (i=t->sizearray; i<size; i++)
     setnilvalue(&t->array[i]);
  t->sizearray = size;
}


static inline void setnodevector (lua_State *L, Table *t, int size) {
  int lsize;
  if (size == 0) {  /* no elements to hash part? */
    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
    lsize = 0;
  }
  else {
    int i;
    lsize = ceillog2(size);
    if (lsize > MAXBITS)
      luaG_runerror(L, "table overflow");
    size = twoto(lsize);
    t->node = luaM_newvector(L, size, Node);
    for (i=0; i<size; i++) {
      Node *n = gnode(t, i);
      gnext(n) = NULL;
      setnilvalue(gkey(n));
      setnilvalue(gval(n));
    }
  }
  t->lsizenode = cast_byte(lsize);
  t->lastfree = gnode(t, size);  /* all positions are free */
}


static inline void resize (lua_State *L, Table *t, int nasize, int nhsize) {
  int i;
  int oldasize = t->sizearray;
  int oldhsize = t->lsizenode;
  Node *nold = t->node;  /* save old hash ... */
  if (nasize > oldasize)  /* array part must grow? */
    setarrayvector(L, t, nasize);
  /* create new hash part with appropriate size */
  setnodevector(L, t, nhsize);  
  if (nasize < oldasize) {  /* array part must shrink? */
    t->sizearray = nasize;
    /* re-insert elements from vanishing slice */
    for (i=nasize; i<oldasize; i++) {
      if (!ttisnil(&t->array[i]))
        setobjt2t(L, luaH_setnum(L, t, i+1), &t->array[i]);
    }
    /* shrink array */
    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
  }
  /* re-insert elements from hash part */
  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
    Node *old = nold+i;
    if (!ttisnil(gval(old)))
      setobjt2t(L, luaH_set(L, t, key2tval(old)), gval(old));
  }
  if (nold != dummynode)
    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
}


static inline void luaH_resizearray (lua_State *L, Table *t, int nasize) {
  int nsize = (t->node == dummynode) ? 0 : sizenode(t);
  resize(L, t, nasize, nsize);
}


static inline void rehash (lua_State *L, Table *t, const TValue *ek) {
  int nasize, na;
  int nums[MAXBITS+1];  /* nums[i] = number of keys between 2^(i-1) and 2^i */
  int i;
  int totaluse;
  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
  nasize = numusearray(t, nums);  /* count keys in array part */
  totaluse = nasize;  /* all those keys are integer keys */
  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
  /* count extra key */
  nasize += countint(ek, nums);
  totaluse++;
  /* compute new size for array part */
  na = computesizes(nums, &nasize);
  /* resize the table to new computed sizes */
  resize(L, t, nasize, totaluse - na);
}



/*
** }=============================================================
*/


Table *luaH_new (lua_State *L, int narray, int nhash) {
  Table *t = luaM_new(L, Table);
  luaC_link(L, obj2gco(t), LUA_TTABLE);
  t->metatable = NULL;
  t->flags = cast_byte(~0);
  /* temporary values (kept only if some malloc fails) */
  t->array = NULL;
  t->sizearray = 0;
  t->lsizenode = 0;
  t->node = cast(Node *, dummynode);
  setarrayvector(L, t, narray);
  setnodevector(L, t, nhash);
  return t;
}


static inline void luaH_free (lua_State *L, Table *t) {
  if (t->node != dummynode)
    luaM_freearray(L, t->node, sizenode(t), Node);
  luaM_freearray(L, t->array, t->sizearray, TValue);
  luaM_free(L, t);
}


static inline Node *getfreepos (Table *t) {
  while (t->lastfree-- > t->node) {
    if (ttisnil(gkey(t->lastfree)))
      return t->lastfree;
  }
  return NULL;  /* could not find a free place */
}



/*
** inserts a new key into a hash table; first, check whether key's main 
** position is free. If not, check whether colliding node is in its main 
** position or not: if it is not, move colliding node to an empty place and 
** put new key in its main position; otherwise (colliding node is in its main 
** position), new key goes to an empty position. 
*/
static inline TValue *newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || mp == dummynode) {
    Node *othern;
    Node *n = getfreepos(t);  /* get a free place */
    if (n == NULL) {  /* cannot find a free place? */
      rehash(L, t, key);  /* grow table */
      return luaH_set(L, t, key);  /* re-insert key into grown table */
    }
    lua_assert(n != dummynode);
    othern = mainposition(t, key2tval(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
      gnext(mp) = NULL;  /* now `mp' is free */
      setnilvalue(gval(mp));
    }
    else {  /* colliding node is in its own main position */
      /* new node will go into free position */
      gnext(n) = gnext(mp);  /* chain new position */
      gnext(mp) = n;
      mp = n;
    }
  }
  gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;
  luaC_barriert(L, t, key);
  lua_assert(ttisnil(gval(mp)));
  return gval(mp);
}


/*
** search function for integers
*/
const TValue *luaH_getnum (Table *t, int key) {
  /* (1 <= key && key <= t->sizearray) */
  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
    return &t->array[key-1];
  else {
    lua_Number nk = cast_num(key);
    Node *n = hashnum(t, nk);
    do {  /* check whether `key' is somewhere in the chain */
      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
        return gval(n);  /* that's it */
      else n = gnext(n);
    } while (n);
    return luaO_nilobject;
  }
}


/*
** search function for strings
*/
const TValue *luaH_getstr (Table *t, TString *key) {
  Node *n = hashstr(t, key);
  do {  /* check whether `key' is somewhere in the chain */
    if (ttisstring(gkey(n)) && rawtsvalue(gkey(n)) == key)
      return gval(n);  /* that's it */
    else n = gnext(n);
  } while (n);
  return luaO_nilobject;
}


/*
** main search function
*/
const TValue *luaH_get (Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TNIL: return luaO_nilobject;
    case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));
    case LUA_TNUMBER: {
      int k;
      lua_Number n = nvalue(key);
      lua_number2int(k, n);
      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */
        return luaH_getnum(t, k);  /* use specialized version */
      /* else go through */
    }
    default: {
      Node *n = mainposition(t, key);
      do {  /* check whether `key' is somewhere in the chain */
        if (luaO_rawequalObj(key2tval(n), key))
          return gval(n);  /* that's it */
        else n = gnext(n);
      } while (n);
      return luaO_nilobject;
    }
  }
}


TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
  const TValue *p = luaH_get(t, key);
  t->flags = 0;
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    if (ttisnil(key)) luaG_runerror(L, "table index is nil");
    else if (ttisnumber(key) && luai_numisnan(nvalue(key)))
      luaG_runerror(L, "table index is NaN");
    return newkey(L, t, key);
  }
}


TValue *luaH_setnum (lua_State *L, Table *t, int key) {
  const TValue *p = luaH_getnum(t, key);
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    TValue k;
    setnvalue(&k, cast_num(key));
    return newkey(L, t, &k);
  }
}


TValue *luaH_setstr (lua_State *L, Table *t, TString *key) {
  const TValue *p = luaH_getstr(t, key);
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else {
    TValue k;
    setsvalue(L, &k, key);
    return newkey(L, t, &k);
  }
}


static inline int unbound_search (Table *t, unsigned int j) {
  unsigned int i = j;  /* i is zero or a present index */
  j++;
  /* find `i' and `j' such that i is present and j is not */
  while (!ttisnil(luaH_getnum(t, j))) {
    i = j;
    j *= 2;
    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
      /* table was built with bad purposes: resort to linear search */
      i = 1;
      while (!ttisnil(luaH_getnum(t, i))) i++;
      return i - 1;
    }
  }
  /* now do a binary search between them */
  while (j - i > 1) {
    unsigned int m = (i+j)/2;
    if (ttisnil(luaH_getnum(t, m))) j = m;
    else i = m;
  }
  return i;
}


/*
** Try to find a boundary in table `t'. A `boundary' is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
static inline int luaH_getn (Table *t) {
  unsigned int j = t->sizearray;
  if (j > 0 && ttisnil(&t->array[j - 1])) {
    /* there is a boundary in the array part: (binary) search for it */
    unsigned int i = 0;
    while (j - i > 1) {
      unsigned int m = (i+j)/2;
      if (ttisnil(&t->array[m - 1])) j = m;
      else i = m;
    }
    return i;
  }
  /* else must find a boundary in hash part */
  else if (t->node == dummynode)  /* hash part is empty? */
    return j;  /* that is easy... */
  else return unbound_search(t, j);
}



#if defined(LUA_DEBUG)

Node *luaH_mainposition (const Table *t, const TValue *key) {
  return mainposition(t, key);
}

int luaH_isdummy (Node *n) { return n == dummynode; }

#endif

/*-- File: src.cpp/ltable.cpp end --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- File: src.cpp/ltablib.cpp start --*/
/*
** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
** Library for Table Manipulation
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stddef.h" start --*/

#define ltablib_c
#define LUA_LIB

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lauxlib.h" start --*/
/*-- #include "src.cpp/lualib.h" start --*/


#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))


static inline int foreachi (lua_State *L) {
  int i;
  int n = aux_getn(L, 1);
  luaL_checktype(L, 2, LUA_TFUNCTION);
  for (i=1; i <= n; i++) {
    lua_pushvalue(L, 2);  /* function */
    lua_pushinteger(L, i);  /* 1st argument */
    lua_rawgeti(L, 1, i);  /* 2nd argument */
    lua_call(L, 2, 1);
    if (!lua_isnil(L, -1))
      return 1;
    lua_pop(L, 1);  /* remove nil result */
  }
  return 0;
}


static inline int foreach (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checktype(L, 2, LUA_TFUNCTION);
  lua_pushnil(L);  /* first key */
  while (lua_next(L, 1)) {
    lua_pushvalue(L, 2);  /* function */
    lua_pushvalue(L, -3);  /* key */
    lua_pushvalue(L, -3);  /* value */
    lua_call(L, 2, 1);
    if (!lua_isnil(L, -1))
      return 1;
    lua_pop(L, 2);  /* remove value and result */
  }
  return 0;
}


static inline int maxn (lua_State *L) {
  lua_Number max = 0;
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushnil(L);  /* first key */
  while (lua_next(L, 1)) {
    lua_pop(L, 1);  /* remove value */
    if (lua_type(L, -1) == LUA_TNUMBER) {
      lua_Number v = lua_tonumber(L, -1);
      if (v > max) max = v;
    }
  }
  lua_pushnumber(L, max);
  return 1;
}


static inline int getn (lua_State *L) {
  lua_pushinteger(L, aux_getn(L, 1));
  return 1;
}


static inline int setn (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
#ifndef luaL_setn
  luaL_setn(L, 1, luaL_checkint(L, 2));
#else
  luaL_error(L, LUA_QL("setn") " is obsolete");
#endif
  lua_pushvalue(L, 1);
  return 1;
}


static inline int tinsert (lua_State *L) {
  int e = aux_getn(L, 1) + 1;  /* first empty element */
  int pos;  /* where to insert new element */
  switch (lua_gettop(L)) {
    case 2: {  /* called with only 2 arguments */
      pos = e;  /* insert new element at the end */
      break;
    }
    case 3: {
      int i;
      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
      if (pos > e) e = pos;  /* `grow' array if necessary */
      for (i = e; i > pos; i--) {  /* move up elements */
        lua_rawgeti(L, 1, i-1);
        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
      }
      break;
    }
    default: {
      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
    }
  }
  luaL_setn(L, 1, e);  /* new size */
  lua_rawseti(L, 1, pos);  /* t[pos] = v */
  return 0;
}


static inline int tremove (lua_State *L) {
  int e = aux_getn(L, 1);
  int pos = luaL_optint(L, 2, e);
  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */
   return 0;  /* nothing to remove */
  luaL_setn(L, 1, e - 1);  /* t.n = n-1 */
  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
  for ( ;pos<e; pos++) {
    lua_rawgeti(L, 1, pos+1);
    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
  }
  lua_pushnil(L);
  lua_rawseti(L, 1, e);  /* t[e] = nil */
  return 1;
}


static inline void addfield (lua_State *L, luaL_Buffer *b, int i) {
  lua_rawgeti(L, 1, i);
  if (!lua_isstring(L, -1))
    luaL_error(L, "invalid value (%s) at index %d in table for "
                  LUA_QL("concat"), luaL_typename(L, -1), i);
    luaL_addvalue(b);
}


static inline int tconcat (lua_State *L) {
  luaL_Buffer b;
  size_t lsep;
  int i, last;
  const char *sep = luaL_optlstring(L, 2, "", &lsep);
  luaL_checktype(L, 1, LUA_TTABLE);
  i = luaL_optint(L, 3, 1);
  last = luaL_opt(L, luaL_checkint, 4, luaL_getn(L, 1));
  luaL_buffinit(L, &b);
  for (; i < last; i++) {
    addfield(L, &b, i);
    luaL_addlstring(&b, sep, lsep);
  }
  if (i == last)  /* add last value (if interval was not empty) */
    addfield(L, &b, i);
  luaL_pushresult(&b);
  return 1;
}



/*
** {======================================================
** Quicksort
** (based on `Algorithms in MODULA-3', Robert Sedgewick;
**  Addison-Wesley, 1993.)
*/


static inline void set2 (lua_State *L, int i, int j) {
  lua_rawseti(L, 1, i);
  lua_rawseti(L, 1, j);
}

static inline int sort_comp (lua_State *L, int a, int b) {
  if (!lua_isnil(L, 2)) {  /* function? */
    int res;
    lua_pushvalue(L, 2);
    lua_pushvalue(L, a-1);  /* -1 to compensate function */
    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
    lua_call(L, 2, 1);
    res = lua_toboolean(L, -1);
    lua_pop(L, 1);
    return res;
  }
  else  /* a < b? */
    return lua_lessthan(L, a, b);
}

static inline void auxsort (lua_State *L, int l, int u) {
  while (l < u) {  /* for tail recursion */
    int i, j;
    /* sort elements a[l], a[(l+u)/2] and a[u] */
    lua_rawgeti(L, 1, l);
    lua_rawgeti(L, 1, u);
    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
      set2(L, l, u);  /* swap a[l] - a[u] */
    else
      lua_pop(L, 2);
    if (u-l == 1) break;  /* only 2 elements */
    i = (l+u)/2;
    lua_rawgeti(L, 1, i);
    lua_rawgeti(L, 1, l);
    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
      set2(L, i, l);
    else {
      lua_pop(L, 1);  /* remove a[l] */
      lua_rawgeti(L, 1, u);
      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
        set2(L, i, u);
      else
        lua_pop(L, 2);
    }
    if (u-l == 2) break;  /* only 3 elements */
    lua_rawgeti(L, 1, i);  /* Pivot */
    lua_pushvalue(L, -1);
    lua_rawgeti(L, 1, u-1);
    set2(L, i, u-1);
    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
    i = l; j = u-1;
    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
      /* repeat ++i until a[i] >= P */
      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
        if (i>u) luaL_error(L, "invalid order function for sorting");
        lua_pop(L, 1);  /* remove a[i] */
      }
      /* repeat --j until a[j] <= P */
      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
        if (j<l) luaL_error(L, "invalid order function for sorting");
        lua_pop(L, 1);  /* remove a[j] */
      }
      if (j<i) {
        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
        break;
      }
      set2(L, i, j);
    }
    lua_rawgeti(L, 1, u-1);
    lua_rawgeti(L, 1, i);
    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
    if (i-l < u-i) {
      j=l; i=i-1; l=i+2;
    }
    else {
      j=i+1; i=u; u=j-2;
    }
    auxsort(L, j, i);  /* call recursively the smaller one */
  }  /* repeat the routine for the larger one */
}

static inline int sort (lua_State *L) {
  int n = aux_getn(L, 1);
  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
    luaL_checktype(L, 2, LUA_TFUNCTION);
  lua_settop(L, 2);  /* make sure there is two arguments */
  auxsort(L, 1, n);
  return 0;
}

/* }====================================================== */


static const luaL_Reg tab_funcs[] = {
  {"concat", tconcat},
  {"foreach", foreach},
  {"foreachi", foreachi},
  {"getn", getn},
  {"maxn", maxn},
  {"insert", tinsert},
  {"remove", tremove},
  {"setn", setn},
  {"sort", sort},
  {NULL, NULL}
};


LUALIB_API int luaopen_table (lua_State *L) {
  luaL_register(L, LUA_TABLIBNAME, tab_funcs);
  return 1;
}


/*-- File: src.cpp/ltablib.cpp end --*/
/*-- File: src.cpp/ltm.cpp start --*/
/*
** $Id: ltm.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/string.h" start --*/

#define ltm_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/



static const char *const luaT_typenames[] = {
  "nil", "boolean", "userdata", "number",
  "string", "table", "function", "userdata", "thread",
  "proto", "upval"
};


static inline void luaT_init (lua_State *L) {
  static const char *const luaT_eventname[] = {  /* ORDER TM */
    "__index", "__newindex",
    "__gc", "__mode", "__eq",
    "__add", "__sub", "__mul", "__div", "__mod",
    "__pow", "__unm", "__len", "__lt", "__le",
    "__concat", "__call"
  };
  int i;
  for (i=0; i<TM_N; i++) {
    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
  }
}


/*
** function to be used with macro "fasttm": optimized for absence of
** tag methods
*/
const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
  const TValue *tm = luaH_getstr(events, ename);
  lua_assert(event <= TM_EQ);
  if (ttisnil(tm)) {  /* no tag method? */
    events->flags |= cast_byte(1u<<event);  /* cache this fact */
    return NULL;
  }
  else return tm;
}


const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
  Table *mt;
  switch (ttype(o)) {
    case LUA_TTABLE:
      mt = hvalue(o)->metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(o)->metatable;
      break;
    default:
      mt = G(L)->mt[ttype(o)];
  }
  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
}


/*-- File: src.cpp/ltm.cpp end --*/
/*-- #include "src.cpp/ltm.h" start --*/
/*-- #include "src.cpp/lua.h" start --*/
/*-- #include "src.cpp/luaconf.h" start --*/
/*-- #include "src.cpp/lualib.h" start --*/
/*-- File: src.cpp/lundump.cpp start --*/
/*
** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

/*-- #include "src.cpp/string.h" start --*/

#define lundump_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/lundump.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/

typedef struct {
 lua_State* L;
 ZIO* Z;
 Mbuffer* b;
 const char* name;
} LoadState;

#ifdef LUAC_TRUST_BINARIES
#define IF(c,s)
#define error(S,s)
#else
#define IF(c,s)		if (c) error(S,s)

static inline void error(LoadState* S, const char* why)
{
 luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
 luaD_throw(S->L,LUA_ERRSYNTAX);
}
#endif

#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
#define	LoadByte(S)		(lu_byte)LoadChar(S)
#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)

static inline void LoadBlock(LoadState* S, void* b, size_t size)
{
 size_t r=luaZ_read(S->Z,b,size);
 IF (r!=0, "unexpected end");
}

static inline int LoadChar(LoadState* S)
{
 char x;
 LoadVar(S,x);
 return x;
}

static inline int LoadInt(LoadState* S)
{
 int x;
 LoadVar(S,x);
 IF (x<0, "bad integer");
 return x;
}

static inline lua_Number LoadNumber(LoadState* S)
{
 lua_Number x;
 LoadVar(S,x);
 return x;
}

static inline TString* LoadString(LoadState* S)
{
 size_t size;
 LoadVar(S,size);
 if (size==0)
  return NULL;
 else
 {
  char* s=luaZ_openspace(S->L,S->b,size);
  LoadBlock(S,s,size);
  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
 }
}

static inline void LoadCode(LoadState* S, Proto* f)
{
 int n=LoadInt(S);
 f->code=luaM_newvector(S->L,n,Instruction);
 f->sizecode=n;
 LoadVector(S,f->code,n,sizeof(Instruction));
}

static inline Proto* LoadFunction(LoadState* S, TString* p);

static inline void LoadConstants(LoadState* S, Proto* f)
{
 int i,n;
 n=LoadInt(S);
 f->k=luaM_newvector(S->L,n,TValue);
 f->sizek=n;
 for (i=0; i<n; i++) setnilvalue(&f->k[i]);
 for (i=0; i<n; i++)
 {
  TValue* o=&f->k[i];
  int t=LoadChar(S);
  switch (t)
  {
   case LUA_TNIL:
   	setnilvalue(o);
	break;
   case LUA_TBOOLEAN:
   	setbvalue(o,LoadChar(S)!=0);
	break;
   case LUA_TNUMBER:
	setnvalue(o,LoadNumber(S));
	break;
   case LUA_TSTRING:
	setsvalue2n(S->L,o,LoadString(S));
	break;
   default:
	error(S,"bad constant");
	break;
  }
 }
 n=LoadInt(S);
 f->p=luaM_newvector(S->L,n,Proto*);
 f->sizep=n;
 for (i=0; i<n; i++) f->p[i]=NULL;
 for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
}

static inline void LoadDebug(LoadState* S, Proto* f)
{
 int i,n;
 n=LoadInt(S);
 f->lineinfo=luaM_newvector(S->L,n,int);
 f->sizelineinfo=n;
 LoadVector(S,f->lineinfo,n,sizeof(int));
 n=LoadInt(S);
 f->locvars=luaM_newvector(S->L,n,LocVar);
 f->sizelocvars=n;
 for (i=0; i<n; i++) f->locvars[i].varname=NULL;
 for (i=0; i<n; i++)
 {
  f->locvars[i].varname=LoadString(S);
  f->locvars[i].startpc=LoadInt(S);
  f->locvars[i].endpc=LoadInt(S);
 }
 n=LoadInt(S);
 f->upvalues=luaM_newvector(S->L,n,TString*);
 f->sizeupvalues=n;
 for (i=0; i<n; i++) f->upvalues[i]=NULL;
 for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
}

static inline Proto* LoadFunction(LoadState* S, TString* p)
{
 Proto* f;
 if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
 f=luaF_newproto(S->L);
 setptvalue2s(S->L,S->L->top,f); incr_top(S->L);
 f->source=LoadString(S); if (f->source==NULL) f->source=p;
 f->linedefined=LoadInt(S);
 f->lastlinedefined=LoadInt(S);
 f->nups=LoadByte(S);
 f->numparams=LoadByte(S);
 f->is_vararg=LoadByte(S);
 f->maxstacksize=LoadByte(S);
 LoadCode(S,f);
 LoadConstants(S,f);
 LoadDebug(S,f);
 IF (!luaG_checkcode(f), "bad code");
 S->L->top--;
 S->L->nCcalls--;
 return f;
}

static inline void LoadHeader(LoadState* S)
{
 char h[LUAC_HEADERSIZE];
 char s[LUAC_HEADERSIZE];
 luaU_header(h);
 LoadBlock(S,s,LUAC_HEADERSIZE);
 IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, "bad header");
}

/*
** load precompiled chunk
*/
Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
{
 LoadState S;
 if (*name=='@' || *name=='=')
  S.name=name+1;
 else if (*name==LUA_SIGNATURE[0])
  S.name="binary string";
 else
  S.name=name;
 S.L=L;
 S.Z=Z;
 S.b=buff;
 LoadHeader(&S);
 return LoadFunction(&S,luaS_newliteral(L,"=?"));
}

/*
* make header
*/
static inline void luaU_header (char* h)
{
 int x=1;
 memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);
 h+=sizeof(LUA_SIGNATURE)-1;
 *h++=(char)LUAC_VERSION;
 *h++=(char)LUAC_FORMAT;
 *h++=(char)*(char*)&x;				/* endianness */
 *h++=(char)sizeof(int);
 *h++=(char)sizeof(size_t);
 *h++=(char)sizeof(Instruction);
 *h++=(char)sizeof(lua_Number);
 *h++=(char)(((lua_Number)0.5)==0);		/* is lua_Number integral? */
}

/*-- File: src.cpp/lundump.cpp end --*/
/*-- #include "src.cpp/lundump.h" start --*/
/*-- File: src.cpp/lvm.cpp start --*/
/*
** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/

#define lvm_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/ldebug.h" start --*/
/*-- #include "src.cpp/ldo.h" start --*/
/*-- #include "src.cpp/lfunc.h" start --*/
/*-- #include "src.cpp/lgc.h" start --*/
/*-- #include "src.cpp/lobject.h" start --*/
/*-- #include "src.cpp/lopcodes.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lstring.h" start --*/
/*-- #include "src.cpp/ltable.h" start --*/
/*-- #include "src.cpp/ltm.h" start --*/
/*-- #include "src.cpp/lvm.h" start --*/



/* limit for table tag-method chains (to avoid loops) */
#define MAXTAGLOOP	100


const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
  lua_Number num;
  if (ttisnumber(obj)) return obj;
  if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
    setnvalue(n, num);
    return n;
  }
  else
    return NULL;
}


static inline int luaV_tostring (lua_State *L, StkId obj) {
  if (!ttisnumber(obj))
    return 0;
  else {
    char s[LUAI_MAXNUMBER2STR];
    lua_Number n = nvalue(obj);
    lua_number2str(s, n);
    setsvalue2s(L, obj, luaS_new(L, s));
    return 1;
  }
}


static inline void traceexec (lua_State *L, const Instruction *pc) {
  lu_byte mask = L->hookmask;
  const Instruction *oldpc = L->savedpc;
  L->savedpc = pc;
  if ((mask & LUA_MASKCOUNT) && L->hookcount == 0) {
    resethookcount(L);
    luaD_callhook(L, LUA_HOOKCOUNT, -1);
  }
  if (mask & LUA_MASKLINE) {
    Proto *p = ci_func(L->ci)->l.p;
    int npc = pcRel(pc, p);
    int newline = getline(p, npc);
    /* call linehook when enter a new function, when jump back (loop),
       or when enter a new line */
    if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
      luaD_callhook(L, LUA_HOOKLINE, newline);
  }
}


static inline void callTMres (lua_State *L, StkId res, const TValue *f,
                        const TValue *p1, const TValue *p2) {
  ptrdiff_t result = savestack(L, res);
  setobj2s(L, L->top, f);  /* push function */
  setobj2s(L, L->top+1, p1);  /* 1st argument */
  setobj2s(L, L->top+2, p2);  /* 2nd argument */
  luaD_checkstack(L, 3);
  L->top += 3;
  luaD_call(L, L->top - 3, 1);
  res = restorestack(L, result);
  L->top--;
  setobjs2s(L, res, L->top);
}



static inline void callTM (lua_State *L, const TValue *f, const TValue *p1,
                    const TValue *p2, const TValue *p3) {
  setobj2s(L, L->top, f);  /* push function */
  setobj2s(L, L->top+1, p1);  /* 1st argument */
  setobj2s(L, L->top+2, p2);  /* 2nd argument */
  setobj2s(L, L->top+3, p3);  /* 3th argument */
  luaD_checkstack(L, 4);
  L->top += 4;
  luaD_call(L, L->top - 4, 0);
}


static inline void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
  int loop;
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    const TValue *tm;
    if (ttistable(t)) {  /* `t' is a table? */
      Table *h = hvalue(t);
      const TValue *res = luaH_get(h, key); /* do a primitive get */
      if (!ttisnil(res) ||  /* result is no nil? */
          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
        setobj2s(L, val, res);
        return;
      }
      /* else will try the tag method */
    }
    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
      luaG_typeerror(L, t, "index");
    if (ttisfunction(tm)) {
      callTMres(L, val, tm, t, key);
      return;
    }
    t = tm;  /* else repeat with `tm' */ 
  }
  luaG_runerror(L, "loop in gettable");
}


static inline void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
  int loop;
  TValue temp;
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    const TValue *tm;
    if (ttistable(t)) {  /* `t' is a table? */
      Table *h = hvalue(t);
      TValue *oldval = luaH_set(L, h, key); /* do a primitive set */
      if (!ttisnil(oldval) ||  /* result is no nil? */
          (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
        setobj2t(L, oldval, val);
        h->flags = 0;
        luaC_barriert(L, h, val);
        return;
      }
      /* else will try the tag method */
    }
    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
      luaG_typeerror(L, t, "index");
    if (ttisfunction(tm)) {
      callTM(L, tm, t, key, val);
      return;
    }
    /* else repeat with `tm' */
    setobj(L, &temp, tm);  /* avoid pointing inside table (may rehash) */
    t = &temp;
  }
  luaG_runerror(L, "loop in settable");
}


static inline int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
                       StkId res, TMS event) {
  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
  if (ttisnil(tm))
    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
  if (ttisnil(tm)) return 0;
  callTMres(L, res, tm, p1, p2);
  return 1;
}


static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
                                  TMS event) {
  const TValue *tm1 = fasttm(L, mt1, event);
  const TValue *tm2;
  if (tm1 == NULL) return NULL;  /* no metamethod */
  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
  tm2 = fasttm(L, mt2, event);
  if (tm2 == NULL) return NULL;  /* no metamethod */
  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
    return tm1;
  return NULL;
}


static inline int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
                         TMS event) {
  const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
  const TValue *tm2;
  if (ttisnil(tm1)) return -1;  /* no metamethod? */
  tm2 = luaT_gettmbyobj(L, p2, event);
  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
    return -1;
  callTMres(L, L->top, tm1, p1, p2);
  return !l_isfalse(L->top);
}


static inline int l_strcmp (const TString *ls, const TString *rs) {
  const char *l = getstr(ls);
  size_t ll = ls->tsv.len;
  const char *r = getstr(rs);
  size_t lr = rs->tsv.len;
  for (;;) {
    int temp = strcoll(l, r);
    if (temp != 0) return temp;
    else {  /* strings are equal up to a `\0' */
      size_t len = strlen(l);  /* index of first `\0' in both strings */
      if (len == lr)  /* r is finished? */
        return (len == ll) ? 0 : 1;
      else if (len == ll)  /* l is finished? */
        return -1;  /* l is smaller than r (because r is not finished) */
      /* both strings longer than `len'; go on comparing (after the `\0') */
      len++;
      l += len; ll -= len; r += len; lr -= len;
    }
  }
}


static inline int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttype(l) != ttype(r))
    return luaG_ordererror(L, l, r);
  else if (ttisnumber(l))
    return luai_numlt(nvalue(l), nvalue(r));
  else if (ttisstring(l))
    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
    return res;
  return luaG_ordererror(L, l, r);
}


static inline int lessequal (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttype(l) != ttype(r))
    return luaG_ordererror(L, l, r);
  else if (ttisnumber(l))
    return luai_numle(nvalue(l), nvalue(r));
  else if (ttisstring(l))
    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
    return res;
  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
    return !res;
  return luaG_ordererror(L, l, r);
}


static inline int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
  const TValue *tm;
  lua_assert(ttype(t1) == ttype(t2));
  switch (ttype(t1)) {
    case LUA_TNIL: return 1;
    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
    case LUA_TUSERDATA: {
      if (uvalue(t1) == uvalue(t2)) return 1;
      tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
                         TM_EQ);
      break;  /* will try TM */
    }
    case LUA_TTABLE: {
      if (hvalue(t1) == hvalue(t2)) return 1;
      tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
      break;  /* will try TM */
    }
    default: return gcvalue(t1) == gcvalue(t2);
  }
  if (tm == NULL) return 0;  /* no TM? */
  callTMres(L, L->top, tm, t1, t2);  /* call TM */
  return !l_isfalse(L->top);
}


static inline void luaV_concat (lua_State *L, int total, int last) {
  do {
    StkId top = L->base + last + 1;
    int n = 2;  /* number of elements handled in this pass (at least 2) */
    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
        luaG_concaterror(L, top-2, top-1);
    } else if (tsvalue(top-1)->len == 0)  /* second op is empty? */
      (void)tostring(L, top - 2);  /* result is first op (as string) */
    else {
      /* at least two string values; get as many as possible */
      size_t tl = tsvalue(top-1)->len;
      char *buffer;
      int i;
      /* collect total length */
      for (n = 1; n < total && tostring(L, top-n-1); n++) {
        size_t l = tsvalue(top-n-1)->len;
        if (l >= MAX_SIZET - tl) luaG_runerror(L, "string length overflow");
        tl += l;
      }
      buffer = luaZ_openspace(L, &G(L)->buff, tl);
      tl = 0;
      for (i=n; i>0; i--) {  /* concat all strings */
        size_t l = tsvalue(top-i)->len;
        memcpy(buffer+tl, svalue(top-i), l);
        tl += l;
      }
      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
    }
    total -= n-1;  /* got `n' strings to create 1 new */
    last -= n-1;
  } while (total > 1);  /* repeat until only 1 result left */
}


static inline void Arith (lua_State *L, StkId ra, const TValue *rb,
                   const TValue *rc, TMS op) {
  TValue tempb, tempc;
  const TValue *b, *c;
  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
      (c = luaV_tonumber(rc, &tempc)) != NULL) {
    lua_Number nb = nvalue(b), nc = nvalue(c);
    switch (op) {
      case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
      case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
      case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
      case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
      case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
      case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
      case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
      default: lua_assert(0); break;
    }
  }
  else if (!call_binTM(L, rb, rc, ra, op))
    luaG_aritherror(L, rb, rc);
}



/*
** some macros for common tasks in `luaV_execute'
*/

#define runtime_check(L, c)	{ if (!(c)) break; }

#define RA(i)	(base+GETARG_A(i))
/* to be used after possible stack reallocation */
#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
#define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))


#define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}


#define Protect(x)	{ L->savedpc = pc; {x;}; base = L->base; }


#define arith_op(op,tm) { \
        TValue *rb = RKB(i); \
        TValue *rc = RKC(i); \
        if (ttisnumber(rb) && ttisnumber(rc)) { \
          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
          setnvalue(ra, op(nb, nc)); \
        } \
        else \
          Protect(Arith(L, ra, rb, rc, tm)); \
      }



static inline void luaV_execute (lua_State *L, int nexeccalls) {
  LClosure *cl;
  StkId base;
  TValue *k;
  const Instruction *pc;
 reentry:  /* entry point */
  lua_assert(isLua(L->ci));
  pc = L->savedpc;
  cl = &clvalue(L->ci->func)->l;
  base = L->base;
  k = cl->p->k;
  /* main loop of interpreter */
  for (;;) {
    const Instruction i = *pc++;
    StkId ra;
    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
      traceexec(L, pc);
      if (L->status == LUA_YIELD) {  /* did hook yield? */
        L->savedpc = pc - 1;
        return;
      }
      base = L->base;
    }
    /* warning!! several calls may realloc the stack and invalidate `ra' */
    ra = RA(i);
    lua_assert(base == L->base && L->base == L->ci->base);
    lua_assert(base <= L->top && L->top <= L->stack + L->stacksize);
    lua_assert(L->top == L->ci->top || luaG_checkopenop(i));
    switch (GET_OPCODE(i)) {
      case OP_MOVE: {
        setobjs2s(L, ra, RB(i));
        continue;
      }
      case OP_LOADK: {
        setobj2s(L, ra, KBx(i));
        continue;
      }
      case OP_LOADBOOL: {
        setbvalue(ra, GETARG_B(i));
        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
        continue;
      }
      case OP_LOADNIL: {
        TValue *rb = RB(i);
        do {
          setnilvalue(rb--);
        } while (rb >= ra);
        continue;
      }
      case OP_GETUPVAL: {
        int b = GETARG_B(i);
        setobj2s(L, ra, cl->upvals[b]->v);
        continue;
      }
      case OP_GETGLOBAL: {
        TValue g;
        TValue *rb = KBx(i);
        sethvalue(L, &g, cl->env);
        lua_assert(ttisstring(rb));
        Protect(luaV_gettable(L, &g, rb, ra));
        continue;
      }
      case OP_GETTABLE: {
        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
        continue;
      }
      case OP_SETGLOBAL: {
        TValue g;
        sethvalue(L, &g, cl->env);
        lua_assert(ttisstring(KBx(i)));
        Protect(luaV_settable(L, &g, KBx(i), ra));
        continue;
      }
      case OP_SETUPVAL: {
        UpVal *uv = cl->upvals[GETARG_B(i)];
        setobj(L, uv->v, ra);
        luaC_barrier(L, uv, ra);
        continue;
      }
      case OP_SETTABLE: {
        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
        continue;
      }
      case OP_NEWTABLE: {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
        Protect(luaC_checkGC(L));
        continue;
      }
      case OP_SELF: {
        StkId rb = RB(i);
        setobjs2s(L, ra+1, rb);
        Protect(luaV_gettable(L, rb, RKC(i), ra));
        continue;
      }
      case OP_ADD: {
        arith_op(luai_numadd, TM_ADD);
        continue;
      }
      case OP_SUB: {
        arith_op(luai_numsub, TM_SUB);
        continue;
      }
      case OP_MUL: {
        arith_op(luai_nummul, TM_MUL);
        continue;
      }
      case OP_DIV: {
        arith_op(luai_numdiv, TM_DIV);
        continue;
      }
      case OP_MOD: {
        arith_op(luai_nummod, TM_MOD);
        continue;
      }
      case OP_POW: {
        arith_op(luai_numpow, TM_POW);
        continue;
      }
      case OP_UNM: {
        TValue *rb = RB(i);
        if (ttisnumber(rb)) {
          lua_Number nb = nvalue(rb);
          setnvalue(ra, luai_numunm(nb));
        }
        else {
          Protect(Arith(L, ra, rb, rb, TM_UNM));
        }
        continue;
      }
      case OP_NOT: {
        int res = l_isfalse(RB(i));  /* next assignment may change this value */
        setbvalue(ra, res);
        continue;
      }
      case OP_LEN: {
        const TValue *rb = RB(i);
        switch (ttype(rb)) {
          case LUA_TTABLE: {
            setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
            break;
          }
          case LUA_TSTRING: {
            setnvalue(ra, cast_num(tsvalue(rb)->len));
            break;
          }
          default: {  /* try metamethod */
            Protect(
              if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
                luaG_typeerror(L, rb, "get length of");
            )
          }
        }
        continue;
      }
      case OP_CONCAT: {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L));
        setobjs2s(L, RA(i), base+b);
        continue;
      }
      case OP_JMP: {
        dojump(L, pc, GETARG_sBx(i));
        continue;
      }
      case OP_EQ: {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        Protect(
          if (equalobj(L, rb, rc) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_LT: {
        Protect(
          if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_LE: {
        Protect(
          if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        continue;
      }
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      case OP_CALL: {
        int b = GETARG_B(i);
        int nresults = GETARG_C(i) - 1;
        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
        L->savedpc = pc;
        switch (luaD_precall(L, ra, nresults)) {
          case PCRLUA: {
            nexeccalls++;
            goto reentry;  /* restart luaV_execute over new Lua function */
          }
          case PCRC: {
            /* it was a C function (`precall' called it); adjust results */
            if (nresults >= 0) L->top = L->ci->top;
            base = L->base;
            continue;
          }
          default: {
            return;  /* yield */
          }
        }
      }
      case OP_TAILCALL: {
        int b = GETARG_B(i);
        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
        L->savedpc = pc;
        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
        switch (luaD_precall(L, ra, LUA_MULTRET)) {
          case PCRLUA: {
            /* tail call: put new frame in place of previous one */
            CallInfo *ci = L->ci - 1;  /* previous frame */
            int aux;
            StkId func = ci->func;
            StkId pfunc = (ci+1)->func;  /* previous function index */
            if (L->openupval) luaF_close(L, ci->base);
            L->base = ci->base = ci->func + ((ci+1)->base - pfunc);
            for (aux = 0; pfunc+aux < L->top; aux++)  /* move frame down */
              setobjs2s(L, func+aux, pfunc+aux);
            ci->top = L->top = func+aux;  /* correct top */
            lua_assert(L->top == L->base + clvalue(func)->l.p->maxstacksize);
            ci->savedpc = L->savedpc;
            ci->tailcalls++;  /* one more call lost */
            L->ci--;  /* remove new frame */
            goto reentry;
          }
          case PCRC: {  /* it was a C function (`precall' called it) */
            base = L->base;
            continue;
          }
          default: {
            return;  /* yield */
          }
        }
      }
      case OP_RETURN: {
        int b = GETARG_B(i);
        if (b != 0) L->top = ra+b-1;
        if (L->openupval) luaF_close(L, base);
        L->savedpc = pc;
        b = luaD_poscall(L, ra);
        if (--nexeccalls == 0)  /* was previous function running `here'? */
          return;  /* no: return */
        else {  /* yes: continue its execution */
          if (b) L->top = L->ci->top;
          lua_assert(isLua(L->ci));
          lua_assert(GET_OPCODE(*((L->ci)->savedpc - 1)) == OP_CALL);
          goto reentry;
        }
      }
      case OP_FORLOOP: {
        lua_Number step = nvalue(ra+2);
        lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */
        lua_Number limit = nvalue(ra+1);
        if (luai_numlt(0, step) ? luai_numle(idx, limit)
                                : luai_numle(limit, idx)) {
          dojump(L, pc, GETARG_sBx(i));  /* jump back */
          setnvalue(ra, idx);  /* update internal index... */
          setnvalue(ra+3, idx);  /* ...and external index */
        }
        continue;
      }
      case OP_FORPREP: {
        const TValue *init = ra;
        const TValue *plimit = ra+1;
        const TValue *pstep = ra+2;
        L->savedpc = pc;  /* next steps may throw errors */
        if (!tonumber(init, ra))
          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
        else if (!tonumber(plimit, ra+1))
          luaG_runerror(L, LUA_QL("for") " limit must be a number");
        else if (!tonumber(pstep, ra+2))
          luaG_runerror(L, LUA_QL("for") " step must be a number");
        setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));
        dojump(L, pc, GETARG_sBx(i));
        continue;
      }
      case OP_TFORLOOP: {
        StkId cb = ra + 3;  /* call base */
        setobjs2s(L, cb+2, ra+2);
        setobjs2s(L, cb+1, ra+1);
        setobjs2s(L, cb, ra);
        L->top = cb+3;  /* func. + 2 args (state and index) */
        Protect(luaD_call(L, cb, GETARG_C(i)));
        L->top = L->ci->top;
        cb = RA(i) + 3;  /* previous call may change the stack */
        if (!ttisnil(cb)) {  /* continue loop? */
          setobjs2s(L, cb-1, cb);  /* save control variable */
          dojump(L, pc, GETARG_sBx(*pc));  /* jump back */
        }
        pc++;
        continue;
      }
      case OP_SETLIST: {
        int n = GETARG_B(i);
        int c = GETARG_C(i);
        int last;
        Table *h;
        if (n == 0) {
          n = cast_int(L->top - ra) - 1;
          L->top = L->ci->top;
        }
        if (c == 0) c = cast_int(*pc++);
        runtime_check(L, ttistable(ra));
        h = hvalue(ra);
        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
        if (last > h->sizearray)  /* needs more space? */
          luaH_resizearray(L, h, last);  /* pre-alloc it at once */
        for (; n > 0; n--) {
          TValue *val = ra+n;
          setobj2t(L, luaH_setnum(L, h, last--), val);
          luaC_barriert(L, h, val);
        }
        continue;
      }
      case OP_CLOSE: {
        luaF_close(L, ra);
        continue;
      }
      case OP_CLOSURE: {
        Proto *p;
        Closure *ncl;
        int nup, j;
        p = cl->p->p[GETARG_Bx(i)];
        nup = p->nups;
        ncl = luaF_newLclosure(L, nup, cl->env);
        ncl->l.p = p;
        for (j=0; j<nup; j++, pc++) {
          if (GET_OPCODE(*pc) == OP_GETUPVAL)
            ncl->l.upvals[j] = cl->upvals[GETARG_B(*pc)];
          else {
            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
            ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
          }
        }
        setclvalue(L, ra, ncl);
        Protect(luaC_checkGC(L));
        continue;
      }
      case OP_VARARG: {
        int b = GETARG_B(i) - 1;
        int j;
        CallInfo *ci = L->ci;
        int n = cast_int(ci->base - ci->func) - cl->p->numparams - 1;
        if (b == LUA_MULTRET) {
          Protect(luaD_checkstack(L, n));
          ra = RA(i);  /* previous call may change the stack */
          b = n;
          L->top = ra + n;
        }
        for (j = 0; j < b; j++) {
          if (j < n) {
            setobjs2s(L, ra + j, ci->base - n + j);
          }
          else {
            setnilvalue(ra + j);
          }
        }
        continue;
      }
    }
  }
}


/*-- File: src.cpp/lvm.cpp end --*/
/*-- #include "src.cpp/lvm.h" start --*/
/*-- File: src.cpp/lzio.cpp start --*/
/*
** $Id: lzio.c,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
** a generic input stream interface
** See Copyright Notice in lua.h
*/


/*-- #include "src.cpp/string.h" start --*/

#define lzio_c
#define LUA_CORE

/*-- #include "src.cpp/lua.h" start --*/

/*-- #include "src.cpp/llimits.h" start --*/
/*-- #include "src.cpp/lmem.h" start --*/
/*-- #include "src.cpp/lstate.h" start --*/
/*-- #include "src.cpp/lzio.h" start --*/


static inline int luaZ_fill (ZIO *z) {
  size_t size;
  lua_State *L = z->L;
  const char *buff;
  lua_unlock(L);
  buff = z->reader(L, z->data, &size);
  lua_lock(L);
  if (buff == NULL || size == 0) return EOZ;
  z->n = size - 1;
  z->p = buff;
  return char2int(*(z->p++));
}


static inline int luaZ_lookahead (ZIO *z) {
  if (z->n == 0) {
    if (luaZ_fill(z) == EOZ)
      return EOZ;
    else {
      z->n++;  /* luaZ_fill removed first byte; put back it */
      z->p--;
    }
  }
  return char2int(*z->p);
}


static inline void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
  z->L = L;
  z->reader = reader;
  z->data = data;
  z->n = 0;
  z->p = NULL;
}


/* --------------------------------------------------------------- read --- */
static inline size_t luaZ_read (ZIO *z, void *b, size_t n) {
  while (n) {
    size_t m;
    if (luaZ_lookahead(z) == EOZ)
      return n;  /* return number of missing bytes */
    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
    memcpy(b, z->p, m);
    z->n -= m;
    z->p += m;
    b = (char *)b + m;
    n -= m;
  }
  return 0;
}

/* ------------------------------------------------------------------------ */
static inline char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
  if (n > buff->buffsize) {
    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
    luaZ_resizebuffer(L, buff, n);
  }
  return buff->buffer;
}



/*-- File: src.cpp/lzio.cpp end --*/
/*-- #include "src.cpp/lzio.h" start --*/
/*-- #include "src.cpp/math.h" start --*/
/*-- #include "src.cpp/readline/history.h" start --*/

/*-- #include "src.cpp/readline/readline.h" start --*/

/*-- #include "src.cpp/setjmp.h" start --*/
/*-- #include "src.cpp/stdarg.h" start --*/
/*-- #include "src.cpp/stddef.h" start --*/
/*-- #include "src.cpp/stdio.h" start --*/
/*-- #include "src.cpp/stdlib.h" start --*/
/*-- #include "src.cpp/string.h" start --*/
/*-- #include "src.cpp/unistd.h" start --*/