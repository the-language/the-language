/* Generated by make.rkt */
/*
    The Language
    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
#include "lang.h"
#include <stddef.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
static inline int user_defined_isspace(int c) {
  return c == ' ' || (unsigned)c - '\t' < 5;
}
typedef struct lua_State lua_State;
typedef int (*lua_CFunction)(lua_State *L);
typedef const char *(*lua_Reader)(lua_State *L, void *ud, size_t *sz);
typedef int (*lua_Writer)(lua_State *L, const void *p, size_t sz, void *ud);
typedef void *(*lua_Alloc)(void *ud, void *ptr, size_t osize, size_t nsize);
typedef double lua_Number;
typedef ptrdiff_t lua_Integer;
static inline lua_State *(lua_newstate)(lua_Alloc f, void *ud);
static inline void(lua_close)(lua_State *L);
static inline lua_State *(lua_newthread)(lua_State *L);
static inline lua_CFunction(lua_atpanic)(lua_State *L, lua_CFunction panicf);
static inline int(lua_gettop)(lua_State *L);
static inline void(lua_settop)(lua_State *L, int idx);
static inline void(lua_pushvalue)(lua_State *L, int idx);
static inline void(lua_remove)(lua_State *L, int idx);
static inline void(lua_insert)(lua_State *L, int idx);
static inline void(lua_replace)(lua_State *L, int idx);
static inline int(lua_checkstack)(lua_State *L, int sz);
static inline void(lua_xmove)(lua_State *from, lua_State *to, int n);
static inline int(lua_isnumber)(lua_State *L, int idx);
static inline int(lua_isstring)(lua_State *L, int idx);
static inline int(lua_iscfunction)(lua_State *L, int idx);
static inline int(lua_isuserdata)(lua_State *L, int idx);
static inline int(lua_type)(lua_State *L, int idx);
static inline const char *(lua_typename)(lua_State *L, int tp);
static inline int(lua_equal)(lua_State *L, int idx1, int idx2);
static inline int(lua_rawequal)(lua_State *L, int idx1, int idx2);
static inline int(lua_lessthan)(lua_State *L, int idx1, int idx2);
static inline lua_Number(lua_tonumber)(lua_State *L, int idx);
static inline lua_Integer(lua_tointeger)(lua_State *L, int idx);
static inline int(lua_toboolean)(lua_State *L, int idx);
static inline const char *(lua_tolstring)(lua_State *L, int idx, size_t *len);
static inline size_t(lua_objlen)(lua_State *L, int idx);
static inline lua_CFunction(lua_tocfunction)(lua_State *L, int idx);
static inline void *(lua_touserdata)(lua_State *L, int idx);
static inline lua_State *(lua_tothread)(lua_State *L, int idx);
static inline const void *(lua_topointer)(lua_State *L, int idx);
static inline void(lua_pushnil)(lua_State *L);
static inline void(lua_pushnumber)(lua_State *L, lua_Number n);
static inline void(lua_pushinteger)(lua_State *L, lua_Integer n);
static inline void(lua_pushlstring)(lua_State *L, const char *s, size_t l);
static inline void(lua_pushstring)(lua_State *L, const char *s);
static inline const char *(lua_pushvfstring)(lua_State *L, const char *fmt,
                                             va_list argp);
static inline const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...);
static inline void(lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n);
static inline void(lua_pushboolean)(lua_State *L, int b);
static inline void(lua_pushlightuserdata)(lua_State *L, void *p);
static inline int(lua_pushthread)(lua_State *L);
static inline void(lua_gettable)(lua_State *L, int idx);
static inline void(lua_getfield)(lua_State *L, int idx, const char *k);
static inline void(lua_rawget)(lua_State *L, int idx);
static inline void(lua_rawgeti)(lua_State *L, int idx, int n);
static inline void(lua_createtable)(lua_State *L, int narr, int nrec);
static inline void *(lua_newuserdata)(lua_State *L, size_t sz);
static inline int(lua_getmetatable)(lua_State *L, int objindex);
static inline void(lua_getfenv)(lua_State *L, int idx);
static inline void(lua_settable)(lua_State *L, int idx);
static inline void(lua_setfield)(lua_State *L, int idx, const char *k);
static inline void(lua_rawset)(lua_State *L, int idx);
static inline void(lua_rawseti)(lua_State *L, int idx, int n);
static inline int(lua_setmetatable)(lua_State *L, int objindex);
static inline int(lua_setfenv)(lua_State *L, int idx);
static inline void(lua_call)(lua_State *L, int nargs, int nresults);
static inline int(lua_pcall)(lua_State *L, int nargs, int nresults,
                             int errfunc);
static inline int(lua_cpcall)(lua_State *L, lua_CFunction func, void *ud);
static inline int(lua_yield)(lua_State *L, int nresults);
static inline int(lua_resume)(lua_State *L, int narg);
static inline int(lua_status)(lua_State *L);
static inline int(lua_error)(lua_State *L);
static inline int(lua_next)(lua_State *L, int idx);
static inline void(lua_concat)(lua_State *L, int n);
static inline lua_Alloc(lua_getallocf)(lua_State *L, void **ud);
static inline void lua_setallocf(lua_State *L, lua_Alloc f, void *ud);
static inline void lua_setlevel(lua_State *from, lua_State *to);
typedef struct lua_Debug lua_Debug;
typedef void (*lua_Hook)(lua_State *L, lua_Debug *ar);
static inline int lua_getstack(lua_State *L, int level, lua_Debug *ar);
static inline int lua_getinfo(lua_State *L, const char *what, lua_Debug *ar);
static inline const char *lua_getlocal(lua_State *L, const lua_Debug *ar,
                                       int n);
static inline const char *lua_setlocal(lua_State *L, const lua_Debug *ar,
                                       int n);
static inline const char *lua_getupvalue(lua_State *L, int funcindex, int n);
static inline const char *lua_setupvalue(lua_State *L, int funcindex, int n);
static inline int lua_sethook(lua_State *L, lua_Hook func, int mask, int count);
static inline lua_Hook lua_gethook(lua_State *L);
static inline int lua_gethookmask(lua_State *L);
static inline int lua_gethookcount(lua_State *L);
struct lua_Debug {
  int event;
  const char *name;
  const char *namewhat;
  const char *what;
  const char *source;
  int currentline;
  int nups;
  int linedefined;
  int lastlinedefined;
  char short_src[60];
  int i_ci;
};
typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;
static inline void(luaL_openlib)(lua_State *L, const char *libname,
                                 const luaL_Reg *l, int nup);
static inline void(luaL_register)(lua_State *L, const char *libname,
                                  const luaL_Reg *l);
static inline int(luaL_getmetafield)(lua_State *L, int obj, const char *e);
static inline int(luaL_callmeta)(lua_State *L, int obj, const char *e);
static inline int(luaL_typerror)(lua_State *L, int narg, const char *tname);
static inline int(luaL_argerror)(lua_State *L, int numarg,
                                 const char *extramsg);
static inline const char *(luaL_checklstring)(lua_State *L, int numArg,
                                              size_t *l);
static inline const char *(luaL_optlstring)(lua_State *L, int numArg,
                                            const char *def, size_t *l);
static inline lua_Number(luaL_checknumber)(lua_State *L, int numArg);
static inline lua_Number(luaL_optnumber)(lua_State *L, int nArg,
                                         lua_Number def);
static inline lua_Integer(luaL_checkinteger)(lua_State *L, int numArg);
static inline lua_Integer(luaL_optinteger)(lua_State *L, int nArg,
                                           lua_Integer def);
static inline void(luaL_checkstack)(lua_State *L, int sz, const char *msg);
static inline void(luaL_checktype)(lua_State *L, int narg, int t);
static inline void(luaL_checkany)(lua_State *L, int narg);
static inline int(luaL_newmetatable)(lua_State *L, const char *tname);
static inline void *(luaL_checkudata)(lua_State *L, int ud, const char *tname);
static inline void(luaL_where)(lua_State *L, int lvl);
static inline int(luaL_error)(lua_State *L, const char *fmt, ...);
static inline int(luaL_checkoption)(lua_State *L, int narg, const char *def,
                                    const char *const lst[]);
static inline int(luaL_ref)(lua_State *L, int t);
static inline void(luaL_unref)(lua_State *L, int t, int ref);
static inline lua_State *(luaL_newstate)(void);
static inline const char *(luaL_gsub)(lua_State *L, const char *s,
                                      const char *p, const char *r);
static inline const char *(luaL_findtable)(lua_State *L, int idx,
                                           const char *fname, int szhint);
typedef struct luaL_Buffer {
  char *p;
  int lvl;
  lua_State *L;
  char buffer[BUFSIZ];
} luaL_Buffer;
static inline void(luaL_buffinit)(lua_State *L, luaL_Buffer *B);
static inline char *(luaL_prepbuffer)(luaL_Buffer *B);
static inline void(luaL_addlstring)(luaL_Buffer *B, const char *s, size_t l);
static inline void(luaL_addstring)(luaL_Buffer *B, const char *s);
static inline void(luaL_addvalue)(luaL_Buffer *B);
static inline void(luaL_pushresult)(luaL_Buffer *B);
static inline int(luaopen_base)(lua_State *L);
static inline int(luaopen_table)(lua_State *L);
static inline int(luaopen_string)(lua_State *L);
static inline void(luaL_openlibs)(lua_State *L);
static inline void lc_newclosuretable(lua_State *L, int idx) {
  lua_createtable(L, 0, 0);
  lua_pushvalue(L, idx);
  lua_rawseti(L, -2, 0);
}
static inline void lc_add(lua_State *L, int idxa, int idxb) {
  if (lua_isnumber(L, idxa) && lua_isnumber(L, idxb)) {
    lua_pushnumber(L, lua_tonumber(L, idxa) + lua_tonumber(L, idxb));
  } else {
    if (luaL_getmetafield(L, idxa, "__add") ||
        luaL_getmetafield(L, idxb, "__add")) {
      lua_pushvalue(L, idxa < 0 && idxa > (-10000) ? idxa - 1 : idxa);
      lua_pushvalue(L, idxb < 0 && idxb > (-10000) ? idxb - 2 : idxb);
      lua_call(L, 2, 1);
    } else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
static inline int lcf1_l(lua_State *L) {
  if ((lua_gettop(L) < 1)) {
    lua_settop(L, 1);
  }
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - 1);
  lua_createtable(L, 1, 0);
  const int lc2 = lua_gettop(L);
  {
    int i;
    for (i = 1 + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc2)) {
    lua_rawseti(L, lc2, (0 + (lua_gettop(L) - lc2)));
  }
  lua_getfield(L, (-10001), "ipairs");
  lua_pushvalue(L, (2 + lc_nextra));
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lua_pushvalue(L, (7 + lc_nextra));
    const double lc4 = lua_objlen(L, 1);
    lua_pushnumber(L, lc4);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_insert(L, -2);
    lua_settable(L, 1);
    lua_settop(L, -(2) - 1);
  }
  lua_settop(L, (2 + lc_nextra));
  const double lc5 = lua_objlen(L, 1);
  lua_pushnumber(L, lc5);
  return 1;
}
static inline void lc_sub(lua_State *L, int idxa, int idxb) {
  if (lua_isnumber(L, idxa) && lua_isnumber(L, idxb)) {
    lua_pushnumber(L, lua_tonumber(L, idxa) - lua_tonumber(L, idxb));
  } else {
    if (luaL_getmetafield(L, idxa, "__sub") ||
        luaL_getmetafield(L, idxb, "__sub")) {
      lua_pushvalue(L, idxa < 0 && idxa > (-10000) ? idxa - 1 : idxa);
      lua_pushvalue(L, idxb < 0 && idxb > (-10000) ? idxb - 2 : idxb);
      lua_call(L, 2, 1);
    } else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
static inline int lc_le(lua_State *L, int idxa, int idxb) {
  if (lua_type(L, idxa) == 3 && lua_type(L, idxb) == 3) {
    return lua_tonumber(L, idxa) <= lua_tonumber(L, idxb);
  } else if (lua_type(L, idxa) == 4 && lua_type(L, idxb) == 4) {
    return lua_lessthan(L, idxa, idxb) || lua_rawequal(L, idxa, idxb);
  } else if (luaL_getmetafield(L, idxa, "__le") ||
             luaL_getmetafield(L, idxb, "__le")) {
    lua_pushvalue(L, idxa < 0 && idxa > (-10000) ? idxa - 1 : idxa);
    lua_pushvalue(L, idxb < 0 && idxb > (-10000) ? idxb - 2 : idxb);
    lua_call(L, 2, 1);
    const int result = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    return result;
  } else if (luaL_getmetafield(L, idxa, "__lt") ||
             luaL_getmetafield(L, idxb, "__lt")) {
    lua_pushvalue(L, idxb < 0 && idxb > (-10000) ? idxb - 1 : idxb);
    lua_pushvalue(L, idxa < 0 && idxa > (-10000) ? idxa - 2 : idxa);
    lua_call(L, 2, 1);
    const int result = !lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    return result;
  } else {
    return luaL_error(L, "attempt to compare");
  }
}
static inline int lcf1_Ae(lua_State *L) {
  if ((lua_gettop(L) < 1)) {
    lua_settop(L, 1);
  }
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - 1);
  lua_createtable(L, 1, 0);
  const int lc7 = lua_gettop(L);
  {
    int i;
    for (i = 1 + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc7)) {
    lua_rawseti(L, lc7, (0 + (lua_gettop(L) - lc7)));
  }
  const double lc8 = lua_objlen(L, (2 + lc_nextra));
  lua_pushnumber(L, lc8);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  while (1) {
    lua_pushnumber(L, 0);
    const int lc10 = lc_le(L, -1, (3 + lc_nextra));
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc10);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_getfield(L, (-10001), "table");
    lua_pushlstring(L,
                    ""
                    "insert",
                    (sizeof("insert") / sizeof(char)) - 1);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_pushnumber(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, (3 + lc_nextra), -1);
    lua_remove(L, -2);
    lua_gettable(L, (2 + lc_nextra));
    lua_call(L, 3, 0);
    lua_pushnumber(L, 1);
    lc_sub(L, (3 + lc_nextra), -1);
    lua_remove(L, -2);
    lua_replace(L, (3 + lc_nextra));
  }
  lua_settop(L, (3 + lc_nextra));
  lua_settop(L, -(1) - 1);
  const double lc11 = lua_objlen(L, 1);
  lua_pushnumber(L, lc11);
  return 1;
}
static inline int lcf1_k(lua_State *L) {
  lua_settop(L, 0);
  lua_getfield(L, (-10001), "error");
  lua_pushlstring(L,
                  ""
                  "TheLanguage PANIC",
                  (sizeof("TheLanguage PANIC") / sizeof(char)) - 1);
  lua_call(L, 1, 0);
  return 0;
}
static inline void lc_setupvalue(lua_State *L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L, tidx, varid);
  } else {
    lua_pushvalue(L, tidx);
    while (--level >= 0) {
      lua_rawgeti(L, tidx, 0);
      lua_remove(L, -2);
      tidx = -1;
    }
    lua_insert(L, -2);
    lua_rawseti(L, -2, varid);
    lua_settop(L, -(1) - 1);
  }
}
static inline void lc_getupvalue(lua_State *L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L, tidx, varid);
  } else {
    lua_pushvalue(L, tidx);
    while (--level >= 0) {
      lua_rawgeti(L, tidx, 0);
      lua_remove(L, -2);
      tidx = -1;
    }
    lua_rawgeti(L, -1, varid);
    lua_remove(L, -2);
  }
}
static inline int lcf1_O(lua_State *L) {
  lua_settop(L, 1);
  lua_pushboolean(L, !(lua_toboolean(L, 1)));
  const int lc14 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc14) {
    const int lc15 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 114);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc15);
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf1_ae(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 103);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_q(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 103);
  const int lc16 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc16);
  return 1;
}
static inline int lcf1_te(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_U(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_Q(lua_State *L) {
  lua_settop(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 100);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1_f(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 112);
  const int lc18 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc18);
  return 1;
}
static inline int lcf1_L(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_S(lua_State *L) {
  lua_settop(L, 2);
  const int lc20 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc20);
  const int lc21 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc21) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 95);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 95);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc23 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc23);
  const int lc24 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc24) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 60);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  return 0;
}
static inline int lcf1_h(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 111);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_a(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 111);
  const int lc25 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc25);
  return 1;
}
static inline int lcf1_i(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_n(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_s(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 110);
  const int lc26 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc26);
  return 1;
}
static inline int lcf1_z(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 109);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_c(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 109);
  const int lc27 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc27);
  return 1;
}
static inline int lcf1_j(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_T(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_W(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 108);
  const int lc28 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc28);
  return 1;
}
static inline int lcf1_Ke(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_H(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 107);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_F(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 107);
  const int lc29 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc29);
  return 1;
}
static inline int lcf1_G(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_Z(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_Ve(lua_State *L) {
  lua_settop(L, 3);
  lua_createtable(L, 4, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 105);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 4);
  return 1;
}
static inline int lcf1_P(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 105);
  const int lc30 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc30);
  return 1;
}
static inline int lcf1_qe(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_ge(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_ke(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 4);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1__(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 106);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_V(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 106);
  const int lc31 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc31);
  return 1;
}
static inline int lcf1_le(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_se(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_M(lua_State *L) {
  lua_settop(L, 2);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 104);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_B(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 104);
  const int lc32 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc32);
  return 1;
}
static inline int lcf1_je(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_ze(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  return 1;
}
static inline int lcf1_t(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 64);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 64);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1_Y(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 23);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf1_t, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 86);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc34 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc34) {
    const int lc35 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc35);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 0, 92);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc37 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc37) {
      const int lc38 = lua_gettop(L);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 2);
      lua_call(L, 1, (-1));
      return (lua_gettop(L) - lc38);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 100);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      const int lc40 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc40) {
        const int lc41 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 2);
        lua_call(L, 1, (-1));
        return (lua_gettop(L) - lc41);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf1_xe(lua_State *L) {
  lua_settop(L, 0);
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 102);
  lua_rawseti(L, -2, 1);
  return 1;
}
static inline int lcf1_o(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 102);
  const int lc42 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc42);
  return 1;
}
static inline int lcf1_N(lua_State *L) {
  lua_settop(L, 2);
  const int lc44 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc44);
  const int lc45 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc45) {
    return 0;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 89);
  const int lc47 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc47);
  const int lc48 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc48) {
    lua_pushvalue(L, 2);
    lua_replace(L, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 89);
    lua_replace(L, 2);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 108);
  lua_pushnumber(L, 1);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lua_pushvalue(L, 2);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lua_pushboolean(L, 0);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lua_pushboolean(L, 0);
  lua_pushnumber(L, 4);
  lua_insert(L, -2);
  lua_settable(L, 1);
  return 0;
}
static inline int lcf1_oe(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 113);
  const int lc49 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 61);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc49), 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 113);
  lc_getupvalue(L, ((-10002) - (1)), 0, 61);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_pushnumber(L, 1);
  lua_gettable(L, 4);
  lua_pushnumber(L, 1);
  lua_insert(L, -2);
  lua_settable(L, 3);
  lua_pushnumber(L, 2);
  lua_gettable(L, 4);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 3);
  lua_pushnumber(L, 3);
  lua_gettable(L, 4);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 3);
  lua_pushnumber(L, 4);
  lua_gettable(L, 4);
  lua_pushnumber(L, 4);
  lua_insert(L, -2);
  lua_settable(L, 3);
  return 0;
}
static inline int lcf1_Ge(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 62);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 59);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf1_b(lua_State *L) {
  lua_settop(L, 2);
  const int lc50 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 87);
  const int lc51 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 52);
  lc_getupvalue(L, ((-10002) - (1)), 0, 93);
  const int lc52 = lua_gettop(L);
  lua_pushvalue(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 93);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc52), (-1));
  lua_call(L, (lua_gettop(L) - lc51), (-1));
  return (lua_gettop(L) - lc50);
}
static inline int lcf1_E(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 89);
  const double lc53 = lua_objlen(L, 1);
  lua_pushnumber(L, lc53);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  while (1) {
    lua_pushnumber(L, 0);
    const int lc55 = lc_le(L, -1, 3);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc55);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 93);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    lua_replace(L, 2);
    lua_pushnumber(L, 1);
    lc_sub(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf1_e(lua_State *L) {
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - 0);
  lua_createtable(L, 1, 0);
  const int lc56 = lua_gettop(L);
  {
    int i;
    for (i = 0 + 1; i <= lc_nactualargs; i++) {
      lua_pushvalue(L, i);
    }
  }
  while ((lua_gettop(L) > lc56)) {
    lua_rawseti(L, lc56, (0 + (lua_gettop(L) - lc56)));
  }
  const int lc57 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 31);
  lua_pushvalue(L, (1 + lc_nextra));
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc57);
}
static inline int lcf1_I(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 83);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc59 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc59) {
    lua_pushvalue(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  lua_createtable(L, 0, 0);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 83);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 2, 1);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    lc_getupvalue(L, ((-10002) - (1)), 0, 82);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_replace(L, 2);
  }
  lua_settop(L, 3);
  lua_getfield(L, (-10001), "ipairs");
  lua_pushvalue(L, 3);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lc_getupvalue(L, ((-10002) - (1)), 0, 60);
    lua_pushvalue(L, 8);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    lua_settop(L, -(2) - 1);
  }
  lua_settop(L, 3);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf1_he(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 80);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 76);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 71);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 67);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
}
static inline int lcf1_y(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 83);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 28);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
}
static inline int lcf1_ee(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 100);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
  }
  return 1;
}
static inline int lcf1_r(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 2, 60);
  lc_getupvalue(L, ((-10002) - (1)), 0, 120);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  lua_pushnumber(L, 0);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 1, 117);
    const double lc74 = lua_objlen(L, -1);
    lua_settop(L, -(1) - 1);
    lua_pushnumber(L, lc74);
    const int lc75 = lua_lessthan(L, 2, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc75);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 2, 60);
    lc_getupvalue(L, ((-10002) - (1)), 1, 117);
    lua_pushnumber(L, 1);
    lc_add(L, 2, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_call(L, 2, 0);
    lua_pushnumber(L, 1);
    lc_add(L, 2, -1);
    lua_remove(L, -2);
    lua_replace(L, 2);
  }
  lua_settop(L, 2);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_n(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 119);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 2, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc77 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc77) {
    lc_getupvalue(L, ((-10002) - (1)), 4, 1);
    lc_getupvalue(L, ((-10002) - (1)), 1, 117);
    lc_getupvalue(L, ((-10002) - (1)), 0, 120);
    lua_call(L, 2, 0);
    const int lc78 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 2, 25);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, ((-10002) - (1)), 1, 115);
    lua_createtable(L, 2, 0);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 1);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 2);
    lc_getupvalue(L, ((-10002) - (1)), 1, 117);
    lua_call(L, 4, (-1));
    return (lua_gettop(L) - lc78);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_o(lua_State *L) {
  lua_settop(L, 0);
  lua_pushboolean(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 2, 116);
  lua_insert(L, -2);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, -3);
  lua_settop(L, -(1) - 1);
  const int lc80 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 118);
  lc_getupvalue(L, ((-10002) - (1)), 3, 51);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc80);
}
static inline int lcf1_u(lua_State *L) {
  lua_settop(L, 0);
  lua_createtable(L, 0, 0);
  lua_getfield(L, (-10001), "pairs");
  lc_getupvalue(L, ((-10002) - (1)), 0, 121);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if ((lua_type(L, (-1)) == 0)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);
    lua_pushboolean(L, 1);
    lua_pushvalue(L, 5);
    lua_insert(L, -2);
    lua_settable(L, 1);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "pairs");
  lc_getupvalue(L, ((-10002) - (1)), 2, 115);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if ((lua_type(L, (-1)) == 0)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);
    lua_pushboolean(L, 1);
    lua_pushvalue(L, 5);
    lua_insert(L, -2);
    lua_settable(L, 1);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1_d(lua_State *L) {
  lua_checkstack(L, 29);
  lua_settop(L, 4);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 115);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 116);
  lua_pushvalue(L, 4);
  lua_rawseti(L, -2, 117);
  lc_getupvalue(L, 5, 0, 115);
  lua_pushnil(L);
  const int lc64 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc64);
  const int lc65 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc65) {
    lua_createtable(L, 0, 0);
    lc_setupvalue(L, 5, 0, 115);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, 5, 0, 116);
  lua_pushnil(L);
  const int lc67 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc67);
  const int lc68 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc68) {
    lua_createtable(L, 2, 0);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 1);
    lua_pushboolean(L, 0);
    lua_rawseti(L, -2, 2);
    lc_setupvalue(L, 5, 0, 116);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, 5, 0, 117);
  lua_pushnil(L);
  const int lc70 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc70);
  const int lc71 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc71) {
    lua_createtable(L, 0, 0);
    lc_setupvalue(L, 5, 0, 117);
  }
  lua_settop(L, 5);
  lc_newclosuretable(L, 5);
  lua_settop(L, (lua_gettop(L) + 3));
  lua_rawseti(L, 6, 118);
  lua_rawseti(L, 6, 119);
  lua_rawseti(L, 6, 120);
  lua_pushvalue(L, 6);
  lua_pushcclosure(L, lcf1_r, 1);
  lc_setupvalue(L, 6, 0, 119);
  lua_pushvalue(L, 6);
  lua_pushcclosure(L, lcf2_n, 1);
  lc_setupvalue(L, 6, 0, 118);
  lc_newclosuretable(L, 6);
  lua_createtable(L, 0, 0);
  lua_rawseti(L, 7, 121);
  lua_pushvalue(L, 1);
  lc_setupvalue(L, 7, 1, 120);
  lua_pushvalue(L, 7);
  lua_pushcclosure(L, lcf2_o, 1);
  lua_pushvalue(L, 7);
  lua_pushcclosure(L, lcf1_u, 1);
  lua_pushnumber(L, 0);
  while (1) {
    lc_getupvalue(L, 7, 3, 27);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lua_pushnumber(L, 32);
      const int lc84 = lua_lessthan(L, 10, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc84);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 7, 5, 1);
    lc_getupvalue(L, 7, 2, 117);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 2, 0);
    lc_getupvalue(L, 7, 3, 24);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 1, 1);
    lc_setupvalue(L, 7, 1, 120);
    lua_pushnumber(L, 1);
    lc_add(L, 10, -1);
    lua_remove(L, -2);
    lua_replace(L, 10);
  }
  lua_settop(L, 10);
  lua_settop(L, -(1) - 1);
  while (1) {
    lc_getupvalue(L, 7, 3, 27);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 7, 3, 3);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 1, 1);
    lc_getupvalue(L, 7, 2, 115);
    lua_pushvalue(L, 10);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushboolean(L, 1);
    const int lc87 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc87);
    const int lc88 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc88) {
      const int lc89 = lua_gettop(L);
      lua_pushvalue(L, 8);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc89);
    }
    lua_settop(L, 10);
    lc_getupvalue(L, 7, 0, 121);
    lua_pushvalue(L, 10);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushboolean(L, 1);
    const int lc91 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc91);
    const int lc92 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc92) {
      lua_pushboolean(L, 1);
      lc_getupvalue(L, 7, 2, 116);
      lua_insert(L, -2);
      lua_pushnumber(L, 1);
      lua_insert(L, -2);
      lua_settable(L, -3);
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 7, 3, 80);
      lc_getupvalue(L, 7, 1, 120);
      lua_call(L, 1, 1);
      const int lc94 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc94) {
        const int lc95 = lua_gettop(L);
        lua_pushvalue(L, 8);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc95);
      } else {
        lc_getupvalue(L, 7, 3, 71);
        lc_getupvalue(L, 7, 1, 120);
        lua_call(L, 1, 1);
        const int lc97 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc97) {
          lc_getupvalue(L, 7, 3, 70);
          lc_getupvalue(L, 7, 1, 120);
          lua_call(L, 1, 1);
          lc_getupvalue(L, 7, 3, 69);
          lc_getupvalue(L, 7, 1, 120);
          lua_call(L, 1, 1);
          lua_createtable(L, 8, 0);
          lc_getupvalue(L, 7, 3, 50);
          lua_rawseti(L, -2, 1);
          lc_getupvalue(L, 7, 3, 49);
          lua_rawseti(L, -2, 2);
          lc_getupvalue(L, 7, 3, 48);
          lua_rawseti(L, -2, 3);
          lc_getupvalue(L, 7, 3, 47);
          lua_rawseti(L, -2, 4);
          lc_getupvalue(L, 7, 3, 46);
          lua_rawseti(L, -2, 5);
          lc_getupvalue(L, 7, 3, 45);
          lua_rawseti(L, -2, 6);
          lc_getupvalue(L, 7, 3, 44);
          lua_rawseti(L, -2, 7);
          lc_getupvalue(L, 7, 3, 43);
          lua_rawseti(L, -2, 8);
          lua_pushboolean(L, 0);
          lua_getfield(L, (-10001), "ipairs");
          lua_pushvalue(L, 13);
          lua_call(L, 1, 3);
          while (1) {
            lua_pushvalue(L, -3);
            lua_pushvalue(L, -3);
            lua_pushvalue(L, -3);
            lua_call(L, 2, 2);
            if ((lua_type(L, (-2)) == 0)) {
              break;
            }
            lua_pushvalue(L, -2);
            lua_replace(L, -4);
            lc_getupvalue(L, 7, 3, 4);
            lua_pushvalue(L, 19);
            lua_pushvalue(L, 11);
            lua_call(L, 2, 1);
            const int lc100 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc100) {
              lua_pushboolean(L, 1);
              lua_replace(L, 14);
              break;
            }
            lua_settop(L, 19);
            lua_settop(L, -(2) - 1);
          }
          lua_settop(L, 14);
          if (lua_toboolean(L, 14)) {
            lc_getupvalue(L, 7, 3, 113);
            const double lc102 = lua_objlen(L, 12);
            lua_pushnumber(L, lc102);
            lua_pushnumber(L, 1);
            const int lc103 = lua_equal(L, -2, -1);
            lua_settop(L, -(2) - 1);
            lua_pushboolean(L, lc103);
            lua_call(L, 1, 0);
            lc_getupvalue(L, 7, 3, 113);
            lc_getupvalue(L, 7, 2, 116);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lua_pushboolean(L, 0);
            const int lc104 = lua_equal(L, -2, -1);
            lua_settop(L, -(2) - 1);
            lua_pushboolean(L, lc104);
            lua_call(L, 1, 0);
            lc_getupvalue(L, 7, 3, 25);
            lua_pushnumber(L, 1);
            lua_gettable(L, 12);
            lua_pushvalue(L, 9);
            lua_call(L, 0, 1);
            lc_getupvalue(L, 7, 2, 116);
            lua_call(L, 3, 1);
            lc_getupvalue(L, 7, 2, 116);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            const int lc106 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc106) {
              const int lc107 = lua_gettop(L);
              lc_getupvalue(L, 7, 1, 118);
              const int lc108 = lua_gettop(L);
              lc_getupvalue(L, 7, 3, 72);
              lua_pushvalue(L, 11);
              lua_createtable(L, 1, 0);
              lua_pushvalue(L, 15);
              lua_rawseti(L, -2, 1);
              lua_call(L, 2, (-1));
              lua_call(L, (lua_gettop(L) - lc108), (-1));
              return (lua_gettop(L) - lc107);
            } else {
              const int lc109 = lua_gettop(L);
              lc_getupvalue(L, 7, 3, 114);
              lua_call(L, 0, (-1));
              return (lua_gettop(L) - lc109);
            }
            lua_settop(L, 15);
          }
          lua_settop(L, 14);
          lc_getupvalue(L, 7, 3, 4);
          lua_pushvalue(L, 11);
          lc_getupvalue(L, 7, 3, 42);
          lua_call(L, 2, 1);
          const int lc111 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc111) {
            const int lc112 = lua_gettop(L);
            lua_pushvalue(L, 8);
            lua_call(L, 0, (-1));
            return (lua_gettop(L) - lc112);
          } else {
            lc_getupvalue(L, 7, 3, 4);
            lua_pushvalue(L, 11);
            lc_getupvalue(L, 7, 3, 41);
            lua_call(L, 2, 1);
            const int lc114 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc114) {
              const int lc115 = lua_gettop(L);
              lua_pushvalue(L, 8);
              lua_call(L, 0, (-1));
              return (lua_gettop(L) - lc115);
            } else {
              lc_getupvalue(L, 7, 3, 4);
              lua_pushvalue(L, 11);
              lc_getupvalue(L, 7, 3, 40);
              lua_call(L, 2, 1);
              const int lc117 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc117) {
                const int lc118 = lua_gettop(L);
                lua_pushvalue(L, 8);
                lua_call(L, 0, (-1));
                return (lua_gettop(L) - lc118);
              } else {
                lc_getupvalue(L, 7, 3, 4);
                lua_pushvalue(L, 11);
                lc_getupvalue(L, 7, 3, 39);
                lua_call(L, 2, 1);
                const int lc120 = lua_toboolean(L, -1);
                lua_settop(L, -(1) - 1);
                if (lc120) {
                  lc_getupvalue(L, 7, 3, 113);
                  const double lc121 = lua_objlen(L, 12);
                  lua_pushnumber(L, lc121);
                  lua_pushnumber(L, 3);
                  const int lc122 = lua_equal(L, -2, -1);
                  lua_settop(L, -(2) - 1);
                  lua_pushboolean(L, lc122);
                  lua_call(L, 1, 0);
                  lc_getupvalue(L, 7, 3, 113);
                  lc_getupvalue(L, 7, 2, 116);
                  lua_pushnumber(L, 2);
                  lua_gettable(L, -2);
                  lua_remove(L, -2);
                  lua_pushboolean(L, 0);
                  const int lc123 = lua_equal(L, -2, -1);
                  lua_settop(L, -(2) - 1);
                  lua_pushboolean(L, lc123);
                  lua_call(L, 1, 0);
                  lc_getupvalue(L, 7, 3, 25);
                  lua_pushnumber(L, 1);
                  lua_gettable(L, 12);
                  lua_pushvalue(L, 9);
                  lua_call(L, 0, 1);
                  lc_getupvalue(L, 7, 2, 116);
                  lua_call(L, 3, 1);
                  lc_getupvalue(L, 7, 2, 116);
                  lua_pushnumber(L, 2);
                  lua_gettable(L, -2);
                  lua_remove(L, -2);
                  const int lc125 = lua_toboolean(L, -1);
                  lua_settop(L, -(1) - 1);
                  if (lc125) {
                    const int lc126 = lua_gettop(L);
                    lc_getupvalue(L, 7, 1, 118);
                    const int lc127 = lua_gettop(L);
                    lc_getupvalue(L, 7, 3, 72);
                    lc_getupvalue(L, 7, 3, 39);
                    lua_createtable(L, 3, 0);
                    lua_pushvalue(L, 15);
                    lua_rawseti(L, -2, 1);
                    lua_pushnumber(L, 2);
                    lua_gettable(L, 12);
                    lua_rawseti(L, -2, 2);
                    lua_pushnumber(L, 3);
                    lua_gettable(L, 12);
                    lua_rawseti(L, -2, 3);
                    lua_call(L, 2, (-1));
                    lua_call(L, (lua_gettop(L) - lc127), (-1));
                    return (lua_gettop(L) - lc126);
                  } else {
                    const int lc128 = lua_gettop(L);
                    lc_getupvalue(L, 7, 3, 114);
                    lua_call(L, 0, (-1));
                    return (lua_gettop(L) - lc128);
                  }
                  lua_settop(L, 15);
                }
                lua_settop(L, 14);
              }
              lua_settop(L, 14);
            }
            lua_settop(L, 14);
          }
          lua_settop(L, 14);
          const int lc129 = lua_gettop(L);
          lc_getupvalue(L, 7, 3, 114);
          lua_call(L, 0, (-1));
          return (lua_gettop(L) - lc129);
        } else {
          lc_getupvalue(L, 7, 3, 76);
          lc_getupvalue(L, 7, 1, 120);
          lua_call(L, 1, 1);
          const int lc131 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc131) {
            const int lc132 = lua_gettop(L);
            lua_pushvalue(L, 8);
            lua_call(L, 0, (-1));
            return (lua_gettop(L) - lc132);
          } else {
            lc_getupvalue(L, 7, 3, 67);
            lc_getupvalue(L, 7, 1, 120);
            lua_call(L, 1, 1);
            const int lc134 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc134) {
              const int lc135 = lua_gettop(L);
              lua_pushvalue(L, 8);
              lua_call(L, 0, (-1));
              return (lua_gettop(L) - lc135);
            }
            lua_settop(L, 10);
          }
          lua_settop(L, 10);
        }
        lua_settop(L, 10);
      }
      lua_settop(L, 10);
      const int lc136 = lua_gettop(L);
      lc_getupvalue(L, 7, 3, 114);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc136);
    }
    lua_settop(L, 10);
    lua_pushboolean(L, 1);
    lc_getupvalue(L, 7, 0, 121);
    lua_insert(L, -2);
    lua_pushvalue(L, 10);
    lua_insert(L, -2);
    lua_settable(L, -3);
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 7, 5, 1);
    lc_getupvalue(L, 7, 2, 117);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 2, 0);
    lc_getupvalue(L, 7, 3, 24);
    lc_getupvalue(L, 7, 1, 120);
    lua_call(L, 1, 1);
    lc_setupvalue(L, 7, 1, 120);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 9);
  const int lc137 = lua_gettop(L);
  lc_getupvalue(L, 7, 1, 119);
  lc_getupvalue(L, 7, 1, 120);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc137);
}
static inline int lcf1_g(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 29);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_settop(L, (lua_gettop(L) + 1));
  lc_getupvalue(L, ((-10002) - (1)), 0, 113);
  lc_getupvalue(L, ((-10002) - (1)), 0, 83);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 80);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc139 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc139) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 12);
    lc_getupvalue(L, ((-10002) - (1)), 0, 79);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 78);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 1);
    lua_call(L, 3, 1);
    lua_replace(L, 3);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 0, 76);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc141 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc141) {
      lc_getupvalue(L, ((-10002) - (1)), 0, 8);
      lc_getupvalue(L, ((-10002) - (1)), 0, 75);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 74);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 73);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushvalue(L, 1);
      lua_call(L, 4, 1);
      lua_replace(L, 3);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 71);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      const int lc143 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc143) {
        lc_getupvalue(L, ((-10002) - (1)), 0, 9);
        lc_getupvalue(L, ((-10002) - (1)), 0, 70);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lc_getupvalue(L, ((-10002) - (1)), 0, 69);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushvalue(L, 1);
        lua_call(L, 3, 1);
        lua_replace(L, 3);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 0, 67);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        const int lc145 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc145) {
          lc_getupvalue(L, ((-10002) - (1)), 0, 10);
          lc_getupvalue(L, ((-10002) - (1)), 0, 66);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lc_getupvalue(L, ((-10002) - (1)), 0, 65);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushvalue(L, 1);
          lua_call(L, 3, 1);
          lua_replace(L, 3);
        } else {
          lua_pushvalue(L, 2);
          lua_replace(L, 3);
        }
        lua_settop(L, 3);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 0, 29);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lua_replace(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 0, 60);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 3);
  lua_call(L, 2, 0);
  lua_pushvalue(L, 3);
  return 1;
}
static inline int lcf2_r(lua_State *L) {
  lua_settop(L, 1);
  const int lc146 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 25);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc146);
}
static inline int lcf1_ve(lua_State *L) {
  lua_settop(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 27);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 100);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 23);
    const int lc148 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc148), 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1_pe(lua_State *L) {
  lua_settop(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 100);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 100);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1_ot(lua_State *L) {
  lua_settop(L, 4);
  lua_createtable(L, 0, 0);
  lua_createtable(L, 0, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 29);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 1);
  while (1) {
    lua_pushboolean(L, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 88);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    const int lc153 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc153) {
      const int lc154 = lua_gettop(L);
      lua_pushvalue(L, 4);
      lua_pushvalue(L, 6);
      lua_pushvalue(L, 5);
      lua_call(L, 2, (-1));
      return (lua_gettop(L) - lc154);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 100);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc156 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc156) {
        lc_getupvalue(L, ((-10002) - (1)), 2, 1);
        const int lc157 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lc_getupvalue(L, ((-10002) - (1)), 0, 99);
        lua_pushvalue(L, 7);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc157), 0);
        lc_getupvalue(L, ((-10002) - (1)), 0, 98);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        lua_replace(L, 7);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 0, 92);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        const int lc159 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc159) {
          lc_getupvalue(L, ((-10002) - (1)), 2, 1);
          const int lc160 = lua_gettop(L);
          lua_pushvalue(L, 5);
          lc_getupvalue(L, ((-10002) - (1)), 0, 91);
          lua_pushvalue(L, 7);
          lua_call(L, 1, (-1));
          lua_call(L, (lua_gettop(L) - lc160), 0);
          lc_getupvalue(L, ((-10002) - (1)), 0, 90);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lua_replace(L, 7);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 0, 27);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          const int lc162 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc162) {
            if (lua_toboolean(L, 8)) {
              lua_pushboolean(L, 0);
              lua_replace(L, 8);
              lc_getupvalue(L, ((-10002) - (1)), 0, 24);
              lua_pushvalue(L, 7);
              lua_call(L, 1, 1);
              lua_replace(L, 7);
            } else {
              const int lc164 = lua_gettop(L);
              lua_pushvalue(L, 3);
              lua_call(L, 0, (-1));
              return (lua_gettop(L) - lc164);
            }
            lua_settop(L, 8);
          } else {
            const int lc165 = lua_gettop(L);
            lua_pushvalue(L, 2);
            lua_call(L, 0, (-1));
            return (lua_gettop(L) - lc165);
          }
          lua_settop(L, 8);
        }
        lua_settop(L, 8);
      }
      lua_settop(L, 8);
    }
    lua_settop(L, 8);
  }
  lua_settop(L, 8);
  return 0;
}
static inline int lcf1_m(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc167 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc167) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 21);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 26);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc169 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc169) {
    lua_pushnil(L);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc171 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc171) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 86);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc173 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc173) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 85);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 26);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc175 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc175) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 21);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_replace(L, 2);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 26);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc177 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc177) {
    lua_pushnil(L);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 96);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc179 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc179) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  const int lc180 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 94);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 56);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc180);
}
static inline int lcf1_be(lua_State *L) {
  lua_settop(L, 3);
  lua_createtable(L, 0, 0);
  lua_pushnumber(L, 0);
  while (1) {
    const double lc182 = lua_objlen(L, 1);
    lua_pushnumber(L, lc182);
    const int lc183 = lua_lessthan(L, 5, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc183);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 5, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc185 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc185) {
      lua_pushvalue(L, 2);
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushvalue(L, 3);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushnumber(L, 2);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_replace(L, 5);
      while (1) {
        const double lc187 = lua_objlen(L, 1);
        lua_pushnumber(L, lc187);
        const int lc188 = lua_lessthan(L, 5, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc188);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lua_pushnumber(L, 0);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_gettable(L, 1);
        lua_pushnumber(L, 0);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 4);
        lua_pushnumber(L, 1);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_gettable(L, 1);
        lua_pushnumber(L, 1);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 4);
        lua_pushnumber(L, 2);
        lc_add(L, 5, -1);
        lua_remove(L, -2);
        lua_replace(L, 5);
      }
      lua_settop(L, 5);
      lua_pushvalue(L, 4);
      return 1;
    } else {
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      lua_pushnumber(L, 0);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_insert(L, -2);
      lua_settable(L, 4);
    }
    lua_settop(L, 5);
    lua_pushnumber(L, 2);
    lc_add(L, 5, -1);
    lua_remove(L, -2);
    lua_replace(L, 5);
  }
  lua_settop(L, 5);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 2);
  const double lc189 = lua_objlen(L, 1);
  lua_pushnumber(L, lc189);
  lua_pushnumber(L, 0);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_insert(L, -2);
  lua_settable(L, 4);
  lua_pushvalue(L, 3);
  const double lc190 = lua_objlen(L, 1);
  lua_pushnumber(L, lc190);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_insert(L, -2);
  lua_settable(L, 4);
  lua_pushvalue(L, 4);
  return 1;
}
static inline int lcf1_Le(lua_State *L) {
  lua_settop(L, 3);
  lua_pushnumber(L, 0);
  while (1) {
    const double lc192 = lua_objlen(L, 1);
    lua_pushnumber(L, lc192);
    const int lc193 = lua_lessthan(L, 4, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc193);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 4, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc195 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc195) {
      lua_pushnumber(L, 1);
      lc_add(L, 4, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      return 1;
    }
    lua_settop(L, 4);
    lua_pushnumber(L, 2);
    lc_add(L, 4, -1);
    lua_remove(L, -2);
    lua_replace(L, 4);
  }
  lua_settop(L, 4);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 3);
  return 1;
}
static inline int lcf1_Be(lua_State *L) {
  lua_settop(L, 2);
  lua_pushnumber(L, 0);
  while (1) {
    const double lc197 = lua_objlen(L, 1);
    lua_pushnumber(L, lc197);
    const int lc198 = lua_lessthan(L, 3, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc198);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 4);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    const int lc200 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc200) {
      lua_pushnumber(L, 1);
      lc_add(L, 3, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 1);
      return 1;
    }
    lua_settop(L, 3);
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_settop(L, -(1) - 1);
  const int lc201 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc201);
}
static inline int lcf1_R(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 89);
  lua_pushnumber(L, 0);
  while (1) {
    const double lc203 = lua_objlen(L, 1);
    lua_pushnumber(L, lc203);
    const int lc204 = lua_lessthan(L, 3, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc204);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 93);
    lc_getupvalue(L, ((-10002) - (1)), 0, 30);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_call(L, 2, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    lua_replace(L, 2);
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_settop(L, -(1) - 1);
  const int lc205 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 87);
  const int lc206 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 53);
  lc_getupvalue(L, ((-10002) - (1)), 0, 30);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc206), (-1));
  return (lua_gettop(L) - lc205);
}
static inline int lcf1_Ue(lua_State *L) {
  lua_settop(L, 2);
  lua_pushnumber(L, 0);
  while (1) {
    const double lc208 = lua_objlen(L, 1);
    lua_pushnumber(L, lc208);
    const int lc209 = lua_lessthan(L, 3, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc209);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 2);
    lua_pushnumber(L, 0);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_pushnumber(L, 1);
    lc_add(L, -2, -1);
    lua_remove(L, -2);
    lua_remove(L, -2);
    lua_gettable(L, 1);
    lua_call(L, 2, 0);
    lua_pushnumber(L, 2);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_settop(L, -(1) - 1);
  return 0;
}
static inline int lcf2_t(lua_State *L) {
  lua_settop(L, 0);
  const int lc215 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 32);
  const int lc216 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 57);
  lc_getupvalue(L, ((-10002) - (1)), 3, 30);
  const int lc217 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 36);
  lc_getupvalue(L, ((-10002) - (1)), 3, 30);
  const int lc218 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 40);
  lc_getupvalue(L, ((-10002) - (1)), 3, 30);
  lc_getupvalue(L, ((-10002) - (1)), 3, 14);
  lc_getupvalue(L, ((-10002) - (1)), 2, 122);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 1, 124);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc218), (-1));
  lua_call(L, (lua_gettop(L) - lc217), (-1));
  lua_call(L, (lua_gettop(L) - lc216), (-1));
  return (lua_gettop(L) - lc215);
}
static inline int lcf222(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 2, 123);
  return 1;
}
static inline int lcf292(lua_State *L) {
  lua_settop(L, 2);
  const double lc224 = lua_objlen(L, 1);
  lua_pushnumber(L, lc224);
  lua_pushnumber(L, 0);
  const int lc225 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc225);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc226 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc226) {
    lua_getfield(L, (-10001), "error");
    lua_pushlstring(L,
                    ""
                    "WIP",
                    (sizeof("WIP") / sizeof(char)) - 1);
    lua_call(L, 1, 0);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 3, 4);
  lua_pushnumber(L, 1);
  lua_gettable(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 3, 35);
  lua_call(L, 2, 1);
  const int lc228 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc228) {
    const double lc230 = lua_objlen(L, 2);
    lua_pushnumber(L, lc230);
    lua_pushnumber(L, 1);
    const int lc231 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc231);
    const int lc232 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc232) {
      const int lc233 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 0, 125);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc233);
    }
    lua_settop(L, 2);
    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    lua_createtable(L, 0, 0);
    lua_pushnumber(L, 2);
    while (1) {
      const double lc235 = lua_objlen(L, 2);
      lua_pushnumber(L, lc235);
      const int lc236 = lua_lessthan(L, 5, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc236);
      if (!(lua_toboolean(L, -1))) {
        break;
      }
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 5, 1);
      lua_pushvalue(L, 4);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_gettable(L, 2);
      lua_call(L, 2, 0);
      lua_pushnumber(L, 1);
      lc_add(L, 5, -1);
      lua_remove(L, -2);
      lua_replace(L, 5);
    }
    lua_settop(L, 5);
    lua_settop(L, -(1) - 1);
    const int lc237 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 3, 77);
    lc_getupvalue(L, ((-10002) - (1)), 2, 122);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 4);
    lua_call(L, 3, (-1));
    return (lua_gettop(L) - lc237);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 3, 4);
    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    lc_getupvalue(L, ((-10002) - (1)), 3, 34);
    lua_call(L, 2, 1);
    const int lc239 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc239) {
      const double lc241 = lua_objlen(L, 2);
      lua_pushnumber(L, lc241);
      lua_pushnumber(L, 1);
      const int lc242 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc242);
      const int lc243 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc243) {
        const int lc244 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc244);
      }
      lua_settop(L, 2);
      lc_getupvalue(L, ((-10002) - (1)), 3, 23);
      const int lc245 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 81);
      lc_getupvalue(L, ((-10002) - (1)), 2, 122);
      lua_pushnumber(L, 2);
      lua_gettable(L, 2);
      lua_call(L, 2, (-1));
      lua_call(L, (lua_gettop(L) - lc245), 1);
      lc_getupvalue(L, ((-10002) - (1)), 3, 86);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc247 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc247) {
        const int lc248 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc248);
      }
      lua_settop(L, 3);
      lc_getupvalue(L, ((-10002) - (1)), 3, 24);
      const int lc249 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 85);
      lua_pushvalue(L, 3);
      lua_call(L, 1, (-1));
      lua_call(L, (lua_gettop(L) - lc249), 1);
      lc_getupvalue(L, ((-10002) - (1)), 3, 27);
      lua_pushvalue(L, 4);
      lua_call(L, 1, 1);
      const int lc251 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc251) {
        lc_getupvalue(L, ((-10002) - (1)), 2, 123);
        return 1;
      }
      lua_settop(L, 4);
      lc_getupvalue(L, ((-10002) - (1)), 3, 96);
      lua_pushvalue(L, 4);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc253 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc253) {
        const int lc254 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc254);
      }
      lua_settop(L, 4);
      lc_getupvalue(L, ((-10002) - (1)), 3, 94);
      lua_pushvalue(L, 4);
      lc_getupvalue(L, ((-10002) - (1)), 3, 54);
      lua_call(L, 2, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc256 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc256) {
        const int lc257 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc257);
      }
      lua_settop(L, 4);
      lc_getupvalue(L, ((-10002) - (1)), 3, 24);
      const int lc258 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 84);
      lua_pushvalue(L, 3);
      lua_call(L, 1, (-1));
      lua_call(L, (lua_gettop(L) - lc258), 1);
      lc_getupvalue(L, ((-10002) - (1)), 3, 27);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      const int lc260 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc260) {
        lc_getupvalue(L, ((-10002) - (1)), 2, 123);
        return 1;
      }
      lua_settop(L, 5);
      lc_getupvalue(L, ((-10002) - (1)), 3, 92);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc262 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc262) {
        const int lc263 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc263);
      }
      lua_settop(L, 5);
      lc_getupvalue(L, ((-10002) - (1)), 3, 91);
      lua_pushvalue(L, 5);
      lua_call(L, 1, 1);
      lc_getupvalue(L, ((-10002) - (1)), 3, 24);
      const int lc264 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 90);
      lua_pushvalue(L, 5);
      lua_call(L, 1, (-1));
      lua_call(L, (lua_gettop(L) - lc264), 1);
      lc_getupvalue(L, ((-10002) - (1)), 3, 27);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc266 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc266) {
        lc_getupvalue(L, ((-10002) - (1)), 2, 123);
        return 1;
      }
      lua_settop(L, 7);
      lc_getupvalue(L, ((-10002) - (1)), 3, 88);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc268 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc268) {
        const int lc269 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 125);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc269);
      }
      lua_settop(L, 7);
      lua_createtable(L, 1, 0);
      const int lc270 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 14);
      lc_getupvalue(L, ((-10002) - (1)), 2, 122);
      lua_call(L, 1, (-1));
      while ((lua_gettop(L) > lc270)) {
        lua_rawseti(L, lc270, (0 + (lua_gettop(L) - lc270)));
      }
      lua_pushnumber(L, 2);
      while (1) {
        const double lc272 = lua_objlen(L, 2);
        lua_pushnumber(L, lc272);
        const int lc273 = lua_lessthan(L, 9, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc273);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lc_getupvalue(L, ((-10002) - (1)), 5, 1);
        lua_pushvalue(L, 8);
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_gettable(L, 2);
        lua_call(L, 2, 0);
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_replace(L, 9);
      }
      lua_settop(L, 9);
      lua_settop(L, -(1) - 1);
      const int lc274 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 3, 68);
      lua_pushvalue(L, 6);
      lua_pushvalue(L, 8);
      lua_call(L, 2, (-1));
      return (lua_gettop(L) - lc274);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 3, 4);
      lua_pushnumber(L, 1);
      lua_gettable(L, 2);
      lc_getupvalue(L, ((-10002) - (1)), 3, 36);
      lua_call(L, 2, 1);
      const int lc276 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc276) {
        const double lc278 = lua_objlen(L, 2);
        lua_pushnumber(L, lc278);
        lua_pushnumber(L, 1);
        const int lc279 = lua_equal(L, -2, -1);
        lua_settop(L, -(2) - 1);
        lua_pushboolean(L, lc279);
        const int lc280 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc280) {
          const int lc281 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 0, 125);
          lua_call(L, 0, (-1));
          return (lua_gettop(L) - lc281);
        }
        lua_settop(L, 2);
        lua_pushnumber(L, 2);
        lua_gettable(L, 2);
        lua_createtable(L, 0, 0);
        lua_pushnumber(L, 2);
        while (1) {
          const double lc283 = lua_objlen(L, 2);
          lua_pushnumber(L, lc283);
          const int lc284 = lua_lessthan(L, 5, -1);
          lua_settop(L, -(1) - 1);
          lua_pushboolean(L, lc284);
          if (!(lua_toboolean(L, -1))) {
            break;
          }
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, ((-10002) - (1)), 5, 1);
          const int lc285 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lc_getupvalue(L, ((-10002) - (1)), 3, 81);
          lc_getupvalue(L, ((-10002) - (1)), 2, 122);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_gettable(L, 2);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc285), 0);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_replace(L, 5);
        }
        lua_settop(L, 5);
        lua_settop(L, -(1) - 1);
        const int lc286 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 3, 72);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 4);
        lua_call(L, 2, (-1));
        return (lua_gettop(L) - lc286);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 3, 81);
        lc_getupvalue(L, ((-10002) - (1)), 2, 122);
        lua_pushnumber(L, 1);
        lua_gettable(L, 2);
        lua_call(L, 2, 1);
        lua_createtable(L, 0, 0);
        lua_pushnumber(L, 1);
        while (1) {
          const double lc288 = lua_objlen(L, 2);
          lua_pushnumber(L, lc288);
          const int lc289 = lua_lessthan(L, 5, -1);
          lua_settop(L, -(1) - 1);
          lua_pushboolean(L, lc289);
          if (!(lua_toboolean(L, -1))) {
            break;
          }
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, ((-10002) - (1)), 5, 1);
          const int lc290 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lc_getupvalue(L, ((-10002) - (1)), 3, 81);
          lc_getupvalue(L, ((-10002) - (1)), 2, 122);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_gettable(L, 2);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc290), 0);
          lua_pushnumber(L, 1);
          lc_add(L, 5, -1);
          lua_remove(L, -2);
          lua_replace(L, 5);
        }
        lua_settop(L, 5);
        lua_settop(L, -(1) - 1);
        const int lc291 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 3, 68);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 4);
        lua_call(L, 2, (-1));
        return (lua_gettop(L) - lc291);
      }
      lua_settop(L, 2);
    }
    lua_settop(L, 2);
  }
  lua_settop(L, 2);
  return 0;
}
static inline int lcf1_it(lua_State *L) {
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 122);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 123);
  lc_newclosuretable(L, 4);
  lc_getupvalue(L, 4, 1, 24);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_rawseti(L, 5, 124);
  lc_getupvalue(L, 5, 2, 27);
  lc_getupvalue(L, 5, 0, 124);
  lua_call(L, 1, 1);
  const int lc213 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc213) {
    lc_getupvalue(L, 5, 1, 123);
    return 1;
  }
  lua_settop(L, 5);
  lc_newclosuretable(L, 5);
  lua_pushvalue(L, 6);
  lua_pushcclosure(L, lcf2_t, 1);
  lua_rawseti(L, 6, 125);
  lc_getupvalue(L, 6, 3, 92);
  lc_getupvalue(L, 6, 1, 124);
  lua_call(L, 1, 1);
  const int lc220 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc220) {
    const int lc221 = lua_gettop(L);
    lc_getupvalue(L, 6, 3, 20);
    lc_getupvalue(L, 6, 1, 124);
    lc_getupvalue(L, 6, 0, 125);
    lua_pushvalue(L, 6);
    lua_pushcclosure(L, lcf222, 1);
    lua_pushvalue(L, 6);
    lua_pushcclosure(L, lcf292, 1);
    lua_call(L, 4, (-1));
    return (lua_gettop(L) - lc221);
  } else {
    lc_getupvalue(L, 6, 3, 88);
    lc_getupvalue(L, 6, 1, 124);
    lua_call(L, 1, 1);
    const int lc294 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc294) {
      lc_getupvalue(L, 6, 1, 124);
      return 1;
    }
    lua_settop(L, 6);
  }
  lua_settop(L, 6);
  lc_getupvalue(L, 6, 3, 19);
  lc_getupvalue(L, 6, 1, 124);
  lua_call(L, 1, 1);
  lua_pushnil(L);
  const int lc296 = lua_equal(L, 7, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc296);
  const int lc297 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc297) {
    lc_getupvalue(L, 6, 2, 123);
    return 1;
  }
  lua_settop(L, 7);
  lua_pushboolean(L, 1);
  const int lc299 = lua_equal(L, 7, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc299);
  const int lc300 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc300) {
    const int lc301 = lua_gettop(L);
    lc_getupvalue(L, 6, 3, 16);
    const int lc302 = lua_gettop(L);
    lc_getupvalue(L, 6, 2, 122);
    lc_getupvalue(L, 6, 1, 124);
    lc_getupvalue(L, 6, 0, 125);
    lua_call(L, 0, (-1));
    lua_call(L, (lua_gettop(L) - lc302), (-1));
    return (lua_gettop(L) - lc301);
  }
  lua_settop(L, 7);
  const int lc303 = lua_gettop(L);
  lc_getupvalue(L, 6, 0, 125);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc303);
}
static inline int lcf3_o(lua_State *L) {
  lua_settop(L, 0);
  const int lc305 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 32);
  const int lc306 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 57);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc307 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 36);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc308 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 41);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc309 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 126);
  lc_getupvalue(L, ((-10002) - (1)), 1, 31);
  lc_getupvalue(L, ((-10002) - (1)), 0, 127);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc309), (-1));
  lua_call(L, (lua_gettop(L) - lc308), (-1));
  lua_call(L, (lua_gettop(L) - lc307), (-1));
  lua_call(L, (lua_gettop(L) - lc306), (-1));
  return (lua_gettop(L) - lc305);
}
static inline int lcf1_nt(lua_State *L) {
  lua_checkstack(L, 25);
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 126);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 127);
  lua_pushvalue(L, 4);
  lua_pushcclosure(L, lcf3_o, 1);
  lc_getupvalue(L, 4, 1, 24);
  lc_getupvalue(L, 4, 0, 126);
  lua_call(L, 1, 1);
  lc_setupvalue(L, 4, 0, 126);
  lc_getupvalue(L, 4, 1, 27);
  lc_getupvalue(L, 4, 0, 126);
  lua_call(L, 1, 1);
  const int lc311 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc311) {
    lua_pushvalue(L, 3);
    return 1;
  }
  lua_settop(L, 5);
  lc_getupvalue(L, 4, 1, 86);
  lc_getupvalue(L, 4, 0, 126);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc313 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc313) {
    const int lc314 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc314);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, 4, 1, 23);
  const int lc315 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 85);
  lc_getupvalue(L, 4, 0, 126);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc315), 1);
  lc_getupvalue(L, 4, 1, 96);
  lua_pushvalue(L, 6);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 4, 1, 94);
    lua_pushvalue(L, 6);
    lc_getupvalue(L, 4, 1, 55);
    lua_call(L, 2, 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc317 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc317) {
    const int lc318 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc318);
  }
  lua_settop(L, 6);
  lc_getupvalue(L, 4, 1, 23);
  const int lc319 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 84);
  lc_getupvalue(L, 4, 0, 126);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc319), 1);
  lc_getupvalue(L, 4, 1, 92);
  lua_pushvalue(L, 7);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc321 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc321) {
    const int lc322 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc322);
  }
  lua_settop(L, 7);
  lc_getupvalue(L, 4, 1, 64);
  const int lc323 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 91);
  lua_pushvalue(L, 7);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc323), 1);
  lc_getupvalue(L, 4, 1, 23);
  const int lc324 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 90);
  lua_pushvalue(L, 7);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc324), 1);
  lc_getupvalue(L, 4, 1, 92);
  lua_pushvalue(L, 9);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 4, 1, 88);
    const int lc326 = lua_gettop(L);
    lc_getupvalue(L, 4, 1, 23);
    const int lc327 = lua_gettop(L);
    lc_getupvalue(L, 4, 1, 90);
    lua_pushvalue(L, 9);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc327), (-1));
    lua_call(L, (lua_gettop(L) - lc326), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc328 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc328) {
    const int lc329 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc329);
  }
  lua_settop(L, 9);
  lc_getupvalue(L, 4, 1, 91);
  lua_pushvalue(L, 9);
  lua_call(L, 1, 1);
  lc_getupvalue(L, 4, 1, 18);
  lua_pushnumber(L, 0);
  while (1) {
    lc_getupvalue(L, 4, 1, 88);
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 4, 1, 19);
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    lua_pushnil(L);
    const int lc332 = lua_equal(L, 13, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc332);
    const int lc333 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc333) {
      lua_pushvalue(L, 3);
      return 1;
    }
    lua_settop(L, 13);
    lua_pushboolean(L, 1);
    const int lc335 = lua_equal(L, 13, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc335);
    const int lc336 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc336) {
      lc_getupvalue(L, 4, 1, 89);
      lc_getupvalue(L, 4, 0, 127);
      const double lc337 = lua_objlen(L, -1);
      lua_settop(L, -(1) - 1);
      lua_pushnumber(L, lc337);
      lua_pushnumber(L, 1);
      lc_sub(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      while (1) {
        lua_pushboolean(L, lc_le(L, 12, 15));
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lc_getupvalue(L, 4, 1, 93);
        lc_getupvalue(L, 4, 0, 127);
        lua_pushnumber(L, 1);
        lc_add(L, 15, -1);
        lua_remove(L, -2);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_pushvalue(L, 14);
        lua_call(L, 2, 1);
        lua_replace(L, 14);
        lua_pushnumber(L, 1);
        lc_sub(L, 15, -1);
        lua_remove(L, -2);
        lua_replace(L, 15);
      }
      lua_settop(L, 15);
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 4, 1, 17);
      lua_pushvalue(L, 11);
      lua_pushvalue(L, 8);
      lua_pushvalue(L, 14);
      lua_call(L, 3, 1);
      lua_replace(L, 11);
      lc_getupvalue(L, 4, 0, 127);
      const double lc339 = lua_objlen(L, -1);
      lua_settop(L, -(1) - 1);
      lua_pushnumber(L, lc339);
      lua_replace(L, 12);
      lc_getupvalue(L, 4, 1, 89);
      lua_replace(L, 8);
    } else {
      lc_getupvalue(L, 4, 1, 92);
      lua_pushvalue(L, 8);
      lua_call(L, 1, 1);
      const int lc341 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc341) {
        lc_getupvalue(L, 4, 0, 127);
        const double lc343 = lua_objlen(L, -1);
        lua_settop(L, -(1) - 1);
        lua_pushnumber(L, lc343);
        const int lc344 = lua_lessthan(L, 12, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc344);
        const int lc345 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc345) {
          lc_getupvalue(L, 4, 0, 127);
          lua_pushnumber(L, 1);
          lc_add(L, 12, -1);
          lua_remove(L, -2);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          lua_pushnumber(L, 1);
          lc_add(L, 12, -1);
          lua_remove(L, -2);
          lua_replace(L, 12);
          lc_getupvalue(L, 4, 1, 17);
          lua_pushvalue(L, 11);
          lc_getupvalue(L, 4, 1, 91);
          lua_pushvalue(L, 8);
          lua_call(L, 1, 1);
          lua_pushvalue(L, 14);
          lua_call(L, 3, 1);
          lua_replace(L, 11);
          lc_getupvalue(L, 4, 1, 90);
          lua_pushvalue(L, 8);
          lua_call(L, 1, 1);
          lua_replace(L, 8);
        } else {
          const int lc346 = lua_gettop(L);
          lua_pushvalue(L, 5);
          lua_call(L, 0, (-1));
          return (lua_gettop(L) - lc346);
        }
        lua_settop(L, 13);
      } else {
        const int lc347 = lua_gettop(L);
        lua_pushvalue(L, 5);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc347);
      }
      lua_settop(L, 13);
    }
    lua_settop(L, 13);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 12);
  lc_getupvalue(L, 4, 0, 127);
  const double lc349 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc349);
  const int lc350 = lua_equal(L, -1, 12);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc350);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc351 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc351) {
    const int lc352 = lua_gettop(L);
    lua_pushvalue(L, 5);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc352);
  }
  lua_settop(L, 12);
  const int lc353 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 81);
  lua_pushvalue(L, 11);
  lua_pushvalue(L, 10);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc353);
}
static inline int lcf2_a(lua_State *L) {
  lua_settop(L, 0);
  const int lc355 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 32);
  const int lc356 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 57);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc357 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 36);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc358 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 128);
  lc_getupvalue(L, ((-10002) - (1)), 1, 31);
  lc_getupvalue(L, ((-10002) - (1)), 0, 129);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc358), (-1));
  lua_call(L, (lua_gettop(L) - lc357), (-1));
  lua_call(L, (lua_gettop(L) - lc356), (-1));
  return (lua_gettop(L) - lc355);
}
static inline int lcf1_ht(lua_State *L) {
  lua_checkstack(L, 20);
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 128);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 129);
  lua_pushvalue(L, 4);
  lua_pushcclosure(L, lcf2_a, 1);
  lua_getfield(L, (-10001), "ipairs");
  lc_getupvalue(L, 4, 1, 11);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lc_getupvalue(L, 4, 1, 4);
    lc_getupvalue(L, 4, 0, 128);
    lua_pushnumber(L, 1);
    lua_gettable(L, 10);
    lua_call(L, 2, 1);
    const int lc361 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc361) {
      lc_getupvalue(L, 4, 0, 129);
      const double lc363 = lua_objlen(L, -1);
      lua_settop(L, -(1) - 1);
      lua_pushnumber(L, lc363);
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      const int lc364 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc364);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc365 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc365) {
        const int lc366 = lua_gettop(L);
        lua_pushvalue(L, 5);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc366);
      }
      lua_settop(L, 10);
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      lua_pushnumber(L, 1);
      const int lc368 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc368);
      const int lc369 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc369) {
        const int lc370 = lua_gettop(L);
        lua_pushnumber(L, 3);
        lua_gettable(L, 10);
        lc_getupvalue(L, 4, 0, 129);
        lua_pushnumber(L, 1);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_pushvalue(L, 5);
        lua_pushvalue(L, 3);
        lua_call(L, 3, (-1));
        return (lua_gettop(L) - lc370);
      } else {
        lua_pushnumber(L, 2);
        lua_gettable(L, 10);
        lua_pushnumber(L, 2);
        const int lc372 = lua_equal(L, -2, -1);
        lua_settop(L, -(2) - 1);
        lua_pushboolean(L, lc372);
        const int lc373 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc373) {
          const int lc374 = lua_gettop(L);
          lua_pushnumber(L, 3);
          lua_gettable(L, 10);
          lc_getupvalue(L, 4, 0, 129);
          lua_pushnumber(L, 1);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          lc_getupvalue(L, 4, 0, 129);
          lua_pushnumber(L, 2);
          lua_gettable(L, -2);
          lua_remove(L, -2);
          lua_pushvalue(L, 5);
          lua_pushvalue(L, 3);
          lua_call(L, 4, (-1));
          return (lua_gettop(L) - lc374);
        } else {
          lua_pushnumber(L, 2);
          lua_gettable(L, 10);
          lua_pushnumber(L, 3);
          const int lc376 = lua_equal(L, -2, -1);
          lua_settop(L, -(2) - 1);
          lua_pushboolean(L, lc376);
          const int lc377 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc377) {
            const int lc378 = lua_gettop(L);
            lua_pushnumber(L, 3);
            lua_gettable(L, 10);
            lc_getupvalue(L, 4, 0, 129);
            lua_pushnumber(L, 1);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lc_getupvalue(L, 4, 0, 129);
            lua_pushnumber(L, 2);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lc_getupvalue(L, 4, 0, 129);
            lua_pushnumber(L, 3);
            lua_gettable(L, -2);
            lua_remove(L, -2);
            lua_pushvalue(L, 5);
            lua_pushvalue(L, 3);
            lua_call(L, 5, (-1));
            return (lua_gettop(L) - lc378);
          }
          lua_settop(L, 10);
        }
        lua_settop(L, 10);
      }
      lua_settop(L, 10);
      const int lc379 = lua_gettop(L);
      lc_getupvalue(L, 4, 1, 114);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc379);
    }
    lua_settop(L, 10);
    lua_settop(L, -(2) - 1);
  }
  lua_settop(L, 5);
  const int lc380 = lua_gettop(L);
  lua_pushvalue(L, 5);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc380);
}
static inline int lcf3_a(lua_State *L) {
  lua_settop(L, 0);
  const int lc382 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 32);
  const int lc383 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 57);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc384 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 35);
  lc_getupvalue(L, ((-10002) - (1)), 1, 30);
  const int lc385 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 14);
  lc_getupvalue(L, ((-10002) - (1)), 0, 130);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 131);
  lc_getupvalue(L, ((-10002) - (1)), 1, 31);
  lc_getupvalue(L, ((-10002) - (1)), 0, 132);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc385), (-1));
  lua_call(L, (lua_gettop(L) - lc384), (-1));
  lua_call(L, (lua_gettop(L) - lc383), (-1));
  return (lua_gettop(L) - lc382);
}
static inline int lcf1_at(lua_State *L) {
  lua_settop(L, 4);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 130);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 131);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 132);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf3_a, 1);
  lc_getupvalue(L, 5, 1, 4);
  lc_getupvalue(L, 5, 0, 131);
  lc_getupvalue(L, 5, 1, 38);
  lua_call(L, 2, 1);
  const int lc387 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc387) {
    lc_getupvalue(L, 5, 0, 132);
    const double lc389 = lua_objlen(L, -1);
    lua_settop(L, -(1) - 1);
    lua_pushnumber(L, lc389);
    lua_pushnumber(L, 1);
    const int lc390 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc390);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc391 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc391) {
      const int lc392 = lua_gettop(L);
      lua_pushvalue(L, 6);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc392);
    }
    lua_settop(L, 6);
    lc_getupvalue(L, 5, 0, 132);
    lua_pushnumber(L, 1);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    return 1;
  } else {
    lc_getupvalue(L, 5, 1, 4);
    lc_getupvalue(L, 5, 0, 131);
    lc_getupvalue(L, 5, 1, 37);
    lua_call(L, 2, 1);
    const int lc394 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc394) {
      lc_getupvalue(L, 5, 0, 132);
      const double lc396 = lua_objlen(L, -1);
      lua_settop(L, -(1) - 1);
      lua_pushnumber(L, lc396);
      lua_pushnumber(L, 2);
      const int lc397 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc397);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc398 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc398) {
        const int lc399 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc399);
      }
      lua_settop(L, 6);
      const int lc400 = lua_gettop(L);
      lc_getupvalue(L, 5, 1, 6);
      lc_getupvalue(L, 5, 0, 130);
      lc_getupvalue(L, 5, 0, 132);
      lua_pushnumber(L, 1);
      lua_gettable(L, -2);
      lua_remove(L, -2);
      lc_getupvalue(L, 5, 0, 132);
      lua_pushnumber(L, 2);
      lua_gettable(L, -2);
      lua_remove(L, -2);
      lua_pushvalue(L, 6);
      lua_call(L, 4, (-1));
      return (lua_gettop(L) - lc400);
    } else {
      lc_getupvalue(L, 5, 1, 4);
      lc_getupvalue(L, 5, 0, 131);
      lc_getupvalue(L, 5, 1, 33);
      lua_call(L, 2, 1);
      const int lc402 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc402) {
        lc_getupvalue(L, 5, 0, 132);
        const double lc404 = lua_objlen(L, -1);
        lua_settop(L, -(1) - 1);
        lua_pushnumber(L, lc404);
        lua_pushnumber(L, 2);
        const int lc405 = lua_equal(L, -2, -1);
        lua_settop(L, -(2) - 1);
        lua_pushboolean(L, lc405);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc406 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc406) {
          const int lc407 = lua_gettop(L);
          lua_pushvalue(L, 6);
          lua_call(L, 0, (-1));
          return (lua_gettop(L) - lc407);
        }
        lua_settop(L, 6);
        const int lc408 = lua_gettop(L);
        lc_getupvalue(L, 5, 1, 101);
        const int lc409 = lua_gettop(L);
        lc_getupvalue(L, 5, 0, 132);
        lua_pushnumber(L, 1);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lc_getupvalue(L, 5, 1, 81);
        lc_getupvalue(L, 5, 0, 130);
        lc_getupvalue(L, 5, 0, 132);
        lua_pushnumber(L, 2);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc409), (-1));
        return (lua_gettop(L) - lc408);
      }
      lua_settop(L, 6);
    }
    lua_settop(L, 6);
  }
  lua_settop(L, 6);
  const int lc410 = lua_gettop(L);
  lua_pushvalue(L, 6);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc410);
}
static inline int lcf1_re(lua_State *L) {
  lua_settop(L, 1);
  const int lc411 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 30);
  lc_getupvalue(L, ((-10002) - (1)), 0, 35);
  lc_getupvalue(L, ((-10002) - (1)), 0, 38);
  lua_pushvalue(L, 1);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc411);
}
static inline int lcf427(lua_State *L) {
  lua_settop(L, 2);
  lua_pushnumber(L, 0);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 1, 133);
    const double lc423 = lua_objlen(L, -1);
    lua_settop(L, -(1) - 1);
    lua_pushnumber(L, lc423);
    const int lc424 = lua_lessthan(L, 3, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc424);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 2, 4);
    lc_getupvalue(L, ((-10002) - (1)), 1, 133);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_call(L, 2, 1);
    const int lc426 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc426) {
      return 0;
    }
    lua_settop(L, 3);
    lua_pushnumber(L, 1);
    lc_add(L, 3, -1);
    lua_remove(L, -2);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_settop(L, -(1) - 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 134);
  lua_pushvalue(L, 1);
  lua_call(L, 2, 0);
  return 0;
}
static inline int lcf1_tt(lua_State *L) {
  lua_checkstack(L, 22);
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 0, 63);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_createtable(L, 0, 0);
  lua_rawseti(L, 5, 133);
  lua_pushboolean(L, 0);
  lua_pushvalue(L, 2);
  while (1) {
    lc_getupvalue(L, 5, 1, 88);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 5, 1, 19);
    lua_pushvalue(L, 7);
    lua_call(L, 1, 1);
    lc_getupvalue(L, 5, 1, 113);
    lua_pushnil(L);
    const int lc414 = lua_equal(L, 8, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc414);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    lua_call(L, 1, 0);
    if (lua_toboolean(L, 8)) {
      lc_getupvalue(L, 5, 3, 1);
      lc_getupvalue(L, 5, 0, 133);
      lua_pushvalue(L, 7);
      lua_call(L, 2, 0);
      lua_pushboolean(L, 1);
      lua_replace(L, 6);
      lc_getupvalue(L, 5, 1, 89);
      lua_replace(L, 7);
    } else {
      lc_getupvalue(L, 5, 1, 92);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      const int lc417 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc417) {
        lc_getupvalue(L, 5, 3, 1);
        const int lc418 = lua_gettop(L);
        lc_getupvalue(L, 5, 0, 133);
        lc_getupvalue(L, 5, 1, 91);
        lua_pushvalue(L, 7);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc418), 0);
        lc_getupvalue(L, 5, 1, 90);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        lua_replace(L, 7);
      } else {
        const int lc419 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc419);
      }
      lua_settop(L, 8);
    }
    lua_settop(L, 8);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 7);
  lua_settop(L, (lua_gettop(L) + 1));
  if (lua_toboolean(L, 6)) {
    lc_getupvalue(L, 5, 1, 31);
    lc_getupvalue(L, 5, 0, 133);
    lua_call(L, 1, 1);
    lua_replace(L, 8);
  } else {
    lua_pushvalue(L, 2);
    lua_replace(L, 8);
  }
  lua_settop(L, 8);
  lc_newclosuretable(L, 5);
  lua_createtable(L, 0, 0);
  lua_rawseti(L, 9, 134);
  lc_getupvalue(L, 9, 2, 13);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 9);
  lua_pushcclosure(L, lcf427, 1);
  lua_call(L, 2, 0);
  lua_pushvalue(L, 8);
  lc_getupvalue(L, 9, 0, 134);
  const double lc428 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc428);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  while (1) {
    lua_pushnumber(L, 0);
    const int lc430 = lc_le(L, -1, 11);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc430);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 9, 2, 93);
    lc_getupvalue(L, 9, 0, 134);
    lua_pushnumber(L, 1);
    lc_add(L, 11, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_pushvalue(L, 10);
    lua_call(L, 2, 1);
    lua_replace(L, 10);
    lua_pushnumber(L, 1);
    lc_sub(L, 11, -1);
    lua_remove(L, -2);
    lua_replace(L, 11);
  }
  lua_settop(L, 11);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 8);
  lc_getupvalue(L, 9, 0, 134);
  const double lc431 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc431);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  while (1) {
    lua_pushnumber(L, 0);
    const int lc433 = lc_le(L, -1, 12);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc433);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 9, 2, 93);
    lc_getupvalue(L, 9, 2, 7);
    const int lc434 = lua_gettop(L);
    lc_getupvalue(L, 9, 2, 15);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, 9, 0, 134);
    lua_pushnumber(L, 1);
    lc_add(L, 12, -1);
    lua_remove(L, -2);
    lua_gettable(L, -2);
    lua_remove(L, -2);
    lua_call(L, 2, (-1));
    lua_call(L, (lua_gettop(L) - lc434), 1);
    lua_pushvalue(L, 11);
    lua_call(L, 2, 1);
    lua_replace(L, 11);
    lua_pushnumber(L, 1);
    lc_sub(L, 12, -1);
    lua_remove(L, -2);
    lua_replace(L, 12);
  }
  lua_settop(L, 12);
  lua_settop(L, -(1) - 1);
  const int lc435 = lua_gettop(L);
  lc_getupvalue(L, 9, 2, 87);
  const int lc436 = lua_gettop(L);
  lc_getupvalue(L, 9, 2, 55);
  lc_getupvalue(L, 9, 2, 30);
  const int lc437 = lua_gettop(L);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, 9, 2, 93);
  lc_getupvalue(L, 9, 2, 7);
  const int lc438 = lua_gettop(L);
  lc_getupvalue(L, 9, 2, 87);
  const int lc439 = lua_gettop(L);
  lc_getupvalue(L, 9, 2, 55);
  lc_getupvalue(L, 9, 2, 30);
  lua_pushvalue(L, 10);
  lua_pushvalue(L, 3);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc439), (-1));
  lua_call(L, (lua_gettop(L) - lc438), 1);
  lua_pushvalue(L, 11);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc437), (-1));
  lua_call(L, (lua_gettop(L) - lc436), (-1));
  return (lua_gettop(L) - lc435);
}
static inline int lcf2_h(lua_State *L) {
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 0, 5);
  const int lc446 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc446), 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 5);
  const int lc447 = lua_gettop(L);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc447), 1);
  lua_pushvalue(L, 5);
  lua_pushboolean(L, 1);
  const int lc449 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc449);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 6);
    lua_pushboolean(L, 1);
    const int lc450 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc450);
  }
  const int lc451 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc451) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 60);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lua_pushboolean(L, 0);
    const int lc453 = lua_equal(L, 5, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc453);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, 0);
      const int lc454 = lua_equal(L, 6, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc454);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    const int lc455 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc455) {
      lua_pushnil(L);
      return 1;
    } else {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 6);
  }
  lua_settop(L, 6);
  return 0;
}
static inline int lcf2_u(lua_State *L) {
  lua_settop(L, 2);
  const int lc441 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc441);
  const int lc442 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc442) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 23);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 23);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  const int lc444 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc444);
  const int lc445 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc445) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 2);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf2_h, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 100);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc457 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc457) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 5);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 1);
    lua_pushboolean(L, 1);
    const int lc459 = lua_equal(L, 5, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc459);
    const int lc460 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc460) {
      lua_pushnil(L);
      lua_replace(L, 5);
    }
    lua_settop(L, 5);
    lua_pushvalue(L, 5);
    return 1;
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 0, 100);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc462 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc462) {
      lc_getupvalue(L, ((-10002) - (1)), 0, 97);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 5);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 4);
      lua_call(L, 2, 1);
      lua_pushboolean(L, 1);
      const int lc464 = lua_equal(L, 5, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc464);
      const int lc465 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc465) {
        lua_pushnil(L);
        lua_replace(L, 5);
      }
      lua_settop(L, 5);
      lua_pushvalue(L, 5);
      return 1;
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 88);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc467 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc467) {
        lc_getupvalue(L, ((-10002) - (1)), 0, 88);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc469 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc469) {
          lua_pushboolean(L, 0);
          return 1;
        }
        lua_settop(L, 3);
        lc_getupvalue(L, ((-10002) - (1)), 0, 60);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lua_call(L, 2, 0);
        lua_pushboolean(L, 1);
        return 1;
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 0, 96);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc471 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc471) {
          lc_getupvalue(L, ((-10002) - (1)), 0, 96);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc473 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc473) {
            lua_pushboolean(L, 0);
            return 1;
          }
          lua_settop(L, 3);
          const int lc474 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 0, 94);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lua_call(L, 2, (-1));
          return (lua_gettop(L) - lc474);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 0, 92);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc476 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc476) {
            lc_getupvalue(L, ((-10002) - (1)), 0, 92);
            lua_pushvalue(L, 2);
            lua_call(L, 1, 1);
            lua_pushboolean(L, !(lua_toboolean(L, -1)));
            lua_remove(L, -2);
            const int lc478 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc478) {
              lua_pushboolean(L, 0);
              return 1;
            }
            lua_settop(L, 3);
            const int lc479 = lua_gettop(L);
            lua_pushvalue(L, 3);
            lua_pushvalue(L, 1);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, ((-10002) - (1)), 0, 91);
            lc_getupvalue(L, ((-10002) - (1)), 0, 90);
            lua_call(L, 4, (-1));
            return (lua_gettop(L) - lc479);
          } else {
            lc_getupvalue(L, ((-10002) - (1)), 0, 86);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 1);
            const int lc481 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc481) {
              lc_getupvalue(L, ((-10002) - (1)), 0, 86);
              lua_pushvalue(L, 2);
              lua_call(L, 1, 1);
              lua_pushboolean(L, !(lua_toboolean(L, -1)));
              lua_remove(L, -2);
              const int lc483 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc483) {
                lua_pushboolean(L, 0);
                return 1;
              }
              lua_settop(L, 3);
              const int lc484 = lua_gettop(L);
              lua_pushvalue(L, 3);
              lua_pushvalue(L, 1);
              lua_pushvalue(L, 2);
              lc_getupvalue(L, ((-10002) - (1)), 0, 85);
              lc_getupvalue(L, ((-10002) - (1)), 0, 84);
              lua_call(L, 4, (-1));
              return (lua_gettop(L) - lc484);
            }
            lua_settop(L, 3);
          }
          lua_settop(L, 3);
        }
        lua_settop(L, 3);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  const int lc485 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc485);
}
static inline int lcf1_w(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 5);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, 1);
  lua_pushboolean(L, 0);
  const int lc486 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc486);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
}
static inline int lcf1_v(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 29);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc488 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc488) {
    lua_pushlstring(L,
                    ""
                    "()",
                    (sizeof("()") / sizeof(char)) - 1);
    return 1;
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 0, 92);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc490 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc490) {
      lua_pushlstring(L,
                      ""
                      "(",
                      (sizeof("(") / sizeof(char)) - 1);
      lua_replace(L, 2);
      lua_pushlstring(L,
                      ""
                      "",
                      (sizeof("") / sizeof(char)) - 1);
      lua_replace(L, 3);
      while (1) {
        lc_getupvalue(L, ((-10002) - (1)), 0, 92);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc492 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 3);
        const int lc493 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 91);
        lua_pushvalue(L, 1);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc493), (-1));
        lua_call(L, (lua_gettop(L) - lc492), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 2);
        lua_pushlstring(L,
                        ""
                        " ",
                        (sizeof(" ") / sizeof(char)) - 1);
        lua_replace(L, 3);
        lc_getupvalue(L, ((-10002) - (1)), 0, 29);
        const int lc494 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 90);
        lua_pushvalue(L, 1);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc494), 1);
        lua_replace(L, 1);
      }
      lua_settop(L, 3);
      lc_getupvalue(L, ((-10002) - (1)), 0, 88);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc496 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc496) {
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushlstring(L,
                        ""
                        ")",
                        (sizeof(")") / sizeof(char)) - 1);
        lua_concat(L, 2);
        lua_replace(L, 2);
      } else {
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushlstring(L,
                        ""
                        " . ",
                        (sizeof(" . ") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc497 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 3);
        lua_pushvalue(L, 1);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc497), 1);
        lua_pushlstring(L,
                        ""
                        ")",
                        (sizeof(")") / sizeof(char)) - 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 2);
      }
      lua_settop(L, 3);
      lua_pushvalue(L, 2);
      return 1;
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 86);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc499 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc499) {
        lua_pushlstring(L,
                        ""
                        "#",
                        (sizeof("#") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc500 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 3);
        const int lc501 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 93);
        const int lc502 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 0, 85);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        lc_getupvalue(L, ((-10002) - (1)), 0, 84);
        lua_pushvalue(L, 1);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc502), (-1));
        lua_call(L, (lua_gettop(L) - lc501), (-1));
        lua_call(L, (lua_gettop(L) - lc500), 1);
        lua_concat(L, 2);
        return 1;
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 0, 96);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc504 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc504) {
          const int lc505 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 0, 95);
          lua_pushvalue(L, 1);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc505);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 0, 100);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc507 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc507) {
            lua_pushlstring(L,
                            ""
                            ";(",
                            (sizeof(";(") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc508 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 0, 3);
            const int lc509 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 0, 99);
            lua_pushvalue(L, 1);
            lua_call(L, 1, (-1));
            lua_call(L, (lua_gettop(L) - lc509), (-1));
            lua_call(L, (lua_gettop(L) - lc508), 1);
            lua_pushlstring(L,
                            ""
                            " ",
                            (sizeof(" ") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc510 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 0, 3);
            const int lc511 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 0, 98);
            lua_pushvalue(L, 1);
            lua_call(L, 1, (-1));
            lua_call(L, (lua_gettop(L) - lc511), (-1));
            lua_call(L, (lua_gettop(L) - lc510), 1);
            lua_pushlstring(L,
                            ""
                            ")",
                            (sizeof(")") / sizeof(char)) - 1);
            lua_concat(L, 2);
            lua_concat(L, 2);
            lua_concat(L, 2);
            lua_concat(L, 2);
            return 1;
          } else {
            lc_getupvalue(L, ((-10002) - (1)), 0, 80);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 1);
            const int lc513 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc513) {
              lua_pushlstring(L,
                              ""
                              "$(",
                              (sizeof("$(") / sizeof(char)) - 1);
              lua_getfield(L, (-10001), "tostring");
              const int lc514 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 0, 3);
              const int lc515 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 0, 14);
              const int lc516 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 0, 79);
              lua_pushvalue(L, 1);
              lua_call(L, 1, (-1));
              lua_call(L, (lua_gettop(L) - lc516), (-1));
              lua_call(L, (lua_gettop(L) - lc515), (-1));
              lua_call(L, (lua_gettop(L) - lc514), 1);
              lua_pushlstring(L,
                              ""
                              " ",
                              (sizeof(" ") / sizeof(char)) - 1);
              lua_getfield(L, (-10001), "tostring");
              const int lc517 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 0, 3);
              const int lc518 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 0, 78);
              lua_pushvalue(L, 1);
              lua_call(L, 1, (-1));
              lua_call(L, (lua_gettop(L) - lc518), (-1));
              lua_call(L, (lua_gettop(L) - lc517), 1);
              lua_pushlstring(L,
                              ""
                              ")",
                              (sizeof(")") / sizeof(char)) - 1);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              return 1;
            } else {
              lc_getupvalue(L, ((-10002) - (1)), 0, 71);
              lua_pushvalue(L, 1);
              lua_call(L, 1, 1);
              const int lc520 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc520) {
                lua_pushlstring(L,
                                ""
                                "%(",
                                (sizeof("%(") / sizeof(char)) - 1);
                lua_getfield(L, (-10001), "tostring");
                const int lc521 = lua_gettop(L);
                lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                const int lc522 = lua_gettop(L);
                lc_getupvalue(L, ((-10002) - (1)), 0, 70);
                lua_pushvalue(L, 1);
                lua_call(L, 1, (-1));
                lua_call(L, (lua_gettop(L) - lc522), (-1));
                lua_call(L, (lua_gettop(L) - lc521), 1);
                lua_pushlstring(L,
                                ""
                                " ",
                                (sizeof(" ") / sizeof(char)) - 1);
                lua_getfield(L, (-10001), "tostring");
                const int lc523 = lua_gettop(L);
                lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                const int lc524 = lua_gettop(L);
                lc_getupvalue(L, ((-10002) - (1)), 0, 31);
                const int lc525 = lua_gettop(L);
                lc_getupvalue(L, ((-10002) - (1)), 0, 69);
                lua_pushvalue(L, 1);
                lua_call(L, 1, (-1));
                lua_call(L, (lua_gettop(L) - lc525), (-1));
                lua_call(L, (lua_gettop(L) - lc524), (-1));
                lua_call(L, (lua_gettop(L) - lc523), 1);
                lua_pushlstring(L,
                                ""
                                ")",
                                (sizeof(")") / sizeof(char)) - 1);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                return 1;
              } else {
                lc_getupvalue(L, ((-10002) - (1)), 0, 76);
                lua_pushvalue(L, 1);
                lua_call(L, 1, 1);
                const int lc527 = lua_toboolean(L, -1);
                lua_settop(L, -(1) - 1);
                if (lc527) {
                  lua_pushlstring(L,
                                  ""
                                  "@(",
                                  (sizeof("@(") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc528 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                  const int lc529 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 14);
                  const int lc530 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 75);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc530), (-1));
                  lua_call(L, (lua_gettop(L) - lc529), (-1));
                  lua_call(L, (lua_gettop(L) - lc528), 1);
                  lua_pushlstring(L,
                                  ""
                                  " ",
                                  (sizeof(" ") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc531 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                  const int lc532 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 74);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc532), (-1));
                  lua_call(L, (lua_gettop(L) - lc531), 1);
                  lua_pushlstring(L,
                                  ""
                                  " ",
                                  (sizeof(" ") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc533 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                  const int lc534 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 31);
                  const int lc535 = lua_gettop(L);
                  lc_getupvalue(L, ((-10002) - (1)), 0, 73);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc535), (-1));
                  lua_call(L, (lua_gettop(L) - lc534), (-1));
                  lua_call(L, (lua_gettop(L) - lc533), 1);
                  lua_pushlstring(L,
                                  ""
                                  ")",
                                  (sizeof(")") / sizeof(char)) - 1);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  return 1;
                } else {
                  lc_getupvalue(L, ((-10002) - (1)), 0, 67);
                  lua_pushvalue(L, 1);
                  lua_call(L, 1, 1);
                  const int lc537 = lua_toboolean(L, -1);
                  lua_settop(L, -(1) - 1);
                  if (lc537) {
                    lua_pushlstring(L,
                                    ""
                                    "^(",
                                    (sizeof("^(") / sizeof(char)) - 1);
                    lua_getfield(L, (-10001), "tostring");
                    const int lc538 = lua_gettop(L);
                    lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                    const int lc539 = lua_gettop(L);
                    lc_getupvalue(L, ((-10002) - (1)), 0, 66);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, (-1));
                    lua_call(L, (lua_gettop(L) - lc539), (-1));
                    lua_call(L, (lua_gettop(L) - lc538), 1);
                    lua_pushlstring(L,
                                    ""
                                    " ",
                                    (sizeof(" ") / sizeof(char)) - 1);
                    lua_getfield(L, (-10001), "tostring");
                    const int lc540 = lua_gettop(L);
                    lc_getupvalue(L, ((-10002) - (1)), 0, 3);
                    const int lc541 = lua_gettop(L);
                    lc_getupvalue(L, ((-10002) - (1)), 0, 31);
                    const int lc542 = lua_gettop(L);
                    lc_getupvalue(L, ((-10002) - (1)), 0, 65);
                    lua_pushvalue(L, 1);
                    lua_call(L, 1, (-1));
                    lua_call(L, (lua_gettop(L) - lc542), (-1));
                    lua_call(L, (lua_gettop(L) - lc541), (-1));
                    lua_call(L, (lua_gettop(L) - lc540), 1);
                    lua_pushlstring(L,
                                    ""
                                    ")",
                                    (sizeof(")") / sizeof(char)) - 1);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    return 1;
                  }
                  lua_settop(L, 3);
                }
                lua_settop(L, 3);
              }
              lua_settop(L, 3);
            }
            lua_settop(L, 3);
          }
          lua_settop(L, 3);
        }
        lua_settop(L, 3);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  const int lc543 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc543);
}
static inline int lcf2_tt(lua_State *L) {
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "pairs");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if ((lua_type(L, (-1)) == 0)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);
    lua_pushboolean(L, 0);
    return 1;
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 1);
  lua_pushboolean(L, 1);
  return 1;
}
static inline int lcf2_at(lua_State *L) {
  lua_settop(L, 1);
  lua_createtable(L, 0, 0);
  lua_getfield(L, (-10001), "pairs");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if ((lua_type(L, (-1)) == 0)) {
      break;
    }
    lua_pushvalue(L, -1);
    lua_replace(L, -3);
    lua_pushvalue(L, 6);
    lua_gettable(L, 1);
    lua_pushvalue(L, 6);
    lua_insert(L, -2);
    lua_settable(L, 2);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 2);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf4_o(lua_State *L) {
  lua_settop(L, 1);
  lua_createtable(L, 2, 0);
  lc_getupvalue(L, ((-10002) - (1)), 3, 112);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 2);
  return 1;
}
static inline int lcf5_o(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 64);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 2);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 64);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 100);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 4, 100);
    lua_pushnumber(L, 3);
    lua_gettable(L, 1);
    lua_call(L, 1, 1);
  }
  const int lc551 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc551) {
    lc_getupvalue(L, ((-10002) - (1)), 4, 58);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushnumber(L, 2);
    lua_gettable(L, 1);
    lua_pushnumber(L, 3);
    lua_gettable(L, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 138);
    lua_pushvalue(L, 3);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 138);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 5);
    lua_pushnumber(L, 2);
    lua_insert(L, -2);
    lua_settable(L, 2);
    lua_pushvalue(L, 6);
    lua_pushnumber(L, 3);
    lua_insert(L, -2);
    lua_settable(L, 2);
    lua_pushvalue(L, 2);
    return 1;
  } else {
    lua_pushvalue(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf1_ce(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf5_o, 1);
  lc_getupvalue(L, ((-10002) - (1)), 4, 86);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  const int lc553 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc553) {
    const int lc554 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc554);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 4, 92);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    const int lc556 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc556) {
      const int lc557 = lua_gettop(L);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 2);
      lua_call(L, 1, (-1));
      return (lua_gettop(L) - lc557);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  lua_pushvalue(L, 2);
  return 1;
}
static inline int lcf2_b(lua_State *L) {
  lua_settop(L, 1);
  const int lc567 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 87);
  const int lc568 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 56);
  lc_getupvalue(L, ((-10002) - (1)), 12, 93);
  const int lc569 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 57);
  lc_getupvalue(L, ((-10002) - (1)), 12, 93);
  lua_pushvalue(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 12, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc569), (-1));
  lua_call(L, (lua_gettop(L) - lc568), (-1));
  return (lua_gettop(L) - lc567);
}
static inline int lcf1_Te(lua_State *L) {
  lua_settop(L, 1);
  const int lc570 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 146);
  const int lc571 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lc_getupvalue(L, ((-10002) - (1)), 5, 141);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lc_getupvalue(L, ((-10002) - (1)), 12, 55);
  lc_getupvalue(L, ((-10002) - (1)), 6, 140);
  lua_pushvalue(L, 1);
  lua_call(L, 3, 1);
  lc_getupvalue(L, ((-10002) - (1)), 7, 139);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc571), (-1));
  return (lua_gettop(L) - lc570);
}
static inline int lcf2_d(lua_State *L) {
  lua_settop(L, 2);
  const int lc572 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 146);
  const int lc573 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lc_getupvalue(L, ((-10002) - (1)), 5, 141);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lc_getupvalue(L, ((-10002) - (1)), 12, 55);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 6, 140);
  lua_call(L, 3, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc573), (-1));
  return (lua_gettop(L) - lc572);
}
static inline int lcf1_de(lua_State *L) {
  lua_settop(L, 1);
  const int lc574 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 146);
  const int lc575 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  const int lc576 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 5, 141);
  lc_getupvalue(L, ((-10002) - (1)), 12, 55);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  const int lc577 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 4, 142);
  lc_getupvalue(L, ((-10002) - (1)), 12, 30);
  lc_getupvalue(L, ((-10002) - (1)), 5, 141);
  lua_pushvalue(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 6, 140);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc577), (-1));
  lua_call(L, (lua_gettop(L) - lc576), (-1));
  lua_call(L, (lua_gettop(L) - lc575), (-1));
  return (lua_gettop(L) - lc574);
}
static inline int lcf1__e(lua_State *L) {
  lua_settop(L, 3);
  lua_createtable(L, 0, 0);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 16, 92);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 18, 1);
    const int lc601 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lc_getupvalue(L, ((-10002) - (1)), 16, 91);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc601), 0);
    lc_getupvalue(L, ((-10002) - (1)), 16, 90);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 16, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc603 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc603) {
    const int lc604 = lua_gettop(L);
    lua_pushvalue(L, 2);
    lua_pushvalue(L, 4);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc604);
  }
  lua_settop(L, 4);
  const int lc605 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc605);
}
static inline int lcf608(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf609(lua_State *L) {
  lua_settop(L, 2);
  lua_pushboolean(L, 0);
  return 1;
}
static inline int lcf1_D(lua_State *L) {
  lua_settop(L, 1);
  const int lc607 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 150);
  lua_pushvalue(L, 1);
  lua_pushcclosure(L, (lcf608), 0);
  lua_pushcclosure(L, (lcf609), 0);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc607);
}
static inline int lcf1_Xe(lua_State *L) {
  lua_settop(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 17, 83);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 17, 100);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 17, 29);
    const int lc611 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 17, 97);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc611), 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_Te(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 18, 80);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc614 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc614) {
    lua_pushvalue(L, 1);
    return 1;
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 18, 76);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc616 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc616) {
      lua_getfield(L, (-10001), "error");
      lua_pushlstring(L,
                      ""
                      "WIP",
                      (sizeof("WIP") / sizeof(char)) - 1);
      lua_call(L, 1, 0);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 18, 71);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc618 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc618) {
        lua_getfield(L, (-10001), "error");
        lua_pushlstring(L,
                        ""
                        "WIP",
                        (sizeof("WIP") / sizeof(char)) - 1);
        lua_call(L, 1, 0);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 18, 67);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc620 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc620) {
          lua_getfield(L, (-10001), "error");
          lua_pushlstring(L,
                          ""
                          "WIP",
                          (sizeof("WIP") / sizeof(char)) - 1);
          lua_call(L, 1, 0);
        }
        lua_settop(L, 1);
      }
      lua_settop(L, 1);
    }
    lua_settop(L, 1);
  }
  lua_settop(L, 1);
  const int lc621 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 18, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc621);
}
static inline int lcf1_et(lua_State *L) {
  lua_settop(L, 1);
  const int lc622 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 18, 79);
  const int lc623 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 152);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc623), (-1));
  return (lua_gettop(L) - lc622);
}
static inline int lcf2_ht(lua_State *L) {
  lua_settop(L, 1);
  const int lc624 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 18, 78);
  const int lc625 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 152);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc625), (-1));
  return (lua_gettop(L) - lc624);
}
static inline int lcf2_it(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 18, 100);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc627 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc627) {
    const int lc628 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 18, 98);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc628);
  } else {
    const int lc629 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 18, 24);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc629);
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf1_Ze(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  lua_pushboolean(L, 1);
  const int lc632 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc632);
  const int lc633 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc633) {
    const int lc634 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 18, 135);
    lua_pushnumber(L, 2);
    lua_gettable(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc634);
  }
  lua_settop(L, 1);
  lua_pushboolean(L, 0);
  return 1;
}
static inline int lcf2_de(lua_State *L) {
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 20, 22);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 20, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc637 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc637) {
    lc_getupvalue(L, ((-10002) - (1)), 22, 1);
    const int lc638 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_pushlstring(L,
                    ""
                    "^",
                    (sizeof("^") / sizeof(char)) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 20, 95);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc638), 0);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 20, 92);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc640 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc640) {
      lc_getupvalue(L, ((-10002) - (1)), 22, 1);
      lua_pushvalue(L, 3);
      lua_pushlstring(L,
                      ""
                      ".",
                      (sizeof(".") / sizeof(char)) - 1);
      lua_call(L, 2, 0);
      lc_getupvalue(L, ((-10002) - (1)), 22, 1);
      const int lc641 = lua_gettop(L);
      lua_pushvalue(L, 2);
      lc_getupvalue(L, ((-10002) - (1)), 20, 91);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      lc_getupvalue(L, ((-10002) - (1)), 20, 90);
      lua_pushvalue(L, 1);
      lua_call(L, 1, (-1));
      lua_call(L, (lua_gettop(L) - lc641), 0);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 20, 88);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc643 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc643) {
        lc_getupvalue(L, ((-10002) - (1)), 22, 1);
        lua_pushvalue(L, 3);
        lua_pushlstring(L,
                        ""
                        "_",
                        (sizeof("_") / sizeof(char)) - 1);
        lua_call(L, 2, 0);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 20, 86);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc645 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc645) {
          lc_getupvalue(L, ((-10002) - (1)), 22, 1);
          lua_pushvalue(L, 3);
          lua_pushlstring(L,
                          ""
                          "#",
                          (sizeof("#") / sizeof(char)) - 1);
          lua_call(L, 2, 0);
          lc_getupvalue(L, ((-10002) - (1)), 22, 1);
          const int lc646 = lua_gettop(L);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, ((-10002) - (1)), 20, 85);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          lc_getupvalue(L, ((-10002) - (1)), 20, 84);
          lua_pushvalue(L, 1);
          lua_call(L, 1, (-1));
          lua_call(L, (lua_gettop(L) - lc646), 0);
        } else {
          const int lc647 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 20, 114);
          lua_call(L, 0, (-1));
          return (lua_gettop(L) - lc647);
        }
        lua_settop(L, 3);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  return 0;
}
static inline int lcf1_We(lua_State *L) {
  lua_settop(L, 1);
  lua_createtable(L, 0, 0);
  lua_createtable(L, 0, 0);
  lua_getfield(L, (-10001), "ipairs");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lc_getupvalue(L, ((-10002) - (1)), 1, 154);
    lua_pushvalue(L, 8);
    lua_pushvalue(L, 2);
    lua_pushvalue(L, 3);
    lua_call(L, 3, 0);
    lua_settop(L, -(2) - 1);
  }
  lua_settop(L, 3);
  lua_createtable(L, 2, 0);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 2);
  return 1;
}
static inline int lcf3_de(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 1, 155);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_pushnumber(L, 1);
  lua_gettable(L, 2);
  lua_pushnumber(L, 2);
  lua_gettable(L, 2);
  lua_createtable(L, 0, 0);
  lua_createtable(L, 3, 0);
  lua_pushboolean(L, 0);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 4);
  lua_rawseti(L, -2, 2);
  lua_pushnumber(L, 3);
  lua_gettable(L, 1);
  lua_rawseti(L, -2, 3);
  const double lc651 = lua_objlen(L, 3);
  lua_pushnumber(L, lc651);
  lua_gettable(L, 3);
  lua_insert(L, -2);
  lua_settable(L, 5);
  lua_createtable(L, 3, 0);
  lua_pushboolean(L, 1);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 5);
  lua_rawseti(L, -2, 2);
  lua_pushnil(L);
  lua_rawseti(L, -2, 3);
  const double lc652 = lua_objlen(L, 3);
  lua_pushnumber(L, lc652);
  lua_pushnumber(L, 2);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  while (1) {
    lua_pushnumber(L, 0);
    const int lc654 = lc_le(L, -1, 7);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc654);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_createtable(L, 0, 0);
    lua_pushvalue(L, 6);
    lua_pushnumber(L, 1);
    lc_add(L, 7, -1);
    lua_remove(L, -2);
    lua_gettable(L, 3);
    lua_insert(L, -2);
    lua_settable(L, 8);
    lua_createtable(L, 3, 0);
    lua_pushboolean(L, 1);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, 8);
    lua_rawseti(L, -2, 2);
    lua_pushnil(L);
    lua_rawseti(L, -2, 3);
    lua_replace(L, 6);
    lua_pushnumber(L, 1);
    lc_sub(L, 7, -1);
    lua_remove(L, -2);
    lua_replace(L, 7);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 7);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, 6);
  return 1;
}
static inline int lcf1_fe(lua_State *L) {
  lua_settop(L, 1);
  lua_createtable(L, 3, 0);
  lua_pushboolean(L, 1);
  lua_rawseti(L, -2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 21, 136);
  lua_pushnumber(L, 2);
  lua_gettable(L, 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, -2, 2);
  lua_pushnil(L);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf1_Ee(lua_State *L) {
  lua_checkstack(L, 27);
  lua_settop(L, 5);
  lua_pushnumber(L, 1);
  lua_gettable(L, 1);
  const int lc658 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc658) {
    lc_getupvalue(L, ((-10002) - (1)), 1, 157);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 3, 155);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushnumber(L, 1);
    lua_gettable(L, 7);
    lua_pushnumber(L, 2);
    lua_gettable(L, 7);
    lua_pushvalue(L, 6);
    lua_getfield(L, (-10001), "ipairs");
    lua_pushvalue(L, 8);
    lua_call(L, 1, 3);
    while (1) {
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_call(L, 2, 2);
      if ((lua_type(L, (-2)) == 0)) {
        break;
      }
      lua_pushvalue(L, -2);
      lua_replace(L, -4);
      lua_pushnil(L);
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      lua_pushvalue(L, 15);
      lua_gettable(L, -2);
      lua_remove(L, -2);
      lua_pushnil(L);
      const int lc661 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc661);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc662 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc662) {
        lua_pushnumber(L, 2);
        lua_gettable(L, 10);
        lua_pushvalue(L, 15);
        lua_gettable(L, -2);
        lua_remove(L, -2);
        lua_pushnumber(L, 0);
        lua_gettable(L, 17);
        const int lc664 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc664) {
          lc_getupvalue(L, ((-10002) - (1)), 1, 157);
          lua_pushvalue(L, 17);
          lua_call(L, 1, 1);
          lua_replace(L, 16);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 2, 156);
          lua_pushvalue(L, 17);
          lua_call(L, 1, 1);
          lua_replace(L, 16);
        }
        lua_settop(L, 17);
      } else {
        lua_createtable(L, 3, 0);
        lua_pushboolean(L, 1);
        lua_rawseti(L, -2, 1);
        lua_createtable(L, 0, 0);
        lua_rawseti(L, -2, 2);
        lua_pushnil(L);
        lua_rawseti(L, -2, 3);
        lua_replace(L, 16);
      }
      lua_settop(L, 16);
      lc_getupvalue(L, ((-10002) - (1)), 24, 113);
      lua_pushnil(L);
      const int lc665 = lua_equal(L, 16, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc665);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      lua_call(L, 1, 0);
      lua_pushvalue(L, 16);
      lua_pushnumber(L, 2);
      lua_gettable(L, 10);
      lua_insert(L, -2);
      lua_pushvalue(L, 15);
      lua_insert(L, -2);
      lua_settable(L, -3);
      lua_settop(L, -(1) - 1);
      lua_pushvalue(L, 16);
      lua_replace(L, 10);
      lua_settop(L, -(3) - 1);
    }
    lua_settop(L, 10);
    lc_getupvalue(L, ((-10002) - (1)), 5, 153);
    lua_pushvalue(L, 10);
    lua_call(L, 1, 1);
    const int lc667 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc667) {
      lua_pushvalue(L, 10);
      lua_pushboolean(L, 0);
      lua_pushnumber(L, 1);
      lua_insert(L, -2);
      lua_settable(L, 11);
      lua_pushvalue(L, 9);
      lua_pushnumber(L, 2);
      lua_insert(L, -2);
      lua_settable(L, 11);
      lua_pushvalue(L, 3);
      lua_pushnumber(L, 3);
      lua_insert(L, -2);
      lua_settable(L, 11);
      lua_pushnumber(L, 1);
      lua_gettable(L, 6);
      lua_pushnumber(L, 1);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushnumber(L, 2);
      lua_gettable(L, 6);
      lua_pushnumber(L, 2);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushnumber(L, 3);
      lua_gettable(L, 6);
      lua_pushnumber(L, 3);
      lua_insert(L, -2);
      lua_settable(L, 4);
      lua_pushvalue(L, 5);
      return 1;
    } else {
      const int lc668 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 0, 158);
      lua_pushvalue(L, 10);
      lua_pushvalue(L, 9);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 10);
      lua_pushvalue(L, 6);
      lua_call(L, 5, (-1));
      return (lua_gettop(L) - lc668);
    }
    lua_settop(L, 10);
  } else {
    const int lc669 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 158);
    lc_getupvalue(L, ((-10002) - (1)), 2, 156);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 2);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 5);
    lua_call(L, 5, (-1));
    return (lua_gettop(L) - lc669);
  }
  lua_settop(L, 5);
  const int lc670 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 24, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc670);
}
static inline int lcf4_de(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 86);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc673 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc673) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  const int lc674 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 85);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc674), 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 96);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc676 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc676) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 94);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 53);
  lua_call(L, 2, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc678 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc678) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  const int lc679 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 84);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc679), 1);
  lua_replace(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc681 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc681) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 88);
  const int lc683 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  const int lc684 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc684), (-1));
  lua_call(L, (lua_gettop(L) - lc683), 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc685 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc685) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  lua_createtable(L, 0, 0);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  const int lc686 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc686), 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 25, 88);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 25, 92);
    lua_pushvalue(L, 4);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc689 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc689) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 4);
    lc_getupvalue(L, ((-10002) - (1)), 25, 23);
    const int lc690 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 91);
    lua_pushvalue(L, 4);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc690), 1);
    lc_getupvalue(L, ((-10002) - (1)), 25, 23);
    const int lc691 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 90);
    lua_pushvalue(L, 4);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc691), 1);
    lua_replace(L, 4);
    lc_getupvalue(L, ((-10002) - (1)), 25, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc693 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc693) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 5);
    lc_getupvalue(L, ((-10002) - (1)), 25, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 25, 23);
    const int lc694 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc694), 1);
    lua_replace(L, 5);
    lc_getupvalue(L, ((-10002) - (1)), 25, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc696 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc696) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 6);
    lc_getupvalue(L, ((-10002) - (1)), 25, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 25, 88);
    const int lc698 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 23);
    const int lc699 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc699), (-1));
    lua_call(L, (lua_gettop(L) - lc698), 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc700 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc700) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 7);
    lua_pushboolean(L, 1);
    lua_pushnumber(L, 0);
    while (1) {
      const double lc702 = lua_objlen(L, 3);
      lua_pushnumber(L, lc702);
      const int lc703 = lua_lessthan(L, 9, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc703);
      if (!(lua_toboolean(L, -1))) {
        break;
      }
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 25, 4);
      lua_pushnumber(L, 0);
      lc_add(L, 9, -1);
      lua_remove(L, -2);
      lua_pushnumber(L, 1);
      lc_add(L, -2, -1);
      lua_remove(L, -2);
      lua_remove(L, -2);
      lua_gettable(L, 3);
      lua_pushvalue(L, 6);
      lua_call(L, 2, 1);
      const int lc705 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc705) {
        lua_pushvalue(L, 7);
        lua_pushnumber(L, 1);
        lc_add(L, 9, -1);
        lua_remove(L, -2);
        lua_pushnumber(L, 1);
        lc_add(L, -2, -1);
        lua_remove(L, -2);
        lua_remove(L, -2);
        lua_insert(L, -2);
        lua_settable(L, 3);
        lua_pushboolean(L, 0);
        lua_replace(L, 8);
        break;
      }
      lua_settop(L, 9);
      lua_pushnumber(L, 2);
      lc_add(L, 9, -1);
      lua_remove(L, -2);
      lua_replace(L, 9);
    }
    lua_settop(L, 9);
    lua_settop(L, -(1) - 1);
    if (lua_toboolean(L, 8)) {
      lc_getupvalue(L, ((-10002) - (1)), 27, 1);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 6);
      lua_pushvalue(L, 7);
      lua_call(L, 3, 0);
    }
    lua_settop(L, 8);
    lua_settop(L, -(4) - 1);
  }
  lua_settop(L, 4);
  lua_pushvalue(L, 3);
  return 1;
}
static inline int lcf713(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 26, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 26, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc709 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc709) {
    const int lc710 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 26, 72);
    lc_getupvalue(L, ((-10002) - (1)), 0, 160);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc710);
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 161);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc712 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc712) {
    lc_getupvalue(L, ((-10002) - (1)), 11, 149);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 12, 148);
  return 1;
}
static inline int lcf2_Ee(lua_State *L) {
  lua_settop(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 160);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 161);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, 3, 0, 160);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf713, 1);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf722(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 26, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 26, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc716 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc716) {
    const int lc717 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 26, 72);
    lc_getupvalue(L, ((-10002) - (1)), 0, 162);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc717);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 163);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc719 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc719) {
    const int lc720 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 164);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc720);
  }
  lua_settop(L, 2);
  const int lc721 = lua_gettop(L);
  lua_pushvalue(L, 2);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc721);
}
static inline int lcf2_fe(lua_State *L) {
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 162);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 163);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 164);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, 4, 0, 162);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 4);
  lua_pushcclosure(L, lcf722, 1);
  lua_rawseti(L, -2, 3);
  return 1;
}
static inline int lcf6_o(lua_State *L) {
  lua_settop(L, 3);
  const int lc733 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 26, 72);
  lc_getupvalue(L, ((-10002) - (1)), 26, 39);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 1);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 3);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc733);
}
static inline int lcf3_h(lua_State *L) {
  lua_settop(L, 2);
  const int lc735 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 165);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 13, 148);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc735);
}
static inline int lcf7_o(lua_State *L) {
  lua_settop(L, 4);
  const int lc736 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 166);
  const int lc737 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 27, 72);
  lc_getupvalue(L, ((-10002) - (1)), 27, 42);
  lua_createtable(L, 2, 0);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, -2, 1);
  const int lc738 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  while ((lua_gettop(L) > lc738)) {
    lua_rawseti(L, lc738, (1 + (lua_gettop(L) - lc738)));
  }
  lua_call(L, 2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 27, 72);
  lc_getupvalue(L, ((-10002) - (1)), 27, 42);
  lua_createtable(L, 2, 0);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, -2, 1);
  const int lc739 = lua_gettop(L);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  while ((lua_gettop(L) > lc739)) {
    lua_rawseti(L, lc739, (1 + (lua_gettop(L) - lc739)));
  }
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc737), (-1));
  return (lua_gettop(L) - lc736);
}
static inline int lcf761(lua_State *L) {
  lua_settop(L, 3);
  const int lc724 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc724);
  const int lc725 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc725) {
    lc_getupvalue(L, ((-10002) - (1)), 10, 149);
    return 1;
  }
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 25, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 24);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 25, 27);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
  }
  const int lc727 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc727) {
    const int lc728 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 72);
    lc_getupvalue(L, ((-10002) - (1)), 25, 42);
    lua_createtable(L, 2, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 2);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc728);
  }
  lua_settop(L, 3);
  const int lc730 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc730);
  const int lc731 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc731) {
    lc_getupvalue(L, ((-10002) - (1)), 10, 149);
    return 1;
  }
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 4);
  lua_pushcclosure(L, lcf6_o, 1);
  lua_rawseti(L, 4, 165);
  lc_newclosuretable(L, 4);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf3_h, 1);
  lua_rawseti(L, 5, 166);
  lc_getupvalue(L, 5, 27, 113);
  lc_getupvalue(L, 5, 27, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf7_o, 1);
  lc_getupvalue(L, 5, 27, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc741 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc741) {
    lc_getupvalue(L, 5, 27, 88);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc743 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc743) {
      lc_getupvalue(L, 5, 13, 148);
      return 1;
    }
    lua_settop(L, 6);
    lc_getupvalue(L, 5, 12, 149);
    return 1;
  } else {
    lc_getupvalue(L, 5, 27, 96);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc745 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc745) {
      lc_getupvalue(L, 5, 27, 96);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc747 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc747) {
        lc_getupvalue(L, 5, 13, 148);
        return 1;
      }
      lua_settop(L, 6);
      lc_getupvalue(L, 5, 27, 94);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 2);
      lua_call(L, 2, 1);
      const int lc749 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc749) {
        lc_getupvalue(L, 5, 12, 149);
        return 1;
      } else {
        lc_getupvalue(L, 5, 13, 148);
        return 1;
      }
      lua_settop(L, 6);
    } else {
      lc_getupvalue(L, 5, 27, 86);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc751 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc751) {
        lc_getupvalue(L, 5, 27, 86);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc753 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc753) {
          lc_getupvalue(L, 5, 13, 148);
          return 1;
        }
        lua_settop(L, 6);
        const int lc754 = lua_gettop(L);
        lua_pushvalue(L, 6);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lc_getupvalue(L, 5, 27, 85);
        lc_getupvalue(L, 5, 27, 84);
        lua_call(L, 4, (-1));
        return (lua_gettop(L) - lc754);
      } else {
        lc_getupvalue(L, 5, 27, 92);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc756 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc756) {
          lc_getupvalue(L, 5, 27, 92);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc758 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc758) {
            lc_getupvalue(L, 5, 13, 148);
            return 1;
          }
          lua_settop(L, 6);
          const int lc759 = lua_gettop(L);
          lua_pushvalue(L, 6);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, 5, 27, 91);
          lc_getupvalue(L, 5, 27, 90);
          lua_call(L, 4, (-1));
          return (lua_gettop(L) - lc759);
        }
        lua_settop(L, 6);
      }
      lua_settop(L, 6);
    }
    lua_settop(L, 6);
  }
  lua_settop(L, 6);
  const int lc760 = lua_gettop(L);
  lc_getupvalue(L, 5, 27, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc760);
}
static inline int lcf769(lua_State *L) {
  lua_settop(L, 3);
  lua_createtable(L, 0, 0);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 25, 92);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 27, 1);
    const int lc763 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lc_getupvalue(L, ((-10002) - (1)), 25, 91);
    lua_pushvalue(L, 5);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc763), 0);
    lc_getupvalue(L, ((-10002) - (1)), 25, 23);
    const int lc764 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 90);
    lua_pushvalue(L, 5);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc764), 1);
    lua_replace(L, 5);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, ((-10002) - (1)), 25, 88);
  lua_pushvalue(L, 5);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc766 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc766) {
    const int lc767 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc767);
  }
  lua_settop(L, 5);
  const int lc768 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 68);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 4);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc768);
}
static inline int lcf775(lua_State *L) {
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 0, 159);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 0);
  const int lc771 = lua_equal(L, 4, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc771);
  const int lc772 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc772) {
    const int lc773 = lua_gettop(L);
    lua_pushvalue(L, 3);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc773);
  }
  lua_settop(L, 4);
  const int lc774 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 81);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc774);
}
static inline int lcf783(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc777 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc777) {
    const int lc778 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 72);
    lc_getupvalue(L, ((-10002) - (1)), 12, 147);
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc778);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 25, 92);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc780 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc780) {
    const int lc781 = lua_gettop(L);
    lua_pushvalue(L, 2);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc781);
  }
  lua_settop(L, 2);
  const int lc782 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 91);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc782);
}
static inline int lcf799(lua_State *L) {
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 25, 24);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 27);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc785 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc785) {
    const int lc786 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 25, 72);
    lc_getupvalue(L, ((-10002) - (1)), 25, 39);
    lua_createtable(L, 3, 0);
    lua_pushvalue(L, 1);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 2);
    lua_pushvalue(L, 3);
    lua_rawseti(L, -2, 3);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc786);
  }
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 25, 86);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc788 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc788) {
    const int lc789 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc789);
  }
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 25, 23);
  const int lc790 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 85);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc790), 1);
  lc_getupvalue(L, ((-10002) - (1)), 25, 96);
  lua_pushvalue(L, 5);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc792 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc792) {
    const int lc793 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc793);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, ((-10002) - (1)), 25, 94);
  lua_pushvalue(L, 5);
  lc_getupvalue(L, ((-10002) - (1)), 15, 144);
  lua_call(L, 2, 1);
  const int lc795 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc795) {
    lua_pushvalue(L, 2);
    return 1;
  }
  lua_settop(L, 5);
  lc_getupvalue(L, ((-10002) - (1)), 25, 94);
  lua_pushvalue(L, 5);
  lc_getupvalue(L, ((-10002) - (1)), 14, 145);
  lua_call(L, 2, 1);
  const int lc797 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc797) {
    lua_pushvalue(L, 3);
    return 1;
  }
  lua_settop(L, 5);
  const int lc798 = lua_gettop(L);
  lua_pushvalue(L, 4);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc798);
}
static inline int lcf8_o(lua_State *L) {
  lua_settop(L, 4);
  lc_getupvalue(L, ((-10002) - (1)), 0, 167);
  const int lc808 = lua_gettop(L);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc808), 1);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 167);
    const int lc809 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 2);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc809), 1);
  }
  const int lc810 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc810) {
    lc_getupvalue(L, ((-10002) - (1)), 26, 60);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 2);
    lua_call(L, 2, 0);
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 4);
  return 0;
}
static inline int lcf3_d(lua_State *L) {
  lua_settop(L, 2);
  const int lc802 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc802);
  const int lc803 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc803) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 26, 29);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_replace(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 26, 29);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_replace(L, 2);
  const int lc805 = lua_equal(L, 1, 2);
  lua_pushboolean(L, lc805);
  const int lc806 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc806) {
    lua_pushboolean(L, 1);
    return 1;
  }
  lua_settop(L, 2);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf8_o, 1);
  lc_getupvalue(L, ((-10002) - (1)), 26, 88);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc812 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc812) {
    lc_getupvalue(L, ((-10002) - (1)), 26, 88);
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc814 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc814) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 3);
    lc_getupvalue(L, ((-10002) - (1)), 26, 60);
    lua_pushvalue(L, 1);
    lc_getupvalue(L, ((-10002) - (1)), 26, 89);
    lua_call(L, 2, 0);
    lc_getupvalue(L, ((-10002) - (1)), 26, 60);
    lua_pushvalue(L, 2);
    lc_getupvalue(L, ((-10002) - (1)), 26, 89);
    lua_call(L, 2, 0);
    lua_pushboolean(L, 1);
    return 1;
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 26, 96);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    const int lc816 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc816) {
      lc_getupvalue(L, ((-10002) - (1)), 26, 96);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc818 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc818) {
        lua_pushboolean(L, 0);
        return 1;
      }
      lua_settop(L, 3);
      const int lc819 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 26, 94);
      lua_pushvalue(L, 1);
      lua_pushvalue(L, 2);
      lua_call(L, 2, (-1));
      return (lua_gettop(L) - lc819);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 26, 92);
      lua_pushvalue(L, 1);
      lua_call(L, 1, 1);
      const int lc821 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc821) {
        lc_getupvalue(L, ((-10002) - (1)), 26, 92);
        lua_pushvalue(L, 2);
        lua_call(L, 1, 1);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        const int lc823 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc823) {
          lua_pushboolean(L, 0);
          return 1;
        }
        lua_settop(L, 3);
        const int lc824 = lua_gettop(L);
        lua_pushvalue(L, 3);
        lua_pushvalue(L, 1);
        lua_pushvalue(L, 2);
        lc_getupvalue(L, ((-10002) - (1)), 26, 91);
        lc_getupvalue(L, ((-10002) - (1)), 26, 90);
        lua_call(L, 4, (-1));
        return (lua_gettop(L) - lc824);
      } else {
        lc_getupvalue(L, ((-10002) - (1)), 26, 86);
        lua_pushvalue(L, 1);
        lua_call(L, 1, 1);
        const int lc826 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc826) {
          lc_getupvalue(L, ((-10002) - (1)), 26, 86);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 1);
          lua_pushboolean(L, !(lua_toboolean(L, -1)));
          lua_remove(L, -2);
          const int lc828 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc828) {
            lua_pushboolean(L, 0);
            return 1;
          }
          lua_settop(L, 3);
          const int lc829 = lua_gettop(L);
          lua_pushvalue(L, 3);
          lua_pushvalue(L, 1);
          lua_pushvalue(L, 2);
          lc_getupvalue(L, ((-10002) - (1)), 26, 85);
          lc_getupvalue(L, ((-10002) - (1)), 26, 84);
          lua_call(L, 4, (-1));
          return (lua_gettop(L) - lc829);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 26, 28);
          lua_pushvalue(L, 1);
          lua_call(L, 1, 1);
          const int lc831 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc831) {
            lua_pushboolean(L, 0);
            return 1;
          }
          lua_settop(L, 3);
        }
        lua_settop(L, 3);
      }
      lua_settop(L, 3);
    }
    lua_settop(L, 3);
  }
  lua_settop(L, 3);
  const int lc832 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 26, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc832);
}
static inline int lcf2_c(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 193);
  const double lc835 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc835);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  const int lc836 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc836);
  return 1;
}
static inline int lcf4_d(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 28, 113);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  lua_call(L, 1, 0);
  lua_getfield(L, (-10001), "string");
  lua_pushlstring(L,
                  ""
                  "sub",
                  (sizeof("sub") / sizeof(char)) - 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 193);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_call(L, 3, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, ((-10002) - (1)), 0, 192);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_w(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 28, 113);
  lua_getfield(L, (-10001), "string");
  lua_pushlstring(L,
                  ""
                  "sub",
                  (sizeof("sub") / sizeof(char)) - 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 193);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lua_call(L, 3, 1);
  lua_pushvalue(L, 1);
  const int lc837 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc837);
  lua_call(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 192);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, ((-10002) - (1)), 0, 192);
  return 0;
}
static inline int lcf3_r(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnil(L);
  const int lc839 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc839);
  const int lc840 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc840) {
    lua_pushlstring(L,
                    ""
                    "",
                    (sizeof("") / sizeof(char)) - 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "error");
  lua_pushlstring(L,
                  ""
                  "TheLanguage parse ERROR!",
                  (sizeof("TheLanguage parse ERROR!") / sizeof(char)) - 1);
  lua_getfield(L, (-10001), "tostring");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lua_call(L, 1, 0);
  return 0;
}
static inline int lcf2_T(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  lua_pushlstring(L,
                  ""
                  " ",
                  (sizeof(" ") / sizeof(char)) - 1);
  const int lc841 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc841);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 1);
    lua_pushlstring(L,
                    ""
                    "\n",
                    (sizeof("\n") / sizeof(char)) - 1);
    const int lc842 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc842);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 1);
    lua_pushlstring(L,
                    ""
                    "	",
                    (sizeof("	") / sizeof(char)) - 1);
    const int lc843 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc843);
  }
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 1);
    lua_pushlstring(L,
                    ""
                    "\r",
                    (sizeof("\r") / sizeof(char)) - 1);
    const int lc844 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc844);
  }
  return 1;
}
static inline int lcf2_j(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc846 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc846) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 187);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc848 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc848) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 187);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 191);
      lua_call(L, 0, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 190);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 187);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc851 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc851) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
  }
  lua_settop(L, 1);
  lua_pushboolean(L, 1);
  return 1;
}
static inline int lcf2_B(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc853 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc853) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 177);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc855 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc855) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 2);
  while (1) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 177);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, ((-10002) - (1)), 0, 191);
      lua_call(L, 0, 1);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_concat(L, 2);
    lua_replace(L, 2);
    lc_getupvalue(L, ((-10002) - (1)), 0, 190);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 177);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc858 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc858) {
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 1);
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_concat(L, 2);
    lua_replace(L, 2);
  } else {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
  }
  lua_settop(L, 2);
  const int lc859 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 25, 137);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc859);
}
static inline int lcf2_i(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 62);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 59);
  const int lc866 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 194);
  lc_getupvalue(L, ((-10002) - (1)), 29, 93);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc866), 0);
  lua_pushvalue(L, 2);
  lc_setupvalue(L, ((-10002) - (1)), 0, 194);
  return 0;
}
static inline int lcf2_g(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc861 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc861) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  "(",
                  (sizeof("(") / sizeof(char)) - 1);
  const int lc863 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc863);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc864 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc864) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lc_getupvalue(L, ((-10002) - (1)), 28, 62);
  lua_call(L, 0, 1);
  lua_rawseti(L, 2, 194);
  lc_getupvalue(L, 2, 0, 194);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_i, 1);
  while (1) {
    lua_pushboolean(L, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 2, 1, 186);
    lua_call(L, 0, 0);
    lc_getupvalue(L, 2, 1, 191);
    lua_call(L, 0, 1);
    const int lc869 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc869) {
      const int lc870 = lua_gettop(L);
      lc_getupvalue(L, 2, 1, 188);
      lua_call(L, 0, (-1));
      return (lua_gettop(L) - lc870);
    }
    lua_settop(L, 4);
    lc_getupvalue(L, 2, 1, 190);
    lua_call(L, 0, 1);
    lua_replace(L, 1);
    lua_pushlstring(L,
                    ""
                    ")",
                    (sizeof(")") / sizeof(char)) - 1);
    const int lc872 = lua_equal(L, 1, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc872);
    const int lc873 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc873) {
      lc_getupvalue(L, 2, 29, 59);
      lc_getupvalue(L, 2, 0, 194);
      lc_getupvalue(L, 2, 29, 89);
      lua_call(L, 2, 0);
      lua_pushvalue(L, 3);
      return 1;
    }
    lua_settop(L, 4);
    lua_pushlstring(L,
                    ""
                    ".",
                    (sizeof(".") / sizeof(char)) - 1);
    const int lc875 = lua_equal(L, 1, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc875);
    const int lc876 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc876) {
      lc_getupvalue(L, 2, 1, 186);
      lua_call(L, 0, 0);
      lc_getupvalue(L, 2, 1, 176);
      lua_call(L, 0, 1);
      lc_getupvalue(L, 2, 29, 59);
      lc_getupvalue(L, 2, 0, 194);
      lua_pushvalue(L, 5);
      lua_call(L, 2, 0);
      lc_getupvalue(L, 2, 1, 186);
      lua_call(L, 0, 0);
      lc_getupvalue(L, 2, 1, 191);
      lua_call(L, 0, 1);
      const int lc878 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc878) {
        const int lc879 = lua_gettop(L);
        lc_getupvalue(L, 2, 1, 188);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc879);
      }
      lua_settop(L, 5);
      lc_getupvalue(L, 2, 1, 190);
      lua_call(L, 0, 1);
      lua_replace(L, 1);
      lua_pushlstring(L,
                      ""
                      ")",
                      (sizeof(")") / sizeof(char)) - 1);
      const int lc881 = lua_equal(L, 1, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc881);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      const int lc882 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc882) {
        const int lc883 = lua_gettop(L);
        lc_getupvalue(L, 2, 1, 188);
        lua_call(L, 0, (-1));
        return (lua_gettop(L) - lc883);
      }
      lua_settop(L, 5);
      lua_pushvalue(L, 3);
      return 1;
    }
    lua_settop(L, 4);
    lc_getupvalue(L, 2, 1, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lc_getupvalue(L, 2, 1, 176);
    lua_call(L, 0, 1);
    lua_pushvalue(L, 4);
    lua_pushvalue(L, 5);
    lua_call(L, 1, 0);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 4);
  return 0;
}
static inline int lcf2_D(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc885 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc885) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  "#",
                  (sizeof("#") / sizeof(char)) - 1);
  const int lc887 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc887);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc888 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc888) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 184);
  lua_call(L, 0, 1);
  lua_pushboolean(L, 0);
  const int lc890 = lua_equal(L, 2, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc890);
  const int lc891 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc891) {
    const int lc892 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc892);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 28, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc894 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc894) {
    const int lc895 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc895);
  }
  lua_settop(L, 2);
  const int lc896 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 87);
  const int lc897 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 28, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc897), (-1));
  return (lua_gettop(L) - lc896);
}
static inline int lcf2_F(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 187);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc899 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc899) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "ipairs");
  lua_createtable(L, 20, 0);
  lua_pushlstring(L,
                  ""
                  "(",
                  (sizeof("(") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 1);
  lua_pushlstring(L,
                  ""
                  ")",
                  (sizeof(")") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 2);
  lua_pushlstring(L,
                  ""
                  "!",
                  (sizeof("!") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 3);
  lua_pushlstring(L,
                  ""
                  "#",
                  (sizeof("#") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 4);
  lua_pushlstring(L,
                  ""
                  ".",
                  (sizeof(".") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 5);
  lua_pushlstring(L,
                  ""
                  "$",
                  (sizeof("$") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 6);
  lua_pushlstring(L,
                  ""
                  "%",
                  (sizeof("%") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 7);
  lua_pushlstring(L,
                  ""
                  "^",
                  (sizeof("^") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 8);
  lua_pushlstring(L,
                  ""
                  "@",
                  (sizeof("@") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 9);
  lua_pushlstring(L,
                  ""
                  "~",
                  (sizeof("~") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 10);
  lua_pushlstring(L,
                  ""
                  "/",
                  (sizeof("/") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 11);
  lua_pushlstring(L,
                  ""
                  "-",
                  (sizeof("-") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 12);
  lua_pushlstring(L,
                  ""
                  ">",
                  (sizeof(">") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 13);
  lua_pushlstring(L,
                  ""
                  "_",
                  (sizeof("_") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 14);
  lua_pushlstring(L,
                  ""
                  ":",
                  (sizeof(":") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 15);
  lua_pushlstring(L,
                  ""
                  "?",
                  (sizeof("?") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 16);
  lua_pushlstring(L,
                  ""
                  "[",
                  (sizeof("[") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 17);
  lua_pushlstring(L,
                  ""
                  "]",
                  (sizeof("]") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 18);
  lua_pushlstring(L,
                  ""
                  "&",
                  (sizeof("&") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 19);
  lua_pushlstring(L,
                  ""
                  ";",
                  (sizeof(";") / sizeof(char)) - 1);
  lua_rawseti(L, -2, 20);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    const int lc902 = lua_equal(L, 6, 1);
    lua_pushboolean(L, lc902);
    const int lc903 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc903) {
      lua_pushboolean(L, 0);
      return 1;
    }
    lua_settop(L, 6);
    lua_settop(L, -(2) - 1);
  }
  lua_settop(L, 1);
  lua_pushboolean(L, 1);
  return 1;
}
static inline int lcf2_U(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 186);
  lua_call(L, 0, 0);
  lua_createtable(L, 8, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 184);
  lua_rawseti(L, -2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 169);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 183);
  lua_rawseti(L, -2, 3);
  lc_getupvalue(L, ((-10002) - (1)), 0, 182);
  lua_rawseti(L, -2, 4);
  lc_getupvalue(L, ((-10002) - (1)), 0, 181);
  lua_rawseti(L, -2, 5);
  lc_getupvalue(L, ((-10002) - (1)), 0, 180);
  lua_rawseti(L, -2, 6);
  lc_getupvalue(L, ((-10002) - (1)), 0, 179);
  lua_rawseti(L, -2, 7);
  lc_getupvalue(L, ((-10002) - (1)), 0, 178);
  lua_rawseti(L, -2, 8);
  lua_getfield(L, (-10001), "ipairs");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lua_pushvalue(L, 6);
    lua_call(L, 0, 1);
    lua_pushboolean(L, 0);
    const int lc906 = lua_equal(L, 7, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc906);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc907 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc907) {
      lua_pushvalue(L, 7);
      return 1;
    }
    lua_settop(L, 7);
    lua_settop(L, -(3) - 1);
  }
  lua_settop(L, 1);
  const int lc908 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 188);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc908);
}
static inline int lcf2_q(lua_State *L) {
  lua_settop(L, 1);
  lua_pushboolean(L, 0);
  const int lc910 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc910);
  const int lc911 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc911) {
    const int lc912 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc912);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_W(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
}
static inline int lcf2_k(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 175);
  const int lc913 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 174);
  lua_call(L, 0, (-1));
  lua_call(L, (lua_gettop(L) - lc913), 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 175);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushvalue(L, 1);
  const int lc914 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc914);
  lua_call(L, 1, 0);
  return 0;
}
static inline int lcf4_a(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 173);
  lua_pushlstring(L,
                  ""
                  "[",
                  (sizeof("[") / sizeof(char)) - 1);
  lua_call(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 172);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 173);
  lua_pushlstring(L,
                  ""
                  "]",
                  (sizeof("]") / sizeof(char)) - 1);
  lua_call(L, 1, 0);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf2_y(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnil(L);
  const int lc916 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc916);
  const int lc917 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc917) {
    lua_pushboolean(L, 0);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf4_a, 1);
  lua_settop(L, (lua_gettop(L) + 1));
  if (lua_toboolean(L, 1)) {
    lua_createtable(L, 9, 0);
    lc_getupvalue(L, ((-10002) - (1)), 0, 184);
    lua_rawseti(L, -2, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 185);
    lua_rawseti(L, -2, 2);
    lua_pushvalue(L, 2);
    lua_rawseti(L, -2, 3);
    lc_getupvalue(L, ((-10002) - (1)), 0, 183);
    lua_rawseti(L, -2, 4);
    lc_getupvalue(L, ((-10002) - (1)), 0, 182);
    lua_rawseti(L, -2, 5);
    lc_getupvalue(L, ((-10002) - (1)), 0, 181);
    lua_rawseti(L, -2, 6);
    lc_getupvalue(L, ((-10002) - (1)), 0, 180);
    lua_rawseti(L, -2, 7);
    lc_getupvalue(L, ((-10002) - (1)), 0, 179);
    lua_rawseti(L, -2, 8);
    lc_getupvalue(L, ((-10002) - (1)), 0, 178);
    lua_rawseti(L, -2, 9);
    lua_replace(L, 3);
  } else {
    lua_createtable(L, 8, 0);
    lc_getupvalue(L, ((-10002) - (1)), 0, 184);
    lua_rawseti(L, -2, 1);
    lc_getupvalue(L, ((-10002) - (1)), 0, 170);
    lua_rawseti(L, -2, 2);
    lc_getupvalue(L, ((-10002) - (1)), 0, 183);
    lua_rawseti(L, -2, 3);
    lc_getupvalue(L, ((-10002) - (1)), 0, 182);
    lua_rawseti(L, -2, 4);
    lc_getupvalue(L, ((-10002) - (1)), 0, 181);
    lua_rawseti(L, -2, 5);
    lc_getupvalue(L, ((-10002) - (1)), 0, 180);
    lua_rawseti(L, -2, 6);
    lc_getupvalue(L, ((-10002) - (1)), 0, 179);
    lua_rawseti(L, -2, 7);
    lc_getupvalue(L, ((-10002) - (1)), 0, 178);
    lua_rawseti(L, -2, 8);
    lua_replace(L, 3);
  }
  lua_settop(L, 3);
  lua_getfield(L, (-10001), "ipairs");
  lua_pushvalue(L, 3);
  lua_call(L, 1, 3);
  while (1) {
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 2);
    if ((lua_type(L, (-2)) == 0)) {
      break;
    }
    lua_pushvalue(L, -2);
    lua_replace(L, -4);
    lua_pushvalue(L, 8);
    lua_call(L, 0, 1);
    lua_pushboolean(L, 0);
    const int lc921 = lua_equal(L, 9, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc921);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    const int lc922 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc922) {
      lua_pushvalue(L, 9);
      return 1;
    }
    lua_settop(L, 9);
    lua_settop(L, -(3) - 1);
  }
  lua_settop(L, 3);
  const int lc923 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 188);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc923);
}
static inline int lcf2_P(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc925 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc925) {
    lua_pushvalue(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  ".",
                  (sizeof(".") / sizeof(char)) - 1);
  const int lc927 = lua_equal(L, 2, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc927);
  const int lc928 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc928) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 172);
    lua_call(L, 0, 1);
    const int lc929 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 28, 30);
    lc_getupvalue(L, ((-10002) - (1)), 21, 141);
    lc_getupvalue(L, ((-10002) - (1)), 28, 30);
    lc_getupvalue(L, ((-10002) - (1)), 28, 55);
    lc_getupvalue(L, ((-10002) - (1)), 28, 30);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lc_getupvalue(L, ((-10002) - (1)), 22, 140);
    lua_call(L, 3, 1);
    lua_pushvalue(L, 3);
    lua_call(L, 3, (-1));
    return (lua_gettop(L) - lc929);
  } else {
    lua_pushlstring(L,
                    ""
                    ":",
                    (sizeof(":") / sizeof(char)) - 1);
    const int lc931 = lua_equal(L, 2, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc931);
    const int lc932 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc932) {
      lc_getupvalue(L, ((-10002) - (1)), 0, 172);
      lua_call(L, 0, 1);
      const int lc933 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 28, 30);
      lc_getupvalue(L, ((-10002) - (1)), 21, 141);
      lua_pushvalue(L, 3);
      lua_pushvalue(L, 1);
      lua_call(L, 3, (-1));
      return (lua_gettop(L) - lc933);
    } else {
      lua_pushlstring(L,
                      ""
                      "~",
                      (sizeof("~") / sizeof(char)) - 1);
      const int lc935 = lua_equal(L, 2, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc935);
      const int lc936 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc936) {
        const int lc937 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 28, 30);
        lc_getupvalue(L, ((-10002) - (1)), 20, 142);
        lua_pushvalue(L, 1);
        lua_call(L, 2, (-1));
        return (lua_gettop(L) - lc937);
      } else {
        lua_pushlstring(L,
                        ""
                        "@",
                        (sizeof("@") / sizeof(char)) - 1);
        const int lc939 = lua_equal(L, 2, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc939);
        const int lc940 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc940) {
          lc_getupvalue(L, ((-10002) - (1)), 0, 172);
          lua_call(L, 0, 1);
          const int lc941 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 28, 30);
          lc_getupvalue(L, ((-10002) - (1)), 21, 141);
          lc_getupvalue(L, ((-10002) - (1)), 28, 30);
          lc_getupvalue(L, ((-10002) - (1)), 28, 55);
          lc_getupvalue(L, ((-10002) - (1)), 28, 93);
          lua_pushvalue(L, 1);
          lc_getupvalue(L, ((-10002) - (1)), 22, 140);
          lua_call(L, 2, 1);
          lc_getupvalue(L, ((-10002) - (1)), 22, 140);
          lua_call(L, 3, 1);
          lua_pushvalue(L, 3);
          lua_call(L, 3, (-1));
          return (lua_gettop(L) - lc941);
        } else {
          lua_pushlstring(L,
                          ""
                          "?",
                          (sizeof("?") / sizeof(char)) - 1);
          const int lc943 = lua_equal(L, 2, -1);
          lua_settop(L, -(1) - 1);
          lua_pushboolean(L, lc943);
          const int lc944 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc944) {
            const int lc945 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 28, 30);
            const int lc946 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 21, 141);
            lc_getupvalue(L, ((-10002) - (1)), 28, 55);
            lc_getupvalue(L, ((-10002) - (1)), 28, 30);
            lc_getupvalue(L, ((-10002) - (1)), 20, 142);
            lua_pushvalue(L, 1);
            lua_call(L, 2, (-1));
            lua_call(L, (lua_gettop(L) - lc946), (-1));
            return (lua_gettop(L) - lc945);
          } else {
            lua_pushlstring(L,
                            ""
                            "/",
                            (sizeof("/") / sizeof(char)) - 1);
            const int lc948 = lua_equal(L, 2, -1);
            lua_settop(L, -(1) - 1);
            lua_pushboolean(L, lc948);
            const int lc949 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc949) {
              lua_createtable(L, 1, 0);
              lua_pushvalue(L, 1);
              lua_rawseti(L, -2, 1);
              while (1) {
                lua_pushboolean(L, 1);
                if (!(lua_toboolean(L, -1))) {
                  break;
                }
                lua_settop(L, -(1) - 1);
                lc_getupvalue(L, ((-10002) - (1)), 0, 172);
                lua_pushboolean(L, 1);
                lua_call(L, 1, 1);
                lc_getupvalue(L, ((-10002) - (1)), 30, 1);
                lua_pushvalue(L, 3);
                lua_pushvalue(L, 4);
                lua_call(L, 2, 0);
                lc_getupvalue(L, ((-10002) - (1)), 0, 191);
                lua_call(L, 0, 1);
                const int lc952 = lua_toboolean(L, -1);
                lua_settop(L, -(1) - 1);
                if (lc952) {
                  break;
                }
                lua_settop(L, 4);
                lc_getupvalue(L, ((-10002) - (1)), 0, 190);
                lua_call(L, 0, 1);
                lua_pushlstring(L,
                                ""
                                "/",
                                (sizeof("/") / sizeof(char)) - 1);
                const int lc954 = lua_equal(L, 5, -1);
                lua_settop(L, -(1) - 1);
                lua_pushboolean(L, lc954);
                lua_pushboolean(L, !(lua_toboolean(L, -1)));
                lua_remove(L, -2);
                const int lc955 = lua_toboolean(L, -1);
                lua_settop(L, -(1) - 1);
                if (lc955) {
                  lc_getupvalue(L, ((-10002) - (1)), 0, 189);
                  lua_pushvalue(L, 5);
                  lua_call(L, 1, 0);
                  break;
                }
                lua_settop(L, 5);
                lua_settop(L, -(2) - 1);
              }
              lua_settop(L, 3);
              const int lc956 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 28, 30);
              const int lc957 = lua_gettop(L);
              lc_getupvalue(L, ((-10002) - (1)), 19, 143);
              lc_getupvalue(L, ((-10002) - (1)), 28, 31);
              lua_pushvalue(L, 3);
              lua_call(L, 1, (-1));
              lua_call(L, (lua_gettop(L) - lc957), (-1));
              return (lua_gettop(L) - lc956);
            } else {
              lc_getupvalue(L, ((-10002) - (1)), 0, 189);
              lua_pushvalue(L, 2);
              lua_call(L, 1, 0);
              lua_pushvalue(L, 1);
              return 1;
            }
            lua_settop(L, 2);
          }
          lua_settop(L, 2);
        }
        lua_settop(L, 2);
      }
      lua_settop(L, 2);
    }
    lua_settop(L, 2);
  }
  lua_settop(L, 2);
  return 0;
}
static inline int lcf2_V(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 191);
  lua_call(L, 0, 1);
  const int lc959 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc959) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 190);
  lua_call(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  "&",
                  (sizeof("&") / sizeof(char)) - 1);
  const int lc961 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc961);
  const int lc962 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc962) {
    lc_getupvalue(L, ((-10002) - (1)), 0, 175);
    const int lc963 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 174);
    lua_call(L, 0, (-1));
    lua_call(L, (lua_gettop(L) - lc963), 0);
    lc_getupvalue(L, ((-10002) - (1)), 0, 190);
    lua_call(L, 0, 1);
    lua_pushlstring(L,
                    ""
                    "+",
                    (sizeof("+") / sizeof(char)) - 1);
    const int lc965 = lua_equal(L, 2, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc965);
    const int lc966 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc966) {
      lc_getupvalue(L, ((-10002) - (1)), 0, 172);
      lua_call(L, 0, 1);
      const int lc967 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 28, 30);
      const int lc968 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 28, 54);
      lc_getupvalue(L, ((-10002) - (1)), 28, 30);
      lc_getupvalue(L, ((-10002) - (1)), 28, 57);
      lua_pushvalue(L, 3);
      lua_call(L, 2, (-1));
      lua_call(L, (lua_gettop(L) - lc968), (-1));
      return (lua_gettop(L) - lc967);
    } else {
      lc_getupvalue(L, ((-10002) - (1)), 0, 189);
      lua_pushvalue(L, 2);
      lua_call(L, 1, 0);
    }
    lua_settop(L, 2);
    lc_getupvalue(L, ((-10002) - (1)), 0, 172);
    lua_call(L, 0, 1);
    const int lc969 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 28, 30);
    lc_getupvalue(L, ((-10002) - (1)), 28, 54);
    lua_pushvalue(L, 3);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc969);
  } else {
    lua_pushlstring(L,
                    ""
                    ":",
                    (sizeof(":") / sizeof(char)) - 1);
    const int lc971 = lua_equal(L, 1, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc971);
    const int lc972 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc972) {
      lc_getupvalue(L, ((-10002) - (1)), 0, 175);
      const int lc973 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 0, 174);
      lua_call(L, 0, (-1));
      lua_call(L, (lua_gettop(L) - lc973), 0);
      lc_getupvalue(L, ((-10002) - (1)), 0, 190);
      lua_call(L, 0, 1);
      lua_pushlstring(L,
                      ""
                      "&",
                      (sizeof("&") / sizeof(char)) - 1);
      const int lc975 = lua_equal(L, 2, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc975);
      const int lc976 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc976) {
        lc_getupvalue(L, ((-10002) - (1)), 0, 173);
        lua_pushlstring(L,
                        ""
                        ">",
                        (sizeof(">") / sizeof(char)) - 1);
        lua_call(L, 1, 0);
        lc_getupvalue(L, ((-10002) - (1)), 0, 172);
        lua_call(L, 0, 1);
        const int lc977 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 28, 30);
        lc_getupvalue(L, ((-10002) - (1)), 21, 141);
        lc_getupvalue(L, ((-10002) - (1)), 28, 30);
        const int lc978 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 28, 54);
        lc_getupvalue(L, ((-10002) - (1)), 28, 30);
        lc_getupvalue(L, ((-10002) - (1)), 28, 55);
        lc_getupvalue(L, ((-10002) - (1)), 22, 140);
        lua_pushvalue(L, 3);
        lua_call(L, 3, (-1));
        lua_call(L, (lua_gettop(L) - lc978), 1);
        lc_getupvalue(L, ((-10002) - (1)), 23, 139);
        lua_call(L, 3, (-1));
        return (lua_gettop(L) - lc977);
      } else {
        lua_pushlstring(L,
                        ""
                        ">",
                        (sizeof(">") / sizeof(char)) - 1);
        const int lc980 = lua_equal(L, 2, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc980);
        const int lc981 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc981) {
          lc_getupvalue(L, ((-10002) - (1)), 0, 172);
          lua_call(L, 0, 1);
          const int lc982 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 28, 30);
          lc_getupvalue(L, ((-10002) - (1)), 21, 141);
          lc_getupvalue(L, ((-10002) - (1)), 28, 30);
          lc_getupvalue(L, ((-10002) - (1)), 28, 55);
          lc_getupvalue(L, ((-10002) - (1)), 22, 140);
          lua_pushvalue(L, 3);
          lua_call(L, 3, 1);
          lc_getupvalue(L, ((-10002) - (1)), 23, 139);
          lua_call(L, 3, (-1));
          return (lua_gettop(L) - lc982);
        } else {
          lc_getupvalue(L, ((-10002) - (1)), 0, 189);
          lua_pushvalue(L, 2);
          lua_call(L, 1, 0);
        }
        lua_settop(L, 2);
      }
      lua_settop(L, 2);
      lc_getupvalue(L, ((-10002) - (1)), 0, 172);
      lua_call(L, 0, 1);
      const int lc983 = lua_gettop(L);
      lc_getupvalue(L, ((-10002) - (1)), 28, 30);
      lc_getupvalue(L, ((-10002) - (1)), 21, 141);
      lua_pushvalue(L, 3);
      lc_getupvalue(L, ((-10002) - (1)), 23, 139);
      lua_call(L, 3, (-1));
      return (lua_gettop(L) - lc983);
    } else {
      lua_pushlstring(L,
                      ""
                      "+",
                      (sizeof("+") / sizeof(char)) - 1);
      const int lc985 = lua_equal(L, 1, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc985);
      const int lc986 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc986) {
        lc_getupvalue(L, ((-10002) - (1)), 0, 172);
        lua_call(L, 0, 1);
        const int lc987 = lua_gettop(L);
        lc_getupvalue(L, ((-10002) - (1)), 28, 30);
        lc_getupvalue(L, ((-10002) - (1)), 28, 57);
        lua_pushvalue(L, 2);
        lua_call(L, 2, (-1));
        return (lua_gettop(L) - lc987);
      } else {
        lua_pushlstring(L,
                        ""
                        "[",
                        (sizeof("[") / sizeof(char)) - 1);
        const int lc989 = lua_equal(L, 1, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc989);
        const int lc990 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc990) {
          lc_getupvalue(L, ((-10002) - (1)), 0, 172);
          lua_call(L, 0, 1);
          lc_getupvalue(L, ((-10002) - (1)), 0, 173);
          lua_pushlstring(L,
                          ""
                          "]",
                          (sizeof("]") / sizeof(char)) - 1);
          lua_call(L, 1, 0);
          const int lc991 = lua_gettop(L);
          lc_getupvalue(L, ((-10002) - (1)), 0, 171);
          lua_pushvalue(L, 2);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc991);
        } else {
          lua_pushlstring(L,
                          ""
                          "_",
                          (sizeof("_") / sizeof(char)) - 1);
          const int lc993 = lua_equal(L, 1, -1);
          lua_settop(L, -(1) - 1);
          lua_pushboolean(L, lc993);
          const int lc994 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc994) {
            lc_getupvalue(L, ((-10002) - (1)), 0, 173);
            lua_pushlstring(L,
                            ""
                            ":",
                            (sizeof(":") / sizeof(char)) - 1);
            lua_call(L, 1, 0);
            lc_getupvalue(L, ((-10002) - (1)), 0, 172);
            lua_call(L, 0, 1);
            const int lc995 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 28, 30);
            lc_getupvalue(L, ((-10002) - (1)), 21, 141);
            lua_pushvalue(L, 2);
            lc_getupvalue(L, ((-10002) - (1)), 22, 140);
            lua_call(L, 3, (-1));
            return (lua_gettop(L) - lc995);
          } else {
            lc_getupvalue(L, ((-10002) - (1)), 0, 189);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 0);
            lc_getupvalue(L, ((-10002) - (1)), 0, 185);
            lua_call(L, 0, 1);
            lua_pushboolean(L, 0);
            const int lc997 = lua_equal(L, 2, -1);
            lua_settop(L, -(1) - 1);
            lua_pushboolean(L, lc997);
            const int lc998 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc998) {
              lua_pushboolean(L, 0);
              return 1;
            }
            lua_settop(L, 2);
            const int lc999 = lua_gettop(L);
            lc_getupvalue(L, ((-10002) - (1)), 0, 171);
            lua_pushvalue(L, 2);
            lua_call(L, 1, (-1));
            return (lua_gettop(L) - lc999);
          }
          lua_settop(L, 1);
        }
        lua_settop(L, 1);
      }
      lua_settop(L, 1);
    }
    lua_settop(L, 1);
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf2_G(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 170);
  lua_call(L, 0, 1);
  lua_pushboolean(L, 0);
  const int lc1001 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1001);
  const int lc1002 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1002) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 28, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc1004 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1004) {
    lua_pushvalue(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  const int lc1005 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 16, 146);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc1005);
}
static inline int lcf1025(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 1, 191);
  lua_call(L, 0, 1);
  const int lc1008 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1008) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 1, 190);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 195);
  const int lc1010 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1010);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1011 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1011) {
    lc_getupvalue(L, ((-10002) - (1)), 1, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 1, 184);
  lua_call(L, 0, 1);
  lua_pushboolean(L, 0);
  const int lc1013 = lua_equal(L, 2, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1013);
  const int lc1014 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1014) {
    const int lc1015 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1015);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 29, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1017 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1017) {
    const int lc1018 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1018);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 29, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 92);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 29, 88);
    const int lc1020 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 29, 90);
    lua_pushvalue(L, 3);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc1020), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1021 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1021) {
    const int lc1022 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1022);
  }
  lua_settop(L, 3);
  const int lc1023 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 196);
  const int lc1024 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 29, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 91);
  lua_pushvalue(L, 3);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1024), (-1));
  return (lua_gettop(L) - lc1023);
}
static inline int lcf3_t(lua_State *L) {
  lua_settop(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 195);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 196);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf1025, 1);
  return 1;
}
static inline int lcf1048(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 1, 191);
  lua_call(L, 0, 1);
  const int lc1028 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1028) {
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 1, 190);
  lua_call(L, 0, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 197);
  const int lc1030 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1030);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1031 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1031) {
    lc_getupvalue(L, ((-10002) - (1)), 1, 189);
    lua_pushvalue(L, 1);
    lua_call(L, 1, 0);
    lua_pushboolean(L, 0);
    return 1;
  }
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 1, 184);
  lua_call(L, 0, 1);
  lua_pushboolean(L, 0);
  const int lc1033 = lua_equal(L, 2, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1033);
  const int lc1034 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1034) {
    const int lc1035 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1035);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 29, 92);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1037 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1037) {
    const int lc1038 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1038);
  }
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 29, 90);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 92);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1040 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1040) {
    const int lc1041 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1041);
  }
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 29, 90);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 92);
  lua_pushvalue(L, 4);
  lua_call(L, 1, 1);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, ((-10002) - (1)), 29, 88);
    const int lc1043 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 29, 90);
    lua_pushvalue(L, 4);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc1043), 1);
  }
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  const int lc1044 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1044) {
    const int lc1045 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1045);
  }
  lua_settop(L, 4);
  const int lc1046 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 198);
  const int lc1047 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 29, 91);
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 91);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 29, 91);
  lua_pushvalue(L, 4);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1047), (-1));
  return (lua_gettop(L) - lc1046);
}
static inline int lcf4_h(lua_State *L) {
  lua_settop(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 197);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 198);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf1048, 1);
  return 1;
}
static inline int lcf1054(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 3, 159);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 0);
  const int lc1050 = lua_equal(L, 3, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1050);
  const int lc1051 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1051) {
    const int lc1052 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1052);
  }
  lua_settop(L, 3);
  const int lc1053 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 81);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1053);
}
static inline int lcf1055(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1057(lua_State *L) {
  lua_settop(L, 2);
  const int lc1056 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 188);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc1056);
}
static inline int lcf1059(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 12, 150);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, (lcf1055), 0);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf1057, 1);
  lua_call(L, 3, 1);
  const int lc1058 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 72);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 3);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1058);
}
static inline int lcf1060(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1062(lua_State *L) {
  lua_settop(L, 2);
  const int lc1061 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 188);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc1061);
}
static inline int lcf1068(lua_State *L) {
  lua_settop(L, 3);
  lc_getupvalue(L, ((-10002) - (1)), 12, 150);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, (lcf1060), 0);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf1062, 1);
  lua_call(L, 3, 1);
  lc_getupvalue(L, ((-10002) - (1)), 3, 159);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 0);
  const int lc1064 = lua_equal(L, 5, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1064);
  const int lc1065 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1065) {
    const int lc1066 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 188);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1066);
  }
  lua_settop(L, 5);
  const int lc1067 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 77);
  lua_pushvalue(L, 5);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 4);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc1067);
}
static inline int lcf1069(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  return 1;
}
static inline int lcf1071(lua_State *L) {
  lua_settop(L, 2);
  const int lc1070 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 188);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc1070);
}
static inline int lcf1073(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 12, 150);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, (lcf1069), 0);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf1071, 1);
  lua_call(L, 3, 1);
  const int lc1072 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 68);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 3);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1072);
}
static inline int lcf1075(lua_State *L) {
  lua_settop(L, 2);
  const int lc1074 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 28, 101);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1074);
}
static inline int lcf1_J(lua_State *L) {
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_settop(L, (lua_gettop(L) + 25));
  lua_rawseti(L, 2, 169);
  lua_rawseti(L, 2, 170);
  lua_rawseti(L, 2, 171);
  lua_rawseti(L, 2, 172);
  lua_rawseti(L, 2, 173);
  lua_rawseti(L, 2, 174);
  lua_rawseti(L, 2, 175);
  lua_rawseti(L, 2, 176);
  lua_rawseti(L, 2, 177);
  lua_rawseti(L, 2, 178);
  lua_rawseti(L, 2, 179);
  lua_rawseti(L, 2, 180);
  lua_rawseti(L, 2, 181);
  lua_rawseti(L, 2, 182);
  lua_rawseti(L, 2, 183);
  lua_rawseti(L, 2, 184);
  lua_rawseti(L, 2, 185);
  lua_rawseti(L, 2, 186);
  lua_rawseti(L, 2, 187);
  lua_rawseti(L, 2, 188);
  lua_rawseti(L, 2, 189);
  lua_rawseti(L, 2, 190);
  lua_rawseti(L, 2, 191);
  lua_rawseti(L, 2, 192);
  lua_rawseti(L, 2, 193);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_c, 1);
  lc_setupvalue(L, 2, 0, 191);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf4_d, 1);
  lc_setupvalue(L, 2, 0, 190);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_w, 1);
  lc_setupvalue(L, 2, 0, 189);
  lua_pushcclosure(L, (lcf3_r), 0);
  lc_setupvalue(L, 2, 0, 188);
  lua_pushcclosure(L, (lcf2_T), 0);
  lc_setupvalue(L, 2, 0, 187);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_j, 1);
  lc_setupvalue(L, 2, 0, 186);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_B, 1);
  lc_setupvalue(L, 2, 0, 185);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_g, 1);
  lc_setupvalue(L, 2, 0, 184);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_D, 1);
  lc_setupvalue(L, 2, 0, 183);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_F, 1);
  lc_setupvalue(L, 2, 0, 177);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_U, 1);
  lc_setupvalue(L, 2, 0, 176);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_q, 1);
  lc_setupvalue(L, 2, 0, 175);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_W, 1);
  lc_setupvalue(L, 2, 0, 174);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_k, 1);
  lc_setupvalue(L, 2, 0, 173);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_y, 1);
  lc_setupvalue(L, 2, 0, 172);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_P, 1);
  lc_setupvalue(L, 2, 0, 171);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_V, 1);
  lc_setupvalue(L, 2, 0, 170);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf2_G, 1);
  lc_setupvalue(L, 2, 0, 169);
  lua_pushvalue(L, 1);
  lc_setupvalue(L, 2, 0, 193);
  lua_pushnumber(L, 0);
  lc_setupvalue(L, 2, 0, 192);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf3_t, 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf4_h, 1);
  lua_pushvalue(L, 3);
  lua_pushlstring(L,
                  ""
                  "$",
                  (sizeof("$") / sizeof(char)) - 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1054, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, 2, 0, 182);
  lua_pushvalue(L, 3);
  lua_pushlstring(L,
                  ""
                  "%",
                  (sizeof("%") / sizeof(char)) - 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1059, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, 2, 0, 181);
  lua_pushvalue(L, 4);
  lua_pushlstring(L,
                  ""
                  "@",
                  (sizeof("@") / sizeof(char)) - 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1068, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, 2, 0, 180);
  lua_pushvalue(L, 3);
  lua_pushlstring(L,
                  ""
                  "^",
                  (sizeof("^") / sizeof(char)) - 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1073, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, 2, 0, 179);
  lua_pushvalue(L, 3);
  lua_pushlstring(L,
                  ""
                  ";",
                  (sizeof(";") / sizeof(char)) - 1);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1075, 1);
  lua_call(L, 2, 1);
  lc_setupvalue(L, 2, 0, 178);
  const int lc1076 = lua_gettop(L);
  lc_getupvalue(L, 2, 0, 176);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc1076);
}
static inline int lcf5_h(lua_State *L) {
  lua_settop(L, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 201);
  const int lc1084 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1084) {
    lua_pushlstring(L,
                    ""
                    "[",
                    (sizeof("[") / sizeof(char)) - 1);
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 1);
    lua_call(L, 1, 1);
    lua_pushlstring(L,
                    ""
                    "]",
                    (sizeof("]") / sizeof(char)) - 1);
    lua_concat(L, 2);
    lua_concat(L, 2);
    return 1;
  } else {
    lua_pushvalue(L, 1);
    return 1;
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf9_o(lua_State *L) {
  lua_settop(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 201);
  lc_getupvalue(L, 3, 30, 96);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  const int lc1081 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1081) {
    const int lc1082 = lua_gettop(L);
    lc_getupvalue(L, 3, 30, 95);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc1082);
  }
  lua_settop(L, 3);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf5_h, 1);
  lc_getupvalue(L, 3, 13, 151);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 0);
  const int lc1086 = lua_equal(L, 5, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1086);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    const double lc1087 = lua_objlen(L, 5);
    lua_pushnumber(L, lc1087);
    lua_pushnumber(L, 3);
    const int lc1088 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc1088);
  }
  if (lua_toboolean(L, -1)) {
    lua_settop(L, -(1) - 1);
    lc_getupvalue(L, 3, 4, 167);
    lua_pushnumber(L, 1);
    lua_gettable(L, 5);
    lc_getupvalue(L, 3, 23, 141);
    lua_call(L, 2, 1);
  }
  const int lc1089 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1089) {
    lc_getupvalue(L, 3, 13, 151);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lua_call(L, 1, 1);
    lua_pushboolean(L, 0);
    const int lc1091 = lua_equal(L, 6, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc1091);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      const double lc1092 = lua_objlen(L, 6);
      lua_pushnumber(L, lc1092);
      lua_pushnumber(L, 3);
      const int lc1093 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc1093);
    }
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 1);
      lua_gettable(L, 6);
      lc_getupvalue(L, 3, 30, 55);
      lua_call(L, 2, 1);
    }
    const int lc1094 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1094) {
      lua_pushnumber(L, 2);
      lua_gettable(L, 6);
      lc_getupvalue(L, 3, 13, 151);
      lua_pushvalue(L, 7);
      lua_call(L, 1, 1);
      lua_pushboolean(L, 0);
      const int lc1096 = lua_equal(L, 8, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc1096);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      if (lua_toboolean(L, -1)) {
        lua_settop(L, -(1) - 1);
        const double lc1097 = lua_objlen(L, 8);
        lua_pushnumber(L, lc1097);
        lua_pushnumber(L, 1);
        const int lc1098 = lua_equal(L, -2, -1);
        lua_settop(L, -(2) - 1);
        lua_pushboolean(L, lc1098);
      }
      if (lua_toboolean(L, -1)) {
        lua_settop(L, -(1) - 1);
        lc_getupvalue(L, 3, 4, 167);
        lua_pushnumber(L, 3);
        lua_gettable(L, 6);
        lc_getupvalue(L, 3, 24, 140);
        lua_call(L, 2, 1);
      }
      const int lc1099 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1099) {
        const int lc1100 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_getfield(L, (-10001), "tostring");
        const int lc1101 = lua_gettop(L);
        lc_getupvalue(L, 3, 1, 200);
        lua_pushnumber(L, 1);
        lua_gettable(L, 8);
        lua_pushboolean(L, 1);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc1101), 1);
        lua_pushlstring(L,
                        ""
                        ".",
                        (sizeof(".") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1102 = lua_gettop(L);
        lc_getupvalue(L, 3, 1, 200);
        lua_pushnumber(L, 3);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc1102), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_call(L, 1, (-1));
        return (lua_gettop(L) - lc1100);
      } else {
        lc_getupvalue(L, 3, 30, 92);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, 3, 4, 167);
          lc_getupvalue(L, 3, 30, 90);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lc_getupvalue(L, 3, 24, 140);
          lua_call(L, 2, 1);
        }
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, 3, 4, 167);
          lua_pushnumber(L, 3);
          lua_gettable(L, 6);
          lc_getupvalue(L, 3, 24, 140);
          lua_call(L, 2, 1);
        }
        const int lc1104 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1104) {
          const int lc1105 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_getfield(L, (-10001), "tostring");
          const int lc1106 = lua_gettop(L);
          lc_getupvalue(L, 3, 1, 200);
          lc_getupvalue(L, 3, 30, 91);
          lua_pushvalue(L, 7);
          lua_call(L, 1, 1);
          lua_pushboolean(L, 1);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc1106), 1);
          lua_pushlstring(L,
                          ""
                          "@",
                          (sizeof("@") / sizeof(char)) - 1);
          lua_getfield(L, (-10001), "tostring");
          const int lc1107 = lua_gettop(L);
          lc_getupvalue(L, 3, 1, 200);
          lua_pushnumber(L, 3);
          lua_gettable(L, 5);
          lua_pushboolean(L, 1);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc1107), 1);
          lua_concat(L, 2);
          lua_concat(L, 2);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc1105);
        } else {
          lc_getupvalue(L, 3, 4, 167);
          lua_pushvalue(L, 7);
          lc_getupvalue(L, 3, 24, 140);
          lua_call(L, 2, 1);
          if (lua_toboolean(L, -1)) {
            lua_settop(L, -(1) - 1);
            lc_getupvalue(L, 3, 4, 167);
            lua_pushnumber(L, 3);
            lua_gettable(L, 5);
            lc_getupvalue(L, 3, 25, 139);
            lua_call(L, 2, 1);
          }
          const int lc1109 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1109) {
            const int lc1110 = lua_gettop(L);
            lua_pushvalue(L, 4);
            lua_pushlstring(L,
                            ""
                            ":>",
                            (sizeof(":>") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc1111 = lua_gettop(L);
            lc_getupvalue(L, 3, 1, 200);
            lua_pushnumber(L, 3);
            lua_gettable(L, 6);
            lua_pushboolean(L, 1);
            lua_call(L, 2, (-1));
            lua_call(L, (lua_gettop(L) - lc1111), 1);
            lua_concat(L, 2);
            lua_call(L, 1, (-1));
            return (lua_gettop(L) - lc1110);
          }
          lua_settop(L, 8);
        }
        lua_settop(L, 8);
      }
      lua_settop(L, 8);
    }
    lua_settop(L, 6);
    lc_getupvalue(L, 3, 13, 151);
    lua_pushnumber(L, 3);
    lua_gettable(L, 5);
    lua_call(L, 1, 1);
    lc_getupvalue(L, 3, 4, 167);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lc_getupvalue(L, 3, 30, 55);
    lua_call(L, 2, 1);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, 0);
      const int lc1113 = lua_equal(L, 7, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc1113);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
    }
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      const double lc1114 = lua_objlen(L, 7);
      lua_pushnumber(L, lc1114);
      lua_pushnumber(L, 2);
      const int lc1115 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc1115);
    }
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 1);
      lua_gettable(L, 7);
      lc_getupvalue(L, 3, 22, 142);
      lua_call(L, 2, 1);
    }
    const int lc1116 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1116) {
      const int lc1117 = lua_gettop(L);
      lua_pushvalue(L, 4);
      lua_getfield(L, (-10001), "tostring");
      const int lc1118 = lua_gettop(L);
      lc_getupvalue(L, 3, 1, 200);
      lua_pushnumber(L, 2);
      lua_gettable(L, 7);
      lua_pushboolean(L, 1);
      lua_call(L, 2, (-1));
      lua_call(L, (lua_gettop(L) - lc1118), 1);
      lua_pushlstring(L,
                      ""
                      "?",
                      (sizeof("?") / sizeof(char)) - 1);
      lua_concat(L, 2);
      lua_call(L, 1, (-1));
      return (lua_gettop(L) - lc1117);
    }
    lua_settop(L, 7);
    lua_pushboolean(L, 0);
    const int lc1120 = lua_equal(L, 6, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc1120);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      const double lc1121 = lua_objlen(L, 6);
      lua_pushnumber(L, lc1121);
      lua_pushnumber(L, 2);
      const int lc1122 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc1122);
    }
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 3);
      lua_gettable(L, 5);
      lc_getupvalue(L, 3, 25, 139);
      lua_call(L, 2, 1);
    }
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 1);
      lua_gettable(L, 6);
      lc_getupvalue(L, 3, 30, 54);
      lua_call(L, 2, 1);
    }
    const int lc1123 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1123) {
      lc_getupvalue(L, 3, 13, 151);
      lua_pushnumber(L, 2);
      lua_gettable(L, 6);
      lua_call(L, 1, 1);
      lua_pushboolean(L, 0);
      const int lc1125 = lua_equal(L, 8, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc1125);
      lua_pushboolean(L, !(lua_toboolean(L, -1)));
      lua_remove(L, -2);
      if (lua_toboolean(L, -1)) {
        lua_settop(L, -(1) - 1);
        const double lc1126 = lua_objlen(L, 8);
        lua_pushnumber(L, lc1126);
        lua_pushnumber(L, 3);
        const int lc1127 = lua_equal(L, -2, -1);
        lua_settop(L, -(2) - 1);
        lua_pushboolean(L, lc1127);
      }
      if (lua_toboolean(L, -1)) {
        lua_settop(L, -(1) - 1);
        lc_getupvalue(L, 3, 4, 167);
        lua_pushnumber(L, 1);
        lua_gettable(L, 8);
        lc_getupvalue(L, 3, 30, 55);
        lua_call(L, 2, 1);
      }
      if (lua_toboolean(L, -1)) {
        lua_settop(L, -(1) - 1);
        lc_getupvalue(L, 3, 4, 167);
        lua_pushnumber(L, 2);
        lua_gettable(L, 8);
        lc_getupvalue(L, 3, 24, 140);
        lua_call(L, 2, 1);
      }
      const int lc1128 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1128) {
        const int lc1129 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_pushlstring(L,
                        ""
                        ":&>",
                        (sizeof(":&>") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1130 = lua_gettop(L);
        lc_getupvalue(L, 3, 1, 200);
        lua_pushnumber(L, 3);
        lua_gettable(L, 8);
        lua_pushboolean(L, 1);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc1130), 1);
        lua_concat(L, 2);
        lua_call(L, 1, (-1));
        return (lua_gettop(L) - lc1129);
      }
      lua_settop(L, 8);
    }
    lua_settop(L, 7);
    lua_settop(L, (lua_gettop(L) + 1));
    lc_getupvalue(L, 3, 4, 167);
    lua_pushnumber(L, 3);
    lua_gettable(L, 5);
    lc_getupvalue(L, 3, 24, 140);
    lua_call(L, 2, 1);
    const int lc1132 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1132) {
      lua_pushlstring(L,
                      ""
                      "_",
                      (sizeof("_") / sizeof(char)) - 1);
      lua_replace(L, 8);
    } else {
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 3);
      lua_gettable(L, 5);
      lc_getupvalue(L, 3, 25, 139);
      lua_call(L, 2, 1);
      const int lc1134 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1134) {
        lua_pushlstring(L,
                        ""
                        "",
                        (sizeof("") / sizeof(char)) - 1);
        lua_replace(L, 8);
      } else {
        lc_getupvalue(L, 3, 1, 200);
        lua_pushnumber(L, 3);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, 1);
        lua_replace(L, 8);
      }
      lua_settop(L, 8);
    }
    lua_settop(L, 8);
    const int lc1135 = lua_gettop(L);
    lua_pushvalue(L, 4);
    lua_getfield(L, (-10001), "tostring");
    lua_pushvalue(L, 8);
    lua_call(L, 1, 1);
    lua_pushlstring(L,
                    ""
                    ":",
                    (sizeof(":") / sizeof(char)) - 1);
    lua_getfield(L, (-10001), "tostring");
    const int lc1136 = lua_gettop(L);
    lc_getupvalue(L, 3, 1, 200);
    lua_pushnumber(L, 2);
    lua_gettable(L, 5);
    lua_pushboolean(L, 1);
    lua_call(L, 2, (-1));
    lua_call(L, (lua_gettop(L) - lc1136), 1);
    lua_concat(L, 2);
    lua_concat(L, 2);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc1135);
  } else {
    lua_pushboolean(L, 0);
    const int lc1138 = lua_equal(L, 5, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc1138);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (lua_toboolean(L, -1)) {
      lua_settop(L, -(1) - 1);
      const double lc1139 = lua_objlen(L, 5);
      lua_pushnumber(L, lc1139);
      lua_pushnumber(L, 2);
      const int lc1140 = lua_equal(L, -2, -1);
      lua_settop(L, -(2) - 1);
      lua_pushboolean(L, lc1140);
    }
    const int lc1141 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1141) {
      lc_getupvalue(L, 3, 4, 167);
      lua_pushnumber(L, 1);
      lua_gettable(L, 5);
      lc_getupvalue(L, 3, 30, 54);
      lua_call(L, 2, 1);
      const int lc1143 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1143) {
        lc_getupvalue(L, 3, 13, 151);
        lua_pushnumber(L, 2);
        lua_gettable(L, 5);
        lua_call(L, 1, 1);
        lua_pushboolean(L, 0);
        const int lc1145 = lua_equal(L, 6, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc1145);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          const double lc1146 = lua_objlen(L, 6);
          lua_pushnumber(L, lc1146);
          lua_pushnumber(L, 2);
          const int lc1147 = lua_equal(L, -2, -1);
          lua_settop(L, -(2) - 1);
          lua_pushboolean(L, lc1147);
        }
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, 3, 4, 167);
          lua_pushnumber(L, 1);
          lua_gettable(L, 6);
          lc_getupvalue(L, 3, 30, 57);
          lua_call(L, 2, 1);
        }
        const int lc1148 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1148) {
          const int lc1149 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_pushlstring(L,
                          ""
                          "&+",
                          (sizeof("&+") / sizeof(char)) - 1);
          lua_getfield(L, (-10001), "tostring");
          const int lc1150 = lua_gettop(L);
          lc_getupvalue(L, 3, 1, 200);
          lua_pushnumber(L, 2);
          lua_gettable(L, 6);
          lua_pushboolean(L, 1);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc1150), 1);
          lua_concat(L, 2);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc1149);
        }
        lua_settop(L, 6);
        const int lc1151 = lua_gettop(L);
        lua_pushvalue(L, 4);
        lua_pushlstring(L,
                        ""
                        "&",
                        (sizeof("&") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1152 = lua_gettop(L);
        lc_getupvalue(L, 3, 1, 200);
        lua_pushnumber(L, 2);
        lua_gettable(L, 5);
        lua_pushboolean(L, 1);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc1152), 1);
        lua_concat(L, 2);
        lua_call(L, 1, (-1));
        return (lua_gettop(L) - lc1151);
      } else {
        lc_getupvalue(L, 3, 4, 167);
        lua_pushnumber(L, 1);
        lua_gettable(L, 5);
        lc_getupvalue(L, 3, 22, 142);
        lua_call(L, 2, 1);
        const int lc1154 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1154) {
          const int lc1155 = lua_gettop(L);
          lua_pushvalue(L, 4);
          lua_getfield(L, (-10001), "tostring");
          const int lc1156 = lua_gettop(L);
          lc_getupvalue(L, 3, 1, 200);
          lua_pushnumber(L, 2);
          lua_gettable(L, 5);
          lua_pushboolean(L, 1);
          lua_call(L, 2, (-1));
          lua_call(L, (lua_gettop(L) - lc1156), 1);
          lua_pushlstring(L,
                          ""
                          "~",
                          (sizeof("~") / sizeof(char)) - 1);
          lua_concat(L, 2);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc1155);
        } else {
          lc_getupvalue(L, 3, 4, 167);
          lua_pushnumber(L, 1);
          lua_gettable(L, 5);
          lc_getupvalue(L, 3, 30, 57);
          lua_call(L, 2, 1);
          const int lc1158 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1158) {
            const int lc1159 = lua_gettop(L);
            lua_pushvalue(L, 4);
            lua_pushlstring(L,
                            ""
                            "+",
                            (sizeof("+") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc1160 = lua_gettop(L);
            lc_getupvalue(L, 3, 1, 200);
            lua_pushnumber(L, 2);
            lua_gettable(L, 5);
            lua_pushboolean(L, 1);
            lua_call(L, 2, (-1));
            lua_call(L, (lua_gettop(L) - lc1160), 1);
            lua_concat(L, 2);
            lua_call(L, 1, (-1));
            return (lua_gettop(L) - lc1159);
          } else {
            lc_getupvalue(L, 3, 4, 167);
            lua_pushnumber(L, 1);
            lua_gettable(L, 5);
            lc_getupvalue(L, 3, 21, 143);
            lua_call(L, 2, 1);
            const int lc1162 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc1162) {
              lc_getupvalue(L, 3, 13, 151);
              lua_pushnumber(L, 2);
              lua_gettable(L, 5);
              lua_call(L, 1, 1);
              lua_pushboolean(L, 0);
              const int lc1164 = lua_equal(L, 6, -1);
              lua_settop(L, -(1) - 1);
              lua_pushboolean(L, lc1164);
              lua_pushboolean(L, !(lua_toboolean(L, -1)));
              lua_remove(L, -2);
              if (lua_toboolean(L, -1)) {
                lua_settop(L, -(1) - 1);
                lua_pushnumber(L, 1);
                const double lc1165 = lua_objlen(L, 6);
                lua_pushnumber(L, lc1165);
                const int lc1166 = lua_lessthan(L, -2, -1);
                lua_settop(L, -(2) - 1);
                lua_pushboolean(L, lc1166);
              }
              const int lc1167 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc1167) {
                lc_getupvalue(L, 3, 1, 200);
                lua_pushnumber(L, 1);
                lua_gettable(L, 6);
                lua_pushboolean(L, 1);
                lua_call(L, 2, 1);
                lua_pushnumber(L, 1);
                while (1) {
                  const double lc1169 = lua_objlen(L, 6);
                  lua_pushnumber(L, lc1169);
                  const int lc1170 = lua_lessthan(L, 8, -1);
                  lua_settop(L, -(1) - 1);
                  lua_pushboolean(L, lc1170);
                  if (!(lua_toboolean(L, -1))) {
                    break;
                  }
                  lua_settop(L, -(1) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  lua_pushvalue(L, 7);
                  lua_call(L, 1, 1);
                  lua_pushlstring(L,
                                  ""
                                  "/",
                                  (sizeof("/") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc1171 = lua_gettop(L);
                  lc_getupvalue(L, 3, 1, 200);
                  lua_pushnumber(L, 1);
                  lc_add(L, 8, -1);
                  lua_remove(L, -2);
                  lua_gettable(L, 6);
                  lua_pushboolean(L, 1);
                  lua_call(L, 2, (-1));
                  lua_call(L, (lua_gettop(L) - lc1171), 1);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_replace(L, 7);
                  lua_pushnumber(L, 1);
                  lc_add(L, 8, -1);
                  lua_remove(L, -2);
                  lua_replace(L, 8);
                }
                lua_settop(L, 8);
                lua_settop(L, -(1) - 1);
                const int lc1172 = lua_gettop(L);
                lua_pushvalue(L, 4);
                lua_pushvalue(L, 7);
                lua_call(L, 1, (-1));
                return (lua_gettop(L) - lc1172);
              }
              lua_settop(L, 6);
            }
            lua_settop(L, 5);
          }
          lua_settop(L, 5);
        }
        lua_settop(L, 5);
      }
      lua_settop(L, 5);
    }
    lua_settop(L, 5);
  }
  lua_settop(L, 5);
  lc_getupvalue(L, 3, 0, 201);
  const int lc1174 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1174) {
    const int lc1175 = lua_gettop(L);
    lc_getupvalue(L, 3, 30, 3);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc1175);
  } else {
    const int lc1176 = lua_gettop(L);
    lc_getupvalue(L, 3, 30, 3);
    const int lc1177 = lua_gettop(L);
    lc_getupvalue(L, 3, 18, 146);
    lua_pushvalue(L, 1);
    lua_call(L, 1, (-1));
    lua_call(L, (lua_gettop(L) - lc1177), (-1));
    return (lua_gettop(L) - lc1176);
  }
  lua_settop(L, 5);
  return 0;
}
static inline int lcf2__(lua_State *L) {
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf9_o, 1);
  lua_rawseti(L, 2, 200);
  lc_getupvalue(L, 2, 2, 168);
  const int lc1178 = lua_gettop(L);
  lc_getupvalue(L, 2, 29, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1178), 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lc_getupvalue(L, 2, 29, 88);
  lua_pushvalue(L, 3);
  lua_call(L, 1, 1);
  const int lc1180 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1180) {
    lua_pushlstring(L,
                    ""
                    "()",
                    (sizeof("()") / sizeof(char)) - 1);
    return 1;
  } else {
    lc_getupvalue(L, 2, 29, 92);
    lua_pushvalue(L, 3);
    lua_call(L, 1, 1);
    const int lc1182 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1182) {
      lua_pushlstring(L,
                      ""
                      "(",
                      (sizeof("(") / sizeof(char)) - 1);
      lua_replace(L, 4);
      lua_pushlstring(L,
                      ""
                      "",
                      (sizeof("") / sizeof(char)) - 1);
      lua_replace(L, 5);
      while (1) {
        lc_getupvalue(L, 2, 29, 92);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 5);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1184 = lua_gettop(L);
        lc_getupvalue(L, 2, 1, 199);
        const int lc1185 = lua_gettop(L);
        lc_getupvalue(L, 2, 29, 91);
        lua_pushvalue(L, 3);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc1185), (-1));
        lua_call(L, (lua_gettop(L) - lc1184), 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 4);
        lua_pushlstring(L,
                        ""
                        " ",
                        (sizeof(" ") / sizeof(char)) - 1);
        lua_replace(L, 5);
        lc_getupvalue(L, 2, 29, 90);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lua_replace(L, 3);
      }
      lua_settop(L, 5);
      lc_getupvalue(L, 2, 29, 88);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      const int lc1187 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1187) {
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_pushlstring(L,
                        ""
                        ")",
                        (sizeof(")") / sizeof(char)) - 1);
        lua_concat(L, 2);
        lua_replace(L, 4);
      } else {
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 4);
        lua_call(L, 1, 1);
        lua_pushlstring(L,
                        ""
                        " . ",
                        (sizeof(" . ") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1188 = lua_gettop(L);
        lc_getupvalue(L, 2, 1, 199);
        lua_pushvalue(L, 3);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc1188), 1);
        lua_pushlstring(L,
                        ""
                        ")",
                        (sizeof(")") / sizeof(char)) - 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_replace(L, 4);
      }
      lua_settop(L, 5);
      lua_pushvalue(L, 4);
      return 1;
    } else {
      lc_getupvalue(L, 2, 29, 86);
      lua_pushvalue(L, 3);
      lua_call(L, 1, 1);
      const int lc1190 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1190) {
        lc_getupvalue(L, 2, 29, 85);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lc_getupvalue(L, 2, 29, 84);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        lc_getupvalue(L, 2, 12, 151);
        lua_pushvalue(L, 7);
        lua_call(L, 1, 1);
        lua_pushboolean(L, 0);
        const int lc1192 = lua_equal(L, 8, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc1192);
        lua_pushboolean(L, !(lua_toboolean(L, -1)));
        lua_remove(L, -2);
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          const double lc1193 = lua_objlen(L, 8);
          lua_pushnumber(L, lc1193);
          lua_pushnumber(L, 2);
          const int lc1194 = lua_equal(L, -2, -1);
          lua_settop(L, -(2) - 1);
          lua_pushboolean(L, lc1194);
        }
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, 2, 3, 167);
          lua_pushvalue(L, 6);
          lc_getupvalue(L, 2, 29, 56);
          lua_call(L, 2, 1);
        }
        if (lua_toboolean(L, -1)) {
          lua_settop(L, -(1) - 1);
          lc_getupvalue(L, 2, 3, 167);
          lua_pushnumber(L, 1);
          lua_gettable(L, 8);
          lc_getupvalue(L, 2, 29, 57);
          lua_call(L, 2, 1);
        }
        const int lc1195 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1195) {
          const int lc1196 = lua_gettop(L);
          lc_getupvalue(L, 2, 0, 200);
          lua_pushnumber(L, 2);
          lua_gettable(L, 8);
          lua_pushboolean(L, 0);
          lua_call(L, 2, (-1));
          return (lua_gettop(L) - lc1196);
        }
        lua_settop(L, 8);
        lua_pushlstring(L,
                        ""
                        "#",
                        (sizeof("#") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1197 = lua_gettop(L);
        lc_getupvalue(L, 2, 1, 199);
        const int lc1198 = lua_gettop(L);
        lc_getupvalue(L, 2, 29, 93);
        lua_pushvalue(L, 6);
        lua_pushvalue(L, 7);
        lua_call(L, 2, (-1));
        lua_call(L, (lua_gettop(L) - lc1198), (-1));
        lua_call(L, (lua_gettop(L) - lc1197), 1);
        lua_concat(L, 2);
        return 1;
      } else {
        lc_getupvalue(L, 2, 29, 96);
        lua_pushvalue(L, 3);
        lua_call(L, 1, 1);
        const int lc1200 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1200) {
          const int lc1201 = lua_gettop(L);
          lc_getupvalue(L, 2, 29, 95);
          lua_pushvalue(L, 3);
          lua_call(L, 1, (-1));
          return (lua_gettop(L) - lc1201);
        } else {
          lc_getupvalue(L, 2, 29, 100);
          lua_pushvalue(L, 3);
          lua_call(L, 1, 1);
          const int lc1203 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1203) {
            lua_pushlstring(L,
                            ""
                            ";(",
                            (sizeof(";(") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc1204 = lua_gettop(L);
            lc_getupvalue(L, 2, 1, 199);
            const int lc1205 = lua_gettop(L);
            lc_getupvalue(L, 2, 29, 99);
            lua_pushvalue(L, 3);
            lua_call(L, 1, (-1));
            lua_call(L, (lua_gettop(L) - lc1205), (-1));
            lua_call(L, (lua_gettop(L) - lc1204), 1);
            lua_pushlstring(L,
                            ""
                            " ",
                            (sizeof(" ") / sizeof(char)) - 1);
            lua_getfield(L, (-10001), "tostring");
            const int lc1206 = lua_gettop(L);
            lc_getupvalue(L, 2, 1, 199);
            const int lc1207 = lua_gettop(L);
            lc_getupvalue(L, 2, 29, 98);
            lua_pushvalue(L, 3);
            lua_call(L, 1, (-1));
            lua_call(L, (lua_gettop(L) - lc1207), (-1));
            lua_call(L, (lua_gettop(L) - lc1206), 1);
            lua_pushlstring(L,
                            ""
                            ")",
                            (sizeof(")") / sizeof(char)) - 1);
            lua_concat(L, 2);
            lua_concat(L, 2);
            lua_concat(L, 2);
            lua_concat(L, 2);
            return 1;
          } else {
            lc_getupvalue(L, 2, 29, 80);
            lua_pushvalue(L, 3);
            lua_call(L, 1, 1);
            const int lc1209 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc1209) {
              lua_pushlstring(L,
                              ""
                              "$(",
                              (sizeof("$(") / sizeof(char)) - 1);
              lua_getfield(L, (-10001), "tostring");
              const int lc1210 = lua_gettop(L);
              lc_getupvalue(L, 2, 1, 199);
              const int lc1211 = lua_gettop(L);
              lc_getupvalue(L, 2, 29, 14);
              const int lc1212 = lua_gettop(L);
              lc_getupvalue(L, 2, 29, 79);
              lua_pushvalue(L, 3);
              lua_call(L, 1, (-1));
              lua_call(L, (lua_gettop(L) - lc1212), (-1));
              lua_call(L, (lua_gettop(L) - lc1211), (-1));
              lua_call(L, (lua_gettop(L) - lc1210), 1);
              lua_pushlstring(L,
                              ""
                              " ",
                              (sizeof(" ") / sizeof(char)) - 1);
              lua_getfield(L, (-10001), "tostring");
              const int lc1213 = lua_gettop(L);
              lc_getupvalue(L, 2, 1, 199);
              const int lc1214 = lua_gettop(L);
              lc_getupvalue(L, 2, 29, 78);
              lua_pushvalue(L, 3);
              lua_call(L, 1, (-1));
              lua_call(L, (lua_gettop(L) - lc1214), (-1));
              lua_call(L, (lua_gettop(L) - lc1213), 1);
              lua_pushlstring(L,
                              ""
                              ")",
                              (sizeof(")") / sizeof(char)) - 1);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              lua_concat(L, 2);
              return 1;
            } else {
              lc_getupvalue(L, 2, 29, 71);
              lua_pushvalue(L, 3);
              lua_call(L, 1, 1);
              const int lc1216 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc1216) {
                lua_pushlstring(L,
                                ""
                                "%(",
                                (sizeof("%(") / sizeof(char)) - 1);
                lua_getfield(L, (-10001), "tostring");
                const int lc1217 = lua_gettop(L);
                lc_getupvalue(L, 2, 1, 199);
                const int lc1218 = lua_gettop(L);
                lc_getupvalue(L, 2, 29, 70);
                lua_pushvalue(L, 3);
                lua_call(L, 1, (-1));
                lua_call(L, (lua_gettop(L) - lc1218), (-1));
                lua_call(L, (lua_gettop(L) - lc1217), 1);
                lua_pushlstring(L,
                                ""
                                " ",
                                (sizeof(" ") / sizeof(char)) - 1);
                lua_getfield(L, (-10001), "tostring");
                const int lc1219 = lua_gettop(L);
                lc_getupvalue(L, 2, 1, 199);
                const int lc1220 = lua_gettop(L);
                lc_getupvalue(L, 2, 29, 31);
                const int lc1221 = lua_gettop(L);
                lc_getupvalue(L, 2, 29, 69);
                lua_pushvalue(L, 3);
                lua_call(L, 1, (-1));
                lua_call(L, (lua_gettop(L) - lc1221), (-1));
                lua_call(L, (lua_gettop(L) - lc1220), (-1));
                lua_call(L, (lua_gettop(L) - lc1219), 1);
                lua_pushlstring(L,
                                ""
                                ")",
                                (sizeof(")") / sizeof(char)) - 1);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                lua_concat(L, 2);
                return 1;
              } else {
                lc_getupvalue(L, 2, 29, 76);
                lua_pushvalue(L, 3);
                lua_call(L, 1, 1);
                const int lc1223 = lua_toboolean(L, -1);
                lua_settop(L, -(1) - 1);
                if (lc1223) {
                  lua_pushlstring(L,
                                  ""
                                  "@(",
                                  (sizeof("@(") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc1224 = lua_gettop(L);
                  lc_getupvalue(L, 2, 1, 199);
                  const int lc1225 = lua_gettop(L);
                  lc_getupvalue(L, 2, 29, 14);
                  const int lc1226 = lua_gettop(L);
                  lc_getupvalue(L, 2, 29, 75);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc1226), (-1));
                  lua_call(L, (lua_gettop(L) - lc1225), (-1));
                  lua_call(L, (lua_gettop(L) - lc1224), 1);
                  lua_pushlstring(L,
                                  ""
                                  " ",
                                  (sizeof(" ") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc1227 = lua_gettop(L);
                  lc_getupvalue(L, 2, 1, 199);
                  const int lc1228 = lua_gettop(L);
                  lc_getupvalue(L, 2, 29, 74);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc1228), (-1));
                  lua_call(L, (lua_gettop(L) - lc1227), 1);
                  lua_pushlstring(L,
                                  ""
                                  " ",
                                  (sizeof(" ") / sizeof(char)) - 1);
                  lua_getfield(L, (-10001), "tostring");
                  const int lc1229 = lua_gettop(L);
                  lc_getupvalue(L, 2, 1, 199);
                  const int lc1230 = lua_gettop(L);
                  lc_getupvalue(L, 2, 29, 31);
                  const int lc1231 = lua_gettop(L);
                  lc_getupvalue(L, 2, 29, 73);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, (-1));
                  lua_call(L, (lua_gettop(L) - lc1231), (-1));
                  lua_call(L, (lua_gettop(L) - lc1230), (-1));
                  lua_call(L, (lua_gettop(L) - lc1229), 1);
                  lua_pushlstring(L,
                                  ""
                                  ")",
                                  (sizeof(")") / sizeof(char)) - 1);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  lua_concat(L, 2);
                  return 1;
                } else {
                  lc_getupvalue(L, 2, 29, 67);
                  lua_pushvalue(L, 3);
                  lua_call(L, 1, 1);
                  const int lc1233 = lua_toboolean(L, -1);
                  lua_settop(L, -(1) - 1);
                  if (lc1233) {
                    lua_pushlstring(L,
                                    ""
                                    "^(",
                                    (sizeof("^(") / sizeof(char)) - 1);
                    lua_getfield(L, (-10001), "tostring");
                    const int lc1234 = lua_gettop(L);
                    lc_getupvalue(L, 2, 1, 199);
                    const int lc1235 = lua_gettop(L);
                    lc_getupvalue(L, 2, 29, 66);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, (-1));
                    lua_call(L, (lua_gettop(L) - lc1235), (-1));
                    lua_call(L, (lua_gettop(L) - lc1234), 1);
                    lua_pushlstring(L,
                                    ""
                                    " ",
                                    (sizeof(" ") / sizeof(char)) - 1);
                    lua_getfield(L, (-10001), "tostring");
                    const int lc1236 = lua_gettop(L);
                    lc_getupvalue(L, 2, 1, 199);
                    const int lc1237 = lua_gettop(L);
                    lc_getupvalue(L, 2, 29, 31);
                    const int lc1238 = lua_gettop(L);
                    lc_getupvalue(L, 2, 29, 65);
                    lua_pushvalue(L, 3);
                    lua_call(L, 1, (-1));
                    lua_call(L, (lua_gettop(L) - lc1238), (-1));
                    lua_call(L, (lua_gettop(L) - lc1237), (-1));
                    lua_call(L, (lua_gettop(L) - lc1236), 1);
                    lua_pushlstring(L,
                                    ""
                                    ")",
                                    (sizeof(")") / sizeof(char)) - 1);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    lua_concat(L, 2);
                    return 1;
                  }
                  lua_settop(L, 5);
                }
                lua_settop(L, 5);
              }
              lua_settop(L, 5);
            }
            lua_settop(L, 5);
          }
          lua_settop(L, 5);
        }
        lua_settop(L, 5);
      }
      lua_settop(L, 5);
    }
    lua_settop(L, 5);
  }
  lua_settop(L, 5);
  const int lc1239 = lua_gettop(L);
  lc_getupvalue(L, 2, 29, 114);
  lua_call(L, 0, (-1));
  return (lua_gettop(L) - lc1239);
}
static inline int lcf2_s(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 205);
  lua_pushnumber(L, 0);
  const int lc1242 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc1242);
  return 1;
}
static inline int lcf4_t(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 204);
  lua_call(L, 0, 1);
  lua_pushboolean(L, !(lua_toboolean(L, -1)));
  lua_remove(L, -2);
  return 1;
}
static inline int lcf5_a(lua_State *L) {
  lua_settop(L, 1);
  lua_pushnil(L);
  const int lc1246 = lua_equal(L, 1, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1246);
  const int lc1247 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1247) {
    lua_pushlstring(L,
                    ""
                    "",
                    (sizeof("") / sizeof(char)) - 1);
    lua_replace(L, 1);
  }
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "error");
  lua_pushlstring(L,
                  ""
                  "MT parse ERROR ",
                  (sizeof("MT parse ERROR ") / sizeof(char)) - 1);
  lua_getfield(L, (-10001), "tostring");
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lua_call(L, 1, 0);
  return 0;
}
static inline int lcf3_i(lua_State *L) {
  lua_settop(L, 1);
  lua_pushboolean(L, !(lua_toboolean(L, 1)));
  const int lc1250 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1250) {
    const int lc1251 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 1, 206);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1251);
  }
  lua_settop(L, 1);
  return 0;
}
static inline int lcf4_r(lua_State *L) {
  lua_settop(L, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 207);
  const int lc1252 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 2, 203);
  lua_call(L, 0, (-1));
  lua_call(L, (lua_gettop(L) - lc1252), 0);
  lc_getupvalue(L, ((-10002) - (1)), 2, 205);
  lua_pushnumber(L, 1);
  lc_sub(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_setupvalue(L, ((-10002) - (1)), 2, 205);
  const int lc1253 = lua_gettop(L);
  lua_getfield(L, (-10001), "string");
  lua_pushlstring(L,
                  ""
                  "sub",
                  (sizeof("sub") / sizeof(char)) - 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 3, 202);
  lc_getupvalue(L, ((-10002) - (1)), 2, 205);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 2, 205);
  lua_pushnumber(L, 1);
  lc_add(L, -2, -1);
  lua_remove(L, -2);
  lua_remove(L, -2);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc1253);
}
static inline int lcf3_n(lua_State *L) {
  lua_settop(L, 1);
  lua_getfield(L, (-10001), "table");
  lua_pushlstring(L,
                  ""
                  "remove",
                  (sizeof("remove") / sizeof(char)) - 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 208);
  lua_call(L, 1, 1);
  lua_getfield(L, (-10001), "table");
  lua_pushlstring(L,
                  ""
                  "remove",
                  (sizeof("remove") / sizeof(char)) - 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  lc_getupvalue(L, ((-10002) - (1)), 0, 208);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 3);
  lua_pushnil(L);
  const int lc1256 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc1256);
  if (!(lua_toboolean(L, -1))) {
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 2);
    lua_pushnil(L);
    const int lc1257 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc1257);
  }
  const int lc1258 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1258) {
    const int lc1259 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 2, 206);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1259);
  } else {
    const int lc1260 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 34, 2);
    const int lc1261 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 0, 208);
    lua_pushvalue(L, 1);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, (-1));
    lua_call(L, (lua_gettop(L) - lc1261), (-1));
    return (lua_gettop(L) - lc1260);
  }
  lua_settop(L, 3);
  return 0;
}
static inline int lcf1285(lua_State *L) {
  lua_settop(L, 2);
  lc_getupvalue(L, ((-10002) - (1)), 8, 159);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushboolean(L, 0);
  const int lc1281 = lua_equal(L, 3, -1);
  lua_settop(L, -(1) - 1);
  lua_pushboolean(L, lc1281);
  const int lc1282 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1282) {
    const int lc1283 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 2, 206);
    lua_call(L, 0, (-1));
    return (lua_gettop(L) - lc1283);
  } else {
    const int lc1284 = lua_gettop(L);
    lc_getupvalue(L, ((-10002) - (1)), 33, 81);
    lua_pushvalue(L, 3);
    lua_pushvalue(L, 2);
    lua_call(L, 2, (-1));
    return (lua_gettop(L) - lc1284);
  }
  lua_settop(L, 3);
  return 0;
}
static inline int lcf1_C(lua_State *L) {
  lua_checkstack(L, 21);
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 202);
  lc_newclosuretable(L, 2);
  lua_settop(L, (lua_gettop(L) + 3));
  lua_rawseti(L, 3, 203);
  lua_rawseti(L, 3, 204);
  lua_rawseti(L, 3, 205);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf2_s, 1);
  lc_setupvalue(L, 3, 0, 204);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf4_t, 1);
  lc_setupvalue(L, 3, 0, 203);
  lc_getupvalue(L, 3, 1, 202);
  const double lc1243 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc1243);
  lc_setupvalue(L, 3, 0, 205);
  lc_newclosuretable(L, 3);
  lua_pushcclosure(L, (lcf5_a), 0);
  lua_rawseti(L, 4, 206);
  lc_newclosuretable(L, 4);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf3_i, 1);
  lua_rawseti(L, 5, 207);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf4_r, 1);
  lc_newclosuretable(L, 5);
  lua_createtable(L, 0, 0);
  lua_rawseti(L, 7, 208);
  lua_pushvalue(L, 7);
  lua_pushcclosure(L, lcf3_n, 1);
  while (1) {
    lc_getupvalue(L, 7, 3, 203);
    lua_call(L, 0, 1);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_pushvalue(L, 6);
    lua_call(L, 0, 1);
    lua_pushlstring(L,
                    ""
                    "^",
                    (sizeof("^") / sizeof(char)) - 1);
    const int lc1264 = lua_equal(L, 9, -1);
    lua_settop(L, -(1) - 1);
    lua_pushboolean(L, lc1264);
    const int lc1265 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1265) {
      lua_pushlstring(L,
                      ""
                      "",
                      (sizeof("") / sizeof(char)) - 1);
      while (1) {
        lua_pushboolean(L, 1);
        if (!(lua_toboolean(L, -1))) {
          break;
        }
        lua_settop(L, -(1) - 1);
        lua_pushvalue(L, 6);
        lua_call(L, 0, 1);
        lua_pushlstring(L,
                        ""
                        "^",
                        (sizeof("^") / sizeof(char)) - 1);
        const int lc1268 = lua_equal(L, 11, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc1268);
        const int lc1269 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1269) {
          break;
        }
        lua_settop(L, 11);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 11);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushvalue(L, 10);
        lua_call(L, 1, 1);
        lua_concat(L, 2);
        lua_replace(L, 10);
        lua_settop(L, -(1) - 1);
      }
      lua_settop(L, 10);
      lc_getupvalue(L, 7, 34, 2);
      const int lc1270 = lua_gettop(L);
      lc_getupvalue(L, 7, 0, 208);
      lc_getupvalue(L, 7, 30, 137);
      lua_pushvalue(L, 10);
      lua_call(L, 1, (-1));
      lua_call(L, (lua_gettop(L) - lc1270), 0);
    } else {
      lua_pushlstring(L,
                      ""
                      ".",
                      (sizeof(".") / sizeof(char)) - 1);
      const int lc1272 = lua_equal(L, 9, -1);
      lua_settop(L, -(1) - 1);
      lua_pushboolean(L, lc1272);
      const int lc1273 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1273) {
        lua_pushvalue(L, 8);
        lc_getupvalue(L, 7, 33, 93);
        lua_call(L, 1, 0);
      } else {
        lua_pushlstring(L,
                        ""
                        "#",
                        (sizeof("#") / sizeof(char)) - 1);
        const int lc1275 = lua_equal(L, 9, -1);
        lua_settop(L, -(1) - 1);
        lua_pushboolean(L, lc1275);
        const int lc1276 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1276) {
          lua_pushvalue(L, 8);
          lc_getupvalue(L, 7, 33, 87);
          lua_call(L, 1, 0);
        } else {
          lua_pushlstring(L,
                          ""
                          "$",
                          (sizeof("$") / sizeof(char)) - 1);
          const int lc1278 = lua_equal(L, 9, -1);
          lua_settop(L, -(1) - 1);
          lua_pushboolean(L, lc1278);
          const int lc1279 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1279) {
            lua_pushvalue(L, 8);
            lua_pushvalue(L, 7);
            lua_pushcclosure(L, lcf1285, 1);
            lua_call(L, 1, 0);
          } else {
            lua_pushlstring(L,
                            ""
                            "_",
                            (sizeof("_") / sizeof(char)) - 1);
            const int lc1287 = lua_equal(L, 9, -1);
            lua_settop(L, -(1) - 1);
            lua_pushboolean(L, lc1287);
            const int lc1288 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc1288) {
              lc_getupvalue(L, 7, 34, 2);
              lc_getupvalue(L, 7, 0, 208);
              lc_getupvalue(L, 7, 33, 89);
              lua_call(L, 2, 0);
            } else {
              const int lc1289 = lua_gettop(L);
              lc_getupvalue(L, 7, 2, 206);
              lua_call(L, 0, (-1));
              return (lua_gettop(L) - lc1289);
            }
            lua_settop(L, 9);
          }
          lua_settop(L, 9);
        }
        lua_settop(L, 9);
      }
      lua_settop(L, 9);
    }
    lua_settop(L, 9);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 8);
  lc_getupvalue(L, 7, 1, 207);
  const int lc1290 = lua_gettop(L);
  lc_getupvalue(L, 7, 3, 204);
  lua_call(L, 0, (-1));
  lua_call(L, (lua_gettop(L) - lc1290), 0);
  lc_getupvalue(L, 7, 1, 207);
  lc_getupvalue(L, 7, 0, 208);
  const double lc1291 = lua_objlen(L, -1);
  lua_settop(L, -(1) - 1);
  lua_pushnumber(L, lc1291);
  lua_pushnumber(L, 1);
  const int lc1292 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc1292);
  lua_call(L, 1, 0);
  lc_getupvalue(L, 7, 0, 208);
  lua_pushnumber(L, 1);
  lua_gettable(L, -2);
  lua_remove(L, -2);
  return 1;
}
static inline int lcf10_o(lua_State *L) {
  lua_settop(L, 4);
  lua_getfield(L, (-10001), "tostring");
  lc_getupvalue(L, ((-10002) - (1)), 1, 209);
  lua_call(L, 1, 1);
  lua_getfield(L, (-10001), "tostring");
  lua_pushvalue(L, 2);
  lua_call(L, 1, 1);
  lua_concat(L, 2);
  lc_setupvalue(L, ((-10002) - (1)), 1, 209);
  const int lc1299 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 32, 1);
  const int lc1300 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 210);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 1);
  lua_call(L, 1, 1);
  lua_pushvalue(L, 4);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1300), (-1));
  return (lua_gettop(L) - lc1299);
}
static inline int lcf1314(lua_State *L) {
  lua_settop(L, 1);
  const int lc1312 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 30, 14);
  const int lc1313 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 30, 79);
  lua_pushvalue(L, 1);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1313), (-1));
  return (lua_gettop(L) - lc1312);
}
static inline int lcf2_N(lua_State *L) {
  lua_checkstack(L, 21);
  lua_settop(L, 1);
  lua_createtable(L, 1, 0);
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_rawseti(L, 3, 209);
  while (1) {
    const double lc1295 = lua_objlen(L, 2);
    lua_pushnumber(L, lc1295);
    lua_pushnumber(L, 0);
    const int lc1296 = lua_equal(L, -2, -1);
    lua_settop(L, -(2) - 1);
    lua_pushboolean(L, lc1296);
    lua_pushboolean(L, !(lua_toboolean(L, -1)));
    lua_remove(L, -2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lc_newclosuretable(L, 3);
    lua_createtable(L, 0, 0);
    lua_rawseti(L, 4, 210);
    lua_getfield(L, (-10001), "ipairs");
    lua_pushvalue(L, 2);
    lua_call(L, 1, 3);
    while (1) {
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_pushvalue(L, -3);
      lua_call(L, 2, 2);
      if ((lua_type(L, (-2)) == 0)) {
        break;
      }
      lua_pushvalue(L, -2);
      lua_replace(L, -4);
      lc_getupvalue(L, 4, 30, 29);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      lua_replace(L, 9);
      lua_pushvalue(L, 4);
      lua_pushcclosure(L, lcf10_o, 1);
      lc_getupvalue(L, 4, 30, 96);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      const int lc1302 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1302) {
        lua_getfield(L, (-10001), "tostring");
        lc_getupvalue(L, 4, 1, 209);
        lua_call(L, 1, 1);
        lua_getfield(L, (-10001), "tostring");
        lua_pushlstring(L,
                        ""
                        "^",
                        (sizeof("^") / sizeof(char)) - 1);
        lua_getfield(L, (-10001), "tostring");
        const int lc1303 = lua_gettop(L);
        lc_getupvalue(L, 4, 30, 95);
        lua_pushvalue(L, 9);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc1303), 1);
        lua_pushlstring(L,
                        ""
                        "^",
                        (sizeof("^") / sizeof(char)) - 1);
        lua_concat(L, 2);
        lua_concat(L, 2);
        lua_call(L, 1, 1);
        lua_concat(L, 2);
        lc_setupvalue(L, 4, 1, 209);
      } else {
        lc_getupvalue(L, 4, 30, 92);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        const int lc1305 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1305) {
          lua_pushvalue(L, 10);
          lua_pushvalue(L, 9);
          lua_pushlstring(L,
                          ""
                          ".",
                          (sizeof(".") / sizeof(char)) - 1);
          lc_getupvalue(L, 4, 30, 91);
          lc_getupvalue(L, 4, 30, 90);
          lua_call(L, 4, 0);
        } else {
          lc_getupvalue(L, 4, 30, 88);
          lua_pushvalue(L, 9);
          lua_call(L, 1, 1);
          const int lc1307 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1307) {
            lua_getfield(L, (-10001), "tostring");
            lc_getupvalue(L, 4, 1, 209);
            lua_call(L, 1, 1);
            lua_getfield(L, (-10001), "tostring");
            lua_pushlstring(L,
                            ""
                            "_",
                            (sizeof("_") / sizeof(char)) - 1);
            lua_call(L, 1, 1);
            lua_concat(L, 2);
            lc_setupvalue(L, 4, 1, 209);
          } else {
            lc_getupvalue(L, 4, 30, 86);
            lua_pushvalue(L, 9);
            lua_call(L, 1, 1);
            const int lc1309 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc1309) {
              lua_pushvalue(L, 10);
              lua_pushvalue(L, 9);
              lua_pushlstring(L,
                              ""
                              "#",
                              (sizeof("#") / sizeof(char)) - 1);
              lc_getupvalue(L, 4, 30, 85);
              lc_getupvalue(L, 4, 30, 84);
              lua_call(L, 4, 0);
            } else {
              lc_getupvalue(L, 4, 30, 28);
              lua_pushvalue(L, 9);
              lua_call(L, 1, 1);
              const int lc1311 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc1311) {
                lc_getupvalue(L, 4, 12, 152);
                lua_pushvalue(L, 9);
                lua_call(L, 1, 1);
                lua_pushvalue(L, 10);
                lua_pushvalue(L, 11);
                lua_pushlstring(L,
                                ""
                                "$",
                                (sizeof("$") / sizeof(char)) - 1);
                lua_pushvalue(L, 4);
                lua_pushcclosure(L, lcf1314, 1);
                lc_getupvalue(L, 4, 30, 78);
                lua_call(L, 4, 0);
              } else {
                const int lc1315 = lua_gettop(L);
                lc_getupvalue(L, 4, 30, 114);
                lua_call(L, 0, (-1));
                return (lua_gettop(L) - lc1315);
              }
              lua_settop(L, 10);
            }
            lua_settop(L, 10);
          }
          lua_settop(L, 10);
        }
        lua_settop(L, 10);
      }
      lua_settop(L, 10);
      lua_settop(L, -(3) - 1);
    }
    lua_settop(L, 4);
    lc_getupvalue(L, 4, 0, 210);
    lua_replace(L, 2);
    lua_settop(L, -(1) - 1);
  }
  lua_settop(L, 3);
  lc_getupvalue(L, 3, 0, 209);
  return 1;
}
static inline int lcf1318(lua_State *L) {
  lua_settop(L, 0);
  lua_createtable(L, 2, 0);
  lua_pushboolean(L, 0);
  lua_rawseti(L, -2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 212);
  lua_rawseti(L, -2, 2);
  return 1;
}
static inline int lcf3_k(lua_State *L) {
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 212);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1318, 1);
  return 1;
}
static inline int lcf1322(lua_State *L) {
  lua_settop(L, 0);
  lua_createtable(L, 2, 0);
  lua_pushboolean(L, 1);
  lua_rawseti(L, -2, 1);
  const int lc1321 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 214);
  lua_call(L, 0, (-1));
  while ((lua_gettop(L) > lc1321)) {
    lua_rawseti(L, lc1321, (1 + (lua_gettop(L) - lc1321)));
  }
  return 1;
}
static inline int lcf5_d(lua_State *L) {
  lua_settop(L, 1);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 214);
  lua_pushvalue(L, 2);
  lua_pushcclosure(L, lcf1322, 1);
  return 1;
}
static inline int lcf1_x(lua_State *L) {
  lua_settop(L, 1);
  lua_pushvalue(L, 1);
  lua_call(L, 0, 1);
  while (1) {
    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    if (!(lua_toboolean(L, -1))) {
      break;
    }
    lua_settop(L, -(1) - 1);
    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    lua_call(L, 0, 1);
    lua_replace(L, 2);
  }
  lua_settop(L, 2);
  lua_pushnumber(L, 2);
  lua_gettable(L, 2);
  return 1;
}
static inline int lcf3_F(lua_State *L) {
  lua_settop(L, 2);
  const int lc1335 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 33, 87);
  const int lc1336 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 217);
  lc_getupvalue(L, ((-10002) - (1)), 33, 30);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1336), (-1));
  return (lua_gettop(L) - lc1335);
}
static inline int lcf3_P(lua_State *L) {
  lua_settop(L, 1);
  const int lc1337 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 33, 87);
  lc_getupvalue(L, ((-10002) - (1)), 1, 216);
  lua_pushvalue(L, 1);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1337);
}
static inline int lcf1_p(lua_State *L) {
  lua_settop(L, 2);
  lua_getfield(L, (-10001), "error");
  lua_pushlstring(L,
                  ""
                  "WIP",
                  (sizeof("WIP") / sizeof(char)) - 1);
  lua_call(L, 1, 0);
  return 0;
}
static inline int lcf6_a(lua_State *L) {
  lua_settop(L, 0);
  const int lc1358 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 219);
  lc_getupvalue(L, ((-10002) - (1)), 1, 225);
  lc_getupvalue(L, ((-10002) - (1)), 0, 226);
  lua_call(L, 2, (-1));
  return (lua_gettop(L) - lc1358);
}
static inline int lcf7_a(lua_State *L) {
  lua_settop(L, 0);
  const int lc1364 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 6, 218);
  lc_getupvalue(L, ((-10002) - (1)), 3, 227);
  lc_getupvalue(L, ((-10002) - (1)), 2, 228);
  lc_getupvalue(L, ((-10002) - (1)), 40, 68);
  lc_getupvalue(L, ((-10002) - (1)), 5, 223);
  lc_getupvalue(L, ((-10002) - (1)), 1, 229);
  lua_call(L, 2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 230);
  lua_call(L, 4, (-1));
  return (lua_gettop(L) - lc1364);
}
static inline int lcf8_a(lua_State *L) {
  lua_settop(L, 0);
  const int lc1384 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 7, 218);
  lc_getupvalue(L, ((-10002) - (1)), 4, 231);
  lc_getupvalue(L, ((-10002) - (1)), 3, 232);
  lc_getupvalue(L, ((-10002) - (1)), 2, 233);
  lc_getupvalue(L, ((-10002) - (1)), 0, 235);
  lc_getupvalue(L, ((-10002) - (1)), 1, 234);
  lua_call(L, 5, (-1));
  return (lua_gettop(L) - lc1384);
}
static inline int lcf2_l(lua_State *L) {
  lua_settop(L, 0);
  const int lc1393 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 9, 218);
  const int lc1394 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 6, 236);
  lc_getupvalue(L, ((-10002) - (1)), 5, 237);
  lc_getupvalue(L, ((-10002) - (1)), 4, 238);
  lc_getupvalue(L, ((-10002) - (1)), 2, 240);
  lc_getupvalue(L, ((-10002) - (1)), 43, 87);
  const int lc1395 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 43, 55);
  lc_getupvalue(L, ((-10002) - (1)), 43, 30);
  const int lc1396 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 43, 30);
  lc_getupvalue(L, ((-10002) - (1)), 0, 242);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 7, 224);
  const int lc1397 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 43, 30);
  lc_getupvalue(L, ((-10002) - (1)), 43, 7);
  lc_getupvalue(L, ((-10002) - (1)), 3, 239);
  lua_call(L, 1, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 242);
  lua_call(L, 2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 43, 7);
  lc_getupvalue(L, ((-10002) - (1)), 1, 241);
  lua_call(L, 1, (-1));
  lua_call(L, (lua_gettop(L) - lc1397), (-1));
  lua_call(L, (lua_gettop(L) - lc1396), (-1));
  lua_call(L, (lua_gettop(L) - lc1395), (-1));
  lua_call(L, (lua_gettop(L) - lc1394), (-1));
  return (lua_gettop(L) - lc1393);
}
static inline int lcf1404(lua_State *L) {
  lua_settop(L, 0);
  const int lc1403 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 220);
  lc_getupvalue(L, ((-10002) - (1)), 1, 221);
  lc_getupvalue(L, ((-10002) - (1)), 1, 222);
  lc_getupvalue(L, ((-10002) - (1)), 1, 219);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc1403);
}
static inline int lcf1410(lua_State *L) {
  lua_settop(L, 0);
  const int lc1409 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 3, 218);
  lc_getupvalue(L, ((-10002) - (1)), 2, 219);
  lc_getupvalue(L, ((-10002) - (1)), 2, 220);
  lc_getupvalue(L, ((-10002) - (1)), 37, 68);
  lc_getupvalue(L, ((-10002) - (1)), 2, 223);
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, ((-10002) - (1)), 0, 243);
  lua_rawseti(L, -2, 1);
  lua_call(L, 2, 1);
  lc_getupvalue(L, ((-10002) - (1)), 0, 244);
  lua_call(L, 4, (-1));
  return (lua_gettop(L) - lc1409);
}
static inline int lcf1411(lua_State *L) {
  lua_settop(L, 2);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 243);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 244);
  const int lc1408 = lua_gettop(L);
  lc_getupvalue(L, 3, 7, 213);
  lua_pushvalue(L, 3);
  lua_pushcclosure(L, lcf1410, 1);
  lua_call(L, 1, (-1));
  return (lua_gettop(L) - lc1408);
}
static inline int lcf1412(lua_State *L) {
  lua_settop(L, 0);
  const int lc1406 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 1, 220);
  lc_getupvalue(L, ((-10002) - (1)), 1, 221);
  lc_getupvalue(L, ((-10002) - (1)), 1, 222);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushcclosure(L, lcf1411, 1);
  lua_call(L, 3, (-1));
  return (lua_gettop(L) - lc1406);
}
static inline int lcf3_b(lua_State *L) {
  lua_checkstack(L, 31);
  lua_settop(L, 5);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 219);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 220);
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 221);
  lua_pushvalue(L, 4);
  lua_rawseti(L, -2, 222);
  lua_pushvalue(L, 5);
  lua_rawseti(L, -2, 223);
  lc_getupvalue(L, 6, 0, 223);
  lua_pushnil(L);
  const int lc1341 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc1341);
  const int lc1342 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1342) {
    lua_pushboolean(L, 0);
    lc_setupvalue(L, 6, 0, 223);
  }
  lua_settop(L, 6);
  lc_newclosuretable(L, 6);
  lua_pushcclosure(L, (lcf1_p), 0);
  lua_rawseti(L, 7, 224);
  lc_getupvalue(L, 7, 36, 23);
  lc_getupvalue(L, 7, 1, 221);
  lua_call(L, 1, 1);
  lc_setupvalue(L, 7, 1, 221);
  lc_getupvalue(L, 7, 36, 86);
  lc_getupvalue(L, 7, 1, 221);
  lua_call(L, 1, 1);
  const int lc1345 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1345) {
    lc_getupvalue(L, 7, 36, 85);
    lc_getupvalue(L, 7, 1, 221);
    lua_call(L, 1, 1);
    lc_getupvalue(L, 7, 36, 84);
    lc_getupvalue(L, 7, 1, 221);
    lua_call(L, 1, 1);
    lc_getupvalue(L, 7, 36, 4);
    lua_pushvalue(L, 8);
    lc_getupvalue(L, 7, 4, 216);
    lua_call(L, 2, 1);
    const int lc1347 = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    if (lc1347) {
      lc_getupvalue(L, 7, 36, 23);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      lua_replace(L, 9);
      lc_getupvalue(L, 7, 36, 92);
      lua_pushvalue(L, 9);
      lua_call(L, 1, 1);
      const int lc1349 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1349) {
        lc_getupvalue(L, 7, 36, 91);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        lc_getupvalue(L, 7, 36, 23);
        const int lc1350 = lua_gettop(L);
        lc_getupvalue(L, 7, 36, 90);
        lua_pushvalue(L, 9);
        lua_call(L, 1, (-1));
        lua_call(L, (lua_gettop(L) - lc1350), 1);
        lc_getupvalue(L, 7, 36, 88);
        lua_pushvalue(L, 11);
        lua_call(L, 1, 1);
        const int lc1352 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1352) {
          lc_getupvalue(L, 7, 1, 223);
          lua_pushboolean(L, 0);
          const int lc1354 = lua_equal(L, -2, -1);
          lua_settop(L, -(2) - 1);
          lua_pushboolean(L, lc1354);
          const int lc1355 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1355) {
            lc_newclosuretable(L, 7);
            lua_pushvalue(L, 10);
            lua_rawseti(L, 12, 225);
            lc_newclosuretable(L, 12);
            lc_getupvalue(L, 12, 2, 222);
            lua_rawseti(L, 13, 226);
            lua_pushvalue(L, 13);
            lua_pushcclosure(L, lcf6_a, 1);
            const int lc1359 = lua_gettop(L);
            lc_getupvalue(L, 13, 8, 213);
            lua_pushvalue(L, 14);
            lua_call(L, 1, (-1));
            return (lua_gettop(L) - lc1359);
          } else {
            lc_newclosuretable(L, 7);
            lua_settop(L, (lua_gettop(L) + 1));
            lua_rawseti(L, 12, 227);
            lc_getupvalue(L, 12, 2, 219);
            lc_setupvalue(L, 12, 0, 227);
            lc_newclosuretable(L, 12);
            lua_settop(L, (lua_gettop(L) + 1));
            lua_rawseti(L, 13, 228);
            lc_getupvalue(L, 13, 3, 220);
            lc_setupvalue(L, 13, 0, 228);
            lc_newclosuretable(L, 13);
            lua_pushvalue(L, 10);
            lua_rawseti(L, 14, 229);
            lc_newclosuretable(L, 14);
            lc_getupvalue(L, 14, 4, 222);
            lua_rawseti(L, 15, 230);
            lua_pushvalue(L, 15);
            lua_pushcclosure(L, lcf7_a, 1);
            const int lc1365 = lua_gettop(L);
            lc_getupvalue(L, 15, 10, 213);
            lua_pushvalue(L, 16);
            lua_call(L, 1, (-1));
            return (lua_gettop(L) - lc1365);
          }
          lua_settop(L, 11);
        }
        lua_settop(L, 11);
      }
      lua_settop(L, 9);
    } else {
      lc_getupvalue(L, 7, 36, 4);
      lua_pushvalue(L, 8);
      lc_getupvalue(L, 7, 3, 217);
      lua_call(L, 2, 1);
      const int lc1367 = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
      if (lc1367) {
        lc_getupvalue(L, 7, 36, 23);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        lua_replace(L, 9);
        lc_getupvalue(L, 7, 36, 92);
        lua_pushvalue(L, 9);
        lua_call(L, 1, 1);
        const int lc1369 = lua_toboolean(L, -1);
        lua_settop(L, -(1) - 1);
        if (lc1369) {
          lc_getupvalue(L, 7, 36, 91);
          lua_pushvalue(L, 9);
          lua_call(L, 1, 1);
          lc_getupvalue(L, 7, 36, 23);
          const int lc1370 = lua_gettop(L);
          lc_getupvalue(L, 7, 36, 90);
          lua_pushvalue(L, 9);
          lua_call(L, 1, (-1));
          lua_call(L, (lua_gettop(L) - lc1370), 1);
          lc_getupvalue(L, 7, 36, 92);
          lua_pushvalue(L, 11);
          lua_call(L, 1, 1);
          const int lc1372 = lua_toboolean(L, -1);
          lua_settop(L, -(1) - 1);
          if (lc1372) {
            lc_getupvalue(L, 7, 36, 91);
            lua_pushvalue(L, 11);
            lua_call(L, 1, 1);
            lc_getupvalue(L, 7, 36, 23);
            const int lc1373 = lua_gettop(L);
            lc_getupvalue(L, 7, 36, 90);
            lua_pushvalue(L, 11);
            lua_call(L, 1, (-1));
            lua_call(L, (lua_gettop(L) - lc1373), 1);
            lc_getupvalue(L, 7, 36, 88);
            lua_pushvalue(L, 13);
            lua_call(L, 1, 1);
            const int lc1375 = lua_toboolean(L, -1);
            lua_settop(L, -(1) - 1);
            if (lc1375) {
              lc_getupvalue(L, 7, 1, 223);
              lua_pushboolean(L, 0);
              const int lc1377 = lua_equal(L, -2, -1);
              lua_settop(L, -(2) - 1);
              lua_pushboolean(L, lc1377);
              const int lc1378 = lua_toboolean(L, -1);
              lua_settop(L, -(1) - 1);
              if (lc1378) {
                lc_newclosuretable(L, 7);
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, 14, 231);
                lc_getupvalue(L, 14, 2, 219);
                lc_setupvalue(L, 14, 0, 231);
                lc_newclosuretable(L, 14);
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, 15, 232);
                lc_getupvalue(L, 15, 3, 220);
                lc_setupvalue(L, 15, 0, 232);
                lc_newclosuretable(L, 15);
                lua_pushvalue(L, 10);
                lua_rawseti(L, 16, 233);
                lc_newclosuretable(L, 16);
                lua_pushvalue(L, 12);
                lua_rawseti(L, 17, 234);
                lc_newclosuretable(L, 17);
                lc_getupvalue(L, 17, 5, 222);
                lua_rawseti(L, 18, 235);
                lua_pushvalue(L, 18);
                lua_pushcclosure(L, lcf8_a, 1);
                const int lc1385 = lua_gettop(L);
                lc_getupvalue(L, 18, 11, 213);
                lua_pushvalue(L, 19);
                lua_call(L, 1, (-1));
                return (lua_gettop(L) - lc1385);
              } else {
                lc_newclosuretable(L, 7);
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, 14, 236);
                lc_getupvalue(L, 14, 2, 219);
                lc_setupvalue(L, 14, 0, 236);
                lc_newclosuretable(L, 14);
                lua_settop(L, (lua_gettop(L) + 1));
                lua_rawseti(L, 15, 237);
                lc_getupvalue(L, 15, 3, 220);
                lc_setupvalue(L, 15, 0, 237);
                lc_newclosuretable(L, 15);
                lua_pushvalue(L, 10);
                lua_rawseti(L, 16, 238);
                lc_newclosuretable(L, 16);
                lua_pushvalue(L, 12);
                lua_rawseti(L, 17, 239);
                lc_newclosuretable(L, 17);
                lc_getupvalue(L, 17, 5, 222);
                lua_rawseti(L, 18, 240);
                lc_newclosuretable(L, 18);
                lc_getupvalue(L, 18, 6, 223);
                lua_rawseti(L, 19, 241);
                lc_newclosuretable(L, 19);
                lc_getupvalue(L, 19, 39, 137);
                lua_pushlstring(L,
                                ""
                                "",
                                (sizeof("") / sizeof(char)) - 1);
                lua_call(L, 1, 1);
                lua_rawseti(L, 20, 242);
                lua_pushvalue(L, 20);
                lua_pushcclosure(L, lcf2_l, 1);
                const int lc1398 = lua_gettop(L);
                lc_getupvalue(L, 20, 13, 213);
                lua_pushvalue(L, 21);
                lua_call(L, 1, (-1));
                return (lua_gettop(L) - lc1398);
              }
              lua_settop(L, 13);
            }
            lua_settop(L, 13);
          }
          lua_settop(L, 11);
        }
        lua_settop(L, 9);
      }
      lua_settop(L, 9);
    }
    lua_settop(L, 9);
  }
  lua_settop(L, 7);
  lc_getupvalue(L, 7, 1, 223);
  lua_pushboolean(L, 0);
  const int lc1400 = lua_equal(L, -2, -1);
  lua_settop(L, -(2) - 1);
  lua_pushboolean(L, lc1400);
  const int lc1401 = lua_toboolean(L, -1);
  lua_settop(L, -(1) - 1);
  if (lc1401) {
    const int lc1402 = lua_gettop(L);
    lc_getupvalue(L, 7, 6, 213);
    lua_pushvalue(L, 7);
    lua_pushcclosure(L, lcf1404, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc1402);
  } else {
    const int lc1405 = lua_gettop(L);
    lc_getupvalue(L, 7, 6, 213);
    lua_pushvalue(L, 7);
    lua_pushcclosure(L, lcf1412, 1);
    lua_call(L, 1, (-1));
    return (lua_gettop(L) - lc1405);
  }
  lua_settop(L, 7);
  return 0;
}
static inline int lcf3_l(lua_State *L) {
  lua_settop(L, 4);
  const int lc1413 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 218);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_call(L, 4, (-1));
  return (lua_gettop(L) - lc1413);
}
static inline int lcf1419(lua_State *L) {
  lua_settop(L, 2);
  const int lc1417 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 6, 211);
  const int lc1418 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 245);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1418), (-1));
  return (lua_gettop(L) - lc1417);
}
static inline int lcf1425(lua_State *L) {
  lua_settop(L, 2);
  const int lc1423 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 5, 215);
  const int lc1424 = lua_gettop(L);
  lc_getupvalue(L, ((-10002) - (1)), 0, 247);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1424), (-1));
  return (lua_gettop(L) - lc1423);
}
static inline int lcf1426(lua_State *L) {
  lua_settop(L, 3);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 3);
  lua_rawseti(L, -2, 247);
  const int lc1421 = lua_gettop(L);
  lc_getupvalue(L, 4, 7, 211);
  const int lc1422 = lua_gettop(L);
  lc_getupvalue(L, 4, 1, 246);
  lua_pushvalue(L, 1);
  lua_pushvalue(L, 2);
  lua_pushvalue(L, 4);
  lua_pushcclosure(L, lcf1425, 1);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc1422), (-1));
  return (lua_gettop(L) - lc1421);
}
static inline int lcf3_u(lua_State *L) {
  lua_settop(L, 4);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_rawseti(L, -2, 245);
  lua_pushvalue(L, 2);
  lua_rawseti(L, -2, 246);
  const int lc1415 = lua_gettop(L);
  lc_getupvalue(L, 5, 4, 215);
  const int lc1416 = lua_gettop(L);
  lc_getupvalue(L, 5, 1, 218);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf1419, 1);
  lua_pushvalue(L, 5);
  lua_pushcclosure(L, lcf1426, 1);
  lua_pushvalue(L, 3);
  lua_pushvalue(L, 4);
  lua_call(L, 4, (-1));
  lua_call(L, (lua_gettop(L) - lc1416), (-1));
  return (lua_gettop(L) - lc1415);
}
static inline int lcf_main(lua_State *L) {
  lua_checkstack(L, 83);
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - 0);
  lc_newclosuretable(L, ((-10002) - (1)));
  lua_pushcclosure(L, (lcf1_l), 0);
  lua_rawseti(L, (1 + lc_nextra), 1);
  lc_newclosuretable(L, (1 + lc_nextra));
  lua_pushcclosure(L, (lcf1_Ae), 0);
  lua_rawseti(L, (2 + lc_nextra), 2);
  lc_newclosuretable(L, (2 + lc_nextra));
  lua_settop(L, (lua_gettop(L) + 112));
  lua_rawseti(L, (3 + lc_nextra), 3);
  lua_rawseti(L, (3 + lc_nextra), 4);
  lua_rawseti(L, (3 + lc_nextra), 5);
  lua_rawseti(L, (3 + lc_nextra), 6);
  lua_rawseti(L, (3 + lc_nextra), 7);
  lua_rawseti(L, (3 + lc_nextra), 8);
  lua_rawseti(L, (3 + lc_nextra), 9);
  lua_rawseti(L, (3 + lc_nextra), 10);
  lua_rawseti(L, (3 + lc_nextra), 11);
  lua_rawseti(L, (3 + lc_nextra), 12);
  lua_rawseti(L, (3 + lc_nextra), 13);
  lua_rawseti(L, (3 + lc_nextra), 14);
  lua_rawseti(L, (3 + lc_nextra), 15);
  lua_rawseti(L, (3 + lc_nextra), 16);
  lua_rawseti(L, (3 + lc_nextra), 17);
  lua_rawseti(L, (3 + lc_nextra), 18);
  lua_rawseti(L, (3 + lc_nextra), 19);
  lua_rawseti(L, (3 + lc_nextra), 20);
  lua_rawseti(L, (3 + lc_nextra), 21);
  lua_rawseti(L, (3 + lc_nextra), 22);
  lua_rawseti(L, (3 + lc_nextra), 23);
  lua_rawseti(L, (3 + lc_nextra), 24);
  lua_rawseti(L, (3 + lc_nextra), 25);
  lua_rawseti(L, (3 + lc_nextra), 26);
  lua_rawseti(L, (3 + lc_nextra), 27);
  lua_rawseti(L, (3 + lc_nextra), 28);
  lua_rawseti(L, (3 + lc_nextra), 29);
  lua_rawseti(L, (3 + lc_nextra), 30);
  lua_rawseti(L, (3 + lc_nextra), 31);
  lua_rawseti(L, (3 + lc_nextra), 32);
  lua_rawseti(L, (3 + lc_nextra), 33);
  lua_rawseti(L, (3 + lc_nextra), 34);
  lua_rawseti(L, (3 + lc_nextra), 35);
  lua_rawseti(L, (3 + lc_nextra), 36);
  lua_rawseti(L, (3 + lc_nextra), 37);
  lua_rawseti(L, (3 + lc_nextra), 38);
  lua_rawseti(L, (3 + lc_nextra), 39);
  lua_rawseti(L, (3 + lc_nextra), 40);
  lua_rawseti(L, (3 + lc_nextra), 41);
  lua_rawseti(L, (3 + lc_nextra), 42);
  lua_rawseti(L, (3 + lc_nextra), 43);
  lua_rawseti(L, (3 + lc_nextra), 44);
  lua_rawseti(L, (3 + lc_nextra), 45);
  lua_rawseti(L, (3 + lc_nextra), 46);
  lua_rawseti(L, (3 + lc_nextra), 47);
  lua_rawseti(L, (3 + lc_nextra), 48);
  lua_rawseti(L, (3 + lc_nextra), 49);
  lua_rawseti(L, (3 + lc_nextra), 50);
  lua_rawseti(L, (3 + lc_nextra), 51);
  lua_rawseti(L, (3 + lc_nextra), 52);
  lua_rawseti(L, (3 + lc_nextra), 53);
  lua_rawseti(L, (3 + lc_nextra), 54);
  lua_rawseti(L, (3 + lc_nextra), 55);
  lua_rawseti(L, (3 + lc_nextra), 56);
  lua_rawseti(L, (3 + lc_nextra), 57);
  lua_rawseti(L, (3 + lc_nextra), 58);
  lua_rawseti(L, (3 + lc_nextra), 59);
  lua_rawseti(L, (3 + lc_nextra), 60);
  lua_rawseti(L, (3 + lc_nextra), 61);
  lua_rawseti(L, (3 + lc_nextra), 62);
  lua_rawseti(L, (3 + lc_nextra), 63);
  lua_rawseti(L, (3 + lc_nextra), 64);
  lua_rawseti(L, (3 + lc_nextra), 65);
  lua_rawseti(L, (3 + lc_nextra), 66);
  lua_rawseti(L, (3 + lc_nextra), 67);
  lua_rawseti(L, (3 + lc_nextra), 68);
  lua_rawseti(L, (3 + lc_nextra), 69);
  lua_rawseti(L, (3 + lc_nextra), 70);
  lua_rawseti(L, (3 + lc_nextra), 71);
  lua_rawseti(L, (3 + lc_nextra), 72);
  lua_rawseti(L, (3 + lc_nextra), 73);
  lua_rawseti(L, (3 + lc_nextra), 74);
  lua_rawseti(L, (3 + lc_nextra), 75);
  lua_rawseti(L, (3 + lc_nextra), 76);
  lua_rawseti(L, (3 + lc_nextra), 77);
  lua_rawseti(L, (3 + lc_nextra), 78);
  lua_rawseti(L, (3 + lc_nextra), 79);
  lua_rawseti(L, (3 + lc_nextra), 80);
  lua_rawseti(L, (3 + lc_nextra), 81);
  lua_rawseti(L, (3 + lc_nextra), 82);
  lua_rawseti(L, (3 + lc_nextra), 83);
  lua_rawseti(L, (3 + lc_nextra), 84);
  lua_rawseti(L, (3 + lc_nextra), 85);
  lua_rawseti(L, (3 + lc_nextra), 86);
  lua_rawseti(L, (3 + lc_nextra), 87);
  lua_rawseti(L, (3 + lc_nextra), 88);
  lua_rawseti(L, (3 + lc_nextra), 89);
  lua_rawseti(L, (3 + lc_nextra), 90);
  lua_rawseti(L, (3 + lc_nextra), 91);
  lua_rawseti(L, (3 + lc_nextra), 92);
  lua_rawseti(L, (3 + lc_nextra), 93);
  lua_rawseti(L, (3 + lc_nextra), 94);
  lua_rawseti(L, (3 + lc_nextra), 95);
  lua_rawseti(L, (3 + lc_nextra), 96);
  lua_rawseti(L, (3 + lc_nextra), 97);
  lua_rawseti(L, (3 + lc_nextra), 98);
  lua_rawseti(L, (3 + lc_nextra), 99);
  lua_rawseti(L, (3 + lc_nextra), 100);
  lua_rawseti(L, (3 + lc_nextra), 101);
  lua_rawseti(L, (3 + lc_nextra), 102);
  lua_rawseti(L, (3 + lc_nextra), 103);
  lua_rawseti(L, (3 + lc_nextra), 104);
  lua_rawseti(L, (3 + lc_nextra), 105);
  lua_rawseti(L, (3 + lc_nextra), 106);
  lua_rawseti(L, (3 + lc_nextra), 107);
  lua_rawseti(L, (3 + lc_nextra), 108);
  lua_rawseti(L, (3 + lc_nextra), 109);
  lua_rawseti(L, (3 + lc_nextra), 110);
  lua_rawseti(L, (3 + lc_nextra), 111);
  lua_rawseti(L, (3 + lc_nextra), 112);
  lua_rawseti(L, (3 + lc_nextra), 113);
  lua_rawseti(L, (3 + lc_nextra), 114);
  lua_pushcclosure(L, (lcf1_k), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 114);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_O, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 113);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_ae, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 101);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_q, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 100);
  lua_pushcclosure(L, (lcf1_te), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 99);
  lua_pushcclosure(L, (lcf1_U), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 98);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Q, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 97);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_f, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 96);
  lua_pushcclosure(L, (lcf1_L), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 95);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_S, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 94);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_h, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 93);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_a, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 92);
  lua_pushcclosure(L, (lcf1_i), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 91);
  lua_pushcclosure(L, (lcf1_n), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 90);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_s, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 88);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_z, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 87);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_c, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 86);
  lua_pushcclosure(L, (lcf1_j), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 85);
  lua_pushcclosure(L, (lcf1_T), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 84);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_W, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 83);
  lua_pushcclosure(L, (lcf1_Ke), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 82);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_H, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 81);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_F, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 80);
  lua_pushcclosure(L, (lcf1_G), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 79);
  lua_pushcclosure(L, (lcf1_Z), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 78);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ve, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 77);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_P, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 76);
  lua_pushcclosure(L, (lcf1_qe), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 75);
  lua_pushcclosure(L, (lcf1_ge), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 74);
  lua_pushcclosure(L, (lcf1_ke), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 73);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1__, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 72);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_V, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 71);
  lua_pushcclosure(L, (lcf1_le), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 70);
  lua_pushcclosure(L, (lcf1_se), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 69);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_M, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 68);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_B, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 67);
  lua_pushcclosure(L, (lcf1_je), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 66);
  lua_pushcclosure(L, (lcf1_ze), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 65);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Y, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 64);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_xe, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 62);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_o, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 61);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_N, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 60);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_oe, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 59);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ge, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 58);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_b, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 32);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_E, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 31);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_e, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 30);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_I, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 29);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_he, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 28);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_y, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 27);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_ee, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 26);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_d, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 25);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_g, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 24);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf2_r, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 23);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_ve, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 22);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_pe, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 21);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_ot, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 20);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_m, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 19);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_be, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 17);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Le, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 16);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_Be, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 15);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_R, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 14);
  lua_pushcclosure(L, (lcf1_Ue), 0);
  lc_setupvalue(L, (3 + lc_nextra), 0, 13);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_it, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 12);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_nt, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 10);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_ht, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 9);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_at, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 8);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_re, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 7);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_tt, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 6);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf2_u, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 5);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_w, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 4);
  lua_pushvalue(L, (3 + lc_nextra));
  lua_pushcclosure(L, lcf1_v, 1);
  lc_setupvalue(L, (3 + lc_nextra), 0, 3);
  lc_newclosuretable(L, (3 + lc_nextra));
  lua_pushcclosure(L, (lcf2_tt), 0);
  lua_rawseti(L, (4 + lc_nextra), 135);
  lc_newclosuretable(L, (4 + lc_nextra));
  lua_pushcclosure(L, (lcf2_at), 0);
  lua_rawseti(L, (5 + lc_nextra), 136);
  lua_pushnumber(L, 0);
  lc_setupvalue(L, (5 + lc_nextra), 2, 112);
  lua_pushnumber(L, 1);
  lc_setupvalue(L, (5 + lc_nextra), 2, 111);
  lua_pushnumber(L, 2);
  lc_setupvalue(L, (5 + lc_nextra), 2, 110);
  lua_pushnumber(L, 3);
  lc_setupvalue(L, (5 + lc_nextra), 2, 109);
  lua_pushnumber(L, 4);
  lc_setupvalue(L, (5 + lc_nextra), 2, 108);
  lua_pushnumber(L, 5);
  lc_setupvalue(L, (5 + lc_nextra), 2, 107);
  lua_pushnumber(L, 6);
  lc_setupvalue(L, (5 + lc_nextra), 2, 106);
  lua_pushnumber(L, 7);
  lc_setupvalue(L, (5 + lc_nextra), 2, 105);
  lua_pushnumber(L, 8);
  lc_setupvalue(L, (5 + lc_nextra), 2, 104);
  lua_pushnumber(L, 10);
  lc_setupvalue(L, (5 + lc_nextra), 2, 103);
  lua_pushnumber(L, 9);
  lc_setupvalue(L, (5 + lc_nextra), 2, 102);
  lc_newclosuretable(L, (5 + lc_nextra));
  lua_pushvalue(L, (6 + lc_nextra));
  lua_pushcclosure(L, lcf4_o, 1);
  lua_rawseti(L, (6 + lc_nextra), 137);
  lua_createtable(L, 1, 0);
  lc_getupvalue(L, (6 + lc_nextra), 3, 110);
  lua_rawseti(L, -2, 1);
  lc_setupvalue(L, (6 + lc_nextra), 3, 89);
  lc_newclosuretable(L, (6 + lc_nextra));
  lua_pushvalue(L, (7 + lc_nextra));
  lua_pushcclosure(L, lcf1_ce, 1);
  lua_rawseti(L, (7 + lc_nextra), 138);
  lc_getupvalue(L, (7 + lc_nextra), 0, 138);
  lc_setupvalue(L, (7 + lc_nextra), 4, 63);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (7 + lc_nextra), 4, 57);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (7 + lc_nextra), 4, 56);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (7 + lc_nextra), 4, 55);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (7 + lc_nextra), 4, 54);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_newclosuretable(L, (7 + lc_nextra));
  lc_getupvalue(L, (7 + lc_nextra), 1, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (10 + lc_nextra), 139);
  lc_newclosuretable(L, (10 + lc_nextra));
  lc_getupvalue(L, (10 + lc_nextra), 2, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (11 + lc_nextra), 140);
  lc_getupvalue(L, (11 + lc_nextra), 3, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (11 + lc_nextra), 6, 53);
  lc_getupvalue(L, (11 + lc_nextra), 3, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_newclosuretable(L, (11 + lc_nextra));
  lc_getupvalue(L, (11 + lc_nextra), 3, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (13 + lc_nextra), 141);
  lc_newclosuretable(L, (13 + lc_nextra));
  lc_getupvalue(L, (13 + lc_nextra), 4, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (14 + lc_nextra), 142);
  lc_newclosuretable(L, (14 + lc_nextra));
  lc_getupvalue(L, (14 + lc_nextra), 5, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (15 + lc_nextra), 143);
  lc_newclosuretable(L, (15 + lc_nextra));
  lc_getupvalue(L, (15 + lc_nextra), 6, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (16 + lc_nextra), 144);
  lc_newclosuretable(L, (16 + lc_nextra));
  lc_getupvalue(L, (16 + lc_nextra), 7, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lua_rawseti(L, (17 + lc_nextra), 145);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_setupvalue(L, (17 + lc_nextra), 11, 52);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 8, 137);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_call(L, 1, 1);
  lc_getupvalue(L, (17 + lc_nextra), 11, 32);
  const int lc565 = lua_gettop(L);
  lc_getupvalue(L, (17 + lc_nextra), 11, 57);
  lc_getupvalue(L, (17 + lc_nextra), 11, 30);
  lua_pushvalue(L, (28 + lc_nextra));
  lc_getupvalue(L, (17 + lc_nextra), 5, 140);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc565), 1);
  lc_setupvalue(L, (17 + lc_nextra), 11, 51);
  lc_newclosuretable(L, (17 + lc_nextra));
  lua_pushvalue(L, (31 + lc_nextra));
  lua_pushcclosure(L, lcf2_b, 1);
  lua_rawseti(L, (31 + lc_nextra), 146);
  lua_pushvalue(L, (31 + lc_nextra));
  lua_pushcclosure(L, lcf1_Te, 1);
  lua_pushvalue(L, (31 + lc_nextra));
  lua_pushcclosure(L, lcf2_d, 1);
  lua_pushvalue(L, (31 + lc_nextra));
  lua_pushcclosure(L, lcf1_de, 1);
  lua_pushvalue(L, (32 + lc_nextra));
  lua_pushvalue(L, (22 + lc_nextra));
  lua_call(L, 1, 1);
  lua_pushvalue(L, (33 + lc_nextra));
  lua_pushvalue(L, (22 + lc_nextra));
  lc_getupvalue(L, (31 + lc_nextra), 12, 56);
  lua_call(L, 2, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 50);
  lua_pushvalue(L, (33 + lc_nextra));
  lua_pushvalue(L, (22 + lc_nextra));
  lua_pushvalue(L, (24 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 49);
  lua_pushvalue(L, (34 + lc_nextra));
  lua_pushvalue(L, (22 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 48);
  lua_pushvalue(L, (32 + lc_nextra));
  lua_pushvalue(L, (21 + lc_nextra));
  lua_call(L, 1, 1);
  lua_pushvalue(L, (34 + lc_nextra));
  lua_pushvalue(L, (21 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 47);
  lua_pushvalue(L, (33 + lc_nextra));
  lua_pushvalue(L, (21 + lc_nextra));
  lua_pushvalue(L, (25 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 46);
  lua_pushvalue(L, (33 + lc_nextra));
  lua_pushvalue(L, (21 + lc_nextra));
  lua_pushvalue(L, (26 + lc_nextra));
  lua_call(L, 2, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 45);
  lua_pushvalue(L, (34 + lc_nextra));
  lua_pushvalue(L, (23 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 44);
  lua_pushvalue(L, (34 + lc_nextra));
  lua_pushvalue(L, (20 + lc_nextra));
  lua_call(L, 1, 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 43);
  lc_getupvalue(L, (31 + lc_nextra), 0, 146);
  const int lc578 = lua_gettop(L);
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  const int lc579 = lua_gettop(L);
  lc_getupvalue(L, (31 + lc_nextra), 5, 141);
  lc_getupvalue(L, (31 + lc_nextra), 12, 55);
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  lc_getupvalue(L, (31 + lc_nextra), 4, 142);
  lua_pushvalue(L, (8 + lc_nextra));
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc579), (-1));
  lua_call(L, (lua_gettop(L) - lc578), 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 42);
  lc_getupvalue(L, (31 + lc_nextra), 0, 146);
  const int lc580 = lua_gettop(L);
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  lc_getupvalue(L, (31 + lc_nextra), 5, 141);
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  lc_getupvalue(L, (31 + lc_nextra), 12, 55);
  lc_getupvalue(L, (31 + lc_nextra), 12, 93);
  lc_getupvalue(L, (31 + lc_nextra), 12, 55);
  lc_getupvalue(L, (31 + lc_nextra), 6, 140);
  lua_call(L, 2, 1);
  lc_getupvalue(L, (31 + lc_nextra), 6, 140);
  lua_call(L, 3, 1);
  lua_pushvalue(L, (19 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc580), 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 41);
  lc_getupvalue(L, (31 + lc_nextra), 0, 146);
  const int lc581 = lua_gettop(L);
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  lc_getupvalue(L, (31 + lc_nextra), 5, 141);
  lc_getupvalue(L, (31 + lc_nextra), 12, 55);
  lua_pushvalue(L, (9 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc581), 1);
  lc_setupvalue(L, (31 + lc_nextra), 12, 40);
  lc_newclosuretable(L, (31 + lc_nextra));
  lua_pushvalue(L, (33 + lc_nextra));
  const int lc583 = lua_gettop(L);
  lua_pushvalue(L, (24 + lc_nextra));
  lc_getupvalue(L, (31 + lc_nextra), 12, 30);
  lc_getupvalue(L, (31 + lc_nextra), 5, 141);
  lua_pushvalue(L, (27 + lc_nextra));
  lc_getupvalue(L, (31 + lc_nextra), 6, 140);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc583), 1);
  lua_rawseti(L, (37 + lc_nextra), 147);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc584 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 6, 141);
  lc_getupvalue(L, (37 + lc_nextra), 13, 55);
  lua_pushvalue(L, (12 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc584), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 39);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc585 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 6, 141);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lua_pushvalue(L, (18 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc585), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 38);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc586 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 6, 141);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  const int lc587 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 13, 55);
  lc_getupvalue(L, (37 + lc_nextra), 7, 140);
  lc_getupvalue(L, (37 + lc_nextra), 13, 55);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc587), 1);
  lc_getupvalue(L, (37 + lc_nextra), 8, 139);
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc586), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 37);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc588 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  const int lc589 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 13, 57);
  lc_getupvalue(L, (37 + lc_nextra), 13, 55);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc589), (-1));
  lua_call(L, (lua_gettop(L) - lc588), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 36);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc590 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  const int lc591 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 13, 57);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc591), (-1));
  lua_call(L, (lua_gettop(L) - lc590), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 35);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc592 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc592), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 34);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc593 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 6, 141);
  lc_getupvalue(L, (37 + lc_nextra), 13, 55);
  lua_pushvalue(L, (30 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc593), 1);
  lc_getupvalue(L, (37 + lc_nextra), 1, 146);
  const int lc594 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lc_getupvalue(L, (37 + lc_nextra), 6, 141);
  lc_getupvalue(L, (37 + lc_nextra), 13, 54);
  lua_pushvalue(L, (30 + lc_nextra));
  lua_call(L, 3, (-1));
  lua_call(L, (lua_gettop(L) - lc594), 1);
  lc_setupvalue(L, (37 + lc_nextra), 13, 33);
  lc_newclosuretable(L, (37 + lc_nextra));
  lc_getupvalue(L, (37 + lc_nextra), 13, 87);
  const int lc596 = lua_gettop(L);
  lc_getupvalue(L, (37 + lc_nextra), 2, 145);
  lc_getupvalue(L, (37 + lc_nextra), 13, 30);
  lua_call(L, 0, (-1));
  lua_call(L, (lua_gettop(L) - lc596), 1);
  lua_rawseti(L, (39 + lc_nextra), 148);
  lc_newclosuretable(L, (39 + lc_nextra));
  lc_getupvalue(L, (39 + lc_nextra), 14, 87);
  const int lc598 = lua_gettop(L);
  lc_getupvalue(L, (39 + lc_nextra), 4, 144);
  lc_getupvalue(L, (39 + lc_nextra), 14, 30);
  lua_call(L, 0, (-1));
  lua_call(L, (lua_gettop(L) - lc598), 1);
  lua_rawseti(L, (40 + lc_nextra), 149);
  lc_newclosuretable(L, (40 + lc_nextra));
  lua_pushvalue(L, (41 + lc_nextra));
  lua_pushcclosure(L, lcf1__e, 1);
  lua_rawseti(L, (41 + lc_nextra), 150);
  lc_newclosuretable(L, (41 + lc_nextra));
  lua_pushvalue(L, (42 + lc_nextra));
  lua_pushcclosure(L, lcf1_D, 1);
  lua_rawseti(L, (42 + lc_nextra), 151);
  lua_pushvalue(L, (42 + lc_nextra));
  lua_pushcclosure(L, lcf1_Xe, 1);
  lc_newclosuretable(L, (42 + lc_nextra));
  lua_pushvalue(L, (44 + lc_nextra));
  lua_pushcclosure(L, lcf2_Te, 1);
  lua_rawseti(L, (44 + lc_nextra), 152);
  lua_pushvalue(L, (44 + lc_nextra));
  lua_pushcclosure(L, lcf1_et, 1);
  lua_pushvalue(L, (44 + lc_nextra));
  lua_pushcclosure(L, lcf2_ht, 1);
  lua_pushvalue(L, (44 + lc_nextra));
  lua_pushcclosure(L, lcf2_it, 1);
  lua_createtable(L, 3, 0);
  lua_pushboolean(L, 1);
  lua_rawseti(L, -2, 1);
  lua_createtable(L, 0, 0);
  lua_rawseti(L, -2, 2);
  lua_pushnil(L);
  lua_rawseti(L, -2, 3);
  lc_newclosuretable(L, (44 + lc_nextra));
  lua_pushvalue(L, (49 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ze, 1);
  lua_rawseti(L, (49 + lc_nextra), 153);
  lc_newclosuretable(L, (49 + lc_nextra));
  lua_pushvalue(L, (50 + lc_nextra));
  lua_pushcclosure(L, lcf2_de, 1);
  lua_rawseti(L, (50 + lc_nextra), 154);
  lc_newclosuretable(L, (50 + lc_nextra));
  lua_pushvalue(L, (51 + lc_nextra));
  lua_pushcclosure(L, lcf1_We, 1);
  lua_rawseti(L, (51 + lc_nextra), 155);
  lc_newclosuretable(L, (51 + lc_nextra));
  lua_pushvalue(L, (52 + lc_nextra));
  lua_pushcclosure(L, lcf3_de, 1);
  lua_rawseti(L, (52 + lc_nextra), 156);
  lc_newclosuretable(L, (52 + lc_nextra));
  lua_pushvalue(L, (53 + lc_nextra));
  lua_pushcclosure(L, lcf1_fe, 1);
  lua_rawseti(L, (53 + lc_nextra), 157);
  lc_newclosuretable(L, (53 + lc_nextra));
  lua_pushvalue(L, (54 + lc_nextra));
  lua_pushcclosure(L, lcf1_Ee, 1);
  lua_rawseti(L, (54 + lc_nextra), 158);
  lua_createtable(L, 0, 0);
  lc_setupvalue(L, (54 + lc_nextra), 24, 18);
  lc_newclosuretable(L, (54 + lc_nextra));
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf4_de, 1);
  lua_rawseti(L, (55 + lc_nextra), 159);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf2_Ee, 1);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf2_fe, 1);
  lua_createtable(L, 16, 0);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 48);
  lc_getupvalue(L, (55 + lc_nextra), 25, 86);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 1);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (35 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (55 + lc_nextra), 25, 87);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 50);
  lc_getupvalue(L, (55 + lc_nextra), 25, 86);
  lc_getupvalue(L, (55 + lc_nextra), 25, 85);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 3);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 49);
  lc_getupvalue(L, (55 + lc_nextra), 25, 86);
  lc_getupvalue(L, (55 + lc_nextra), 25, 84);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 4);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 43);
  lc_getupvalue(L, (55 + lc_nextra), 25, 88);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 5);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (36 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (55 + lc_nextra), 25, 93);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 6);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 47);
  lc_getupvalue(L, (55 + lc_nextra), 25, 92);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 7);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 46);
  lc_getupvalue(L, (55 + lc_nextra), 25, 92);
  lc_getupvalue(L, (55 + lc_nextra), 25, 91);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 8);
  lua_pushvalue(L, (57 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 45);
  lc_getupvalue(L, (55 + lc_nextra), 25, 92);
  lc_getupvalue(L, (55 + lc_nextra), 25, 90);
  lua_call(L, 3, 1);
  lua_rawseti(L, -2, 9);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (55 + lc_nextra), 25, 42);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf761, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 10);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (55 + lc_nextra), 25, 41);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf769, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 11);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (55 + lc_nextra), 25, 40);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf775, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 12);
  lua_pushvalue(L, (56 + lc_nextra));
  lc_getupvalue(L, (55 + lc_nextra), 25, 44);
  lc_getupvalue(L, (55 + lc_nextra), 25, 96);
  lua_call(L, 2, 1);
  lua_rawseti(L, -2, 13);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (55 + lc_nextra), 12, 147);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 1);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf783, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 14);
  lua_createtable(L, 3, 0);
  lc_getupvalue(L, (55 + lc_nextra), 25, 39);
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 3);
  lua_rawseti(L, -2, 2);
  lua_pushvalue(L, (55 + lc_nextra));
  lua_pushcclosure(L, lcf799, 1);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 15);
  lua_createtable(L, 3, 0);
  lua_pushvalue(L, (38 + lc_nextra));
  lua_rawseti(L, -2, 1);
  lua_pushnumber(L, 2);
  lua_rawseti(L, -2, 2);
  lc_getupvalue(L, (55 + lc_nextra), 25, 101);
  lua_rawseti(L, -2, 3);
  lua_rawseti(L, -2, 16);
  lc_setupvalue(L, (55 + lc_nextra), 25, 11);
  lc_newclosuretable(L, (55 + lc_nextra));
  lua_pushvalue(L, (58 + lc_nextra));
  lua_pushcclosure(L, lcf3_d, 1);
  lua_rawseti(L, (58 + lc_nextra), 167);
  lc_newclosuretable(L, (58 + lc_nextra));
  lua_pushvalue(L, (59 + lc_nextra));
  lua_pushcclosure(L, lcf1_J, 1);
  lua_rawseti(L, (59 + lc_nextra), 168);
  lc_newclosuretable(L, (59 + lc_nextra));
  lua_pushvalue(L, (60 + lc_nextra));
  lua_pushcclosure(L, lcf2__, 1);
  lua_rawseti(L, (60 + lc_nextra), 199);
  lua_pushvalue(L, (60 + lc_nextra));
  lua_pushcclosure(L, lcf1_C, 1);
  lua_pushvalue(L, (60 + lc_nextra));
  lua_pushcclosure(L, lcf2_N, 1);
  lc_newclosuretable(L, (60 + lc_nextra));
  lua_pushcclosure(L, (lcf3_k), 0);
  lua_rawseti(L, (63 + lc_nextra), 211);
  lc_newclosuretable(L, (63 + lc_nextra));
  lua_pushcclosure(L, (lcf5_d), 0);
  lua_rawseti(L, (64 + lc_nextra), 213);
  lc_newclosuretable(L, (64 + lc_nextra));
  lua_pushcclosure(L, (lcf1_x), 0);
  lua_rawseti(L, (65 + lc_nextra), 215);
  lc_newclosuretable(L, (65 + lc_nextra));
  lc_getupvalue(L, (65 + lc_nextra), 19, 146);
  const int lc1326 = lua_gettop(L);
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  const int lc1327 = lua_gettop(L);
  lc_getupvalue(L, (65 + lc_nextra), 22, 143);
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  const int lc1328 = lua_gettop(L);
  lua_pushvalue(L, (29 + lc_nextra));
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  const int lc1329 = lua_gettop(L);
  lc_getupvalue(L, (65 + lc_nextra), 24, 141);
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  const int lc1330 = lua_gettop(L);
  lua_pushvalue(L, (27 + lc_nextra));
  lc_getupvalue(L, (65 + lc_nextra), 31, 93);
  lc_getupvalue(L, (65 + lc_nextra), 25, 140);
  lc_getupvalue(L, (65 + lc_nextra), 31, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1330), (-1));
  lua_call(L, (lua_gettop(L) - lc1329), 1);
  lc_getupvalue(L, (65 + lc_nextra), 31, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1328), 1);
  lc_getupvalue(L, (65 + lc_nextra), 31, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1327), (-1));
  lua_call(L, (lua_gettop(L) - lc1326), 1);
  lua_rawseti(L, (66 + lc_nextra), 216);
  lc_newclosuretable(L, (66 + lc_nextra));
  lc_getupvalue(L, (66 + lc_nextra), 20, 146);
  const int lc1332 = lua_gettop(L);
  lc_getupvalue(L, (66 + lc_nextra), 32, 93);
  const int lc1333 = lua_gettop(L);
  lc_getupvalue(L, (66 + lc_nextra), 23, 143);
  lc_getupvalue(L, (66 + lc_nextra), 32, 93);
  lc_getupvalue(L, (66 + lc_nextra), 32, 93);
  const int lc1334 = lua_gettop(L);
  lua_pushvalue(L, (29 + lc_nextra));
  lc_getupvalue(L, (66 + lc_nextra), 32, 93);
  lua_pushvalue(L, (21 + lc_nextra));
  lc_getupvalue(L, (66 + lc_nextra), 32, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1334), 1);
  lc_getupvalue(L, (66 + lc_nextra), 32, 89);
  lua_call(L, 2, (-1));
  lua_call(L, (lua_gettop(L) - lc1333), (-1));
  lua_call(L, (lua_gettop(L) - lc1332), 1);
  lua_rawseti(L, (67 + lc_nextra), 217);
  lua_pushvalue(L, (67 + lc_nextra));
  lua_pushcclosure(L, lcf3_F, 1);
  lua_pushvalue(L, (67 + lc_nextra));
  lua_pushcclosure(L, lcf3_P, 1);
  lc_newclosuretable(L, (67 + lc_nextra));
  lua_pushvalue(L, (70 + lc_nextra));
  lua_pushcclosure(L, lcf3_b, 1);
  lua_rawseti(L, (70 + lc_nextra), 218);
  lua_pushvalue(L, (70 + lc_nextra));
  lua_pushcclosure(L, lcf3_l, 1);
  lua_pushvalue(L, (70 + lc_nextra));
  lua_pushcclosure(L, lcf3_u, 1);
  lua_createtable(L, 0, 0);
  lc_getupvalue(L, (70 + lc_nextra), 34, 101);
  lua_pushlstring(L,
                  ""
                  "new_comment",
                  (sizeof("new_comment") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 100);
  lua_pushlstring(L,
                  ""
                  "comment_p",
                  (sizeof("comment_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 99);
  lua_pushlstring(L,
                  ""
                  "comment_comment",
                  (sizeof("comment_comment") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 98);
  lua_pushlstring(L,
                  ""
                  "comment_x",
                  (sizeof("comment_x") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 97);
  lua_pushlstring(L,
                  ""
                  "un_comment_all",
                  (sizeof("un_comment_all") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 31, 137);
  lua_pushlstring(L,
                  ""
                  "new_atom",
                  (sizeof("new_atom") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 96);
  lua_pushlstring(L,
                  ""
                  "atom_p",
                  (sizeof("atom_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 95);
  lua_pushlstring(L,
                  ""
                  "un_atom",
                  (sizeof("un_atom") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 94);
  lua_pushlstring(L,
                  ""
                  "atom_equal_p",
                  (sizeof("atom_equal_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 93);
  lua_pushlstring(L,
                  ""
                  "new_construction",
                  (sizeof("new_construction") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 92);
  lua_pushlstring(L,
                  ""
                  "construction_p",
                  (sizeof("construction_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 91);
  lua_pushlstring(L,
                  ""
                  "construction_head",
                  (sizeof("construction_head") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 90);
  lua_pushlstring(L,
                  ""
                  "construction_tail",
                  (sizeof("construction_tail") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 89);
  lua_pushlstring(L,
                  ""
                  "null_v",
                  (sizeof("null_v") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 88);
  lua_pushlstring(L,
                  ""
                  "null_p",
                  (sizeof("null_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 87);
  lua_pushlstring(L,
                  ""
                  "new_data",
                  (sizeof("new_data") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 86);
  lua_pushlstring(L,
                  ""
                  "data_p",
                  (sizeof("data_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 85);
  lua_pushlstring(L,
                  ""
                  "data_name",
                  (sizeof("data_name") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 84);
  lua_pushlstring(L,
                  ""
                  "data_list",
                  (sizeof("data_list") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 83);
  lua_pushlstring(L,
                  ""
                  "just_p",
                  (sizeof("just_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 81);
  lua_pushlstring(L,
                  ""
                  "evaluate",
                  (sizeof("evaluate") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 68);
  lua_pushlstring(L,
                  ""
                  "apply",
                  (sizeof("apply") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 64);
  lua_pushlstring(L,
                  ""
                  "force_all_rec",
                  (sizeof("force_all_rec") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 30, 138);
  lua_pushlstring(L,
                  ""
                  "force_uncomment_all_rec",
                  (sizeof("force_uncomment_all_rec") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 63);
  lua_pushlstring(L,
                  ""
                  "unlazy_all_rec",
                  (sizeof("unlazy_all_rec") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 31);
  lua_pushlstring(L,
                  ""
                  "jsArray_to_list",
                  (sizeof("jsArray_to_list") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 17, 151);
  lua_pushlstring(L,
                  ""
                  "maybe_list_to_jsArray",
                  (sizeof("maybe_list_to_jsArray") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 30);
  lua_pushlstring(L,
                  ""
                  "new_list",
                  (sizeof("new_list") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 29);
  lua_pushlstring(L,
                  ""
                  "un_just_all",
                  (sizeof("un_just_all") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (43 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "un_just_comment_all",
                  (sizeof("un_just_comment_all") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 28);
  lua_pushlstring(L,
                  ""
                  "delay_p",
                  (sizeof("delay_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 27);
  lua_pushlstring(L,
                  ""
                  "delay_just_p",
                  (sizeof("delay_just_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 26);
  lua_pushlstring(L,
                  ""
                  "lazy_p",
                  (sizeof("lazy_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (45 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "delay_env",
                  (sizeof("delay_env") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (46 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "delay_x",
                  (sizeof("delay_x") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 23);
  lua_pushlstring(L,
                  ""
                  "force_all",
                  (sizeof("force_all") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 24);
  lua_pushlstring(L,
                  ""
                  "force1",
                  (sizeof("force1") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (47 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "force_uncomment1",
                  (sizeof("force_uncomment1") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 22);
  lua_pushlstring(L,
                  ""
                  "force_uncomment_all",
                  (sizeof("force_uncomment_all") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 21);
  lua_pushlstring(L,
                  ""
                  "unlazy1",
                  (sizeof("unlazy1") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 18);
  lua_pushlstring(L,
                  ""
                  "env_null_v",
                  (sizeof("env_null_v") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 17);
  lua_pushlstring(L,
                  ""
                  "env_set",
                  (sizeof("env_set") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 16);
  lua_pushlstring(L,
                  ""
                  "env_get",
                  (sizeof("env_get") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 14);
  lua_pushlstring(L,
                  ""
                  "env2val",
                  (sizeof("env2val") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 13);
  lua_pushlstring(L,
                  ""
                  "env_foreach",
                  (sizeof("env_foreach") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 9, 159);
  lua_pushlstring(L,
                  ""
                  "val2env",
                  (sizeof("val2env") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 4);
  lua_pushlstring(L,
                  ""
                  "equal_p",
                  (sizeof("equal_p") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 34, 3);
  lua_pushlstring(L,
                  ""
                  "simple_print",
                  (sizeof("simple_print") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 7, 168);
  lua_pushlstring(L,
                  ""
                  "complex_parse",
                  (sizeof("complex_parse") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 6, 199);
  lua_pushlstring(L,
                  ""
                  "complex_print",
                  (sizeof("complex_print") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (61 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "machinetext_parse",
                  (sizeof("machinetext_parse") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (62 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "machinetext_print",
                  (sizeof("machinetext_print") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 5, 211);
  lua_pushlstring(L,
                  ""
                  "trampoline_return",
                  (sizeof("trampoline_return") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 4, 213);
  lua_pushlstring(L,
                  ""
                  "trampoline_delay",
                  (sizeof("trampoline_delay") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 3, 215);
  lua_pushlstring(L,
                  ""
                  "run_trampoline",
                  (sizeof("run_trampoline") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 2, 216);
  lua_pushlstring(L,
                  ""
                  "return_effect_systemName",
                  (sizeof("return_effect_systemName") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lc_getupvalue(L, (70 + lc_nextra), 1, 217);
  lua_pushlstring(L,
                  ""
                  "bind_effect_systemName",
                  (sizeof("bind_effect_systemName") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (68 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "new_effect_bind",
                  (sizeof("new_effect_bind") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (69 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "new_effect_return",
                  (sizeof("new_effect_return") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (71 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "run_monad_trampoline",
                  (sizeof("run_monad_trampoline") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (72 + lc_nextra));
  lua_pushlstring(L,
                  ""
                  "run_monad_stackoverflow",
                  (sizeof("run_monad_stackoverflow") / sizeof(char)) - 1);
  lua_insert(L, -2);
  lua_settable(L, (73 + lc_nextra));
  lua_pushvalue(L, (73 + lc_nextra));
  return 1;
}
struct lang_state {
  lua_State *L;
  int exports_ref;
};
struct lang_value {
  int lua_ref;
};
extern lang_state *lang_state_new_orNULL(void) {
  lang_state *L = malloc(sizeof(lang_state));
  if (NULL != L) {
    L->L = luaL_newstate();
    if (NULL == L->L) {
      free(L);
      return NULL;
    }
    luaL_openlibs(L->L);
    lua_createtable(L->L, 0, 0);
    lua_pushcclosure(L->L, lcf_main, 1);
    lua_call(L->L, 0, 1);
    L->exports_ref = luaL_ref(L->L, (-10000));
  }
  return L;
}
extern void lang_state_delete(lang_state *L) {
  lua_close(L->L);
  L->L = NULL;
  free(L);
}
extern void lang_value_delete(lang_state *L, lang_value *val) {
  luaL_unref(L->L, (-10000), val->lua_ref);
  free(val);
}
extern lang_value *lang_value_copy_orNULL(lang_state *L, lang_value *val) {
  lang_value *ret = malloc(sizeof(lang_value));
  if (NULL == ret) {
    return NULL;
  }
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  ret->lua_ref = luaL_ref(L->L, (-10000));
  return ret;
}
static inline lang_value *lang_value_from_lua_orNULL(lang_state *L) {
  lang_value *ret = malloc(sizeof(lang_value));
  if (NULL == ret) {
    return NULL;
  }
  ret->lua_ref = luaL_ref(L->L, (-10000));
  lua_rawgeti(L->L, (-10000), ret->lua_ref);
  lua_remove(L->L, -1);
  return ret;
}
extern lang_value *lang_complex_parse_orNULL(lang_state *L, const char *str) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "complex_parse");
  lua_remove(L->L, -2);
  lua_pushstring(L->L, str);
  lua_call(L->L, 1, 1);
  lang_value *ret = lang_value_from_lua_orNULL(L);
  if (NULL == ret) {
    lua_settop(L->L, 0);
    return NULL;
  }
  return ret;
};
extern lang_value *lang_machinetext_parse_orNULL(lang_state *L,
                                                 const char *str) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "machinetext_parse");
  lua_remove(L->L, -2);
  lua_pushstring(L->L, str);
  lua_call(L->L, 1, 1);
  lang_value *ret = lang_value_from_lua_orNULL(L);
  if (NULL == ret) {
    lua_settop(L->L, 0);
    return NULL;
  }
  return ret;
};
extern char *lang_complex_print_retMalloc_orNULL(lang_state *L,
                                                 lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "complex_print");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  const char *rawret = lua_tolstring(L->L, (-1), NULL);
  lua_remove(L->L, -1);
  size_t len = strlen(rawret);
  char *ret = malloc(len + 1);
  if (NULL == ret) {
    return NULL;
  }
  memcpy(ret, rawret, len + 1);
  return ret;
};
extern char *lang_simple_print_retMalloc_orNULL(lang_state *L,
                                                lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "simple_print");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  const char *rawret = lua_tolstring(L->L, (-1), NULL);
  lua_remove(L->L, -1);
  size_t len = strlen(rawret);
  char *ret = malloc(len + 1);
  if (NULL == ret) {
    return NULL;
  }
  memcpy(ret, rawret, len + 1);
  return ret;
};
extern char *lang_machinetext_print_retMalloc_orNULL(lang_state *L,
                                                     lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "machinetext_print");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  const char *rawret = lua_tolstring(L->L, (-1), NULL);
  lua_remove(L->L, -1);
  size_t len = strlen(rawret);
  char *ret = malloc(len + 1);
  if (NULL == ret) {
    return NULL;
  }
  memcpy(ret, rawret, len + 1);
  return ret;
};
extern lang_value *lang_force1_orNULL(lang_state *L, lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "force1");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  lang_value *ret = lang_value_from_lua_orNULL(L);
  if (NULL == ret) {
    lua_settop(L->L, 0);
    return NULL;
  }
  return ret;
};
extern lang_value *lang_force_all_orNULL(lang_state *L, lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "force_all");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  lang_value *ret = lang_value_from_lua_orNULL(L);
  if (NULL == ret) {
    lua_settop(L->L, 0);
    return NULL;
  }
  return ret;
};
extern lang_value *lang_force_all_rec_orNULL(lang_state *L, lang_value *val) {
  lua_rawgeti(L->L, (-10000), L->exports_ref);
  lua_getfield(L->L, -1, "force_all_rec");
  lua_remove(L->L, -2);
  lua_rawgeti(L->L, (-10000), val->lua_ref);
  lua_call(L->L, 1, 1);
  lang_value *ret = lang_value_from_lua_orNULL(L);
  if (NULL == ret) {
    lua_settop(L->L, 0);
    return NULL;
  }
  return ret;
};
typedef unsigned long lu_int32;
typedef unsigned long lu_mem;
typedef long l_mem;
typedef unsigned char lu_byte;
typedef union {
  double u;
  void *s;
  long l;
} L_Umaxalign;
typedef double l_uacNumber;
typedef lu_int32 Instruction;
typedef union GCObject GCObject;
typedef struct GCheader {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
} GCheader;
typedef union {
  GCObject *gc;
  void *p;
  lua_Number n;
  int b;
} Value;
typedef struct lua_TValue {
  Value value;
  int tt;
} TValue;
typedef TValue *StkId;
typedef union TString {
  L_Umaxalign dummy;
  struct {
    GCObject *next;
    lu_byte tt;
    lu_byte marked;
    lu_byte reserved;
    unsigned int hash;
    size_t len;
  } tsv;
} TString;
typedef union Udata {
  L_Umaxalign dummy;
  struct {
    GCObject *next;
    lu_byte tt;
    lu_byte marked;
    struct Table *metatable;
    struct Table *env;
    size_t len;
  } uv;
} Udata;
typedef struct Proto {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  TValue *k;
  Instruction *code;
  struct Proto **p;
  int *lineinfo;
  struct LocVar *locvars;
  TString **upvalues;
  TString *source;
  int sizeupvalues;
  int sizek;
  int sizecode;
  int sizelineinfo;
  int sizep;
  int sizelocvars;
  int linedefined;
  int lastlinedefined;
  GCObject *gclist;
  lu_byte nups;
  lu_byte numparams;
  lu_byte is_vararg;
  lu_byte maxstacksize;
} Proto;
typedef struct LocVar {
  TString *varname;
  int startpc;
  int endpc;
} LocVar;
typedef struct UpVal {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  TValue *v;
  union {
    TValue value;
    struct {
      struct UpVal *prev;
      struct UpVal *next;
    } l;
  } u;
} UpVal;
typedef struct CClosure {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte isC;
  lu_byte nupvalues;
  GCObject *gclist;
  struct Table *env;
  lua_CFunction f;
  TValue upvalue[1];
} CClosure;
typedef struct LClosure {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte isC;
  lu_byte nupvalues;
  GCObject *gclist;
  struct Table *env;
  struct Proto *p;
  UpVal *upvals[1];
} LClosure;
typedef union Closure {
  CClosure c;
  LClosure l;
} Closure;
typedef union TKey {
  struct {
    Value value;
    int tt;
    struct Node *next;
  } nk;
  TValue tvk;
} TKey;
typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;
typedef struct Table {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte flags;
  lu_byte lsizenode;
  struct Table *metatable;
  TValue *array;
  Node *node;
  Node *lastfree;
  GCObject *gclist;
  int sizearray;
} Table;
static const TValue luaO_nilobject_;
static inline int luaO_log2(unsigned int x);
static inline int luaO_int2fb(unsigned int x);
static inline int luaO_fb2int(int x);
static inline int luaO_rawequalObj(const TValue *t1, const TValue *t2);
static inline int luaO_str2d(const char *s, lua_Number *result);
static inline const char *luaO_pushvfstring(lua_State *L, const char *fmt,
                                            va_list argp);
static inline const char *luaO_pushfstring(lua_State *L, const char *fmt, ...);
static inline void luaO_chunkid(char *out, const char *source, size_t len);
static inline void luaA_pushobject(lua_State *L, const TValue *o);
typedef enum {
  TM_INDEX,
  TM_NEWINDEX,
  TM_GC,
  TM_MODE,
  TM_EQ,
  TM_ADD,
  TM_SUB,
  TM_MUL,
  TM_DIV,
  TM_MOD,
  TM_POW,
  TM_UNM,
  TM_LEN,
  TM_LT,
  TM_LE,
  TM_CONCAT,
  TM_CALL,
  TM_N
} TMS;
static const char *const luaT_typenames[];
static inline const TValue *luaT_gettm(Table *events, TMS event,
                                       TString *ename);
static inline const TValue *luaT_gettmbyobj(lua_State *L, const TValue *o,
                                            TMS event);
static inline void luaT_init(lua_State *L);
static inline void *luaM_realloc_(lua_State *L, void *block, size_t oldsize,
                                  size_t size);
static inline void *luaM_toobig(lua_State *L);
static inline void *luaM_growaux_(lua_State *L, void *block, int *size,
                                  size_t size_elem, int limit,
                                  const char *errormsg);
typedef struct Zio ZIO;
typedef struct Mbuffer {
  char *buffer;
  size_t n;
  size_t buffsize;
} Mbuffer;
static inline char *luaZ_openspace(lua_State *L, Mbuffer *buff, size_t n);
static inline void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader,
                             void *data);
static inline size_t luaZ_read(ZIO *z, void *b, size_t n);
static inline int luaZ_lookahead(ZIO *z);
struct Zio {
  size_t n;
  const char *p;
  lua_Reader reader;
  void *data;
  lua_State *L;
};
static inline int luaZ_fill(ZIO *z);
struct lua_longjmp;
typedef struct stringtable {
  GCObject **hash;
  lu_int32 nuse;
  int size;
} stringtable;
typedef struct CallInfo {
  StkId base;
  StkId func;
  StkId top;
  const Instruction *savedpc;
  int nresults;
  int tailcalls;
} CallInfo;
typedef struct global_State {
  stringtable strt;
  lua_Alloc frealloc;
  void *ud;
  lu_byte currentwhite;
  lu_byte gcstate;
  int sweepstrgc;
  GCObject *rootgc;
  GCObject **sweepgc;
  GCObject *gray;
  GCObject *grayagain;
  GCObject *weak;
  GCObject *tmudata;
  Mbuffer buff;
  lu_mem GCthreshold;
  lu_mem totalbytes;
  lu_mem estimate;
  lu_mem gcdept;
  int gcpause;
  int gcstepmul;
  lua_CFunction panic;
  TValue l_registry;
  struct lua_State *mainthread;
  UpVal uvhead;
  struct Table *mt[(8 + 1)];
  TString *tmname[TM_N];
} global_State;
struct lua_State {
  GCObject *next;
  lu_byte tt;
  lu_byte marked;
  lu_byte status;
  StkId top;
  StkId base;
  global_State *l_G;
  CallInfo *ci;
  const Instruction *savedpc;
  StkId stack_last;
  StkId stack;
  CallInfo *end_ci;
  CallInfo *base_ci;
  int stacksize;
  int size_ci;
  unsigned short nCcalls;
  unsigned short baseCcalls;
  lu_byte hookmask;
  lu_byte allowhook;
  int basehookcount;
  int hookcount;
  lua_Hook hook;
  TValue l_gt;
  TValue env;
  GCObject *openupval;
  GCObject *gclist;
  struct lua_longjmp *errorJmp;
  ptrdiff_t errfunc;
};
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;
};
static inline lua_State *luaE_newthread(lua_State *L);
static inline void luaE_freethread(lua_State *L, lua_State *L1);
static inline void luaG_typeerror(lua_State *L, const TValue *o,
                                  const char *opname);
static inline void luaG_concaterror(lua_State *L, StkId p1, StkId p2);
static inline void luaG_aritherror(lua_State *L, const TValue *p1,
                                   const TValue *p2);
static inline int luaG_ordererror(lua_State *L, const TValue *p1,
                                  const TValue *p2);
static inline void luaG_runerror(lua_State *L, const char *fmt, ...);
static inline void luaG_errormsg(lua_State *L);
static inline int luaG_checkcode(const Proto *pt);
static inline int luaG_checkopenop(Instruction i);
typedef void (*Pfunc)(lua_State *L, void *ud);
static inline void luaD_callhook(lua_State *L, int event, int line);
static inline int luaD_precall(lua_State *L, StkId func, int nresults);
static inline void luaD_call(lua_State *L, StkId func, int nResults);
static inline int luaD_pcall(lua_State *L, Pfunc func, void *u,
                             ptrdiff_t oldtop, ptrdiff_t ef);
static inline int luaD_poscall(lua_State *L, StkId firstResult);
static inline void luaD_reallocCI(lua_State *L, int newsize);
static inline void luaD_reallocstack(lua_State *L, int newsize);
static inline void luaD_growstack(lua_State *L, int n);
static inline void luaD_throw(lua_State *L, int errcode);
static inline int luaD_rawrunprotected(lua_State *L, Pfunc f, void *ud);
static inline void luaD_seterrorobj(lua_State *L, int errcode, StkId oldtop);
static inline Proto *luaF_newproto(lua_State *L);
static inline Closure *luaF_newCclosure(lua_State *L, int nelems, Table *e);
static inline Closure *luaF_newLclosure(lua_State *L, int nelems, Table *e);
static inline UpVal *luaF_newupval(lua_State *L);
static inline UpVal *luaF_findupval(lua_State *L, StkId level);
static inline void luaF_close(lua_State *L, StkId level);
static inline void luaF_freeproto(lua_State *L, Proto *f);
static inline void luaF_freeclosure(lua_State *L, Closure *c);
static inline void luaF_freeupval(lua_State *L, UpVal *uv);
static inline const char *luaF_getlocalname(const Proto *func, int local_number,
                                            int pc);
static inline size_t luaC_separateudata(lua_State *L, int all);
static inline void luaC_callGCTM(lua_State *L);
static inline void luaC_freeall(lua_State *L);
static inline void luaC_step(lua_State *L);
static inline void luaC_fullgc(lua_State *L);
static inline void luaC_link(lua_State *L, GCObject *o, lu_byte tt);
static inline void luaC_linkupval(lua_State *L, UpVal *uv);
static inline void luaC_barrierf(lua_State *L, GCObject *o, GCObject *v);
static inline void luaC_barrierback(lua_State *L, Table *t);
static inline void luaS_resize(lua_State *L, int newsize);
static inline Udata *luaS_newudata(lua_State *L, size_t s, Table *e);
static inline TString *luaS_newlstr(lua_State *L, const char *str, size_t l);
static inline const TValue *luaH_getnum(Table *t, int key);
static inline TValue *luaH_setnum(lua_State *L, Table *t, int key);
static inline const TValue *luaH_getstr(Table *t, TString *key);
static inline TValue *luaH_setstr(lua_State *L, Table *t, TString *key);
static inline const TValue *luaH_get(Table *t, const TValue *key);
static inline TValue *luaH_set(lua_State *L, Table *t, const TValue *key);
static inline Table *luaH_new(lua_State *L, int narray, int lnhash);
static inline void luaH_resizearray(lua_State *L, Table *t, int nasize);
static inline void luaH_free(lua_State *L, Table *t);
static inline int luaH_next(lua_State *L, Table *t, StkId key);
static inline int luaH_getn(Table *t);
static inline Proto *luaU_undump(lua_State *L, ZIO *Z, Mbuffer *buff,
                                 const char *name);
static inline void luaU_header(char *h);
static inline int luaU_dump(lua_State *L, const Proto *f, lua_Writer w,
                            void *data, int strip);
static inline int luaV_lessthan(lua_State *L, const TValue *l, const TValue *r);
static inline int luaV_equalval(lua_State *L, const TValue *t1,
                                const TValue *t2);
static inline const TValue *luaV_tonumber(const TValue *obj, TValue *n);
static inline int luaV_tostring(lua_State *L, StkId obj);
static inline void luaV_gettable(lua_State *L, const TValue *t, TValue *key,
                                 StkId val);
static inline void luaV_settable(lua_State *L, const TValue *t, TValue *key,
                                 StkId val);
static inline void luaV_execute(lua_State *L, int nexeccalls);
static inline void luaV_concat(lua_State *L, int total, int last);
static const char lua_ident[] =
    "$Lua: "
    "Lua 5.1.5"
    " "
    "Copyright (C) 1994-2012 Lua.org, PUC-Rio"
    " $\n"
    "$Authors: "
    "R. Ierusalimschy, L. H. de Figueiredo & W. Celes"
    " $\n"
    "$URL: www.lua.org $\n";
static inline TValue *index2adr(lua_State *L, int idx) {
  if (idx > 0) {
    TValue *o = L->base + (idx - 1);
    ((void)0);
    if (o >= L->top)
      return ((TValue *)((&luaO_nilobject_)));
    else
      return o;
  } else if (idx > (-10000)) {
    ((void)0);
    return L->top + idx;
  } else
    switch (idx) {
    case (-10000):
      return (&(L->l_G)->l_registry);
    case (-10001): {
      Closure *func = ((((void)0), (&(L->ci->func)->value.gc->cl)));
      {
        TValue *i_o = (&L->env);
        i_o->value.gc = ((GCObject *)((func->c.env)));
        i_o->tt = 5;
        ((void)0);
      };
      return &L->env;
    }
    case (-10002):
      return (&L->l_gt);
    default: {
      Closure *func = ((((void)0), (&(L->ci->func)->value.gc->cl)));
      idx = (-10002) - idx;
      return (idx <= func->c.nupvalues) ? &func->c.upvalue[idx - 1]
                                        : ((TValue *)((&luaO_nilobject_)));
    }
    }
}
static inline Table *getcurrenv(lua_State *L) {
  if (L->ci == L->base_ci)
    return (((void)0), (&((&L->l_gt))->value.gc->h));
  else {
    Closure *func = ((((void)0), (&(L->ci->func)->value.gc->cl)));
    return func->c.env;
  }
}
static inline void luaA_pushobject(lua_State *L, const TValue *o) {
  {
    const TValue *o2 = (o);
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
}
static inline int lua_checkstack(lua_State *L, int size) {
  int res = 1;
  ((void)0);
  if (size > 8000 || (L->top - L->base + size) > 8000)
    res = 0;
  else if (size > 0) {
    if ((char *)L->stack_last - (char *)L->top <= (size) * (int)sizeof(TValue))
      luaD_growstack(L, size);
    else
      ((void)0);
    ;
    if (L->ci->top < L->top + size)
      L->ci->top = L->top + size;
  }
  ((void)0);
  return res;
}
static inline void lua_xmove(lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to)
    return;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  from->top -= n;
  for (i = 0; i < n; i++) {
    {
      const TValue *o2 = (from->top + i);
      TValue *o1 = (to->top++);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
  }
  ((void)0);
}
static inline void lua_setlevel(lua_State *from, lua_State *to) {
  to->nCcalls = from->nCcalls;
}
static inline lua_CFunction lua_atpanic(lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  ((void)0);
  old = (L->l_G)->panic;
  (L->l_G)->panic = panicf;
  ((void)0);
  return old;
}
static inline lua_State *lua_newthread(lua_State *L) {
  lua_State *L1;
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  L1 = luaE_newthread(L);
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((L1)));
    i_o->tt = 8;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
  ((void)L);
  return L1;
}
static inline int lua_gettop(lua_State *L) {
  return ((int)((L->top - L->base)));
}
static inline void lua_settop(lua_State *L, int idx) {
  ((void)0);
  if (idx >= 0) {
    ((void)0);
    while (L->top < L->base + idx)
      ((L->top++)->tt = 0);
    L->top = L->base + idx;
  } else {
    ((void)0);
    L->top += idx + 1;
  }
  ((void)0);
}
static inline void lua_remove(lua_State *L, int idx) {
  StkId p;
  ((void)0);
  p = index2adr(L, idx);
  ((void)0);
  while (++p < L->top) {
    const TValue *o2 = (p);
    TValue *o1 = (p - 1);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  L->top--;
  ((void)0);
}
static inline void lua_insert(lua_State *L, int idx) {
  StkId p;
  StkId q;
  ((void)0);
  p = index2adr(L, idx);
  ((void)0);
  for (q = L->top; q > p; q--) {
    const TValue *o2 = (q - 1);
    TValue *o1 = (q);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (L->top);
    TValue *o1 = (p);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  ((void)0);
}
static inline void lua_replace(lua_State *L, int idx) {
  StkId o;
  ((void)0);
  if (idx == (-10001) && L->ci == L->base_ci)
    luaG_runerror(L, "no calling environment");
  ((void)0);
  o = index2adr(L, idx);
  ((void)0);
  if (idx == (-10001)) {
    Closure *func = ((((void)0), (&(L->ci->func)->value.gc->cl)));
    ((void)0);
    func->c.env = (((void)0), (&(L->top - 1)->value.gc->h));
    {
      if (((((L->top - 1)->tt) >= 4) &&
           ((((((void)0), ((L->top - 1)->value.gc)))->gch.marked) &
            ((((1 << (0)) | (1 << (1))))))) &&
          ((((((GCObject *)((func)))))->gch.marked) & ((1 << (2)))))
        luaC_barrierf(L, (((GCObject *)((func)))),
                      (((void)0), ((L->top - 1)->value.gc)));
    };
  } else {
    {
      const TValue *o2 = (L->top - 1);
      TValue *o1 = (o);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    if (idx < (-10002)) {
      if (((((L->top - 1)->tt) >= 4) &&
           ((((((void)0), ((L->top - 1)->value.gc)))->gch.marked) &
            ((((1 << (0)) | (1 << (1))))))) &&
          ((((((GCObject *)((((((void)0), (&(L->ci->func)->value.gc->cl))))))))
                ->gch.marked) &
           ((1 << (2)))))
        luaC_barrierf(
            L,
            (((GCObject *)((((((void)0), (&(L->ci->func)->value.gc->cl))))))),
            (((void)0), ((L->top - 1)->value.gc)));
    };
  }
  L->top--;
  ((void)0);
}
static inline void lua_pushvalue(lua_State *L, int idx) {
  ((void)0);
  {
    const TValue *o2 = (index2adr(L, idx));
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline int lua_type(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (o == (&luaO_nilobject_)) ? (-1) : ((o)->tt);
}
static inline const char *lua_typename(lua_State *L, int t) {
  ((void)(L));
  return (t == (-1)) ? "no value" : luaT_typenames[t];
}
static inline int lua_iscfunction(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (((o)->tt) == 6 && (((void)0), (&(o)->value.gc->cl))->c.isC);
}
static inline int lua_isnumber(lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  return (((o)->tt) == 3 || (((o) = luaV_tonumber(o, &n)) != NULL));
}
static inline int lua_isstring(lua_State *L, int idx) {
  int t = lua_type(L, idx);
  return (t == 4 || t == 3);
}
static inline int lua_isuserdata(lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return ((((o)->tt) == 7) || (((o)->tt) == 2));
}
static inline int lua_rawequal(lua_State *L, int index1, int index2) {
  StkId o1 = index2adr(L, index1);
  StkId o2 = index2adr(L, index2);
  return (o1 == (&luaO_nilobject_) || o2 == (&luaO_nilobject_))
             ? 0
             : luaO_rawequalObj(o1, o2);
}
static inline int lua_equal(lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  ((void)0);
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == (&luaO_nilobject_) || o2 == (&luaO_nilobject_))
          ? 0
          : (((o1)->tt) == ((o2)->tt) && luaV_equalval(L, o1, o2));
  ((void)0);
  return i;
}
static inline int lua_lessthan(lua_State *L, int index1, int index2) {
  StkId o1, o2;
  int i;
  ((void)0);
  o1 = index2adr(L, index1);
  o2 = index2adr(L, index2);
  i = (o1 == (&luaO_nilobject_) || o2 == (&luaO_nilobject_))
          ? 0
          : luaV_lessthan(L, o1, o2);
  ((void)0);
  return i;
}
static inline lua_Number lua_tonumber(lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if ((((o)->tt) == 3 || (((o) = luaV_tonumber(o, &n)) != NULL)))
    return (((void)0), ((o)->value.n));
  else
    return 0;
}
static inline lua_Integer lua_tointeger(lua_State *L, int idx) {
  TValue n;
  const TValue *o = index2adr(L, idx);
  if ((((o)->tt) == 3 || (((o) = luaV_tonumber(o, &n)) != NULL))) {
    lua_Integer res;
    lua_Number num = (((void)0), ((o)->value.n));
    ((res) = (lua_Integer)(num));
    return res;
  } else
    return 0;
}
static inline int lua_toboolean(lua_State *L, int idx) {
  const TValue *o = index2adr(L, idx);
  return !((((o)->tt) == 0) ||
           ((((o)->tt) == 1) && (((void)0), ((o)->value.b)) == 0));
}
static inline const char *lua_tolstring(lua_State *L, int idx, size_t *len) {
  StkId o = index2adr(L, idx);
  if (!(((o)->tt) == 4)) {
    ((void)0);
    if (!luaV_tostring(L, o)) {
      if (len != NULL)
        *len = 0;
      ((void)0);
      return NULL;
    }
    {
      ((void)0);
      if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
        luaC_step(L);
    };
    o = index2adr(L, idx);
    ((void)0);
  }
  if (len != NULL)
    *len = (&(((void)0), (&(o)->value.gc->ts))->tsv)->len;
  return ((const char *)(((((void)0), (&(o)->value.gc->ts))) + 1));
}
static inline size_t lua_objlen(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (((o)->tt)) {
  case 4:
    return (&(((void)0), (&(o)->value.gc->ts))->tsv)->len;
  case 7:
    return (&(((void)0), (&(o)->value.gc->u))->uv)->len;
  case 5:
    return luaH_getn((((void)0), (&(o)->value.gc->h)));
  case 3: {
    size_t l;
    ((void)0);
    l = (luaV_tostring(L, o) ? (&(((void)0), (&(o)->value.gc->ts))->tsv)->len
                             : 0);
    ((void)0);
    return l;
  }
  default:
    return 0;
  }
}
static inline lua_CFunction lua_tocfunction(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!(((o)->tt) == 6 && (((void)0), (&(o)->value.gc->cl))->c.isC))
             ? NULL
             : (((void)0), (&(o)->value.gc->cl))->c.f;
}
static inline void *lua_touserdata(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (((o)->tt)) {
  case 7:
    return ((((void)0), (&(o)->value.gc->u)) + 1);
  case 2:
    return (((void)0), ((o)->value.p));
  default:
    return NULL;
  }
}
static inline lua_State *lua_tothread(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  return (!(((o)->tt) == 8)) ? NULL : (((void)0), (&(o)->value.gc->th));
}
static inline const void *lua_topointer(lua_State *L, int idx) {
  StkId o = index2adr(L, idx);
  switch (((o)->tt)) {
  case 5:
    return (((void)0), (&(o)->value.gc->h));
  case 6:
    return (((void)0), (&(o)->value.gc->cl));
  case 8:
    return (((void)0), (&(o)->value.gc->th));
  case 7:
  case 2:
    return lua_touserdata(L, idx);
  default:
    return NULL;
  }
}
static inline void lua_pushnil(lua_State *L) {
  ((void)0);
  ((L->top)->tt = 0);
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushnumber(lua_State *L, lua_Number n) {
  ((void)0);
  {
    TValue *i_o = (L->top);
    i_o->value.n = (n);
    i_o->tt = 3;
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushinteger(lua_State *L, lua_Integer n) {
  ((void)0);
  {
    TValue *i_o = (L->top);
    i_o->value.n = (((lua_Number)((n))));
    i_o->tt = 3;
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushlstring(lua_State *L, const char *s, size_t len) {
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((luaS_newlstr(L, s, len))));
    i_o->tt = 4;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushstring(lua_State *L, const char *s) {
  if (s == NULL)
    lua_pushnil(L);
  else
    lua_pushlstring(L, s, strlen(s));
}
static inline const char *lua_pushvfstring(lua_State *L, const char *fmt,
                                           va_list argp) {
  const char *ret;
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  ret = luaO_pushvfstring(L, fmt, argp);
  ((void)0);
  return ret;
}
static inline const char *lua_pushfstring(lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  ((void)0);
  return ret;
}
static inline void lua_pushcclosure(lua_State *L, lua_CFunction fn, int n) {
  Closure *cl;
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  ((void)0);
  cl = luaF_newCclosure(L, n, getcurrenv(L));
  cl->c.f = fn;
  L->top -= n;
  while (n--) {
    const TValue *o2 = (L->top + n);
    TValue *o1 = (&cl->c.upvalue[n]);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((cl)));
    i_o->tt = 6;
    ((void)0);
  };
  ((void)0);
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushboolean(lua_State *L, int b) {
  ((void)0);
  {
    TValue *i_o = (L->top);
    i_o->value.b = ((b != 0));
    i_o->tt = 1;
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_pushlightuserdata(lua_State *L, void *p) {
  ((void)0);
  {
    TValue *i_o = (L->top);
    i_o->value.p = (p);
    i_o->tt = 2;
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline int lua_pushthread(lua_State *L) {
  ((void)0);
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((L)));
    i_o->tt = 8;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
  return ((L->l_G)->mainthread == L);
}
static inline void lua_gettable(lua_State *L, int idx) {
  StkId t;
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  luaV_gettable(L, t, L->top - 1, L->top - 1);
  ((void)0);
}
static inline void lua_getfield(lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  {
    TValue *i_o = (&key);
    i_o->value.gc = ((GCObject *)(((luaS_newlstr(L, k, strlen(k))))));
    i_o->tt = 4;
    ((void)0);
  };
  luaV_gettable(L, t, &key, L->top);
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_rawget(lua_State *L, int idx) {
  StkId t;
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  {
    const TValue *o2 = (luaH_get((((void)0), (&(t)->value.gc->h)), L->top - 1));
    TValue *o1 = (L->top - 1);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  ((void)0);
}
static inline void lua_rawgeti(lua_State *L, int idx, int n) {
  StkId o;
  ((void)0);
  o = index2adr(L, idx);
  ((void)0);
  {
    const TValue *o2 = (luaH_getnum((((void)0), (&(o)->value.gc->h)), n));
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_createtable(lua_State *L, int narray, int nrec) {
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((luaH_new(L, narray, nrec))));
    i_o->tt = 5;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline int lua_getmetatable(lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt = NULL;
  int res;
  ((void)0);
  obj = index2adr(L, objindex);
  switch (((obj)->tt)) {
  case 5:
    mt = (((void)0), (&(obj)->value.gc->h))->metatable;
    break;
  case 7:
    mt = (&(((void)0), (&(obj)->value.gc->u))->uv)->metatable;
    break;
  default:
    mt = (L->l_G)->mt[((obj)->tt)];
    break;
  }
  if (mt == NULL)
    res = 0;
  else {
    {
      TValue *i_o = (L->top);
      i_o->value.gc = ((GCObject *)((mt)));
      i_o->tt = 5;
      ((void)0);
    };
    {
      ((void)0);
      L->top++;
    };
    res = 1;
  }
  ((void)0);
  return res;
}
static inline void lua_getfenv(lua_State *L, int idx) {
  StkId o;
  ((void)0);
  o = index2adr(L, idx);
  ((void)0);
  switch (((o)->tt)) {
  case 6: {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)(((((void)0), (&(o)->value.gc->cl))->c.env)));
    i_o->tt = 5;
    ((void)0);
  }; break;
  case 7: {
    TValue *i_o = (L->top);
    i_o->value.gc =
        ((GCObject *)(((&(((void)0), (&(o)->value.gc->u))->uv)->env)));
    i_o->tt = 5;
    ((void)0);
  }; break;
  case 8: {
    const TValue *o2 = ((&(((void)0), (&(o)->value.gc->th))->l_gt));
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  }; break;
  default:
    ((L->top)->tt = 0);
    break;
  }
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
}
static inline void lua_settable(lua_State *L, int idx) {
  StkId t;
  ((void)0);
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  luaV_settable(L, t, L->top - 2, L->top - 1);
  L->top -= 2;
  ((void)0);
}
static inline void lua_setfield(lua_State *L, int idx, const char *k) {
  StkId t;
  TValue key;
  ((void)0);
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  {
    TValue *i_o = (&key);
    i_o->value.gc = ((GCObject *)(((luaS_newlstr(L, k, strlen(k))))));
    i_o->tt = 4;
    ((void)0);
  };
  luaV_settable(L, t, &key, L->top - 1);
  L->top--;
  ((void)0);
}
static inline void lua_rawset(lua_State *L, int idx) {
  StkId t;
  ((void)0);
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  {
    const TValue *o2 = (L->top - 1);
    TValue *o1 = (luaH_set(L, (((void)0), (&(t)->value.gc->h)), L->top - 2));
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    if (((((L->top - 1)->tt) >= 4) &&
         ((((((void)0), ((L->top - 1)->value.gc)))->gch.marked) &
          ((((1 << (0)) | (1 << (1))))))) &&
        ((((((GCObject *)(((((void)0), (&(t)->value.gc->h)))))))->gch.marked) &
         ((1 << (2)))))
      luaC_barrierback(L, (((void)0), (&(t)->value.gc->h)));
  };
  L->top -= 2;
  ((void)0);
}
static inline void lua_rawseti(lua_State *L, int idx, int n) {
  StkId o;
  ((void)0);
  ((void)0);
  o = index2adr(L, idx);
  ((void)0);
  {
    const TValue *o2 = (L->top - 1);
    TValue *o1 = (luaH_setnum(L, (((void)0), (&(o)->value.gc->h)), n));
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    if (((((L->top - 1)->tt) >= 4) &&
         ((((((void)0), ((L->top - 1)->value.gc)))->gch.marked) &
          ((((1 << (0)) | (1 << (1))))))) &&
        ((((((GCObject *)(((((void)0), (&(o)->value.gc->h)))))))->gch.marked) &
         ((1 << (2)))))
      luaC_barrierback(L, (((void)0), (&(o)->value.gc->h)));
  };
  L->top--;
  ((void)0);
}
static inline int lua_setmetatable(lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  ((void)0);
  ((void)0);
  obj = index2adr(L, objindex);
  ((void)0);
  if ((((L->top - 1)->tt) == 0))
    mt = NULL;
  else {
    ((void)0);
    mt = (((void)0), (&(L->top - 1)->value.gc->h));
  }
  switch (((obj)->tt)) {
  case 5: {
    (((void)0), (&(obj)->value.gc->h))->metatable = mt;
    if (mt) {
      if (((((((GCObject *)((mt)))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))) &&
          ((((((GCObject *)(((((void)0), (&(obj)->value.gc->h)))))))
                ->gch.marked) &
           ((1 << (2)))))
        luaC_barrierback(L, (((void)0), (&(obj)->value.gc->h)));
    };
    break;
  }
  case 7: {
    (&(((void)0), (&(obj)->value.gc->u))->uv)->metatable = mt;
    if (mt) {
      if (((((((GCObject *)((mt)))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))) &&
          ((((((GCObject *)(((((void)0), (&(obj)->value.gc->u)))))))
                ->gch.marked) &
           ((1 << (2)))))
        luaC_barrierf(L, (((GCObject *)(((((void)0), (&(obj)->value.gc->u)))))),
                      (((GCObject *)((mt)))));
    };
    break;
  }
  default: {
    (L->l_G)->mt[((obj)->tt)] = mt;
    break;
  }
  }
  L->top--;
  ((void)0);
  return 1;
}
static inline int lua_setfenv(lua_State *L, int idx) {
  StkId o;
  int res = 1;
  ((void)0);
  ((void)0);
  o = index2adr(L, idx);
  ((void)0);
  ((void)0);
  switch (((o)->tt)) {
  case 6:
    (((void)0), (&(o)->value.gc->cl))->c.env =
        (((void)0), (&(L->top - 1)->value.gc->h));
    break;
  case 7:
    (&(((void)0), (&(o)->value.gc->u))->uv)->env =
        (((void)0), (&(L->top - 1)->value.gc->h));
    break;
  case 8: {
    TValue *i_o = ((&(((void)0), (&(o)->value.gc->th))->l_gt));
    i_o->value.gc = ((GCObject *)(((((void)0), (&(L->top - 1)->value.gc->h)))));
    i_o->tt = 5;
    ((void)0);
  }; break;
  default:
    res = 0;
    break;
  }
  if (res) {
    if (((((((GCObject *)(((((void)0), (&(L->top - 1)->value.gc->h)))))))
              ->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))) &&
        ((((((GCObject *)(((((void)0), ((o)->value.gc)))))))->gch.marked) &
         ((1 << (2)))))
      luaC_barrierf(
          L, (((GCObject *)(((((void)0), ((o)->value.gc)))))),
          (((GCObject *)(((((void)0), (&(L->top - 1)->value.gc->h)))))));
  };
  L->top--;
  ((void)0);
  return res;
}
static inline void lua_call(lua_State *L, int nargs, int nresults) {
  StkId func;
  ((void)0);
  ((void)0);
  ((void)0);
  func = L->top - (nargs + 1);
  luaD_call(L, func, nresults);
  {
    if (nresults == (-1) && L->top >= L->ci->top)
      L->ci->top = L->top;
  };
  ((void)0);
}
struct CallS {
  StkId func;
  int nresults;
};
static inline void f_call(lua_State *L, void *ud) {
  struct CallS *c = ((struct CallS *)(ud));
  luaD_call(L, c->func, c->nresults);
}
static inline int lua_pcall(lua_State *L, int nargs, int nresults,
                            int errfunc) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  ((void)0);
  ((void)0);
  ((void)0);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2adr(L, errfunc);
    ((void)0);
    func = ((char *)(o) - (char *)L->stack);
  }
  c.func = L->top - (nargs + 1);
  c.nresults = nresults;
  status =
      luaD_pcall(L, f_call, &c, ((char *)(c.func) - (char *)L->stack), func);
  {
    if (nresults == (-1) && L->top >= L->ci->top)
      L->ci->top = L->top;
  };
  ((void)0);
  return status;
}
struct CCallS {
  lua_CFunction func;
  void *ud;
};
static inline void f_Ccall(lua_State *L, void *ud) {
  struct CCallS *c = ((struct CCallS *)(ud));
  Closure *cl;
  cl = luaF_newCclosure(L, 0, getcurrenv(L));
  cl->c.f = c->func;
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((cl)));
    i_o->tt = 6;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  {
    TValue *i_o = (L->top);
    i_o->value.p = (c->ud);
    i_o->tt = 2;
  };
  {
    ((void)0);
    L->top++;
  };
  luaD_call(L, L->top - 2, 0);
}
static inline int lua_cpcall(lua_State *L, lua_CFunction func, void *ud) {
  struct CCallS c;
  int status;
  ((void)0);
  c.func = func;
  c.ud = ud;
  status = luaD_pcall(L, f_Ccall, &c, ((char *)(L->top) - (char *)L->stack), 0);
  ((void)0);
  return status;
}
static inline int lua_status(lua_State *L) { return L->status; }
static inline int lua_error(lua_State *L) {
  ((void)0);
  ((void)0);
  luaG_errormsg(L);
  ((void)0);
  return 0;
}
static inline int lua_next(lua_State *L, int idx) {
  StkId t;
  int more;
  ((void)0);
  t = index2adr(L, idx);
  ((void)0);
  more = luaH_next(L, (((void)0), (&(t)->value.gc->h)), L->top - 1);
  if (more) {
    {
      ((void)0);
      L->top++;
    };
  } else
    L->top -= 1;
  ((void)0);
  return more;
}
static inline void lua_concat(lua_State *L, int n) {
  ((void)0);
  ((void)0);
  if (n >= 2) {
    {
      ((void)0);
      if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
        luaC_step(L);
    };
    luaV_concat(L, n, ((int)((L->top - L->base))) - 1);
    L->top -= (n - 1);
  } else if (n == 0) {
    {
      TValue *i_o = (L->top);
      i_o->value.gc = ((GCObject *)((luaS_newlstr(L, "", 0))));
      i_o->tt = 4;
      ((void)0);
    };
    {
      ((void)0);
      L->top++;
    };
  }
  ((void)0);
}
static inline lua_Alloc lua_getallocf(lua_State *L, void **ud) {
  lua_Alloc f;
  ((void)0);
  if (ud)
    *ud = (L->l_G)->ud;
  f = (L->l_G)->frealloc;
  ((void)0);
  return f;
}
static inline void lua_setallocf(lua_State *L, lua_Alloc f, void *ud) {
  ((void)0);
  (L->l_G)->ud = ud;
  (L->l_G)->frealloc = f;
  ((void)0);
}
static inline void *lua_newuserdata(lua_State *L, size_t size) {
  Udata *u;
  ((void)0);
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
  u = luaS_newudata(L, size, getcurrenv(L));
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)((u)));
    i_o->tt = 7;
    ((void)0);
  };
  {
    ((void)0);
    L->top++;
  };
  ((void)0);
  return u + 1;
}
static const char *aux_upvalue(StkId fi, int n, TValue **val) {
  Closure *f;
  if (!(((fi)->tt) == 6))
    return NULL;
  f = (((void)0), (&(fi)->value.gc->cl));
  if (f->c.isC) {
    if (!(1 <= n && n <= f->c.nupvalues))
      return NULL;
    *val = &f->c.upvalue[n - 1];
    return "";
  } else {
    Proto *p = f->l.p;
    if (!(1 <= n && n <= p->sizeupvalues))
      return NULL;
    *val = f->l.upvals[n - 1]->v;
    return ((const char *)((p->upvalues[n - 1]) + 1));
  }
}
static inline const char *lua_getupvalue(lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  ((void)0);
  name = aux_upvalue(index2adr(L, funcindex), n, &val);
  if (name) {
    {
      const TValue *o2 = (val);
      TValue *o1 = (L->top);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      ((void)0);
      L->top++;
    };
  }
  ((void)0);
  return name;
}
static inline const char *lua_setupvalue(lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val;
  StkId fi;
  ((void)0);
  fi = index2adr(L, funcindex);
  ((void)0);
  name = aux_upvalue(fi, n, &val);
  if (name) {
    L->top--;
    {
      const TValue *o2 = (L->top);
      TValue *o1 = (val);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      if (((((L->top)->tt) >= 4) &&
           ((((((void)0), ((L->top)->value.gc)))->gch.marked) &
            ((((1 << (0)) | (1 << (1))))))) &&
          ((((((GCObject *)(((((void)0), (&(fi)->value.gc->cl)))))))
                ->gch.marked) &
           ((1 << (2)))))
        luaC_barrierf(L, (((GCObject *)(((((void)0), (&(fi)->value.gc->cl)))))),
                      (((void)0), ((L->top)->value.gc)));
    };
  }
  ((void)0);
  return name;
}
static inline int luaL_argerror(lua_State *L, int narg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &ar))
    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
  lua_getinfo(L, "n", &ar);
  if (strcmp(ar.namewhat, "method") == 0) {
    narg--;
    if (narg == 0)
      return luaL_error(L,
                        "calling "
                        "'"
                        "%s"
                        "'"
                        " on bad self (%s)",
                        ar.name, extramsg);
  }
  if (ar.name == NULL)
    ar.name = "?";
  return luaL_error(L,
                    "bad argument #%d to "
                    "'"
                    "%s"
                    "'"
                    " (%s)",
                    narg, ar.name, extramsg);
}
static inline int luaL_typerror(lua_State *L, int narg, const char *tname) {
  const char *msg = lua_pushfstring(L, "%s expected, got %s", tname,
                                    lua_typename(L, lua_type(L, (narg))));
  return luaL_argerror(L, narg, msg);
}
static inline void tag_error(lua_State *L, int narg, int tag) {
  luaL_typerror(L, narg, lua_typename(L, tag));
}
static inline void luaL_where(lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &ar)) {
    lua_getinfo(L, "Sl", &ar);
    if (ar.currentline > 0) {
      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
}
static inline int luaL_error(lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}
static inline int luaL_checkoption(lua_State *L, int narg, const char *def,
                                   const char *const lst[]) {
  const char *name = (def) ? (luaL_optlstring(L, (narg), (def), NULL))
                           : (luaL_checklstring(L, (narg), NULL));
  int i;
  for (i = 0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, narg,
                       lua_pushfstring(L,
                                       "invalid option "
                                       "'"
                                       "%s"
                                       "'",
                                       name));
}
static inline int luaL_newmetatable(lua_State *L, const char *tname) {
  lua_getfield(L, (-10000), tname);
  if (!(lua_type(L, (-1)) == 0))
    return 0;
  lua_settop(L, -(1) - 1);
  lua_createtable(L, 0, 0);
  lua_pushvalue(L, -1);
  lua_setfield(L, (-10000), tname);
  return 1;
}
static inline void *luaL_checkudata(lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {
    if (lua_getmetatable(L, ud)) {
      lua_getfield(L, (-10000), tname);
      if (lua_rawequal(L, -1, -2)) {
        lua_settop(L, -(2) - 1);
        return p;
      }
    }
  }
  luaL_typerror(L, ud, tname);
  return NULL;
}
static inline void luaL_checkstack(lua_State *L, int space, const char *mes) {
  if (!lua_checkstack(L, space))
    luaL_error(L, "stack overflow (%s)", mes);
}
static inline void luaL_checktype(lua_State *L, int narg, int t) {
  if (lua_type(L, narg) != t)
    tag_error(L, narg, t);
}
static inline void luaL_checkany(lua_State *L, int narg) {
  if (lua_type(L, narg) == (-1))
    luaL_argerror(L, narg, "value expected");
}
static inline const char *luaL_checklstring(lua_State *L, int narg,
                                            size_t *len) {
  const char *s = lua_tolstring(L, narg, len);
  if (!s)
    tag_error(L, narg, 4);
  return s;
}
static inline const char *luaL_optlstring(lua_State *L, int narg,
                                          const char *def, size_t *len) {
  if ((lua_type(L, (narg)) <= 0)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  } else
    return luaL_checklstring(L, narg, len);
}
static inline lua_Number luaL_checknumber(lua_State *L, int narg) {
  lua_Number d = lua_tonumber(L, narg);
  if (d == 0 && !lua_isnumber(L, narg))
    tag_error(L, narg, 3);
  return d;
}
static inline lua_Number luaL_optnumber(lua_State *L, int narg,
                                        lua_Number def) {
  return ((lua_type(L, ((narg))) <= 0) ? (def) : luaL_checknumber(L, (narg)));
}
static inline lua_Integer luaL_checkinteger(lua_State *L, int narg) {
  lua_Integer d = lua_tointeger(L, narg);
  if (d == 0 && !lua_isnumber(L, narg))
    tag_error(L, narg, 3);
  return d;
}
static inline lua_Integer luaL_optinteger(lua_State *L, int narg,
                                          lua_Integer def) {
  return ((lua_type(L, ((narg))) <= 0) ? (def) : luaL_checkinteger(L, (narg)));
}
static inline int luaL_getmetafield(lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj))
    return 0;
  lua_pushstring(L, event);
  lua_rawget(L, -2);
  if ((lua_type(L, (-1)) == 0)) {
    lua_settop(L, -(2) - 1);
    return 0;
  } else {
    lua_remove(L, -2);
    return 1;
  }
}
static inline int luaL_callmeta(lua_State *L, int obj, const char *event) {
  obj = ((obj) > 0 || (obj) <= (-10000) ? (obj) : lua_gettop(L) + (obj) + 1);
  if (!luaL_getmetafield(L, obj, event))
    return 0;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return 1;
}
static inline void(luaL_register)(lua_State *L, const char *libname,
                                  const luaL_Reg *l) {
  luaL_openlib(L, libname, l, 0);
}
static inline int libsize(const luaL_Reg *l) {
  int size = 0;
  for (; l->name; l++)
    size++;
  return size;
}
static inline void luaL_openlib(lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup) {
  if (libname) {
    int size = libsize(l);
    luaL_findtable(L, (-10000), "_LOADED", 1);
    lua_getfield(L, -1, libname);
    if (!(lua_type(L, (-1)) == 5)) {
      lua_settop(L, -(1) - 1);
      if (luaL_findtable(L, (-10002), libname, size) != NULL)
        luaL_error(L,
                   "name conflict for module "
                   "'"
                   "%s"
                   "'",
                   libname);
      lua_pushvalue(L, -1);
      lua_setfield(L, -3, libname);
    }
    lua_remove(L, -2);
    lua_insert(L, -(nup + 1));
  }
  for (; l->name; l++) {
    int i;
    for (i = 0; i < nup; i++)
      lua_pushvalue(L, -nup);
    lua_pushcclosure(L, l->func, nup);
    lua_setfield(L, -(nup + 2), l->name);
  }
  lua_settop(L, -(nup)-1);
}
static inline const char *luaL_gsub(lua_State *L, const char *s, const char *p,
                                    const char *r) {
  const char *wild;
  size_t l = strlen(p);
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while ((wild = strstr(s, p)) != NULL) {
    luaL_addlstring(&b, s, wild - s);
    luaL_addstring(&b, r);
    s = wild + l;
  }
  luaL_addstring(&b, s);
  luaL_pushresult(&b);
  return lua_tolstring(L, (-1), NULL);
}
static inline const char *luaL_findtable(lua_State *L, int idx,
                                         const char *fname, int szhint) {
  const char *e;
  lua_pushvalue(L, idx);
  do {
    e = strchr(fname, '.');
    if (e == NULL)
      e = fname + strlen(fname);
    lua_pushlstring(L, fname, e - fname);
    lua_rawget(L, -2);
    if ((lua_type(L, (-1)) == 0)) {
      lua_settop(L, -(1) - 1);
      lua_createtable(L, 0, (*e == '.' ? 1 : szhint));
      lua_pushlstring(L, fname, e - fname);
      lua_pushvalue(L, -2);
      lua_settable(L, -4);
    } else if (!(lua_type(L, (-1)) == 5)) {
      lua_settop(L, -(2) - 1);
      return fname;
    }
    lua_remove(L, -2);
    fname = e + 1;
  } while (*e == '.');
  return NULL;
}
static inline int emptybuffer(luaL_Buffer *B) {
  size_t l = ((B)->p - (B)->buffer);
  if (l == 0)
    return 0;
  else {
    lua_pushlstring(B->L, B->buffer, l);
    B->p = B->buffer;
    B->lvl++;
    return 1;
  }
}
static inline void adjuststack(luaL_Buffer *B) {
  if (B->lvl > 1) {
    lua_State *L = B->L;
    int toget = 1;
    size_t toplen = lua_objlen(L, (-1));
    do {
      size_t l = lua_objlen(L, (-(toget + 1)));
      if (B->lvl - toget + 1 >= (20 / 2) || toplen > l) {
        toplen += l;
        toget++;
      } else
        break;
    } while (toget < B->lvl);
    lua_concat(L, toget);
    B->lvl = B->lvl - toget + 1;
  }
}
static inline char *luaL_prepbuffer(luaL_Buffer *B) {
  if (emptybuffer(B))
    adjuststack(B);
  return B->buffer;
}
static inline void luaL_addlstring(luaL_Buffer *B, const char *s, size_t l) {
  while (l--)
    ((void)((B)->p < ((B)->buffer + BUFSIZ) || luaL_prepbuffer(B)),
     (*(B)->p++ = (char)(*s++)));
}
static inline void luaL_addstring(luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}
static inline void luaL_pushresult(luaL_Buffer *B) {
  emptybuffer(B);
  lua_concat(B->L, B->lvl);
  B->lvl = 1;
}
static inline void luaL_addvalue(luaL_Buffer *B) {
  lua_State *L = B->L;
  size_t vl;
  const char *s = lua_tolstring(L, -1, &vl);
  if (vl <= ((size_t)(BUFSIZ - ((B)->p - (B)->buffer)))) {
    memcpy(B->p, s, vl);
    B->p += vl;
    lua_settop(L, -(1) - 1);
  } else {
    if (emptybuffer(B))
      lua_insert(L, -2);
    B->lvl++;
    adjuststack(B);
  }
}
static inline void luaL_buffinit(lua_State *L, luaL_Buffer *B) {
  B->L = L;
  B->p = B->buffer;
  B->lvl = 0;
}
static inline int luaL_ref(lua_State *L, int t) {
  int ref;
  t = ((t) > 0 || (t) <= (-10000) ? (t) : lua_gettop(L) + (t) + 1);
  if ((lua_type(L, (-1)) == 0)) {
    lua_settop(L, -(1) - 1);
    return (-1);
  }
  lua_rawgeti(L, t, 0);
  ref = (int)lua_tointeger(L, -1);
  lua_settop(L, -(1) - 1);
  if (ref != 0) {
    lua_rawgeti(L, t, ref);
    lua_rawseti(L, t, 0);
  } else {
    ref = (int)lua_objlen(L, t);
    ref++;
  }
  lua_rawseti(L, t, ref);
  return ref;
}
static inline void luaL_unref(lua_State *L, int t, int ref) {
  if (ref >= 0) {
    t = ((t) > 0 || (t) <= (-10000) ? (t) : lua_gettop(L) + (t) + 1);
    lua_rawgeti(L, t, 0);
    lua_rawseti(L, t, ref);
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, 0);
  }
}
static inline void *l_alloc(void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud;
  (void)osize;
  if (nsize == 0) {
    free(ptr);
    return NULL;
  } else
    return realloc(ptr, nsize);
}
static inline int panic(lua_State *L) {
  (void)L;
  fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
          lua_tolstring(L, (-1), NULL));
  return 0;
}
static inline lua_State *luaL_newstate(void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (L)
    lua_atpanic(L, &panic);
  return L;
}
static inline int luaB_tonumber(lua_State *L) {
  int base = ((int)luaL_optinteger(L, (2), (10)));
  if (base == 10) {
    luaL_checkany(L, 1);
    if (lua_isnumber(L, 1)) {
      lua_pushnumber(L, lua_tonumber(L, 1));
      return 1;
    }
  } else {
    const char *s1 = (luaL_checklstring(L, (1), NULL));
    char *s2;
    unsigned long n;
    ((void)((2 <= base && base <= 36) ||
            luaL_argerror(L, (2), ("base out of range"))));
    n = strtoul(s1, &s2, base);
    if (s1 != s2) {
      while (user_defined_isspace((unsigned char)(*s2)))
        s2++;
      if (*s2 == '\0') {
        lua_pushnumber(L, (lua_Number)n);
        return 1;
      }
    }
  }
  lua_pushnil(L);
  return 1;
}
static inline int luaB_error(lua_State *L) {
  int level = ((int)luaL_optinteger(L, (2), (1)));
  lua_settop(L, 1);
  if (lua_isstring(L, 1) && level > 0) {
    luaL_where(L, level);
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}
static inline int luaB_getmetatable(lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;
  }
  luaL_getmetafield(L, 1, "__metatable");
  return 1;
}
static inline int luaB_setmetatable(lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, 5);
  ((void)((t == 0 || t == 5) ||
          luaL_argerror(L, (2), ("nil or table expected"))));
  if (luaL_getmetafield(L, 1, "__metatable"))
    luaL_error(L, "cannot change a protected metatable");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}
static inline void getfunc(lua_State *L, int opt) {
  if ((lua_type(L, (1)) == 6))
    lua_pushvalue(L, 1);
  else {
    lua_Debug ar;
    int level = opt ? ((int)luaL_optinteger(L, (1), (1)))
                    : ((int)luaL_checkinteger(L, (1)));
    ((void)((level >= 0) ||
            luaL_argerror(L, (1), ("level must be non-negative"))));
    if (lua_getstack(L, level, &ar) == 0)
      luaL_argerror(L, 1, "invalid level");
    lua_getinfo(L, "f", &ar);
    if ((lua_type(L, (-1)) == 0))
      luaL_error(L, "no function environment for tail call at level %d", level);
  }
}
static inline int luaB_rawequal(lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}
static inline int luaB_rawget(lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}
static inline int luaB_rawset(lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}
static inline int luaB_type(lua_State *L) {
  luaL_checkany(L, 1);
  lua_pushstring(L, lua_typename(L, lua_type(L, (1))));
  return 1;
}
static inline int luaB_next(lua_State *L) {
  luaL_checktype(L, 1, 5);
  lua_settop(L, 2);
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}
static inline int luaB_pairs(lua_State *L) {
  luaL_checktype(L, 1, 5);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_pushnil(L);
  return 3;
}
static inline int ipairsaux(lua_State *L) {
  int i = ((int)luaL_checkinteger(L, (2)));
  luaL_checktype(L, 1, 5);
  i++;
  lua_pushinteger(L, i);
  lua_rawgeti(L, 1, i);
  return ((lua_type(L, (-1)) == 0)) ? 0 : 2;
}
static inline int luaB_ipairs(lua_State *L) {
  luaL_checktype(L, 1, 5);
  lua_pushvalue(L, ((-10002) - (1)));
  lua_pushvalue(L, 1);
  lua_pushinteger(L, 0);
  return 3;
}
static inline int load_aux(lua_State *L, int status) {
  if (status == 0)
    return 1;
  else {
    lua_pushnil(L);
    lua_insert(L, -2);
    return 2;
  }
}
static inline int luaB_assert(lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_toboolean(L, 1))
    return luaL_error(L, "%s",
                      (luaL_optlstring(L, (2), ("assertion failed!"), NULL)));
  return lua_gettop(L);
}
static inline int luaB_unpack(lua_State *L) {
  int i, e, n;
  luaL_checktype(L, 1, 5);
  i = ((int)luaL_optinteger(L, (2), (1)));
  e = ((lua_type(L, ((3))) <= 0) ? (((int)lua_objlen(L, 1)))
                                 : ((int)luaL_checkinteger(L, ((3)))));
  if (i > e)
    return 0;
  n = e - i + 1;
  if (n <= 0 || !lua_checkstack(L, n))
    return luaL_error(L, "too many results to unpack");
  lua_rawgeti(L, 1, i);
  while (i++ < e)
    lua_rawgeti(L, 1, i);
  return n;
}
static inline int luaB_select(lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == 4 && *lua_tolstring(L, (1), NULL) == '#') {
    lua_pushinteger(L, n - 1);
    return 1;
  } else {
    int i = ((int)luaL_checkinteger(L, (1)));
    if (i < 0)
      i = n + i;
    else if (i > n)
      i = n;
    ((void)((1 <= i) || luaL_argerror(L, (1), ("index out of range"))));
    return n - i;
  }
}
static inline int luaB_pcall(lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  status = lua_pcall(L, lua_gettop(L) - 1, (-1), 0);
  lua_pushboolean(L, (status == 0));
  lua_insert(L, 1);
  return lua_gettop(L);
}
static inline int luaB_xpcall(lua_State *L) {
  int status;
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_insert(L, 1);
  status = lua_pcall(L, 0, (-1), 1);
  lua_pushboolean(L, (status == 0));
  lua_replace(L, 1);
  return lua_gettop(L);
}
static inline int luaB_tostring(lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_callmeta(L, 1, "__tostring"))
    return 1;
  switch (lua_type(L, 1)) {
  case 3:
    lua_pushstring(L, lua_tolstring(L, (1), NULL));
    break;
  case 4:
    lua_pushvalue(L, 1);
    break;
  case 1:
    lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
    break;
  case 0:
    lua_pushlstring(L,
                    ""
                    "nil",
                    (sizeof("nil") / sizeof(char)) - 1);
    break;
  default:
    lua_pushfstring(L, "%s: %p", lua_typename(L, lua_type(L, (1))),
                    lua_topointer(L, 1));
    break;
  }
  return 1;
}
static inline int luaB_newproxy(lua_State *L) {
  lua_settop(L, 1);
  lua_newuserdata(L, 0);
  if (lua_toboolean(L, 1) == 0)
    return 1;
  else if ((lua_type(L, (1)) == 1)) {
    lua_createtable(L, 0, 0);
    lua_pushvalue(L, -1);
    lua_pushboolean(L, 1);
    lua_rawset(L, ((-10002) - (1)));
  } else {
    int validproxy = 0;
    if (lua_getmetatable(L, 1)) {
      lua_rawget(L, ((-10002) - (1)));
      validproxy = lua_toboolean(L, -1);
      lua_settop(L, -(1) - 1);
    }
    ((void)((validproxy) ||
            luaL_argerror(L, (1), ("boolean or proxy expected"))));
    lua_getmetatable(L, 1);
  }
  lua_setmetatable(L, 2);
  return 1;
}
static const luaL_Reg base_funcs[] = {{"assert", luaB_assert},
                                      {"error", luaB_error},
                                      {"getmetatable", luaB_getmetatable},
                                      {"next", luaB_next},
                                      {"pcall", luaB_pcall},
                                      {"rawequal", luaB_rawequal},
                                      {"rawget", luaB_rawget},
                                      {"rawset", luaB_rawset},
                                      {"select", luaB_select},
                                      {"setmetatable", luaB_setmetatable},
                                      {"tonumber", luaB_tonumber},
                                      {"tostring", luaB_tostring},
                                      {"type", luaB_type},
                                      {"unpack", luaB_unpack},
                                      {"xpcall", luaB_xpcall},
                                      {NULL, NULL}};
static const char *const statnames[] = {"running", "suspended", "normal",
                                        "dead"};
static inline int costatus(lua_State *L, lua_State *co) {
  if (L == co)
    return 0;
  switch (lua_status(co)) {
  case 1:
    return 1;
  case 0: {
    lua_Debug ar;
    if (lua_getstack(co, 0, &ar) > 0)
      return 2;
    else if (lua_gettop(co) == 0)
      return 3;
    else
      return 1;
  }
  default:
    return 3;
  }
}
static inline int luaB_costatus(lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  ((void)((co) || luaL_argerror(L, (1), ("coroutine expected"))));
  lua_pushstring(L, statnames[costatus(L, co)]);
  return 1;
}
static inline int auxresume(lua_State *L, lua_State *co, int narg) {
  int status = costatus(L, co);
  if (!lua_checkstack(co, narg))
    luaL_error(L, "too many arguments to resume");
  if (status != 1) {
    lua_pushfstring(L, "cannot resume %s coroutine", statnames[status]);
    return -1;
  }
  lua_xmove(L, co, narg);
  lua_setlevel(L, co);
  status = lua_resume(co, narg);
  if (status == 0 || status == 1) {
    int nres = lua_gettop(co);
    if (!lua_checkstack(L, nres + 1))
      luaL_error(L, "too many results to resume");
    lua_xmove(co, L, nres);
    return nres;
  } else {
    lua_xmove(co, L, 1);
    return -1;
  }
}
static inline int luaB_coresume(lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  int r;
  ((void)((co) || luaL_argerror(L, (1), ("coroutine expected"))));
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (r < 0) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;
  } else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;
  }
}
static inline int luaB_auxwrap(lua_State *L) {
  lua_State *co = lua_tothread(L, ((-10002) - (1)));
  int r = auxresume(L, co, lua_gettop(L));
  if (r < 0) {
    if (lua_isstring(L, -1)) {
      luaL_where(L, 1);
      lua_insert(L, -2);
      lua_concat(L, 2);
    }
    lua_error(L);
  }
  return r;
}
static inline int luaB_cocreate(lua_State *L) {
  lua_State *NL = lua_newthread(L);
  ((void)(((lua_type(L, (1)) == 6) && !lua_iscfunction(L, 1)) ||
          luaL_argerror(L, (1), ("Lua function expected"))));
  lua_pushvalue(L, 1);
  lua_xmove(L, NL, 1);
  return 1;
}
static inline int luaB_cowrap(lua_State *L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
}
static inline int luaB_yield(lua_State *L) {
  return lua_yield(L, lua_gettop(L));
}
static inline int luaB_corunning(lua_State *L) {
  if (lua_pushthread(L))
    lua_pushnil(L);
  return 1;
}
static const luaL_Reg co_funcs[] = {{"create", luaB_cocreate},
                                    {"resume", luaB_coresume},
                                    {"running", luaB_corunning},
                                    {"status", luaB_costatus},
                                    {"wrap", luaB_cowrap},
                                    {"yield", luaB_yield},
                                    {NULL, NULL}};
static inline void auxopen(lua_State *L, const char *name, lua_CFunction f,
                           lua_CFunction u) {
  lua_pushcclosure(L, (u), 0);
  lua_pushcclosure(L, f, 1);
  lua_setfield(L, -2, name);
}
static inline void base_open(lua_State *L) {
  lua_pushvalue(L, (-10002));
  lua_setfield(L, (-10002), ("_G"));
  luaL_register(L, "_G", base_funcs);
  lua_pushlstring(L,
                  ""
                  "Lua 5.1",
                  (sizeof("Lua 5.1") / sizeof(char)) - 1);
  lua_setfield(L, (-10002), ("_VERSION"));
  auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
  auxopen(L, "pairs", luaB_pairs, luaB_next);
  lua_createtable(L, 0, 1);
  lua_pushvalue(L, -1);
  lua_setmetatable(L, -2);
  lua_pushlstring(L,
                  ""
                  "kv",
                  (sizeof("kv") / sizeof(char)) - 1);
  lua_setfield(L, -2, "__mode");
  lua_pushcclosure(L, luaB_newproxy, 1);
  lua_setfield(L, (-10002), ("newproxy"));
}
static inline int luaopen_base(lua_State *L) {
  base_open(L);
  luaL_register(L, "coroutine", co_funcs);
  return 2;
}
enum OpMode { iABC, iABx, iAsBx };
typedef enum {
  OP_MOVE,
  OP_LOADK,
  OP_LOADBOOL,
  OP_LOADNIL,
  OP_GETUPVAL,
  OP_GETGLOBAL,
  OP_GETTABLE,
  OP_SETGLOBAL,
  OP_SETUPVAL,
  OP_SETTABLE,
  OP_NEWTABLE,
  OP_SELF,
  OP_ADD,
  OP_SUB,
  OP_MUL,
  OP_DIV,
  OP_MOD,
  OP_POW,
  OP_UNM,
  OP_NOT,
  OP_LEN,
  OP_CONCAT,
  OP_JMP,
  OP_EQ,
  OP_LT,
  OP_LE,
  OP_TEST,
  OP_TESTSET,
  OP_CALL,
  OP_TAILCALL,
  OP_RETURN,
  OP_FORLOOP,
  OP_FORPREP,
  OP_TFORLOOP,
  OP_SETLIST,
  OP_CLOSE,
  OP_CLOSURE,
  OP_VARARG
} OpCode;
enum OpArgMask { OpArgN, OpArgU, OpArgR, OpArgK };
static const lu_byte luaP_opmodes[(((int)(OP_VARARG)) + 1)];
static const char *const luaP_opnames[(((int)(OP_VARARG)) + 1) + 1];
static const char *getfuncname(lua_State *L, CallInfo *ci, const char **name);
static inline int currentpc(lua_State *L, CallInfo *ci) {
  if (!(((((ci)->func)->tt) == 6) &&
        (!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC)))
    return -1;
  if (ci == L->ci)
    ci->savedpc = L->savedpc;
  return (((int)((ci->savedpc) -
                 (((((void)0), (&((ci)->func)->value.gc->cl)))->l.p)->code)) -
          1);
}
static inline int currentline(lua_State *L, CallInfo *ci) {
  int pc = currentpc(L, ci);
  if (pc < 0)
    return -1;
  else
    return (
        ((((((void)0), (&((ci)->func)->value.gc->cl)))->l.p)->lineinfo)
            ? (((((void)0), (&((ci)->func)->value.gc->cl)))->l.p)->lineinfo[pc]
            : 0);
}
static inline int lua_sethook(lua_State *L, lua_Hook func, int mask,
                              int count) {
  if (func == NULL || mask == 0) {
    mask = 0;
    func = NULL;
  }
  L->hook = func;
  L->basehookcount = count;
  (L->hookcount = L->basehookcount);
  L->hookmask = ((lu_byte)((mask)));
  return 1;
}
static inline lua_Hook lua_gethook(lua_State *L) { return L->hook; }
static inline int lua_gethookmask(lua_State *L) { return L->hookmask; }
static inline int lua_gethookcount(lua_State *L) { return L->basehookcount; }
static inline int lua_getstack(lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  ((void)0);
  for (ci = L->ci; level > 0 && ci > L->base_ci; ci--) {
    level--;
    if ((!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC))
      level -= ci->tailcalls;
  }
  if (level == 0 && ci > L->base_ci) {
    status = 1;
    ar->i_ci = ((int)((ci - L->base_ci)));
  } else if (level < 0) {
    status = 1;
    ar->i_ci = 0;
  } else
    status = 0;
  ((void)0);
  return status;
}
static inline Proto *getluaproto(CallInfo *ci) {
  return ((((((ci)->func)->tt) == 6) &&
           (!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC))
              ? ((((void)0), (&((ci)->func)->value.gc->cl)))->l.p
              : NULL);
}
static const char *findlocal(lua_State *L, CallInfo *ci, int n) {
  const char *name;
  Proto *fp = getluaproto(ci);
  if (fp && (name = luaF_getlocalname(fp, n, currentpc(L, ci))) != NULL)
    return name;
  else {
    StkId limit = (ci == L->ci) ? L->top : (ci + 1)->func;
    if (limit - ci->base >= n && n > 0)
      return "(*temporary)";
    else
      return NULL;
  }
}
static inline const char *lua_getlocal(lua_State *L, const lua_Debug *ar,
                                       int n) {
  CallInfo *ci = L->base_ci + ar->i_ci;
  const char *name = findlocal(L, ci, n);
  ((void)0);
  if (name)
    luaA_pushobject(L, ci->base + (n - 1));
  ((void)0);
  return name;
}
static inline const char *lua_setlocal(lua_State *L, const lua_Debug *ar,
                                       int n) {
  CallInfo *ci = L->base_ci + ar->i_ci;
  const char *name = findlocal(L, ci, n);
  ((void)0);
  if (name) {
    const TValue *o2 = (L->top - 1);
    TValue *o1 = (ci->base + (n - 1));
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  L->top--;
  ((void)0);
  return name;
}
static inline void funcinfo(lua_Debug *ar, Closure *cl) {
  if (cl->c.isC) {
    ar->source = "=[C]";
    ar->linedefined = -1;
    ar->lastlinedefined = -1;
    ar->what = "C";
  } else {
    ar->source = ((const char *)((cl->l.p->source) + 1));
    ar->linedefined = cl->l.p->linedefined;
    ar->lastlinedefined = cl->l.p->lastlinedefined;
    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
  }
  luaO_chunkid(ar->short_src, ar->source, 60);
}
static inline void info_tailcall(lua_Debug *ar) {
  ar->name = ar->namewhat = "";
  ar->what = "tail";
  ar->lastlinedefined = ar->linedefined = ar->currentline = -1;
  ar->source = "=(tail call)";
  luaO_chunkid(ar->short_src, ar->source, 60);
  ar->nups = 0;
}
static inline void collectvalidlines(lua_State *L, Closure *f) {
  if (f == NULL || f->c.isC) {
    ((L->top)->tt = 0);
  } else {
    Table *t = luaH_new(L, 0, 0);
    int *lineinfo = f->l.p->lineinfo;
    int i;
    for (i = 0; i < f->l.p->sizelineinfo; i++) {
      TValue *i_o = (luaH_setnum(L, t, lineinfo[i]));
      i_o->value.b = (1);
      i_o->tt = 1;
    };
    {
      TValue *i_o = (L->top);
      i_o->value.gc = ((GCObject *)((t)));
      i_o->tt = 5;
      ((void)0);
    };
  }
  {
    if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
      luaD_growstack(L, 1);
    else
      ((void)0);
    ;
    L->top++;
  };
}
static inline int auxgetinfo(lua_State *L, const char *what, lua_Debug *ar,
                             Closure *f, CallInfo *ci) {
  int status = 1;
  if (f == NULL) {
    info_tailcall(ar);
    return status;
  }
  for (; *what; what++) {
    switch (*what) {
    case 'S': {
      funcinfo(ar, f);
      break;
    }
    case 'l': {
      ar->currentline = (ci) ? currentline(L, ci) : -1;
      break;
    }
    case 'u': {
      ar->nups = f->c.nupvalues;
      break;
    }
    case 'n': {
      ar->namewhat = (ci) ? getfuncname(L, ci, &ar->name) : NULL;
      if (ar->namewhat == NULL) {
        ar->namewhat = "";
        ar->name = NULL;
      }
      break;
    }
    case 'L':
    case 'f':
      break;
    default:
      status = 0;
    }
  }
  return status;
}
static inline int lua_getinfo(lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *f = NULL;
  CallInfo *ci = NULL;
  ((void)0);
  if (*what == '>') {
    StkId func = L->top - 1;
    { (void)L; };
    what++;
    f = (((void)0), (&(func)->value.gc->cl));
    L->top--;
  } else if (ar->i_ci != 0) {
    ci = L->base_ci + ar->i_ci;
    ((void)0);
    f = (((void)0), (&(ci->func)->value.gc->cl));
  }
  status = auxgetinfo(L, what, ar, f, ci);
  if (strchr(what, 'f')) {
    if (f == NULL)
      ((L->top)->tt = 0);
    else {
      TValue *i_o = (L->top);
      i_o->value.gc = ((GCObject *)((f)));
      i_o->tt = 6;
      ((void)0);
    };
    {
      if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
        luaD_growstack(L, 1);
      else
        ((void)0);
      ;
      L->top++;
    };
  }
  if (strchr(what, 'L'))
    collectvalidlines(L, f);
  ((void)0);
  return status;
}
static inline int precheck(const Proto *pt) {
  if (!(pt->maxstacksize <= 250))
    return 0;
  ;
  if (!(pt->numparams + (pt->is_vararg & 1) <= pt->maxstacksize))
    return 0;
  ;
  if (!(!(pt->is_vararg & 4) || (pt->is_vararg & 1)))
    return 0;
  ;
  if (!(pt->sizeupvalues <= pt->nups))
    return 0;
  ;
  if (!(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0))
    return 0;
  ;
  if (!(pt->sizecode > 0 &&
        (((OpCode)(((pt->code[pt->sizecode - 1]) >> 0) &
                   ((~((~(Instruction)0) << 6)) << 0)))) == OP_RETURN))
    return 0;
  ;
  return 1;
}
static inline int luaG_checkopenop(Instruction i) {
  switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))))) {
  case OP_CALL:
  case OP_TAILCALL:
  case OP_RETURN:
  case OP_SETLIST: {
    if (!((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                  ((~((~(Instruction)0) << 9)) << 0)))) == 0))
      return 0;
    ;
    return 1;
  }
  default:
    return 0;
  }
}
static inline int checkArgMode(const Proto *pt, int r, enum OpArgMask mode) {
  switch (mode) {
  case OpArgN:
    if (!(r == 0))
      return 0;
    ;
    break;
  case OpArgU:
    break;
  case OpArgR:
    if (!((r) < (pt)->maxstacksize))
      return 0;
    ;
    break;
  case OpArgK:
    if (!(((r) & (1 << (9 - 1))) ? ((int)(r) & ~(1 << (9 - 1))) < pt->sizek
                                 : r < pt->maxstacksize))
      return 0;
    ;
    break;
  }
  return 1;
}
static inline Instruction symbexec(const Proto *pt, int lastpc, int reg) {
  int pc;
  int last;
  last = pt->sizecode - 1;
  if (!(precheck(pt)))
    return 0;
  ;
  for (pc = 0; pc < lastpc; pc++) {
    Instruction i = pt->code[pc];
    OpCode op = (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))));
    int a = (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))));
    int b = 0;
    int c = 0;
    if (!(op < (((int)(OP_VARARG)) + 1)))
      return 0;
    ;
    if (!((a) < (pt)->maxstacksize))
      return 0;
    ;
    switch ((((enum OpMode)(luaP_opmodes[op] & 3)))) {
    case iABC: {
      b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                  ((~((~(Instruction)0) << 9)) << 0))));
      c = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      if (!(checkArgMode(pt, b,
                         (((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))))))
        return 0;
      ;
      if (!(checkArgMode(pt, c,
                         (((enum OpArgMask)((luaP_opmodes[op] >> 2) & 3))))))
        return 0;
      ;
      break;
    }
    case iABx: {
      b = (((int)(((i) >> ((0 + 6) + 8)) &
                  ((~((~(Instruction)0) << (9 + 9))) << 0))));
      if ((((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))) == OpArgK)
        if (!(b < pt->sizek))
          return 0;
      ;
      break;
    }
    case iAsBx: {
      b = ((((int)(((i) >> ((0 + 6) + 8)) &
                   ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
           (INT_MAX - 2));
      if ((((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))) == OpArgR) {
        int dest = pc + 1 + b;
        if (!(0 <= dest && dest < pt->sizecode))
          return 0;
        ;
        if (dest > 0) {
          int j;
          for (j = 0; j < dest; j++) {
            Instruction d = pt->code[dest - 1 - j];
            if (!((((OpCode)(((d) >> 0) & ((~((~(Instruction)0) << 6))
                                           << 0)))) == OP_SETLIST &&
                  (((int)(((d) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << 9)) << 0)))) == 0))
              break;
          }
          if (!((j & 1) == 0))
            return 0;
          ;
        }
      }
      break;
    }
    }
    if ((luaP_opmodes[op] & (1 << 6))) {
      if (a == reg)
        last = pc;
    }
    if ((luaP_opmodes[op] & (1 << 7))) {
      if (!(pc + 2 < pt->sizecode))
        return 0;
      ;
      if (!((((OpCode)(((pt->code[pc + 1]) >> 0) &
                       ((~((~(Instruction)0) << 6)) << 0)))) == OP_JMP))
        return 0;
      ;
    }
    switch (op) {
    case OP_LOADBOOL: {
      if (c == 1) {
        if (!(pc + 2 < pt->sizecode))
          return 0;
        ;
        if (!((((OpCode)(((pt->code[pc + 1]) >> 0) &
                         ((~((~(Instruction)0) << 6)) << 0)))) != OP_SETLIST ||
              (((int)(((pt->code[pc + 1]) >> ((0 + 6) + 8)) &
                      ((~((~(Instruction)0) << 9)) << 0)))) != 0))
          return 0;
        ;
      }
      break;
    }
    case OP_LOADNIL: {
      if (a <= reg && reg <= b)
        last = pc;
      break;
    }
    case OP_GETUPVAL:
    case OP_SETUPVAL: {
      if (!(b < pt->nups))
        return 0;
      ;
      break;
    }
    case OP_GETGLOBAL:
    case OP_SETGLOBAL: {
      if (!((((&pt->k[b])->tt) == 4)))
        return 0;
      ;
      break;
    }
    case OP_SELF: {
      if (!((a + 1) < (pt)->maxstacksize))
        return 0;
      ;
      if (reg == a + 1)
        last = pc;
      break;
    }
    case OP_CONCAT: {
      if (!(b < c))
        return 0;
      ;
      break;
    }
    case OP_TFORLOOP: {
      if (!(c >= 1))
        return 0;
      ;
      if (!((a + 2 + c) < (pt)->maxstacksize))
        return 0;
      ;
      if (reg >= a + 2)
        last = pc;
      break;
    }
    case OP_FORLOOP:
    case OP_FORPREP:
      if (!((a + 3) < (pt)->maxstacksize))
        return 0;
      ;
    case OP_JMP: {
      int dest = pc + 1 + b;
      if (reg != ((1 << 8) - 1) && pc < dest && dest <= lastpc)
        pc += b;
      break;
    }
    case OP_CALL:
    case OP_TAILCALL: {
      if (b != 0) {
        if (!((a + b - 1) < (pt)->maxstacksize))
          return 0;
        ;
      }
      c--;
      if (c == (-1)) {
        if (!(luaG_checkopenop((pt)->code[(pc) + 1])))
          return 0;
        ;
      } else if (c != 0)
        if (!((a + c - 1) < (pt)->maxstacksize))
          return 0;
      ;
      if (reg >= a)
        last = pc;
      break;
    }
    case OP_RETURN: {
      b--;
      if (b > 0)
        if (!((a + b - 1) < (pt)->maxstacksize))
          return 0;
      ;
      break;
    }
    case OP_SETLIST: {
      if (b > 0)
        if (!((a + b) < (pt)->maxstacksize))
          return 0;
      ;
      if (c == 0) {
        pc++;
        if (!(pc < pt->sizecode - 1))
          return 0;
        ;
      }
      break;
    }
    case OP_CLOSURE: {
      int nup, j;
      if (!(b < pt->sizep))
        return 0;
      ;
      nup = pt->p[b]->nups;
      if (!(pc + nup < pt->sizecode))
        return 0;
      ;
      for (j = 1; j <= nup; j++) {
        OpCode op1 = (((OpCode)(((pt->code[pc + j]) >> 0) &
                                ((~((~(Instruction)0) << 6)) << 0))));
        if (!(op1 == OP_GETUPVAL || op1 == OP_MOVE))
          return 0;
        ;
      }
      if (reg != ((1 << 8) - 1))
        pc += nup;
      break;
    }
    case OP_VARARG: {
      if (!((pt->is_vararg & 2) && !(pt->is_vararg & 4)))
        return 0;
      ;
      b--;
      if (b == (-1))
        if (!(luaG_checkopenop((pt)->code[(pc) + 1])))
          return 0;
      ;
      if (!((a + b - 1) < (pt)->maxstacksize))
        return 0;
      ;
      break;
    }
    default:
      break;
    }
  }
  return pt->code[last];
}
static inline int luaG_checkcode(const Proto *pt) {
  return (symbexec(pt, pt->sizecode, ((1 << 8) - 1)) != 0);
}
static const char *kname(Proto *p, int c) {
  if (((c) & (1 << (9 - 1))) &&
      (((&p->k[((int)(c) & ~(1 << (9 - 1)))])->tt) == 4))
    return ((const char *)(((((void)0), (&(&p->k[((int)(c) & ~(1 << (9 - 1)))])
                                              ->value.gc->ts))) +
                           1));
  else
    return "?";
}
static const char *getobjname(lua_State *L, CallInfo *ci, int stackpos,
                              const char **name) {
  if ((((((ci)->func)->tt) == 6) &&
       (!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC))) {
    Proto *p = ((((void)0), (&((ci)->func)->value.gc->cl)))->l.p;
    int pc = currentpc(L, ci);
    Instruction i;
    *name = luaF_getlocalname(p, stackpos + 1, pc);
    if (*name)
      return "local";
    i = symbexec(p, pc, stackpos);
    ((void)0);
    switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))))) {
    case OP_GETGLOBAL: {
      int g = (((int)(((i) >> ((0 + 6) + 8)) &
                      ((~((~(Instruction)0) << (9 + 9))) << 0))));
      ((void)0);
      *name = ((const char *)(((((void)0), (&(&p->k[g])->value.gc->ts))) + 1));
      return "global";
    }
    case OP_MOVE: {
      int a = (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))));
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      if (b < a)
        return getobjname(L, ci, b, name);
      break;
    }
    case OP_GETTABLE: {
      int k = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      *name = kname(p, k);
      return "field";
    }
    case OP_GETUPVAL: {
      int u = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      *name = p->upvalues ? ((const char *)((p->upvalues[u]) + 1)) : "?";
      return "upvalue";
    }
    case OP_SELF: {
      int k = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      *name = kname(p, k);
      return "method";
    }
    default:
      break;
    }
  }
  return NULL;
}
static const char *getfuncname(lua_State *L, CallInfo *ci, const char **name) {
  Instruction i;
  if (((((((ci)->func)->tt) == 6) &&
        (!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC)) &&
       ci->tailcalls > 0) ||
      !(((((ci - 1)->func)->tt) == 6) &&
        (!((((void)0), (&((ci - 1)->func)->value.gc->cl)))->c.isC)))
    return NULL;
  ci--;
  i = ((((void)0), (&((ci)->func)->value.gc->cl)))->l.p->code[currentpc(L, ci)];
  if ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) ==
          OP_CALL ||
      (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) ==
          OP_TAILCALL ||
      (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) ==
          OP_TFORLOOP)
    return getobjname(
        L, ci, (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))),
        name);
  else
    return NULL;
}
static inline int isinstack(CallInfo *ci, const TValue *o) {
  StkId p;
  for (p = ci->base; p < ci->top; p++)
    if (o == p)
      return 1;
  return 0;
}
static inline void luaG_typeerror(lua_State *L, const TValue *o,
                                  const char *op) {
  const char *name = NULL;
  const char *t = luaT_typenames[((o)->tt)];
  const char *kind = (isinstack(L->ci, o))
                         ? getobjname(L, L->ci, ((int)((o - L->base))), &name)
                         : NULL;
  if (kind)
    luaG_runerror(L,
                  "attempt to %s %s "
                  "'"
                  "%s"
                  "'"
                  " (a %s value)",
                  op, kind, name, t);
  else
    luaG_runerror(L, "attempt to %s a %s value", op, t);
}
static inline void luaG_concaterror(lua_State *L, StkId p1, StkId p2) {
  if ((((p1)->tt) == 4) || (((p1)->tt) == 3))
    p1 = p2;
  ((void)0);
  luaG_typeerror(L, p1, "concatenate");
}
static inline void luaG_aritherror(lua_State *L, const TValue *p1,
                                   const TValue *p2) {
  TValue temp;
  if (luaV_tonumber(p1, &temp) == NULL)
    p2 = p1;
  luaG_typeerror(L, p2, "perform arithmetic on");
}
static inline int luaG_ordererror(lua_State *L, const TValue *p1,
                                  const TValue *p2) {
  const char *t1 = luaT_typenames[((p1)->tt)];
  const char *t2 = luaT_typenames[((p2)->tt)];
  if (t1[2] == t2[2])
    luaG_runerror(L, "attempt to compare two %s values", t1);
  else
    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
  return 0;
}
static inline void addinfo(lua_State *L, const char *msg) {
  CallInfo *ci = L->ci;
  if ((((((ci)->func)->tt) == 6) &&
       (!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC))) {
    char buff[60];
    int line = currentline(L, ci);
    luaO_chunkid(buff, ((const char *)((getluaproto(ci)->source) + 1)), 60);
    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
  }
}
static inline void luaG_errormsg(lua_State *L) {
  if (L->errfunc != 0) {
    StkId errfunc = ((TValue *)((char *)L->stack + (L->errfunc)));
    if (!(((errfunc)->tt) == 6))
      luaD_throw(L, 5);
    {
      const TValue *o2 = (L->top - 1);
      TValue *o1 = (L->top);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      const TValue *o2 = (errfunc);
      TValue *o1 = (L->top - 1);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
        luaD_growstack(L, 1);
      else
        ((void)0);
      ;
      L->top++;
    };
    luaD_call(L, L->top - 2, 1);
  }
  luaD_throw(L, 2);
}
static inline void luaG_runerror(lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  addinfo(L, luaO_pushvfstring(L, fmt, argp));
  va_end(argp);
  luaG_errormsg(L);
}
typedef enum {
  VVOID,
  VNIL,
  VTRUE,
  VFALSE,
  VK,
  VKNUM,
  VLOCAL,
  VUPVAL,
  VGLOBAL,
  VINDEXED,
  VJMP,
  VRELOCABLE,
  VNONRELOC,
  VCALL,
  VVARARG
} expkind;
typedef struct expdesc {
  expkind k;
  union {
    struct {
      int info, aux;
    } s;
    lua_Number nval;
  } u;
  int t;
  int f;
} expdesc;
typedef struct upvaldesc {
  lu_byte k;
  lu_byte info;
} upvaldesc;
struct BlockCnt;
typedef struct FuncState {
  Proto *f;
  Table *h;
  struct FuncState *prev;
  struct LexState *ls;
  struct lua_State *L;
  struct BlockCnt *bl;
  int pc;
  int lasttarget;
  int jpc;
  int freereg;
  int nk;
  int np;
  short nlocvars;
  lu_byte nactvar;
  upvaldesc upvalues[60];
  unsigned short actvar[200];
} FuncState;
struct lua_longjmp {
  struct lua_longjmp *previous;
  jmp_buf b;
  volatile int status;
};
static inline void luaD_seterrorobj(lua_State *L, int errcode, StkId oldtop) {
  switch (errcode) {
  case 4: {
    {
      TValue *i_o = (oldtop);
      i_o->value.gc = ((GCObject *)((
          (luaS_newlstr(L,
                        ""
                        "not enough memory",
                        (sizeof("not enough memory") / sizeof(char)) - 1)))));
      i_o->tt = 4;
      ((void)0);
    };
    break;
  }
  case 5: {
    {
      TValue *i_o = (oldtop);
      i_o->value.gc = ((GCObject *)(((luaS_newlstr(
          L,
          ""
          "error in error handling",
          (sizeof("error in error handling") / sizeof(char)) - 1)))));
      i_o->tt = 4;
      ((void)0);
    };
    break;
  }
  case 3:
  case 2: {
    {
      const TValue *o2 = (L->top - 1);
      TValue *o1 = (oldtop);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    break;
  }
  }
  L->top = oldtop + 1;
}
static inline void restore_stack_limit(lua_State *L) {
  ((void)0);
  if (L->size_ci > 20000) {
    int inuse = ((int)((L->ci - L->base_ci)));
    if (inuse + 1 < 20000)
      luaD_reallocCI(L, 20000);
  }
}
static inline void resetstack(lua_State *L, int status) {
  L->ci = L->base_ci;
  L->base = L->ci->base;
  luaF_close(L, L->base);
  luaD_seterrorobj(L, status, L->base);
  L->nCcalls = L->baseCcalls;
  L->allowhook = 1;
  restore_stack_limit(L);
  L->errfunc = 0;
  L->errorJmp = NULL;
}
static inline void luaD_throw(lua_State *L, int errcode) {
  if (L->errorJmp) {
    L->errorJmp->status = errcode;
    longjmp((L->errorJmp)->b, 1);
  } else {
    L->status = ((lu_byte)((errcode)));
    if ((L->l_G)->panic) {
      resetstack(L, errcode);
      ((void)0);
      (L->l_G)->panic(L);
    }
    exit(EXIT_FAILURE);
  }
}
static inline int luaD_rawrunprotected(lua_State *L, Pfunc f, void *ud) {
  struct lua_longjmp lj;
  lj.status = 0;
  lj.previous = L->errorJmp;
  L->errorJmp = &lj;
  if (setjmp((&lj)->b) == 0) {
    (*f)(L, ud);
  };
  L->errorJmp = lj.previous;
  return lj.status;
}
static inline void correctstack(lua_State *L, TValue *oldstack) {
  CallInfo *ci;
  GCObject *up;
  L->top = (L->top - oldstack) + L->stack;
  for (up = L->openupval; up != NULL; up = up->gch.next)
    (((void)0), (&((up)->uv)))->v =
        ((((void)0), (&((up)->uv)))->v - oldstack) + L->stack;
  for (ci = L->base_ci; ci <= L->ci; ci++) {
    ci->top = (ci->top - oldstack) + L->stack;
    ci->base = (ci->base - oldstack) + L->stack;
    ci->func = (ci->func - oldstack) + L->stack;
  }
  L->base = (L->base - oldstack) + L->stack;
}
static inline void luaD_reallocstack(lua_State *L, int newsize) {
  TValue *oldstack = L->stack;
  int realsize = newsize + 1 + 5;
  ((void)0);
  ((L->stack) = ((TValue *)((
       (((size_t)((realsize) + 1)) <=
        ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
           ? luaM_realloc_(L, (L->stack), (L->stacksize) * (sizeof(TValue)),
                           (realsize) * (sizeof(TValue)))
           : luaM_toobig(L)))));
  L->stacksize = realsize;
  L->stack_last = L->stack + newsize;
  correctstack(L, oldstack);
}
static inline void luaD_reallocCI(lua_State *L, int newsize) {
  CallInfo *oldci = L->base_ci;
  ((L->base_ci) = ((CallInfo *)((
       (((size_t)((newsize) + 1)) <=
        ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo)))
           ? luaM_realloc_(L, (L->base_ci), (L->size_ci) * (sizeof(CallInfo)),
                           (newsize) * (sizeof(CallInfo)))
           : luaM_toobig(L)))));
  L->size_ci = newsize;
  L->ci = (L->ci - oldci) + L->base_ci;
  L->end_ci = L->base_ci + L->size_ci - 1;
}
static inline void luaD_growstack(lua_State *L, int n) {
  if (n <= L->stacksize)
    luaD_reallocstack(L, 2 * L->stacksize);
  else
    luaD_reallocstack(L, L->stacksize + n);
}
static inline CallInfo *growCI(lua_State *L) {
  if (L->size_ci > 20000)
    luaD_throw(L, 5);
  else {
    luaD_reallocCI(L, 2 * L->size_ci);
    if (L->size_ci > 20000)
      luaG_runerror(L, "stack overflow");
  }
  return ++L->ci;
}
static inline void luaD_callhook(lua_State *L, int event, int line) {
  lua_Hook hook = L->hook;
  if (hook && L->allowhook) {
    ptrdiff_t top = ((char *)(L->top) - (char *)L->stack);
    ptrdiff_t ci_top = ((char *)(L->ci->top) - (char *)L->stack);
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    if (event == 4)
      ar.i_ci = 0;
    else
      ar.i_ci = ((int)((L->ci - L->base_ci)));
    if ((char *)L->stack_last - (char *)L->top <= (20) * (int)sizeof(TValue))
      luaD_growstack(L, 20);
    else
      ((void)0);
    ;
    L->ci->top = L->top + 20;
    ((void)0);
    L->allowhook = 0;
    ((void)0);
    (*hook)(L, &ar);
    ((void)0);
    ((void)0);
    L->allowhook = 1;
    L->ci->top = ((TValue *)((char *)L->stack + (ci_top)));
    L->top = ((TValue *)((char *)L->stack + (top)));
  }
}
static inline StkId adjust_varargs(lua_State *L, Proto *p, int actual) {
  int i;
  int nfixargs = p->numparams;
  Table *htab = NULL;
  StkId base, fixed;
  for (; actual < nfixargs; ++actual)
    ((L->top++)->tt = 0);
  if (p->is_vararg & 4) {
    int nvar = actual - nfixargs;
    ((void)0);
    {
      ((void)0);
      if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
        luaC_step(L);
    };
    if ((char *)L->stack_last - (char *)L->top <=
        (p->maxstacksize) * (int)sizeof(TValue))
      luaD_growstack(L, p->maxstacksize);
    else
      ((void)0);
    ;
    htab = luaH_new(L, nvar, 1);
    for (i = 0; i < nvar; i++) {
      const TValue *o2 = (L->top - nvar + i);
      TValue *o1 = (luaH_setnum(L, htab, i + 1));
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      TValue *i_o =
          (luaH_setstr(L, htab,
                       (luaS_newlstr(L,
                                     ""
                                     "n",
                                     (sizeof("n") / sizeof(char)) - 1))));
      i_o->value.n = (((lua_Number)((nvar))));
      i_o->tt = 3;
    };
  }
  fixed = L->top - actual;
  base = L->top;
  for (i = 0; i < nfixargs; i++) {
    {
      const TValue *o2 = (fixed + i);
      TValue *o1 = (L->top++);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    ((fixed + i)->tt = 0);
  }
  if (htab) {
    {
      TValue *i_o = (L->top++);
      i_o->value.gc = ((GCObject *)((htab)));
      i_o->tt = 5;
      ((void)0);
    };
    ((void)0);
  }
  return base;
}
static inline StkId tryfuncTM(lua_State *L, StkId func) {
  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
  StkId p;
  ptrdiff_t funcr = ((char *)(func) - (char *)L->stack);
  if (!(((tm)->tt) == 6))
    luaG_typeerror(L, func, "call");
  for (p = L->top; p > func; p--) {
    const TValue *o2 = (p - 1);
    TValue *o1 = (p);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
      luaD_growstack(L, 1);
    else
      ((void)0);
    ;
    L->top++;
  };
  func = ((TValue *)((char *)L->stack + (funcr)));
  {
    const TValue *o2 = (tm);
    TValue *o1 = (func);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  return func;
}
static inline int luaD_precall(lua_State *L, StkId func, int nresults) {
  LClosure *cl;
  ptrdiff_t funcr;
  if (!(((func)->tt) == 6))
    func = tryfuncTM(L, func);
  funcr = ((char *)(func) - (char *)L->stack);
  cl = &(((void)0), (&(func)->value.gc->cl))->l;
  L->ci->savedpc = L->savedpc;
  if (!cl->isC) {
    CallInfo *ci;
    StkId st, base;
    Proto *p = cl->p;
    if ((char *)L->stack_last - (char *)L->top <=
        (p->maxstacksize) * (int)sizeof(TValue))
      luaD_growstack(L, p->maxstacksize);
    else
      ((void)0);
    ;
    func = ((TValue *)((char *)L->stack + (funcr)));
    if (!p->is_vararg) {
      base = func + 1;
      if (L->top > base + p->numparams)
        L->top = base + p->numparams;
    } else {
      int nargs = ((int)((L->top - func))) - 1;
      base = adjust_varargs(L, p, nargs);
      func = ((TValue *)((char *)L->stack + (funcr)));
    }
    ci = ((L->ci == L->end_ci) ? growCI(L) : (((void)0), ++L->ci));
    ci->func = func;
    L->base = ci->base = base;
    ci->top = L->base + p->maxstacksize;
    ((void)0);
    L->savedpc = p->code;
    ci->tailcalls = 0;
    ci->nresults = nresults;
    for (st = L->top; st < ci->top; st++)
      ((st)->tt = 0);
    L->top = ci->top;
    if (L->hookmask & (1 << 0)) {
      L->savedpc++;
      luaD_callhook(L, 0, -1);
      L->savedpc--;
    }
    return 0;
  } else {
    CallInfo *ci;
    int n;
    if ((char *)L->stack_last - (char *)L->top <= (20) * (int)sizeof(TValue))
      luaD_growstack(L, 20);
    else
      ((void)0);
    ;
    ci = ((L->ci == L->end_ci) ? growCI(L) : (((void)0), ++L->ci));
    ci->func = ((TValue *)((char *)L->stack + (funcr)));
    L->base = ci->base = ci->func + 1;
    ci->top = L->top + 20;
    ((void)0);
    ci->nresults = nresults;
    if (L->hookmask & (1 << 0))
      luaD_callhook(L, 0, -1);
    ((void)0);
    n = (*((((void)0), (&(L->ci->func)->value.gc->cl)))->c.f)(L);
    ((void)0);
    if (n < 0)
      return 2;
    else {
      luaD_poscall(L, L->top - n);
      return 1;
    }
  }
}
static inline StkId callrethooks(lua_State *L, StkId firstResult) {
  ptrdiff_t fr = ((char *)(firstResult) - (char *)L->stack);
  luaD_callhook(L, 1, -1);
  if ((!((((void)0), (&((L->ci)->func)->value.gc->cl)))->c.isC)) {
    while ((L->hookmask & (1 << 1)) && L->ci->tailcalls--)
      luaD_callhook(L, 4, -1);
  }
  return ((TValue *)((char *)L->stack + (fr)));
}
static inline int luaD_poscall(lua_State *L, StkId firstResult) {
  StkId res;
  int wanted, i;
  CallInfo *ci;
  if (L->hookmask & (1 << 1))
    firstResult = callrethooks(L, firstResult);
  ci = L->ci--;
  res = ci->func;
  wanted = ci->nresults;
  L->base = (ci - 1)->base;
  L->savedpc = (ci - 1)->savedpc;
  for (i = wanted; i != 0 && firstResult < L->top; i--) {
    const TValue *o2 = (firstResult++);
    TValue *o1 = (res++);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  while (i-- > 0)
    ((res++)->tt = 0);
  L->top = res;
  return (wanted - (-1));
}
static inline void luaD_call(lua_State *L, StkId func, int nResults) {
  if (++L->nCcalls >= 200) {
    if (L->nCcalls == 200)
      luaG_runerror(L, "C stack overflow");
    else if (L->nCcalls >= (200 + (200 >> 3)))
      luaD_throw(L, 5);
  }
  if (luaD_precall(L, func, nResults) == 0)
    luaV_execute(L, 1);
  L->nCcalls--;
  {
    ((void)0);
    if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
      luaC_step(L);
  };
}
static inline void resume(lua_State *L, void *ud) {
  StkId firstArg = ((StkId)(ud));
  CallInfo *ci = L->ci;
  if (L->status == 0) {
    ((void)0);
    if (luaD_precall(L, firstArg - 1, (-1)) != 0)
      return;
  } else {
    ((void)0);
    L->status = 0;
    if (!(!((((void)0), (&((ci)->func)->value.gc->cl)))->c.isC)) {
      ((void)0);
      if (luaD_poscall(L, firstArg))
        L->top = L->ci->top;
    } else
      L->base = L->ci->base;
  }
  luaV_execute(L, ((int)((L->ci - L->base_ci))));
}
static inline int resume_error(lua_State *L, const char *msg) {
  L->top = L->ci->base;
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)(((luaS_newlstr(L, msg, strlen(msg))))));
    i_o->tt = 4;
    ((void)0);
  };
  {
    if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
      luaD_growstack(L, 1);
    else
      ((void)0);
    ;
    L->top++;
  };
  ((void)0);
  return 2;
}
static inline int lua_resume(lua_State *L, int nargs) {
  int status;
  ((void)0);
  if (L->status != 1 && (L->status != 0 || L->ci != L->base_ci))
    return resume_error(L, "cannot resume non-suspended coroutine");
  if (L->nCcalls >= 200)
    return resume_error(L, "C stack overflow");
  ((void)L);
  ((void)0);
  L->baseCcalls = ++L->nCcalls;
  status = luaD_rawrunprotected(L, resume, L->top - nargs);
  if (status != 0) {
    L->status = ((lu_byte)((status)));
    luaD_seterrorobj(L, status, L->top);
    L->ci->top = L->top;
  } else {
    ((void)0);
    status = L->status;
  }
  --L->nCcalls;
  ((void)0);
  return status;
}
static inline int lua_yield(lua_State *L, int nresults) {
  ((void)L);
  ((void)0);
  if (L->nCcalls > L->baseCcalls)
    luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
  L->base = L->top - nresults;
  L->status = 1;
  ((void)0);
  return -1;
}
static inline int luaD_pcall(lua_State *L, Pfunc func, void *u,
                             ptrdiff_t old_top, ptrdiff_t ef) {
  int status;
  unsigned short oldnCcalls = L->nCcalls;
  ptrdiff_t old_ci = ((char *)(L->ci) - (char *)L->base_ci);
  lu_byte old_allowhooks = L->allowhook;
  ptrdiff_t old_errfunc = L->errfunc;
  L->errfunc = ef;
  status = luaD_rawrunprotected(L, func, u);
  if (status != 0) {
    StkId oldtop = ((TValue *)((char *)L->stack + (old_top)));
    luaF_close(L, oldtop);
    luaD_seterrorobj(L, status, oldtop);
    L->nCcalls = oldnCcalls;
    L->ci = ((CallInfo *)((char *)L->base_ci + (old_ci)));
    L->base = L->ci->base;
    L->savedpc = L->ci->savedpc;
    L->allowhook = old_allowhooks;
    restore_stack_limit(L);
  }
  L->errfunc = old_errfunc;
  return status;
}
struct SParser {
  ZIO *z;
  Mbuffer buff;
  const char *name;
};
typedef struct {
  lua_State *L;
  lua_Writer writer;
  void *data;
  int strip;
  int status;
} DumpState;
static inline void DumpBlock(const void *b, size_t size, DumpState *D) {
  if (D->status == 0) {
    ((void)0);
    D->status = (*D->writer)(D->L, b, size, D->data);
    ((void)0);
  }
}
static inline void DumpChar(int y, DumpState *D) {
  char x = (char)y;
  DumpBlock(&x, (1) * (sizeof(x)), D);
}
static inline void DumpInt(int x, DumpState *D) {
  DumpBlock(&x, (1) * (sizeof(x)), D);
}
static inline void DumpNumber(lua_Number x, DumpState *D) {
  DumpBlock(&x, (1) * (sizeof(x)), D);
}
static inline void DumpVector(const void *b, int n, size_t size, DumpState *D) {
  DumpInt(n, D);
  DumpBlock(b, (n) * (size), D);
}
static inline void DumpString(const TString *s, DumpState *D) {
  if (s == NULL || ((const char *)((s) + 1)) == NULL) {
    size_t size = 0;
    DumpBlock(&size, (1) * (sizeof(size)), D);
  } else {
    size_t size = s->tsv.len + 1;
    DumpBlock(&size, (1) * (sizeof(size)), D);
    DumpBlock(((const char *)((s) + 1)), size, D);
  }
}
static inline void DumpFunction(const Proto *f, const TString *p, DumpState *D);
static inline void DumpConstants(const Proto *f, DumpState *D) {
  int i, n = f->sizek;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    const TValue *o = &f->k[i];
    DumpChar(((o)->tt), D);
    switch (((o)->tt)) {
    case 0:
      break;
    case 1:
      DumpChar((((void)0), ((o)->value.b)), D);
      break;
    case 3:
      DumpNumber((((void)0), ((o)->value.n)), D);
      break;
    case 4:
      DumpString((((void)0), (&(o)->value.gc->ts)), D);
      break;
    default:
      ((void)0);
      break;
    }
  }
  n = f->sizep;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpFunction(f->p[i], f->source, D);
}
static inline void DumpDebug(const Proto *f, DumpState *D) {
  int i, n;
  n = (D->strip) ? 0 : f->sizelineinfo;
  DumpVector(f->lineinfo, n, sizeof(int), D);
  n = (D->strip) ? 0 : f->sizelocvars;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpString(f->locvars[i].varname, D);
    DumpInt(f->locvars[i].startpc, D);
    DumpInt(f->locvars[i].endpc, D);
  }
  n = (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpString(f->upvalues[i], D);
}
static inline void DumpFunction(const Proto *f, const TString *p,
                                DumpState *D) {
  DumpString((f->source == p || D->strip) ? NULL : f->source, D);
  DumpInt(f->linedefined, D);
  DumpInt(f->lastlinedefined, D);
  DumpChar(f->nups, D);
  DumpChar(f->numparams, D);
  DumpChar(f->is_vararg, D);
  DumpChar(f->maxstacksize, D);
  DumpVector(f->code, f->sizecode, sizeof(Instruction), D);
  DumpConstants(f, D);
  DumpDebug(f, D);
}
static inline void DumpHeader(DumpState *D) {
  char h[12];
  luaU_header(h);
  DumpBlock(h, 12, D);
}
static inline int luaU_dump(lua_State *L, const Proto *f, lua_Writer w,
                            void *data, int strip) {
  DumpState D;
  D.L = L;
  D.writer = w;
  D.data = data;
  D.strip = strip;
  D.status = 0;
  DumpHeader(&D);
  DumpFunction(f, NULL, &D);
  return D.status;
}
Closure *luaF_newCclosure(lua_State *L, int nelems, Table *e) {
  Closure *c = ((Closure *)(luaM_realloc_(
      L, NULL, 0,
      ((((int)(sizeof(CClosure))) + ((int)(sizeof(TValue) * ((nelems)-1))))))));
  luaC_link(L, (((GCObject *)((c)))), 6);
  c->c.isC = 1;
  c->c.env = e;
  c->c.nupvalues = ((lu_byte)((nelems)));
  return c;
}
Closure *luaF_newLclosure(lua_State *L, int nelems, Table *e) {
  Closure *c = ((
      Closure *)(luaM_realloc_(L, NULL, 0,
                               ((((int)(sizeof(LClosure))) +
                                 ((int)(sizeof(TValue *) * ((nelems)-1))))))));
  luaC_link(L, (((GCObject *)((c)))), 6);
  c->l.isC = 0;
  c->l.env = e;
  c->l.nupvalues = ((lu_byte)((nelems)));
  while (nelems--)
    c->l.upvals[nelems] = NULL;
  return c;
}
UpVal *luaF_newupval(lua_State *L) {
  UpVal *uv = ((UpVal *)(luaM_realloc_(L, NULL, 0, (sizeof(UpVal)))));
  luaC_link(L, (((GCObject *)((uv)))), (8 + 2));
  uv->v = &uv->u.value;
  ((uv->v)->tt = 0);
  return uv;
}
UpVal *luaF_findupval(lua_State *L, StkId level) {
  global_State *g = (L->l_G);
  GCObject **pp = &L->openupval;
  UpVal *p;
  UpVal *uv;
  while (*pp != NULL && (p = (((void)0), (&((*pp)->uv))))->v >= level) {
    ((void)0);
    if (p->v == level) {
      if ((((((GCObject *)((p)))))->gch.marked &
           (g->currentwhite ^ ((1 << (0)) | (1 << (1)))) &
           ((1 << (0)) | (1 << (1)))))
        (((((GCObject *)((p)))))->gch.marked ^= ((1 << (0)) | (1 << (1))));
      return p;
    }
    pp = &p->next;
  }
  uv = ((UpVal *)(luaM_realloc_(L, NULL, 0, (sizeof(UpVal)))));
  uv->tt = (8 + 2);
  uv->marked = ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))));
  uv->v = level;
  uv->next = *pp;
  *pp = (((GCObject *)((uv))));
  uv->u.l.prev = &g->uvhead;
  uv->u.l.next = g->uvhead.u.l.next;
  uv->u.l.next->u.l.prev = uv;
  g->uvhead.u.l.next = uv;
  ((void)0);
  return uv;
}
static inline void unlinkupval(UpVal *uv) {
  ((void)0);
  uv->u.l.next->u.l.prev = uv->u.l.prev;
  uv->u.l.prev->u.l.next = uv->u.l.next;
}
static inline void luaF_freeupval(lua_State *L, UpVal *uv) {
  if (uv->v != &uv->u.value)
    unlinkupval(uv);
  luaM_realloc_(L, (uv), sizeof(*(uv)), 0);
}
static inline void luaF_close(lua_State *L, StkId level) {
  UpVal *uv;
  global_State *g = (L->l_G);
  while (L->openupval != NULL &&
         (uv = (((void)0), (&((L->openupval)->uv))))->v >= level) {
    GCObject *o = (((GCObject *)((uv))));
    ((void)0);
    L->openupval = uv->next;
    if (((o)->gch.marked & (g->currentwhite ^ ((1 << (0)) | (1 << (1)))) &
         ((1 << (0)) | (1 << (1)))))
      luaF_freeupval(L, uv);
    else {
      unlinkupval(uv);
      {
        const TValue *o2 = (uv->v);
        TValue *o1 = (&uv->u.value);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      uv->v = &uv->u.value;
      luaC_linkupval(L, uv);
    }
  }
}
Proto *luaF_newproto(lua_State *L) {
  Proto *f = ((Proto *)(luaM_realloc_(L, NULL, 0, (sizeof(Proto)))));
  luaC_link(L, (((GCObject *)((f)))), (8 + 1));
  f->k = NULL;
  f->sizek = 0;
  f->p = NULL;
  f->sizep = 0;
  f->code = NULL;
  f->sizecode = 0;
  f->sizelineinfo = 0;
  f->sizeupvalues = 0;
  f->nups = 0;
  f->upvalues = NULL;
  f->numparams = 0;
  f->is_vararg = 0;
  f->maxstacksize = 0;
  f->lineinfo = NULL;
  f->sizelocvars = 0;
  f->locvars = NULL;
  f->linedefined = 0;
  f->lastlinedefined = 0;
  f->source = NULL;
  return f;
}
static inline void luaF_freeproto(lua_State *L, Proto *f) {
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Instruction)))
       ? luaM_realloc_(L, ((f->code)), (f->sizecode) * (sizeof(Instruction)),
                       (0) * (sizeof(Instruction)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto *)))
       ? luaM_realloc_(L, ((f->p)), (f->sizep) * (sizeof(Proto *)),
                       (0) * (sizeof(Proto *)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
       ? luaM_realloc_(L, ((f->k)), (f->sizek) * (sizeof(TValue)),
                       (0) * (sizeof(TValue)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(int)))
       ? luaM_realloc_(L, ((f->lineinfo)), (f->sizelineinfo) * (sizeof(int)),
                       (0) * (sizeof(int)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(struct LocVar)))
       ? luaM_realloc_(L, ((f->locvars)),
                       (f->sizelocvars) * (sizeof(struct LocVar)),
                       (0) * (sizeof(struct LocVar)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString *)))
       ? luaM_realloc_(L, ((f->upvalues)),
                       (f->sizeupvalues) * (sizeof(TString *)),
                       (0) * (sizeof(TString *)))
       : luaM_toobig(L));
  luaM_realloc_(L, (f), sizeof(*(f)), 0);
}
static inline void luaF_freeclosure(lua_State *L, Closure *c) {
  int size = (c->c.isC) ? (((int)(sizeof(CClosure))) +
                           ((int)(sizeof(TValue) * ((c->c.nupvalues) - 1))))
                        : (((int)(sizeof(LClosure))) +
                           ((int)(sizeof(TValue *) * ((c->l.nupvalues) - 1))));
  luaM_realloc_(L, (c), (size), 0);
}
const char *luaF_getlocalname(const Proto *f, int local_number, int pc) {
  int i;
  for (i = 0; i < f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
    if (pc < f->locvars[i].endpc) {
      local_number--;
      if (local_number == 0)
        return ((const char *)((f->locvars[i].varname) + 1));
    }
  }
  return NULL;
}
static inline void removeentry(Node *n) {
  ((void)0);
  if (((((&(n)->i_key.nk))->tt) >= 4))
    ((((&(n)->i_key.nk))->tt) = ((8 + 3)));
}
static inline void reallymarkobject(global_State *g, GCObject *o) {
  ((void)0);
  (((o)->gch.marked) &= ((lu_byte)(~((((1 << (0)) | (1 << (1))))))));
  switch (o->gch.tt) {
  case 4: {
    return;
  }
  case 7: {
    Table *mt = (&(((void)0), (&((o)->u)))->uv)->metatable;
    (((o)->gch.marked) |= ((1 << (2))));
    if (mt) {
      if (((((((GCObject *)((mt)))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((GCObject *)((mt)))));
    };
    {
      if (((((((GCObject *)(((&(((void)0), (&((o)->u)))->uv)->env)))))
                ->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(
            g, (((GCObject *)(((&(((void)0), (&((o)->u)))->uv)->env)))));
    };
    return;
  }
  case (8 + 2): {
    UpVal *uv = (((void)0), (&((o)->uv)));
    {
      ((void)0);
      if ((((uv->v)->tt) >= 4) &&
          ((((((void)0), ((uv->v)->value.gc)))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((void)0), ((uv->v)->value.gc)));
    };
    if (uv->v == &uv->u.value)
      (((o)->gch.marked) |= ((1 << (2))));
    return;
  }
  case 6: {
    (((void)0), (&((o)->cl)))->c.gclist = g->gray;
    g->gray = o;
    break;
  }
  case 5: {
    (((void)0), (&((o)->h)))->gclist = g->gray;
    g->gray = o;
    break;
  }
  case 8: {
    (((void)0), (&((o)->th)))->gclist = g->gray;
    g->gray = o;
    break;
  }
  case (8 + 1): {
    (((void)0), (&((o)->p)))->gclist = g->gray;
    g->gray = o;
    break;
  }
  default:
    ((void)0);
  }
}
static inline void marktmu(global_State *g) {
  GCObject *u = g->tmudata;
  if (u) {
    do {
      u = u->gch.next;
      ((u)->gch.marked = ((lu_byte)(
           (((u)->gch.marked &
             ((lu_byte)((~((1 << (2)) | ((1 << (0)) | (1 << (1)))))))) |
            ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))))))));
      reallymarkobject(g, u);
    } while (u != g->tmudata);
  }
}
static inline size_t luaC_separateudata(lua_State *L, int all) {
  global_State *g = (L->l_G);
  size_t deadmem = 0;
  GCObject **p = &g->mainthread->next;
  GCObject *curr;
  while ((curr = *p) != NULL) {
    if (!((((curr)->gch.marked) & ((((1 << (0)) | (1 << (1)))))) || all) ||
        ((((&(((void)0), (&((curr)->u)))->uv))->marked) & ((1 << (3)))))
      p = &curr->gch.next;
    else if ((((&(((void)0), (&((curr)->u)))->uv)->metatable) == NULL
                  ? NULL
                  : (((&(((void)0), (&((curr)->u)))->uv)->metatable)->flags &
                     (1u << (TM_GC)))
                        ? NULL
                        : luaT_gettm(
                              (&(((void)0), (&((curr)->u)))->uv)->metatable,
                              TM_GC, ((L->l_G))->tmname[TM_GC])) == NULL) {
      ((((&(((void)0), (&((curr)->u)))->uv))->marked) |= ((1 << (3))));
      p = &curr->gch.next;
    } else {
      deadmem +=
          (sizeof(union Udata) + ((&(((void)0), (&((curr)->u)))->uv))->len);
      ((((&(((void)0), (&((curr)->u)))->uv))->marked) |= ((1 << (3))));
      *p = curr->gch.next;
      if (g->tmudata == NULL)
        g->tmudata = curr->gch.next = curr;
      else {
        curr->gch.next = g->tmudata->gch.next;
        g->tmudata->gch.next = curr;
        g->tmudata = curr;
      }
    }
  }
  return deadmem;
}
static inline int traversetable(global_State *g, Table *h) {
  int i;
  int weakkey = 0;
  int weakvalue = 0;
  const TValue *mode;
  if (h->metatable) {
    if (((((((GCObject *)((h->metatable)))))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((GCObject *)((h->metatable)))));
  };
  mode = ((h->metatable) == NULL
              ? NULL
              : ((h->metatable)->flags & (1u << (TM_MODE)))
                    ? NULL
                    : luaT_gettm(h->metatable, TM_MODE, (g)->tmname[TM_MODE]));
  if (mode && (((mode)->tt) == 4)) {
    weakkey =
        (strchr(((const char *)(((((void)0), (&(mode)->value.gc->ts))) + 1)),
                'k') != NULL);
    weakvalue =
        (strchr(((const char *)(((((void)0), (&(mode)->value.gc->ts))) + 1)),
                'v') != NULL);
    if (weakkey || weakvalue) {
      h->marked &= ~((1 << (3)) | (1 << (4)));
      h->marked |= ((lu_byte)(((weakkey << 3) | (weakvalue << 4))));
      h->gclist = g->weak;
      g->weak = (((GCObject *)((h))));
    }
  }
  if (weakkey && weakvalue)
    return 1;
  if (!weakvalue) {
    i = h->sizearray;
    while (i--) {
      ((void)0);
      if ((((&h->array[i])->tt) >= 4) &&
          ((((((void)0), ((&h->array[i])->value.gc)))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((void)0), ((&h->array[i])->value.gc)));
    };
  }
  i = ((1 << ((h)->lsizenode)));
  while (i--) {
    Node *n = (&(h)->node[i]);
    ((void)0);
    if (((((&(n)->i_val))->tt) == 0))
      removeentry(n);
    else {
      ((void)0);
      if (!weakkey) {
        ((void)0);
        if (((((&(n)->i_key.nk))->tt) >= 4) &&
            ((((((void)0), (((&(n)->i_key.nk))->value.gc)))->gch.marked) &
             ((((1 << (0)) | (1 << (1)))))))
          reallymarkobject(g, (((void)0), (((&(n)->i_key.nk))->value.gc)));
      };
      if (!weakvalue) {
        ((void)0);
        if (((((&(n)->i_val))->tt) >= 4) &&
            ((((((void)0), (((&(n)->i_val))->value.gc)))->gch.marked) &
             ((((1 << (0)) | (1 << (1)))))))
          reallymarkobject(g, (((void)0), (((&(n)->i_val))->value.gc)));
      };
    }
  }
  return weakkey || weakvalue;
}
static inline void traverseproto(global_State *g, Proto *f) {
  int i;
  if (f->source)
    (((f->source)->tsv.marked) &= ((lu_byte)(~((((1 << (0)) | (1 << (1))))))));
  for (i = 0; i < f->sizek; i++) {
    ((void)0);
    if ((((&f->k[i])->tt) >= 4) &&
        ((((((void)0), ((&f->k[i])->value.gc)))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((void)0), ((&f->k[i])->value.gc)));
  };
  for (i = 0; i < f->sizeupvalues; i++) {
    if (f->upvalues[i])
      (((f->upvalues[i])->tsv.marked) &=
       ((lu_byte)(~((((1 << (0)) | (1 << (1))))))));
  }
  for (i = 0; i < f->sizep; i++) {
    if (f->p[i]) {
      if (((((((GCObject *)((f->p[i])))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((GCObject *)((f->p[i])))));
    };
  }
  for (i = 0; i < f->sizelocvars; i++) {
    if (f->locvars[i].varname)
      (((f->locvars[i].varname)->tsv.marked) &=
       ((lu_byte)(~((((1 << (0)) | (1 << (1))))))));
  }
}
static inline void traverseclosure(global_State *g, Closure *cl) {
  {
    if (((((((GCObject *)((cl->c.env)))))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((GCObject *)((cl->c.env)))));
  };
  if (cl->c.isC) {
    int i;
    for (i = 0; i < cl->c.nupvalues; i++) {
      ((void)0);
      if ((((&cl->c.upvalue[i])->tt) >= 4) &&
          ((((((void)0), ((&cl->c.upvalue[i])->value.gc)))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((void)0), ((&cl->c.upvalue[i])->value.gc)));
    };
  } else {
    int i;
    ((void)0);
    {
      if (((((((GCObject *)((cl->l.p)))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((GCObject *)((cl->l.p)))));
    };
    for (i = 0; i < cl->l.nupvalues; i++) {
      if (((((((GCObject *)((cl->l.upvals[i])))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((GCObject *)((cl->l.upvals[i])))));
    };
  }
}
static inline void checkstacksizes(lua_State *L, StkId max) {
  int ci_used = ((int)((L->ci - L->base_ci)));
  int s_used = ((int)((max - L->stack)));
  if (L->size_ci > 20000)
    return;
  if (4 * ci_used < L->size_ci && 2 * 8 < L->size_ci)
    luaD_reallocCI(L, L->size_ci / 2);
  ((void)0);
  if (4 * s_used < L->stacksize && 2 * ((2 * 20) + 5) < L->stacksize)
    luaD_reallocstack(L, L->stacksize / 2);
  ((void)0);
}
static inline void traversestack(global_State *g, lua_State *l) {
  StkId o, lim;
  CallInfo *ci;
  {
    ((void)0);
    if (((((&l->l_gt))->tt) >= 4) &&
        ((((((void)0), (((&l->l_gt))->value.gc)))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((void)0), (((&l->l_gt))->value.gc)));
  };
  lim = l->top;
  for (ci = l->base_ci; ci <= l->ci; ci++) {
    ((void)0);
    if (lim < ci->top)
      lim = ci->top;
  }
  for (o = l->stack; o < l->top; o++) {
    ((void)0);
    if ((((o)->tt) >= 4) && ((((((void)0), ((o)->value.gc)))->gch.marked) &
                             ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((void)0), ((o)->value.gc)));
  };
  for (; o <= lim; o++)
    ((o)->tt = 0);
  checkstacksizes(l, lim);
}
static inline l_mem propagatemark(global_State *g) {
  GCObject *o = g->gray;
  ((void)0);
  (((o)->gch.marked) |= ((1 << (2))));
  switch (o->gch.tt) {
  case 5: {
    Table *h = (((void)0), (&((o)->h)));
    g->gray = h->gclist;
    if (traversetable(g, h))
      (((o)->gch.marked) &= ((lu_byte)(~((1 << (2))))));
    return sizeof(Table) + sizeof(TValue) * h->sizearray +
           sizeof(Node) * ((1 << ((h)->lsizenode)));
  }
  case 6: {
    Closure *cl = (((void)0), (&((o)->cl)));
    g->gray = cl->c.gclist;
    traverseclosure(g, cl);
    return (cl->c.isC) ? (((int)(sizeof(CClosure))) +
                          ((int)(sizeof(TValue) * ((cl->c.nupvalues) - 1))))
                       : (((int)(sizeof(LClosure))) +
                          ((int)(sizeof(TValue *) * ((cl->l.nupvalues) - 1))));
  }
  case 8: {
    lua_State *th = (((void)0), (&((o)->th)));
    g->gray = th->gclist;
    th->gclist = g->grayagain;
    g->grayagain = o;
    (((o)->gch.marked) &= ((lu_byte)(~((1 << (2))))));
    traversestack(g, th);
    return sizeof(lua_State) + sizeof(TValue) * th->stacksize +
           sizeof(CallInfo) * th->size_ci;
  }
  case (8 + 1): {
    Proto *p = (((void)0), (&((o)->p)));
    g->gray = p->gclist;
    traverseproto(g, p);
    return sizeof(Proto) + sizeof(Instruction) * p->sizecode +
           sizeof(Proto *) * p->sizep + sizeof(TValue) * p->sizek +
           sizeof(int) * p->sizelineinfo + sizeof(LocVar) * p->sizelocvars +
           sizeof(TString *) * p->sizeupvalues;
  }
  default:
    ((void)0);
    return 0;
  }
}
static inline size_t propagateall(global_State *g) {
  size_t m = 0;
  while (g->gray)
    m += propagatemark(g);
  return m;
}
static inline int iscleared(const TValue *o, int iskey) {
  if (!(((o)->tt) >= 4))
    return 0;
  if ((((o)->tt) == 4)) {
    ((((((void)0), (&(o)->value.gc->ts)))->tsv.marked) &=
     ((lu_byte)(~((((1 << (0)) | (1 << (1))))))));
    return 0;
  }
  return ((((((void)0), ((o)->value.gc)))->gch.marked) &
          ((((1 << (0)) | (1 << (1)))))) ||
         ((((o)->tt) == 7) &&
          (!iskey && ((((&(((void)0), (&(o)->value.gc->u))->uv))->marked) &
                      ((1 << (3))))));
}
static inline void cleartable(GCObject *l) {
  while (l) {
    Table *h = (((void)0), (&((l)->h)));
    int i = h->sizearray;
    ((void)0);
    if (((h->marked) & ((1 << (4))))) {
      while (i--) {
        TValue *o = &h->array[i];
        if (iscleared(o, 0))
          ((o)->tt = 0);
      }
    }
    i = ((1 << ((h)->lsizenode)));
    while (i--) {
      Node *n = (&(h)->node[i]);
      if (!((((&(n)->i_val))->tt) == 0) &&
          (iscleared((&(n)->i_key.tvk), 1) || iscleared((&(n)->i_val), 0))) {
        (((&(n)->i_val))->tt = 0);
        removeentry(n);
      }
    }
    l = h->gclist;
  }
}
static inline void freeobj(lua_State *L, GCObject *o) {
  switch (o->gch.tt) {
  case (8 + 1):
    luaF_freeproto(L, (((void)0), (&((o)->p))));
    break;
  case 6:
    luaF_freeclosure(L, (((void)0), (&((o)->cl))));
    break;
  case (8 + 2):
    luaF_freeupval(L, (((void)0), (&((o)->uv))));
    break;
  case 5:
    luaH_free(L, (((void)0), (&((o)->h))));
    break;
  case 8: {
    ((void)0);
    luaE_freethread(L, (((void)0), (&((o)->th))));
    break;
  }
  case 4: {
    (L->l_G)->strt.nuse--;
    luaM_realloc_(
        L, (o),
        ((sizeof(union TString) +
          (((&(((void)0), (&((o)->ts)))->tsv))->len + 1) * sizeof(char))),
        0);
    break;
  }
  case 7: {
    luaM_realloc_(
        L, (o),
        ((sizeof(union Udata) + ((&(((void)0), (&((o)->u)))->uv))->len)), 0);
    break;
  }
  default:
    ((void)0);
  }
}
static inline GCObject **sweeplist(lua_State *L, GCObject **p, lu_mem count) {
  GCObject *curr;
  global_State *g = (L->l_G);
  int deadmask = (g->currentwhite ^ ((1 << (0)) | (1 << (1))));
  while ((curr = *p) != NULL && count-- > 0) {
    if (curr->gch.tt == 8)
      sweeplist(L, &(((void)0), (&((curr)->th)))->openupval,
                ((lu_mem)(~(lu_mem)0) - 2));
    if ((curr->gch.marked ^ ((1 << (0)) | (1 << (1)))) & deadmask) {
      ((void)0);
      ((curr)->gch.marked = ((lu_byte)(
           (((curr)->gch.marked &
             ((lu_byte)((~((1 << (2)) | ((1 << (0)) | (1 << (1)))))))) |
            ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))))))));
      p = &curr->gch.next;
    } else {
      ((void)0);
      *p = curr->gch.next;
      if (curr == g->rootgc)
        g->rootgc = curr->gch.next;
      freeobj(L, curr);
    }
  }
  return p;
}
static inline void checkSizes(lua_State *L) {
  global_State *g = (L->l_G);
  if (g->strt.nuse < ((lu_int32)(g->strt.size / 4)) && g->strt.size > 32 * 2)
    luaS_resize(L, g->strt.size / 2);
  if (((&g->buff)->buffsize) > 32 * 2) {
    size_t newsize = ((&g->buff)->buffsize) / 2;
    ((((&g->buff)->buffer) = ((
          char *)(((((size_t)((newsize) + 1)) <=
                    ((size_t)(~(size_t)0) - 2) / (sizeof(char)))
                       ? luaM_realloc_(L, ((&g->buff)->buffer),
                                       ((&g->buff)->buffsize) * (sizeof(char)),
                                       (newsize) * (sizeof(char)))
                       : luaM_toobig(L))))),
     (&g->buff)->buffsize = newsize);
  }
}
static inline void GCTM(lua_State *L) {
  global_State *g = (L->l_G);
  GCObject *o = g->tmudata->gch.next;
  Udata *udata = (((void)0), (&((o)->u)));
  const TValue *tm;
  if (o == g->tmudata)
    g->tmudata = NULL;
  else
    g->tmudata->gch.next = udata->uv.next;
  udata->uv.next = g->mainthread->next;
  g->mainthread->next = o;
  ((o)->gch.marked = ((lu_byte)(
       (((o)->gch.marked &
         ((lu_byte)((~((1 << (2)) | ((1 << (0)) | (1 << (1)))))))) |
        ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))))))));
  tm = ((udata->uv.metatable) == NULL
            ? NULL
            : ((udata->uv.metatable)->flags & (1u << (TM_GC)))
                  ? NULL
                  : luaT_gettm(udata->uv.metatable, TM_GC,
                               ((L->l_G))->tmname[TM_GC]));
  if (tm != NULL) {
    lu_byte oldah = L->allowhook;
    lu_mem oldt = g->GCthreshold;
    L->allowhook = 0;
    g->GCthreshold = 2 * g->totalbytes;
    {
      const TValue *o2 = (tm);
      TValue *o1 = (L->top);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    {
      TValue *i_o = (L->top + 1);
      i_o->value.gc = ((GCObject *)((udata)));
      i_o->tt = 7;
      ((void)0);
    };
    L->top += 2;
    luaD_call(L, L->top - 2, 0);
    L->allowhook = oldah;
    g->GCthreshold = oldt;
  }
}
static inline void luaC_callGCTM(lua_State *L) {
  while ((L->l_G)->tmudata)
    GCTM(L);
}
static inline void luaC_freeall(lua_State *L) {
  global_State *g = (L->l_G);
  int i;
  g->currentwhite = ((1 << (0)) | (1 << (1))) | (1 << (6));
  sweeplist(L, &g->rootgc, ((lu_mem)(~(lu_mem)0) - 2));
  for (i = 0; i < g->strt.size; i++)
    sweeplist(L, &g->strt.hash[i], ((lu_mem)(~(lu_mem)0) - 2));
}
static inline void markmt(global_State *g) {
  int i;
  for (i = 0; i < (8 + 1); i++)
    if (g->mt[i]) {
      if (((((((GCObject *)((g->mt[i])))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((GCObject *)((g->mt[i])))));
    };
}
static inline void markroot(lua_State *L) {
  global_State *g = (L->l_G);
  g->gray = NULL;
  g->grayagain = NULL;
  g->weak = NULL;
  {
    if (((((((GCObject *)((g->mainthread)))))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((GCObject *)((g->mainthread)))));
  };
  {
    ((void)0);
    if (((((&g->mainthread->l_gt))->tt) >= 4) &&
        ((((((void)0), (((&g->mainthread->l_gt))->value.gc)))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((void)0), (((&g->mainthread->l_gt))->value.gc)));
  };
  {
    ((void)0);
    if (((((&(L->l_G)->l_registry))->tt) >= 4) &&
        ((((((void)0), (((&(L->l_G)->l_registry))->value.gc)))->gch.marked) &
         ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((void)0), (((&(L->l_G)->l_registry))->value.gc)));
  };
  markmt(g);
  g->gcstate = 1;
}
static inline void remarkupvals(global_State *g) {
  UpVal *uv;
  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
    ((void)0);
    if ((!((((((GCObject *)((uv)))))->gch.marked) & ((1 << (2)))) &&
         !((((((GCObject *)((uv)))))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))) {
      ((void)0);
      if ((((uv->v)->tt) >= 4) &&
          ((((((void)0), ((uv->v)->value.gc)))->gch.marked) &
           ((((1 << (0)) | (1 << (1)))))))
        reallymarkobject(g, (((void)0), ((uv->v)->value.gc)));
    };
  }
}
static inline void atomic(lua_State *L) {
  global_State *g = (L->l_G);
  size_t udsize;
  remarkupvals(g);
  propagateall(g);
  g->gray = g->weak;
  g->weak = NULL;
  ((void)0);
  {
    if (((((((GCObject *)((L)))))->gch.marked) & ((((1 << (0)) | (1 << (1)))))))
      reallymarkobject(g, (((GCObject *)((L)))));
  };
  markmt(g);
  propagateall(g);
  g->gray = g->grayagain;
  g->grayagain = NULL;
  propagateall(g);
  udsize = luaC_separateudata(L, 0);
  marktmu(g);
  udsize += propagateall(g);
  cleartable(g->weak);
  g->currentwhite =
      ((lu_byte)(((g->currentwhite ^ ((1 << (0)) | (1 << (1)))))));
  g->sweepstrgc = 0;
  g->sweepgc = &g->rootgc;
  g->gcstate = 2;
  g->estimate = g->totalbytes - udsize;
}
static inline l_mem singlestep(lua_State *L) {
  global_State *g = (L->l_G);
  switch (g->gcstate) {
  case 0: {
    markroot(L);
    return 0;
  }
  case 1: {
    if (g->gray)
      return propagatemark(g);
    else {
      atomic(L);
      return 0;
    }
  }
  case 2: {
    lu_mem old = g->totalbytes;
    sweeplist(L, &g->strt.hash[g->sweepstrgc++], ((lu_mem)(~(lu_mem)0) - 2));
    if (g->sweepstrgc >= g->strt.size)
      g->gcstate = 3;
    ((void)0);
    g->estimate -= old - g->totalbytes;
    return 10;
  }
  case 3: {
    lu_mem old = g->totalbytes;
    g->sweepgc = sweeplist(L, g->sweepgc, 40);
    if (*g->sweepgc == NULL) {
      checkSizes(L);
      g->gcstate = 4;
    }
    ((void)0);
    g->estimate -= old - g->totalbytes;
    return 40 * 10;
  }
  case 4: {
    if (g->tmudata) {
      GCTM(L);
      if (g->estimate > 100)
        g->estimate -= 100;
      return 100;
    } else {
      g->gcstate = 0;
      g->gcdept = 0;
      return 0;
    }
  }
  default:
    ((void)0);
    return 0;
  }
}
static inline void luaC_step(lua_State *L) {
  global_State *g = (L->l_G);
  l_mem lim = (1024u / 100) * g->gcstepmul;
  if (lim == 0)
    lim = (((lu_mem)(~(lu_mem)0) - 2) - 1) / 2;
  g->gcdept += g->totalbytes - g->GCthreshold;
  do {
    lim -= singlestep(L);
    if (g->gcstate == 0)
      break;
  } while (lim > 0);
  if (g->gcstate != 0) {
    if (g->gcdept < 1024u)
      g->GCthreshold = g->totalbytes + 1024u;
    else {
      g->gcdept -= 1024u;
      g->GCthreshold = g->totalbytes;
    }
  } else {
    (g->GCthreshold = (g->estimate / 100) * g->gcpause);
  }
}
static inline void luaC_fullgc(lua_State *L) {
  global_State *g = (L->l_G);
  if (g->gcstate <= 1) {
    g->sweepstrgc = 0;
    g->sweepgc = &g->rootgc;
    g->gray = NULL;
    g->grayagain = NULL;
    g->weak = NULL;
    g->gcstate = 2;
  }
  ((void)0);
  while (g->gcstate != 4) {
    ((void)0);
    singlestep(L);
  }
  markroot(L);
  while (g->gcstate != 0) {
    singlestep(L);
  }
  (g->GCthreshold = (g->estimate / 100) * g->gcpause);
}
static inline void luaC_barrierf(lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = (L->l_G);
  ((void)0);
  ((void)0);
  ((void)0);
  if (g->gcstate == 1)
    reallymarkobject(g, v);
  else
    ((o)->gch.marked = ((lu_byte)(
         (((o)->gch.marked &
           ((lu_byte)((~((1 << (2)) | ((1 << (0)) | (1 << (1)))))))) |
          ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))))))));
}
static inline void luaC_barrierback(lua_State *L, Table *t) {
  global_State *g = (L->l_G);
  GCObject *o = (((GCObject *)((t))));
  ((void)0);
  ((void)0);
  (((o)->gch.marked) &= ((lu_byte)(~((1 << (2))))));
  t->gclist = g->grayagain;
  g->grayagain = o;
}
static inline void luaC_link(lua_State *L, GCObject *o, lu_byte tt) {
  global_State *g = (L->l_G);
  o->gch.next = g->rootgc;
  g->rootgc = o;
  o->gch.marked = ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))));
  o->gch.tt = tt;
}
static inline void luaC_linkupval(lua_State *L, UpVal *uv) {
  global_State *g = (L->l_G);
  GCObject *o = (((GCObject *)((uv))));
  o->gch.next = g->rootgc;
  g->rootgc = o;
  if ((!(((o)->gch.marked) & ((1 << (2)))) &&
       !(((o)->gch.marked) & ((((1 << (0)) | (1 << (1)))))))) {
    if (g->gcstate == 1) {
      (((o)->gch.marked) |= ((1 << (2))));
      {
        if (((((uv->v)->tt) >= 4) &&
             ((((((void)0), ((uv->v)->value.gc)))->gch.marked) &
              ((((1 << (0)) | (1 << (1))))))) &&
            ((((((GCObject *)((uv)))))->gch.marked) & ((1 << (2)))))
          luaC_barrierf(L, (((GCObject *)((uv)))),
                        (((void)0), ((uv->v)->value.gc)));
      };
    } else {
      ((o)->gch.marked = ((lu_byte)(
           (((o)->gch.marked &
             ((lu_byte)((~((1 << (2)) | ((1 << (0)) | (1 << (1)))))))) |
            ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))))))));
      ((void)0);
    }
  }
}
static const luaL_Reg lualibs[] = {{"", luaopen_base},
                                   {"table", luaopen_table},
                                   {"string", luaopen_string},
                                   {NULL, NULL}};
static inline void luaL_openlibs(lua_State *L) {
  const luaL_Reg *lib = lualibs;
  for (; lib->func; lib++) {
    lua_pushcclosure(L, (lib->func), 0);
    lua_pushstring(L, lib->name);
    lua_call(L, 1, 0);
  }
}
static inline void *luaM_growaux_(lua_State *L, void *block, int *size,
                                  size_t size_elems, int limit,
                                  const char *errormsg) {
  void *newblock;
  int newsize;
  if (*size >= limit / 2) {
    if (*size >= limit)
      luaG_runerror(L, errormsg);
    newsize = limit;
  } else {
    newsize = (*size) * 2;
    if (newsize < 4)
      newsize = 4;
  }
  newblock =
      ((((size_t)((newsize) + 1)) <= ((size_t)(~(size_t)0) - 2) / (size_elems))
           ? luaM_realloc_(L, (block), (*size) * (size_elems),
                           (newsize) * (size_elems))
           : luaM_toobig(L));
  *size = newsize;
  return newblock;
}
static inline void *luaM_toobig(lua_State *L) {
  luaG_runerror(L, "memory allocation error: block too big");
  return NULL;
}
static inline void *luaM_realloc_(lua_State *L, void *block, size_t osize,
                                  size_t nsize) {
  global_State *g = (L->l_G);
  ((void)0);
  block = (*g->frealloc)(g->ud, block, osize, nsize);
  if (block == NULL && nsize > 0)
    luaD_throw(L, 4);
  ((void)0);
  g->totalbytes = (g->totalbytes - osize) + nsize;
  return block;
}
static const TValue luaO_nilobject_ = {{NULL}, 0};
static inline int luaO_int2fb(unsigned int x) {
  int e = 0;
  while (x >= 16) {
    x = (x + 1) >> 1;
    e++;
  }
  if (x < 8)
    return x;
  else
    return ((e + 1) << 3) | (((int)((x))) - 8);
}
static inline int luaO_fb2int(int x) {
  int e = (x >> 3) & 31;
  if (e == 0)
    return x;
  else
    return ((x & 7) + 8) << (e - 1);
}
static inline int luaO_log2(unsigned int x) {
  static const lu_byte log_2[256] = {
      0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
  int l = -1;
  while (x >= 256) {
    l += 8;
    x >>= 8;
  }
  return l + log_2[x];
}
static inline int luaO_rawequalObj(const TValue *t1, const TValue *t2) {
  if (((t1)->tt) != ((t2)->tt))
    return 0;
  else
    switch (((t1)->tt)) {
    case 0:
      return 1;
    case 3:
      return (((((void)0), ((t1)->value.n))) == ((((void)0), ((t2)->value.n))));
    case 1:
      return (((void)0), ((t1)->value.b)) == (((void)0), ((t2)->value.b));
    case 2:
      return (((void)0), ((t1)->value.p)) == (((void)0), ((t2)->value.p));
    default:
      ((void)0);
      return (((void)0), ((t1)->value.gc)) == (((void)0), ((t2)->value.gc));
    }
}
static inline int luaO_str2d(const char *s, lua_Number *result) {
  char *endptr;
  *result = strtod((s), (&endptr));
  if (endptr == s)
    return 0;
  if (*endptr == 'x' || *endptr == 'X')
    *result = ((lua_Number)((strtoul(s, &endptr, 16))));
  if (*endptr == '\0')
    return 1;
  while (user_defined_isspace(((unsigned char)(*endptr))))
    endptr++;
  if (*endptr != '\0')
    return 0;
  return 1;
}
static inline void pushstr(lua_State *L, const char *str) {
  {
    TValue *i_o = (L->top);
    i_o->value.gc = ((GCObject *)(((luaS_newlstr(L, str, strlen(str))))));
    i_o->tt = 4;
    ((void)0);
  };
  {
    if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
      luaD_growstack(L, 1);
    else
      ((void)0);
    ;
    L->top++;
  };
}
const char *luaO_pushvfstring(lua_State *L, const char *fmt, va_list argp) {
  int n = 1;
  pushstr(L, "");
  for (;;) {
    const char *e = strchr(fmt, '%');
    if (e == NULL)
      break;
    {
      TValue *i_o = (L->top);
      i_o->value.gc = ((GCObject *)((luaS_newlstr(L, fmt, e - fmt))));
      i_o->tt = 4;
      ((void)0);
    };
    {
      if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
        luaD_growstack(L, 1);
      else
        ((void)0);
      ;
      L->top++;
    };
    switch (*(e + 1)) {
    case 's': {
      const char *s = va_arg(argp, char *);
      if (s == NULL)
        s = "(null)";
      pushstr(L, s);
      break;
    }
    case 'c': {
      char buff[2];
      buff[0] = ((char)(va_arg(argp, int)));
      buff[1] = '\0';
      pushstr(L, buff);
      break;
    }
    case 'd': {
      {
        TValue *i_o = (L->top);
        i_o->value.n = (((lua_Number)((va_arg(argp, int)))));
        i_o->tt = 3;
      };
      {
        if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
          luaD_growstack(L, 1);
        else
          ((void)0);
        ;
        L->top++;
      };
      break;
    }
    case 'f': {
      {
        TValue *i_o = (L->top);
        i_o->value.n = (((lua_Number)((va_arg(argp, l_uacNumber)))));
        i_o->tt = 3;
      };
      {
        if ((char *)L->stack_last - (char *)L->top <= (1) * (int)sizeof(TValue))
          luaD_growstack(L, 1);
        else
          ((void)0);
        ;
        L->top++;
      };
      break;
    }
    case 'p': {
      char buff[4 * sizeof(void *) + 8];
      sprintf(buff, "%p", va_arg(argp, void *));
      pushstr(L, buff);
      break;
    }
    case '%': {
      pushstr(L, "%");
      break;
    }
    default: {
      char buff[3];
      buff[0] = '%';
      buff[1] = *(e + 1);
      buff[2] = '\0';
      pushstr(L, buff);
      break;
    }
    }
    n += 2;
    fmt = e + 2;
  }
  pushstr(L, fmt);
  luaV_concat(L, n + 1, ((int)((L->top - L->base))) - 1);
  L->top -= n;
  return ((const char *)(((((void)0), (&(L->top - 1)->value.gc->ts))) + 1));
}
const char *luaO_pushfstring(lua_State *L, const char *fmt, ...) {
  const char *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  return msg;
}
static inline void luaO_chunkid(char *out, const char *source, size_t bufflen) {
  if (*source == '=') {
    strncpy(out, source + 1, bufflen);
    out[bufflen - 1] = '\0';
  } else {
    if (*source == '@') {
      size_t l;
      source++;
      bufflen -= sizeof(" '...' ");
      l = strlen(source);
      strcpy(out, "");
      if (l > bufflen) {
        source += (l - bufflen);
        strcat(out, "...");
      }
      strcat(out, source);
    } else {
      size_t len = strcspn(source, "\n\r");
      bufflen -= sizeof(" [string \"...\"] ");
      if (len > bufflen)
        len = bufflen;
      strcpy(out, "[string \"");
      if (source[len] != '\0') {
        strncat(out, source, len);
        strcat(out, "...");
      } else
        strcat(out, source);
      strcat(out, "\"]");
    }
  }
}
static const char *const luaP_opnames[(((int)(OP_VARARG)) + 1) + 1] = {
    "MOVE",     "LOADK",     "LOADBOOL", "LOADNIL",  "GETUPVAL", "GETGLOBAL",
    "GETTABLE", "SETGLOBAL", "SETUPVAL", "SETTABLE", "NEWTABLE", "SELF",
    "ADD",      "SUB",       "MUL",      "DIV",      "MOD",      "POW",
    "UNM",      "NOT",       "LEN",      "CONCAT",   "JMP",      "EQ",
    "LT",       "LE",        "TEST",     "TESTSET",  "CALL",     "TAILCALL",
    "RETURN",   "FORLOOP",   "FORPREP",  "TFORLOOP", "SETLIST",  "CLOSE",
    "CLOSURE",  "VARARG",    NULL};
static const lu_byte luaP_opmodes[(((int)(OP_VARARG)) + 1)] = {
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),
    (((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgR) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),
    (((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),
    (((1) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgU) << 2) | (iABC)),
    (((1) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),
    (((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),
    (((1) << 7) | ((0) << 6) | ((OpArgN) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),
    (((0) << 7) | ((0) << 6) | ((OpArgN) << 4) | ((OpArgN) << 2) | (iABC)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABx)),
    (((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC))};
typedef struct LG {
  lua_State l;
  global_State g;
} LG;
static inline void stack_init(lua_State *L1, lua_State *L) {
  L1->base_ci = ((CallInfo *)((
      (((size_t)((8) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo)))
          ? luaM_realloc_(L, (NULL), (0) * (sizeof(CallInfo)),
                          (8) * (sizeof(CallInfo)))
          : luaM_toobig(L))));
  L1->ci = L1->base_ci;
  L1->size_ci = 8;
  L1->end_ci = L1->base_ci + L1->size_ci - 1;
  L1->stack =
      ((TValue *)(((((size_t)(((2 * 20) + 5) + 1)) <=
                    ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
                       ? luaM_realloc_(L, (NULL), (0) * (sizeof(TValue)),
                                       ((2 * 20) + 5) * (sizeof(TValue)))
                       : luaM_toobig(L))));
  L1->stacksize = (2 * 20) + 5;
  L1->top = L1->stack;
  L1->stack_last = L1->stack + (L1->stacksize - 5) - 1;
  L1->ci->func = L1->top;
  ((L1->top++)->tt = 0);
  L1->base = L1->ci->base = L1->top;
  L1->ci->top = L1->top + 20;
}
static inline void freestack(lua_State *L, lua_State *L1) {
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo)))
       ? luaM_realloc_(L, ((L1->base_ci)), (L1->size_ci) * (sizeof(CallInfo)),
                       (0) * (sizeof(CallInfo)))
       : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
       ? luaM_realloc_(L, ((L1->stack)), (L1->stacksize) * (sizeof(TValue)),
                       (0) * (sizeof(TValue)))
       : luaM_toobig(L));
}
static inline void f_luaopen(lua_State *L, void *ud) {
  global_State *g = (L->l_G);
  ((void)(ud));
  stack_init(L, L);
  {
    TValue *i_o = ((&L->l_gt));
    i_o->value.gc = ((GCObject *)((luaH_new(L, 0, 2))));
    i_o->tt = 5;
    ((void)0);
  };
  {
    TValue *i_o = ((&(L->l_G)->l_registry));
    i_o->value.gc = ((GCObject *)((luaH_new(L, 0, 2))));
    i_o->tt = 5;
    ((void)0);
  };
  luaS_resize(L, 32);
  luaT_init(L);
  ((((luaS_newlstr(L,
                   ""
                   "not enough memory",
                   (sizeof("not enough memory") / sizeof(char)) - 1)))
        ->tsv.marked) |= ((1 << (5))));
  g->GCthreshold = 4 * g->totalbytes;
}
static inline void preinit_state(lua_State *L, global_State *g) {
  (L->l_G) = g;
  L->stack = NULL;
  L->stacksize = 0;
  L->errorJmp = NULL;
  L->hook = NULL;
  L->hookmask = 0;
  L->basehookcount = 0;
  L->allowhook = 1;
  (L->hookcount = L->basehookcount);
  L->openupval = NULL;
  L->size_ci = 0;
  L->nCcalls = L->baseCcalls = 0;
  L->status = 0;
  L->base_ci = L->ci = NULL;
  L->savedpc = NULL;
  L->errfunc = 0;
  (((&L->l_gt))->tt = 0);
}
static inline void close_state(lua_State *L) {
  global_State *g = (L->l_G);
  luaF_close(L, L->stack);
  luaC_freeall(L);
  ((void)0);
  ((void)0);
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString *)))
       ? luaM_realloc_(L, (((L->l_G)->strt.hash)),
                       ((L->l_G)->strt.size) * (sizeof(TString *)),
                       (0) * (sizeof(TString *)))
       : luaM_toobig(L));
  ((((&g->buff)->buffer) = ((char *)((
        (((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(char)))
            ? luaM_realloc_(L, ((&g->buff)->buffer),
                            ((&g->buff)->buffsize) * (sizeof(char)),
                            (0) * (sizeof(char)))
            : luaM_toobig(L))))),
   (&g->buff)->buffsize = 0);
  freestack(L, L);
  ((void)0);
  (*g->frealloc)(g->ud, (((lu_byte *)((L))) - 0), (sizeof(LG) + 0), 0);
}
static inline lua_State *luaE_newthread(lua_State *L) {
  lua_State *L1 = (((lua_State *)(((lu_byte *)(luaM_realloc_(
                                      L, NULL, 0, ((sizeof(lua_State) + 0))))) +
                                  0)));
  luaC_link(L, (((GCObject *)((L1)))), 8);
  preinit_state(L1, (L->l_G));
  stack_init(L1, L);
  {
    const TValue *o2 = ((&L->l_gt));
    TValue *o1 = ((&L1->l_gt));
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  L1->hookmask = L->hookmask;
  L1->basehookcount = L->basehookcount;
  L1->hook = L->hook;
  (L1->hookcount = L1->basehookcount);
  ((void)0);
  return L1;
}
static inline void luaE_freethread(lua_State *L, lua_State *L1) {
  luaF_close(L1, L1->stack);
  ((void)0);
  ((void)L1);
  freestack(L, L1);
  luaM_realloc_(L, ((((lu_byte *)((L1))) - 0)), ((sizeof(lua_State) + 0)), 0);
}
static inline lua_State *lua_newstate(lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  void *l = (*f)(ud, NULL, 0, (sizeof(LG) + 0));
  if (l == NULL)
    return NULL;
  L = (((lua_State *)(((lu_byte *)(l)) + 0)));
  g = &((LG *)L)->g;
  L->next = NULL;
  L->tt = 8;
  g->currentwhite = ((1 << (0)) | (1 << (5)));
  L->marked = ((lu_byte)((g)->currentwhite & ((1 << (0)) | (1 << (1)))));
  ((L->marked) |= ((((1 << (5)) | (1 << (6))))));
  preinit_state(L, g);
  g->frealloc = f;
  g->ud = ud;
  g->mainthread = L;
  g->uvhead.u.l.prev = &g->uvhead;
  g->uvhead.u.l.next = &g->uvhead;
  g->GCthreshold = 0;
  g->strt.size = 0;
  g->strt.nuse = 0;
  g->strt.hash = NULL;
  (((&(L->l_G)->l_registry))->tt = 0);
  ((&g->buff)->buffer = NULL, (&g->buff)->buffsize = 0);
  g->panic = NULL;
  g->gcstate = 0;
  g->rootgc = (((GCObject *)((L))));
  g->sweepstrgc = 0;
  g->sweepgc = &g->rootgc;
  g->gray = NULL;
  g->grayagain = NULL;
  g->weak = NULL;
  g->tmudata = NULL;
  g->totalbytes = sizeof(LG);
  g->gcpause = 200;
  g->gcstepmul = 200;
  g->gcdept = 0;
  for (i = 0; i < (8 + 1); i++)
    g->mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
    close_state(L);
    L = NULL;
  } else
    ((void)L);
  return L;
}
static inline void callallgcTM(lua_State *L, void *ud) {
  ((void)(ud));
  luaC_callGCTM(L);
}
static inline void lua_close(lua_State *L) {
  L = (L->l_G)->mainthread;
  ((void)0);
  luaF_close(L, L->stack);
  luaC_separateudata(L, 1);
  L->errfunc = 0;
  do {
    L->ci = L->base_ci;
    L->base = L->top = L->ci->base;
    L->nCcalls = L->baseCcalls = 0;
  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
  ((void)0);
  ((void)L);
  close_state(L);
}
static inline void luaS_resize(lua_State *L, int newsize) {
  GCObject **newhash;
  stringtable *tb;
  int i;
  if ((L->l_G)->gcstate == 2)
    return;
  newhash =
      ((GCObject **)(((((size_t)((newsize) + 1)) <=
                       ((size_t)(~(size_t)0) - 2) / (sizeof(GCObject *)))
                          ? luaM_realloc_(L, (NULL), (0) * (sizeof(GCObject *)),
                                          (newsize) * (sizeof(GCObject *)))
                          : luaM_toobig(L))));
  tb = &(L->l_G)->strt;
  for (i = 0; i < newsize; i++)
    newhash[i] = NULL;
  for (i = 0; i < tb->size; i++) {
    GCObject *p = tb->hash[i];
    while (p) {
      GCObject *next = p->gch.next;
      unsigned int h = (&(((void)0), (&((p)->ts)))->tsv)->hash;
      int h1 = ((((void)0), ((((int)((h) & ((newsize)-1)))))));
      ((void)0);
      p->gch.next = newhash[h1];
      newhash[h1] = p;
      p = next;
    }
  }
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString *)))
       ? luaM_realloc_(L, ((tb->hash)), (tb->size) * (sizeof(TString *)),
                       (0) * (sizeof(TString *)))
       : luaM_toobig(L));
  tb->size = newsize;
  tb->hash = newhash;
}
static inline TString *newlstr(lua_State *L, const char *str, size_t l,
                               unsigned int h) {
  TString *ts;
  stringtable *tb;
  if (l + 1 > (((size_t)(~(size_t)0) - 2) - sizeof(TString)) / sizeof(char))
    luaM_toobig(L);
  ts = ((TString *)(luaM_realloc_(L, NULL, 0,
                                  ((l + 1) * sizeof(char) + sizeof(TString)))));
  ts->tsv.len = l;
  ts->tsv.hash = h;
  ts->tsv.marked =
      ((lu_byte)(((L->l_G))->currentwhite & ((1 << (0)) | (1 << (1)))));
  ts->tsv.tt = 4;
  ts->tsv.reserved = 0;
  memcpy(ts + 1, str, l * sizeof(char));
  ((char *)(ts + 1))[l] = '\0';
  tb = &(L->l_G)->strt;
  h = ((((void)0), ((((int)((h) & ((tb->size) - 1)))))));
  ts->tsv.next = tb->hash[h];
  tb->hash[h] = (((GCObject *)((ts))));
  tb->nuse++;
  if (tb->nuse > ((lu_int32)(tb->size)) && tb->size <= (INT_MAX - 2) / 2)
    luaS_resize(L, tb->size * 2);
  return ts;
}
TString *luaS_newlstr(lua_State *L, const char *str, size_t l) {
  GCObject *o;
  unsigned int h = ((unsigned int)(l));
  size_t step = (l >> 5) + 1;
  size_t l1;
  for (l1 = l; l1 >= step; l1 -= step)
    h = h ^ ((h << 5) + (h >> 2) + ((unsigned char)(str[l1 - 1])));
  for (o = (L->l_G)->strt.hash[(
           (((void)0), ((((int)((h) & (((L->l_G)->strt.size) - 1)))))))];
       o != NULL; o = o->gch.next) {
    TString *ts = (((void)0), (&((o)->ts)));
    if (ts->tsv.len == l && (memcmp(str, ((const char *)((ts) + 1)), l) == 0)) {
      if (((o)->gch.marked &
           ((L->l_G)->currentwhite ^ ((1 << (0)) | (1 << (1)))) &
           ((1 << (0)) | (1 << (1)))))
        ((o)->gch.marked ^= ((1 << (0)) | (1 << (1))));
      return ts;
    }
  }
  return newlstr(L, str, l, h);
}
Udata *luaS_newudata(lua_State *L, size_t s, Table *e) {
  Udata *u;
  if (s > ((size_t)(~(size_t)0) - 2) - sizeof(Udata))
    luaM_toobig(L);
  u = ((Udata *)(luaM_realloc_(L, NULL, 0, (s + sizeof(Udata)))));
  u->uv.marked =
      ((lu_byte)(((L->l_G))->currentwhite & ((1 << (0)) | (1 << (1)))));
  u->uv.tt = 7;
  u->uv.len = s;
  u->uv.metatable = NULL;
  u->uv.env = e;
  u->uv.next = (L->l_G)->mainthread->next;
  (L->l_G)->mainthread->next = (((GCObject *)((u))));
  return u;
}
static inline int str_len(lua_State *L) {
  size_t l;
  luaL_checklstring(L, 1, &l);
  lua_pushinteger(L, l);
  return 1;
}
static inline ptrdiff_t posrelat(ptrdiff_t pos, size_t len) {
  if (pos < 0)
    pos += (ptrdiff_t)len + 1;
  return (pos >= 0) ? pos : 0;
}
static inline int str_sub(lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
  ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
  if (start < 1)
    start = 1;
  if (end > (ptrdiff_t)l)
    end = (ptrdiff_t)l;
  if (start <= end)
    lua_pushlstring(L, s + start - 1, end - start + 1);
  else
    lua_pushlstring(L,
                    ""
                    "",
                    (sizeof("") / sizeof(char)) - 1);
  return 1;
}
static inline int str_byte(lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
  ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
  int n, i;
  if (posi <= 0)
    posi = 1;
  if ((size_t)pose > l)
    pose = l;
  if (posi > pose)
    return 0;
  n = (int)(pose - posi + 1);
  if (posi + n <= pose)
    luaL_error(L, "string slice too long");
  luaL_checkstack(L, n, "string slice too long");
  for (i = 0; i < n; i++)
    lua_pushinteger(L, ((unsigned char)(s[posi + i - 1])));
  return n;
}
static const luaL_Reg strlib[] = {
    {"byte", str_byte}, {"len", str_len}, {"sub", str_sub}, {NULL, NULL}};
static inline void createmetatable(lua_State *L) {
  lua_createtable(L, 0, 1);
  lua_pushlstring(L,
                  ""
                  "",
                  (sizeof("") / sizeof(char)) - 1);
  lua_pushvalue(L, -2);
  lua_setmetatable(L, -2);
  lua_settop(L, -(1) - 1);
  lua_pushvalue(L, -2);
  lua_setfield(L, -2, "__index");
  lua_settop(L, -(1) - 1);
}
static inline int luaopen_string(lua_State *L) {
  luaL_register(L, "string", strlib);
  createmetatable(L);
  return 1;
}
static const Node dummynode_ = {{{NULL}, 0}, {{{NULL}, 0, NULL}}};
static inline Node *hashnum(const Table *t, lua_Number n) {
  unsigned int a[((int)((sizeof(lua_Number) / sizeof(int))))];
  int i;
  if (((n) == (0)))
    return (&(t)->node[0]);
  memcpy(a, &n, sizeof(a));
  for (i = 1; i < ((int)((sizeof(lua_Number) / sizeof(int)))); i++)
    a[0] += a[i];
  return ((&(t)->node[((a[0]) % ((((1 << ((t)->lsizenode))) - 1) | 1))]));
}
static inline Node *mainposition(const Table *t, const TValue *key) {
  switch (((key)->tt)) {
  case 3:
    return hashnum(t, (((void)0), ((key)->value.n)));
  case 4:
    return ((&(t)->node[(
        (((void)0),
         ((((int)(((((((void)0), (&(key)->value.gc->ts)))->tsv.hash)) &
                  ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case 1:
    return ((&(t)->node[(
        (((void)0), ((((int)((((((void)0), ((key)->value.b)))) &
                             ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  case 2:
    return (
        (&(t)->node[((((unsigned int)(lu_mem)((((void)0), ((key)->value.p))))) %
                     ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  default:
    return ((
        &(t)->node[((((unsigned int)(lu_mem)((((void)0), ((key)->value.gc))))) %
                    ((((1 << ((t)->lsizenode))) - 1) | 1))]));
  }
}
static inline int arrayindex(const TValue *key) {
  if ((((key)->tt) == 3)) {
    lua_Number n = (((void)0), ((key)->value.n));
    int k;
    ((k) = (int)(n));
    if (((((lua_Number)((k)))) == (n)))
      return k;
  }
  return -1;
}
static inline int findindex(lua_State *L, Table *t, StkId key) {
  int i;
  if ((((key)->tt) == 0))
    return -1;
  i = arrayindex(key);
  if (0 < i && i <= t->sizearray)
    return i - 1;
  else {
    Node *n = mainposition(t, key);
    do {
      if (luaO_rawequalObj((&(n)->i_key.tvk), key) ||
          ((((&(n)->i_key.nk))->tt) == (8 + 3) && (((key)->tt) >= 4) &&
           (((void)0), (((&(n)->i_key.nk))->value.gc)) ==
               (((void)0), ((key)->value.gc)))) {
        i = ((int)((n - (&(t)->node[0]))));
        return i + t->sizearray;
      } else
        n = ((n)->i_key.nk.next);
    } while (n);
    luaG_runerror(L, "invalid key to "
                     "'"
                     "next"
                     "'");
    return 0;
  }
}
static inline int luaH_next(lua_State *L, Table *t, StkId key) {
  int i = findindex(L, t, key);
  for (i++; i < t->sizearray; i++) {
    if (!(((&t->array[i])->tt) == 0)) {
      {
        TValue *i_o = (key);
        i_o->value.n = (((lua_Number)((i + 1))));
        i_o->tt = 3;
      };
      {
        const TValue *o2 = (&t->array[i]);
        TValue *o1 = (key + 1);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      return 1;
    }
  }
  for (i -= t->sizearray; i < ((1 << ((t)->lsizenode))); i++) {
    if (!((((&((&(t)->node[i]))->i_val))->tt) == 0)) {
      {
        const TValue *o2 = ((&((&(t)->node[i]))->i_key.tvk));
        TValue *o1 = (key);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      {
        const TValue *o2 = ((&((&(t)->node[i]))->i_val));
        TValue *o1 = (key + 1);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      return 1;
    }
  }
  return 0;
}
static inline int computesizes(int nums[], int *narray) {
  int i;
  int twotoi;
  int a = 0;
  int na = 0;
  int n = 0;
  for (i = 0, twotoi = 1; twotoi / 2 < *narray; i++, twotoi *= 2) {
    if (nums[i] > 0) {
      a += nums[i];
      if (a > twotoi / 2) {
        n = twotoi;
        na = a;
      }
    }
    if (a == *narray)
      break;
  }
  *narray = n;
  ((void)0);
  return na;
}
static inline int countint(const TValue *key, int *nums) {
  int k = arrayindex(key);
  if (0 < k && k <= (1 << (16 - 2))) {
    nums[(luaO_log2((k)-1) + 1)]++;
    return 1;
  } else
    return 0;
}
static inline int numusearray(const Table *t, int *nums) {
  int lg;
  int ttlg;
  int ause = 0;
  int i = 1;
  for (lg = 0, ttlg = 1; lg <= (16 - 2); lg++, ttlg *= 2) {
    int lc = 0;
    int lim = ttlg;
    if (lim > t->sizearray) {
      lim = t->sizearray;
      if (i > lim)
        break;
    }
    for (; i <= lim; i++) {
      if (!(((&t->array[i - 1])->tt) == 0))
        lc++;
    }
    nums[lg] += lc;
    ause += lc;
  }
  return ause;
}
static inline int numusehash(const Table *t, int *nums, int *pnasize) {
  int totaluse = 0;
  int ause = 0;
  int i = ((1 << ((t)->lsizenode)));
  while (i--) {
    Node *n = &t->node[i];
    if (!((((&(n)->i_val))->tt) == 0)) {
      ause += countint((&(n)->i_key.tvk), nums);
      totaluse++;
    }
  }
  *pnasize += ause;
  return totaluse;
}
static inline void setarrayvector(lua_State *L, Table *t, int size) {
  int i;
  ((t->array) = ((TValue *)((
       (((size_t)((size) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
           ? luaM_realloc_(L, (t->array), (t->sizearray) * (sizeof(TValue)),
                           (size) * (sizeof(TValue)))
           : luaM_toobig(L)))));
  for (i = t->sizearray; i < size; i++)
    ((&t->array[i])->tt = 0);
  t->sizearray = size;
}
static inline void setnodevector(lua_State *L, Table *t, int size) {
  int lsize;
  if (size == 0) {
    t->node = ((Node *)((&dummynode_)));
    lsize = 0;
  } else {
    int i;
    lsize = (luaO_log2((size)-1) + 1);
    if (lsize > (16 - 2))
      luaG_runerror(L, "table overflow");
    size = (1 << (lsize));
    t->node = ((Node *)((
        (((size_t)((size) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node)))
            ? luaM_realloc_(L, (NULL), (0) * (sizeof(Node)),
                            (size) * (sizeof(Node)))
            : luaM_toobig(L))));
    for (i = 0; i < size; i++) {
      Node *n = (&(t)->node[i]);
      ((n)->i_key.nk.next) = NULL;
      (((&(n)->i_key.nk))->tt = 0);
      (((&(n)->i_val))->tt = 0);
    }
  }
  t->lsizenode = ((lu_byte)((lsize)));
  t->lastfree = (&(t)->node[size]);
}
static inline void resize(lua_State *L, Table *t, int nasize, int nhsize) {
  int i;
  int oldasize = t->sizearray;
  int oldhsize = t->lsizenode;
  Node *nold = t->node;
  if (nasize > oldasize)
    setarrayvector(L, t, nasize);
  setnodevector(L, t, nhsize);
  if (nasize < oldasize) {
    t->sizearray = nasize;
    for (i = nasize; i < oldasize; i++) {
      if (!(((&t->array[i])->tt) == 0)) {
        const TValue *o2 = (&t->array[i]);
        TValue *o1 = (luaH_setnum(L, t, i + 1));
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
    }
    ((t->array) = ((TValue *)((
         (((size_t)((nasize) + 1)) <=
          ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
             ? luaM_realloc_(L, (t->array), (oldasize) * (sizeof(TValue)),
                             (nasize) * (sizeof(TValue)))
             : luaM_toobig(L)))));
  }
  for (i = (1 << (oldhsize)) - 1; i >= 0; i--) {
    Node *old = nold + i;
    if (!((((&(old)->i_val))->tt) == 0)) {
      const TValue *o2 = ((&(old)->i_val));
      TValue *o1 = (luaH_set(L, t, (&(old)->i_key.tvk)));
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
  }
  if (nold != (&dummynode_))
    ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node)))
         ? luaM_realloc_(L, ((nold)), ((1 << (oldhsize))) * (sizeof(Node)),
                         (0) * (sizeof(Node)))
         : luaM_toobig(L));
}
static inline void luaH_resizearray(lua_State *L, Table *t, int nasize) {
  int nsize = (t->node == (&dummynode_)) ? 0 : ((1 << ((t)->lsizenode)));
  resize(L, t, nasize, nsize);
}
static inline void rehash(lua_State *L, Table *t, const TValue *ek) {
  int nasize, na;
  int nums[(16 - 2) + 1];
  int i;
  int totaluse;
  for (i = 0; i <= (16 - 2); i++)
    nums[i] = 0;
  nasize = numusearray(t, nums);
  totaluse = nasize;
  totaluse += numusehash(t, nums, &nasize);
  nasize += countint(ek, nums);
  totaluse++;
  na = computesizes(nums, &nasize);
  resize(L, t, nasize, totaluse - na);
}
Table *luaH_new(lua_State *L, int narray, int nhash) {
  Table *t = ((Table *)(luaM_realloc_(L, NULL, 0, (sizeof(Table)))));
  luaC_link(L, (((GCObject *)((t)))), 5);
  t->metatable = NULL;
  t->flags = ((lu_byte)((~0)));
  t->array = NULL;
  t->sizearray = 0;
  t->lsizenode = 0;
  t->node = ((Node *)((&dummynode_)));
  setarrayvector(L, t, narray);
  setnodevector(L, t, nhash);
  return t;
}
static inline void luaH_free(lua_State *L, Table *t) {
  if (t->node != (&dummynode_))
    ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node)))
         ? luaM_realloc_(L, ((t->node)),
                         (((1 << ((t)->lsizenode)))) * (sizeof(Node)),
                         (0) * (sizeof(Node)))
         : luaM_toobig(L));
  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
       ? luaM_realloc_(L, ((t->array)), (t->sizearray) * (sizeof(TValue)),
                       (0) * (sizeof(TValue)))
       : luaM_toobig(L));
  luaM_realloc_(L, (t), sizeof(*(t)), 0);
}
static inline Node *getfreepos(Table *t) {
  while (t->lastfree-- > t->node) {
    if (((((&(t->lastfree)->i_key.nk))->tt) == 0))
      return t->lastfree;
  }
  return NULL;
}
static inline TValue *newkey(lua_State *L, Table *t, const TValue *key) {
  Node *mp = mainposition(t, key);
  if (!((((&(mp)->i_val))->tt) == 0) || mp == (&dummynode_)) {
    Node *othern;
    Node *n = getfreepos(t);
    if (n == NULL) {
      rehash(L, t, key);
      return luaH_set(L, t, key);
    }
    ((void)0);
    othern = mainposition(t, (&(mp)->i_key.tvk));
    if (othern != mp) {
      while (((othern)->i_key.nk.next) != mp)
        othern = ((othern)->i_key.nk.next);
      ((othern)->i_key.nk.next) = n;
      *n = *mp;
      ((mp)->i_key.nk.next) = NULL;
      (((&(mp)->i_val))->tt = 0);
    } else {
      ((n)->i_key.nk.next) = ((mp)->i_key.nk.next);
      ((mp)->i_key.nk.next) = n;
      mp = n;
    }
  }
  (&(mp)->i_key.nk)->value = key->value;
  (&(mp)->i_key.nk)->tt = key->tt;
  {
    if (((((key)->tt) >= 4) && ((((((void)0), ((key)->value.gc)))->gch.marked) &
                                ((((1 << (0)) | (1 << (1))))))) &&
        ((((((GCObject *)((t)))))->gch.marked) & ((1 << (2)))))
      luaC_barrierback(L, t);
  };
  ((void)0);
  return (&(mp)->i_val);
}
const TValue *luaH_getnum(Table *t, int key) {
  if (((unsigned int)(key - 1)) < ((unsigned int)(t->sizearray)))
    return &t->array[key - 1];
  else {
    lua_Number nk = ((lua_Number)((key)));
    Node *n = hashnum(t, nk);
    do {
      if (((((&(n)->i_key.nk))->tt) == 3) &&
          (((((void)0), (((&(n)->i_key.nk))->value.n))) == (nk)))
        return (&(n)->i_val);
      else
        n = ((n)->i_key.nk.next);
    } while (n);
    return (&luaO_nilobject_);
  }
}
const TValue *luaH_getstr(Table *t, TString *key) {
  Node *n = ((&(t)->node[((
      ((void)0),
      ((((int)((((key)->tsv.hash)) & ((((1 << ((t)->lsizenode)))) - 1)))))))]));
  do {
    if (((((&(n)->i_key.nk))->tt) == 4) &&
        (((void)0), (&((&(n)->i_key.nk))->value.gc->ts)) == key)
      return (&(n)->i_val);
    else
      n = ((n)->i_key.nk.next);
  } while (n);
  return (&luaO_nilobject_);
}
const TValue *luaH_get(Table *t, const TValue *key) {
  switch (((key)->tt)) {
  case 0:
    return (&luaO_nilobject_);
  case 4:
    return luaH_getstr(t, (((void)0), (&(key)->value.gc->ts)));
  case 3: {
    int k;
    lua_Number n = (((void)0), ((key)->value.n));
    ((k) = (int)(n));
    if (((((lua_Number)((k)))) == ((((void)0), ((key)->value.n)))))
      return luaH_getnum(t, k);
  }
  default: {
    Node *n = mainposition(t, key);
    do {
      if (luaO_rawequalObj((&(n)->i_key.tvk), key))
        return (&(n)->i_val);
      else
        n = ((n)->i_key.nk.next);
    } while (n);
    return (&luaO_nilobject_);
  }
  }
}
TValue *luaH_set(lua_State *L, Table *t, const TValue *key) {
  const TValue *p = luaH_get(t, key);
  t->flags = 0;
  if (p != (&luaO_nilobject_))
    return ((TValue *)(p));
  else {
    if ((((key)->tt) == 0))
      luaG_runerror(L, "table index is nil");
    else if ((((key)->tt) == 3) && (!((((((void)0), ((key)->value.n)))) ==
                                      (((((void)0), ((key)->value.n)))))))
      luaG_runerror(L, "table index is NaN");
    return newkey(L, t, key);
  }
}
TValue *luaH_setnum(lua_State *L, Table *t, int key) {
  const TValue *p = luaH_getnum(t, key);
  if (p != (&luaO_nilobject_))
    return ((TValue *)(p));
  else {
    TValue k;
    {
      TValue *i_o = (&k);
      i_o->value.n = (((lua_Number)((key))));
      i_o->tt = 3;
    };
    return newkey(L, t, &k);
  }
}
TValue *luaH_setstr(lua_State *L, Table *t, TString *key) {
  const TValue *p = luaH_getstr(t, key);
  if (p != (&luaO_nilobject_))
    return ((TValue *)(p));
  else {
    TValue k;
    {
      TValue *i_o = (&k);
      i_o->value.gc = ((GCObject *)((key)));
      i_o->tt = 4;
      ((void)0);
    };
    return newkey(L, t, &k);
  }
}
static inline int unbound_search(Table *t, unsigned int j) {
  unsigned int i = j;
  j++;
  while (!(((luaH_getnum(t, j))->tt) == 0)) {
    i = j;
    j *= 2;
    if (j > ((unsigned int)((INT_MAX - 2)))) {
      i = 1;
      while (!(((luaH_getnum(t, i))->tt) == 0))
        i++;
      return i - 1;
    }
  }
  while (j - i > 1) {
    unsigned int m = (i + j) / 2;
    if ((((luaH_getnum(t, m))->tt) == 0))
      j = m;
    else
      i = m;
  }
  return i;
}
static inline int luaH_getn(Table *t) {
  unsigned int j = t->sizearray;
  if (j > 0 && (((&t->array[j - 1])->tt) == 0)) {
    unsigned int i = 0;
    while (j - i > 1) {
      unsigned int m = (i + j) / 2;
      if ((((&t->array[m - 1])->tt) == 0))
        j = m;
      else
        i = m;
    }
    return i;
  } else if (t->node == (&dummynode_))
    return j;
  else
    return unbound_search(t, j);
}
static inline int foreachi(lua_State *L) {
  int i;
  int n = (luaL_checktype(L, 1, 5), ((int)lua_objlen(L, 1)));
  luaL_checktype(L, 2, 6);
  for (i = 1; i <= n; i++) {
    lua_pushvalue(L, 2);
    lua_pushinteger(L, i);
    lua_rawgeti(L, 1, i);
    lua_call(L, 2, 1);
    if (!(lua_type(L, (-1)) == 0))
      return 1;
    lua_settop(L, -(1) - 1);
  }
  return 0;
}
static inline int foreach (lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_checktype(L, 2, 6);
  lua_pushnil(L);
  while (lua_next(L, 1)) {
    lua_pushvalue(L, 2);
    lua_pushvalue(L, -3);
    lua_pushvalue(L, -3);
    lua_call(L, 2, 1);
    if (!(lua_type(L, (-1)) == 0))
      return 1;
    lua_settop(L, -(2) - 1);
  }
  return 0;
}
static inline int maxn(lua_State *L) {
  lua_Number max = 0;
  luaL_checktype(L, 1, 5);
  lua_pushnil(L);
  while (lua_next(L, 1)) {
    lua_settop(L, -(1) - 1);
    if (lua_type(L, -1) == 3) {
      lua_Number v = lua_tonumber(L, -1);
      if (v > max)
        max = v;
    }
  }
  lua_pushnumber(L, max);
  return 1;
}
static inline int getn(lua_State *L) {
  lua_pushinteger(L, (luaL_checktype(L, 1, 5), ((int)lua_objlen(L, 1))));
  return 1;
}
static inline int setn(lua_State *L) {
  luaL_checktype(L, 1, 5);
  luaL_error(L, "'"
                "setn"
                "'"
                " is obsolete");
  lua_pushvalue(L, 1);
  return 1;
}
static inline int tinsert(lua_State *L) {
  int e = (luaL_checktype(L, 1, 5), ((int)lua_objlen(L, 1))) + 1;
  int pos;
  switch (lua_gettop(L)) {
  case 2: {
    pos = e;
    break;
  }
  case 3: {
    int i;
    pos = ((int)luaL_checkinteger(L, (2)));
    if (pos > e)
      e = pos;
    for (i = e; i > pos; i--) {
      lua_rawgeti(L, 1, i - 1);
      lua_rawseti(L, 1, i);
    }
    break;
  }
  default: {
    return luaL_error(L, "wrong number of arguments to "
                         "'"
                         "insert"
                         "'");
  }
  }
  ((void)0);
  lua_rawseti(L, 1, pos);
  return 0;
}
static inline int tremove(lua_State *L) {
  int e = (luaL_checktype(L, 1, 5), ((int)lua_objlen(L, 1)));
  int pos = ((int)luaL_optinteger(L, (2), (e)));
  if (!(1 <= pos && pos <= e))
    return 0;
  ((void)0);
  lua_rawgeti(L, 1, pos);
  for (; pos < e; pos++) {
    lua_rawgeti(L, 1, pos + 1);
    lua_rawseti(L, 1, pos);
  }
  lua_pushnil(L);
  lua_rawseti(L, 1, e);
  return 1;
}
static inline void addfield(lua_State *L, luaL_Buffer *b, int i) {
  lua_rawgeti(L, 1, i);
  if (!lua_isstring(L, -1))
    luaL_error(L,
               "invalid value (%s) at index %d in table for "
               "'"
               "concat"
               "'",
               lua_typename(L, lua_type(L, (-1))), i);
  luaL_addvalue(b);
}
static inline int tconcat(lua_State *L) {
  luaL_Buffer b;
  size_t lsep;
  int i, last;
  const char *sep = luaL_optlstring(L, 2, "", &lsep);
  luaL_checktype(L, 1, 5);
  i = ((int)luaL_optinteger(L, (3), (1)));
  last = ((lua_type(L, ((4))) <= 0) ? (((int)lua_objlen(L, 1)))
                                    : ((int)luaL_checkinteger(L, ((4)))));
  luaL_buffinit(L, &b);
  for (; i < last; i++) {
    addfield(L, &b, i);
    luaL_addlstring(&b, sep, lsep);
  }
  if (i == last)
    addfield(L, &b, i);
  luaL_pushresult(&b);
  return 1;
}
static inline void set2(lua_State *L, int i, int j) {
  lua_rawseti(L, 1, i);
  lua_rawseti(L, 1, j);
}
static inline int sort_comp(lua_State *L, int a, int b) {
  if (!(lua_type(L, (2)) == 0)) {
    int res;
    lua_pushvalue(L, 2);
    lua_pushvalue(L, a - 1);
    lua_pushvalue(L, b - 2);
    lua_call(L, 2, 1);
    res = lua_toboolean(L, -1);
    lua_settop(L, -(1) - 1);
    return res;
  } else
    return lua_lessthan(L, a, b);
}
static inline void auxsort(lua_State *L, int l, int u) {
  while (l < u) {
    int i, j;
    lua_rawgeti(L, 1, l);
    lua_rawgeti(L, 1, u);
    if (sort_comp(L, -1, -2))
      set2(L, l, u);
    else
      lua_settop(L, -(2) - 1);
    if (u - l == 1)
      break;
    i = (l + u) / 2;
    lua_rawgeti(L, 1, i);
    lua_rawgeti(L, 1, l);
    if (sort_comp(L, -2, -1))
      set2(L, i, l);
    else {
      lua_settop(L, -(1) - 1);
      lua_rawgeti(L, 1, u);
      if (sort_comp(L, -1, -2))
        set2(L, i, u);
      else
        lua_settop(L, -(2) - 1);
    }
    if (u - l == 2)
      break;
    lua_rawgeti(L, 1, i);
    lua_pushvalue(L, -1);
    lua_rawgeti(L, 1, u - 1);
    set2(L, i, u - 1);
    i = l;
    j = u - 1;
    for (;;) {
      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
        if (i > u)
          luaL_error(L, "invalid order function for sorting");
        lua_settop(L, -(1) - 1);
      }
      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
        if (j < l)
          luaL_error(L, "invalid order function for sorting");
        lua_settop(L, -(1) - 1);
      }
      if (j < i) {
        lua_settop(L, -(3) - 1);
        break;
      }
      set2(L, i, j);
    }
    lua_rawgeti(L, 1, u - 1);
    lua_rawgeti(L, 1, i);
    set2(L, u - 1, i);
    if (i - l < u - i) {
      j = l;
      i = i - 1;
      l = i + 2;
    } else {
      j = i + 1;
      i = u;
      u = j - 2;
    }
    auxsort(L, j, i);
  }
}
static inline int sort(lua_State *L) {
  int n = (luaL_checktype(L, 1, 5), ((int)lua_objlen(L, 1)));
  luaL_checkstack(L, 40, "");
  if (!(lua_type(L, (2)) <= 0))
    luaL_checktype(L, 2, 6);
  lua_settop(L, 2);
  auxsort(L, 1, n);
  return 0;
}
static const luaL_Reg tab_funcs[] = {
    {"concat", tconcat}, {"foreach", foreach}, {"foreachi", foreachi},
    {"getn", getn},      {"maxn", maxn},       {"insert", tinsert},
    {"remove", tremove}, {"setn", setn},       {"sort", sort},
    {NULL, NULL}};
static inline int luaopen_table(lua_State *L) {
  luaL_register(L, "table", tab_funcs);
  return 1;
}
static const char *const luaT_typenames[] = {
    "nil",      "boolean",  "userdata", "number", "string", "table",
    "function", "userdata", "thread",   "proto",  "upval"};
static inline void luaT_init(lua_State *L) {
  static const char *const luaT_eventname[] = {
      "__index", "__newindex", "__gc",  "__mode",   "__eq",  "__add",
      "__sub",   "__mul",      "__div", "__mod",    "__pow", "__unm",
      "__len",   "__lt",       "__le",  "__concat", "__call"};
  int i;
  for (i = 0; i < TM_N; i++) {
    (L->l_G)->tmname[i] =
        (luaS_newlstr(L, luaT_eventname[i], strlen(luaT_eventname[i])));
    ((((L->l_G)->tmname[i])->tsv.marked) |= ((1 << (5))));
  }
}
const TValue *luaT_gettm(Table *events, TMS event, TString *ename) {
  const TValue *tm = luaH_getstr(events, ename);
  ((void)0);
  if ((((tm)->tt) == 0)) {
    events->flags |= ((lu_byte)((1u << event)));
    return NULL;
  } else
    return tm;
}
const TValue *luaT_gettmbyobj(lua_State *L, const TValue *o, TMS event) {
  Table *mt;
  switch (((o)->tt)) {
  case 5:
    mt = (((void)0), (&(o)->value.gc->h))->metatable;
    break;
  case 7:
    mt = (&(((void)0), (&(o)->value.gc->u))->uv)->metatable;
    break;
  default:
    mt = (L->l_G)->mt[((o)->tt)];
  }
  return (mt ? luaH_getstr(mt, (L->l_G)->tmname[event]) : (&luaO_nilobject_));
}
typedef struct {
  lua_State *L;
  ZIO *Z;
  Mbuffer *b;
  const char *name;
} LoadState;
static inline void error(LoadState *S, const char *why) {
  luaO_pushfstring(S->L, "%s: %s in precompiled chunk", S->name, why);
  luaD_throw(S->L, 3);
}
static inline void LoadBlock(LoadState *S, void *b, size_t size) {
  size_t r = luaZ_read(S->Z, b, size);
  if (r != 0)
    error(S, "unexpected end");
}
static inline int LoadChar(LoadState *S) {
  char x;
  LoadBlock(S, &x, (1) * (sizeof(x)));
  return x;
}
static inline int LoadInt(LoadState *S) {
  int x;
  LoadBlock(S, &x, (1) * (sizeof(x)));
  if (x < 0)
    error(S, "bad integer");
  return x;
}
static inline lua_Number LoadNumber(LoadState *S) {
  lua_Number x;
  LoadBlock(S, &x, (1) * (sizeof(x)));
  return x;
}
static inline TString *LoadString(LoadState *S) {
  size_t size;
  LoadBlock(S, &size, (1) * (sizeof(size)));
  if (size == 0)
    return NULL;
  else {
    char *s = luaZ_openspace(S->L, S->b, size);
    LoadBlock(S, s, size);
    return luaS_newlstr(S->L, s, size - 1);
  }
}
static inline void LoadCode(LoadState *S, Proto *f) {
  int n = LoadInt(S);
  f->code = ((Instruction *)((
      (((size_t)((n) + 1)) <=
       ((size_t)(~(size_t)0) - 2) / (sizeof(Instruction)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(Instruction)),
                          (n) * (sizeof(Instruction)))
          : luaM_toobig(S->L))));
  f->sizecode = n;
  LoadBlock(S, f->code, (n) * (sizeof(Instruction)));
}
static inline Proto *LoadFunction(LoadState *S, TString *p);
static inline void LoadConstants(LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->k = ((TValue *)((
      (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TValue)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(TValue)),
                          (n) * (sizeof(TValue)))
          : luaM_toobig(S->L))));
  f->sizek = n;
  for (i = 0; i < n; i++)
    ((&f->k[i])->tt = 0);
  for (i = 0; i < n; i++) {
    TValue *o = &f->k[i];
    int t = LoadChar(S);
    switch (t) {
    case 0:
      ((o)->tt = 0);
      break;
    case 1: {
      TValue *i_o = (o);
      i_o->value.b = (LoadChar(S) != 0);
      i_o->tt = 1;
    }; break;
    case 3: {
      TValue *i_o = (o);
      i_o->value.n = (LoadNumber(S));
      i_o->tt = 3;
    }; break;
    case 4: {
      TValue *i_o = (o);
      i_o->value.gc = ((GCObject *)((LoadString(S))));
      i_o->tt = 4;
      ((void)0);
    }; break;
    default:
      error(S, "bad constant");
      break;
    }
  }
  n = LoadInt(S);
  f->p = ((Proto **)((
      (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto *)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(Proto *)),
                          (n) * (sizeof(Proto *)))
          : luaM_toobig(S->L))));
  f->sizep = n;
  for (i = 0; i < n; i++)
    f->p[i] = NULL;
  for (i = 0; i < n; i++)
    f->p[i] = LoadFunction(S, f->source);
}
static inline void LoadDebug(LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->lineinfo = ((int *)((
      (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(int)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(int)),
                          (n) * (sizeof(int)))
          : luaM_toobig(S->L))));
  f->sizelineinfo = n;
  LoadBlock(S, f->lineinfo, (n) * (sizeof(int)));
  n = LoadInt(S);
  f->locvars = ((LocVar *)((
      (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LocVar)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(LocVar)),
                          (n) * (sizeof(LocVar)))
          : luaM_toobig(S->L))));
  f->sizelocvars = n;
  for (i = 0; i < n; i++)
    f->locvars[i].varname = NULL;
  for (i = 0; i < n; i++) {
    f->locvars[i].varname = LoadString(S);
    f->locvars[i].startpc = LoadInt(S);
    f->locvars[i].endpc = LoadInt(S);
  }
  n = LoadInt(S);
  f->upvalues = ((TString **)((
      (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString *)))
          ? luaM_realloc_(S->L, (NULL), (0) * (sizeof(TString *)),
                          (n) * (sizeof(TString *)))
          : luaM_toobig(S->L))));
  f->sizeupvalues = n;
  for (i = 0; i < n; i++)
    f->upvalues[i] = NULL;
  for (i = 0; i < n; i++)
    f->upvalues[i] = LoadString(S);
}
static inline Proto *LoadFunction(LoadState *S, TString *p) {
  Proto *f;
  if (++S->L->nCcalls > 200)
    error(S, "code too deep");
  f = luaF_newproto(S->L);
  {
    TValue *i_o = (S->L->top);
    i_o->value.gc = ((GCObject *)((f)));
    i_o->tt = (8 + 1);
    ((void)0);
  };
  {
    if ((char *)S->L->stack_last - (char *)S->L->top <=
        (1) * (int)sizeof(TValue))
      luaD_growstack(S->L, 1);
    else
      ((void)0);
    ;
    S->L->top++;
  };
  f->source = LoadString(S);
  if (f->source == NULL)
    f->source = p;
  f->linedefined = LoadInt(S);
  f->lastlinedefined = LoadInt(S);
  f->nups = (lu_byte)LoadChar(S);
  f->numparams = (lu_byte)LoadChar(S);
  f->is_vararg = (lu_byte)LoadChar(S);
  f->maxstacksize = (lu_byte)LoadChar(S);
  LoadCode(S, f);
  LoadConstants(S, f);
  LoadDebug(S, f);
  if (!luaG_checkcode(f))
    error(S, "bad code");
  S->L->top--;
  S->L->nCcalls--;
  return f;
}
static inline void LoadHeader(LoadState *S) {
  char h[12];
  char s[12];
  luaU_header(h);
  LoadBlock(S, s, 12);
  if (memcmp(h, s, 12) != 0)
    error(S, "bad header");
}
Proto *luaU_undump(lua_State *L, ZIO *Z, Mbuffer *buff, const char *name) {
  LoadState S;
  if (*name == '@' || *name == '=')
    S.name = name + 1;
  else if (*name == "\033Lua"[0])
    S.name = "binary string";
  else
    S.name = name;
  S.L = L;
  S.Z = Z;
  S.b = buff;
  LoadHeader(&S);
  return LoadFunction(&S, (luaS_newlstr(L,
                                        ""
                                        "=?",
                                        (sizeof("=?") / sizeof(char)) - 1)));
}
static inline void luaU_header(char *h) {
  int x = 1;
  memcpy(h, "\033Lua", sizeof("\033Lua") - 1);
  h += sizeof("\033Lua") - 1;
  *h++ = (char)0x51;
  *h++ = (char)0;
  *h++ = (char)*(char *)&x;
  *h++ = (char)sizeof(int);
  *h++ = (char)sizeof(size_t);
  *h++ = (char)sizeof(Instruction);
  *h++ = (char)sizeof(lua_Number);
  *h++ = (char)(((lua_Number)0.5) == 0);
}
const TValue *luaV_tonumber(const TValue *obj, TValue *n) {
  lua_Number num;
  if ((((obj)->tt) == 3))
    return obj;
  if ((((obj)->tt) == 4) &&
      luaO_str2d(((const char *)(((((void)0), (&(obj)->value.gc->ts))) + 1)),
                 &num)) {
    {
      TValue *i_o = (n);
      i_o->value.n = (num);
      i_o->tt = 3;
    };
    return n;
  } else
    return NULL;
}
static inline int luaV_tostring(lua_State *L, StkId obj) {
  if (!(((obj)->tt) == 3))
    return 0;
  else {
    char s[32];
    lua_Number n = (((void)0), ((obj)->value.n));
    sprintf((s), "%.14g", (n));
    {
      TValue *i_o = (obj);
      i_o->value.gc = ((GCObject *)(((luaS_newlstr(L, s, strlen(s))))));
      i_o->tt = 4;
      ((void)0);
    };
    return 1;
  }
}
static inline void traceexec(lua_State *L, const Instruction *pc) {
  lu_byte mask = L->hookmask;
  const Instruction *oldpc = L->savedpc;
  L->savedpc = pc;
  if ((mask & (1 << 3)) && L->hookcount == 0) {
    (L->hookcount = L->basehookcount);
    luaD_callhook(L, 3, -1);
  }
  if (mask & (1 << 2)) {
    Proto *p = ((((void)0), (&((L->ci)->func)->value.gc->cl)))->l.p;
    int npc = (((int)((pc) - (p)->code)) - 1);
    int newline = (((p)->lineinfo) ? (p)->lineinfo[npc] : 0);
    if (npc == 0 || pc <= oldpc ||
        newline != (((p)->lineinfo)
                        ? (p)->lineinfo[(((int)((oldpc) - (p)->code)) - 1)]
                        : 0))
      luaD_callhook(L, 2, newline);
  }
}
static inline void callTMres(lua_State *L, StkId res, const TValue *f,
                             const TValue *p1, const TValue *p2) {
  ptrdiff_t result = ((char *)(res) - (char *)L->stack);
  {
    const TValue *o2 = (f);
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (p1);
    TValue *o1 = (L->top + 1);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (p2);
    TValue *o1 = (L->top + 2);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  if ((char *)L->stack_last - (char *)L->top <= (3) * (int)sizeof(TValue))
    luaD_growstack(L, 3);
  else
    ((void)0);
  ;
  L->top += 3;
  luaD_call(L, L->top - 3, 1);
  res = ((TValue *)((char *)L->stack + (result)));
  L->top--;
  {
    const TValue *o2 = (L->top);
    TValue *o1 = (res);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
}
static inline void callTM(lua_State *L, const TValue *f, const TValue *p1,
                          const TValue *p2, const TValue *p3) {
  {
    const TValue *o2 = (f);
    TValue *o1 = (L->top);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (p1);
    TValue *o1 = (L->top + 1);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (p2);
    TValue *o1 = (L->top + 2);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  {
    const TValue *o2 = (p3);
    TValue *o1 = (L->top + 3);
    o1->value = o2->value;
    o1->tt = o2->tt;
    ((void)0);
  };
  if ((char *)L->stack_last - (char *)L->top <= (4) * (int)sizeof(TValue))
    luaD_growstack(L, 4);
  else
    ((void)0);
  ;
  L->top += 4;
  luaD_call(L, L->top - 4, 0);
}
static inline void luaV_gettable(lua_State *L, const TValue *t, TValue *key,
                                 StkId val) {
  int loop;
  for (loop = 0; loop < 100; loop++) {
    const TValue *tm;
    if ((((t)->tt) == 5)) {
      Table *h = (((void)0), (&(t)->value.gc->h));
      const TValue *res = luaH_get(h, key);
      if (!(((res)->tt) == 0) ||
          (tm = ((h->metatable) == NULL
                     ? NULL
                     : ((h->metatable)->flags & (1u << (TM_INDEX)))
                           ? NULL
                           : luaT_gettm(h->metatable, TM_INDEX,
                                        ((L->l_G))->tmname[TM_INDEX]))) ==
              NULL) {
        {
          const TValue *o2 = (res);
          TValue *o1 = (val);
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        return;
      }
    } else if ((((tm = luaT_gettmbyobj(L, t, TM_INDEX))->tt) == 0))
      luaG_typeerror(L, t, "index");
    if ((((tm)->tt) == 6)) {
      callTMres(L, val, tm, t, key);
      return;
    }
    t = tm;
  }
  luaG_runerror(L, "loop in gettable");
}
static inline void luaV_settable(lua_State *L, const TValue *t, TValue *key,
                                 StkId val) {
  int loop;
  TValue temp;
  for (loop = 0; loop < 100; loop++) {
    const TValue *tm;
    if ((((t)->tt) == 5)) {
      Table *h = (((void)0), (&(t)->value.gc->h));
      TValue *oldval = luaH_set(L, h, key);
      if (!(((oldval)->tt) == 0) ||
          (tm = ((h->metatable) == NULL
                     ? NULL
                     : ((h->metatable)->flags & (1u << (TM_NEWINDEX)))
                           ? NULL
                           : luaT_gettm(h->metatable, TM_NEWINDEX,
                                        ((L->l_G))->tmname[TM_NEWINDEX]))) ==
              NULL) {
        {
          const TValue *o2 = (val);
          TValue *o1 = (oldval);
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        h->flags = 0;
        {
          if (((((val)->tt) >= 4) &&
               ((((((void)0), ((val)->value.gc)))->gch.marked) &
                ((((1 << (0)) | (1 << (1))))))) &&
              ((((((GCObject *)((h)))))->gch.marked) & ((1 << (2)))))
            luaC_barrierback(L, h);
        };
        return;
      }
    } else if ((((tm = luaT_gettmbyobj(L, t, TM_NEWINDEX))->tt) == 0))
      luaG_typeerror(L, t, "index");
    if ((((tm)->tt) == 6)) {
      callTM(L, tm, t, key, val);
      return;
    }
    {
      const TValue *o2 = (tm);
      TValue *o1 = (&temp);
      o1->value = o2->value;
      o1->tt = o2->tt;
      ((void)0);
    };
    t = &temp;
  }
  luaG_runerror(L, "loop in settable");
}
static inline int call_binTM(lua_State *L, const TValue *p1, const TValue *p2,
                             StkId res, TMS event) {
  const TValue *tm = luaT_gettmbyobj(L, p1, event);
  if ((((tm)->tt) == 0))
    tm = luaT_gettmbyobj(L, p2, event);
  if ((((tm)->tt) == 0))
    return 0;
  callTMres(L, res, tm, p1, p2);
  return 1;
}
static const TValue *get_compTM(lua_State *L, Table *mt1, Table *mt2,
                                TMS event) {
  const TValue *tm1 =
      ((mt1) == NULL ? NULL
                     : ((mt1)->flags & (1u << (event)))
                           ? NULL
                           : luaT_gettm(mt1, event, ((L->l_G))->tmname[event]));
  const TValue *tm2;
  if (tm1 == NULL)
    return NULL;
  if (mt1 == mt2)
    return tm1;
  tm2 =
      ((mt2) == NULL ? NULL
                     : ((mt2)->flags & (1u << (event)))
                           ? NULL
                           : luaT_gettm(mt2, event, ((L->l_G))->tmname[event]));
  if (tm2 == NULL)
    return NULL;
  if (luaO_rawequalObj(tm1, tm2))
    return tm1;
  return NULL;
}
static inline int call_orderTM(lua_State *L, const TValue *p1, const TValue *p2,
                               TMS event) {
  const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
  const TValue *tm2;
  if ((((tm1)->tt) == 0))
    return -1;
  tm2 = luaT_gettmbyobj(L, p2, event);
  if (!luaO_rawequalObj(tm1, tm2))
    return -1;
  callTMres(L, L->top, tm1, p1, p2);
  return !((((L->top)->tt) == 0) ||
           ((((L->top)->tt) == 1) && (((void)0), ((L->top)->value.b)) == 0));
}
static inline int l_strcmp(const TString *ls, const TString *rs) {
  const char *l = ((const char *)((ls) + 1));
  size_t ll = ls->tsv.len;
  const char *r = ((const char *)((rs) + 1));
  size_t lr = rs->tsv.len;
  for (;;) {
    int temp = strcoll(l, r);
    if (temp != 0)
      return temp;
    else {
      size_t len = strlen(l);
      if (len == lr)
        return (len == ll) ? 0 : 1;
      else if (len == ll)
        return -1;
      len++;
      l += len;
      ll -= len;
      r += len;
      lr -= len;
    }
  }
}
static inline int luaV_lessthan(lua_State *L, const TValue *l,
                                const TValue *r) {
  int res;
  if (((l)->tt) != ((r)->tt))
    return luaG_ordererror(L, l, r);
  else if ((((l)->tt) == 3))
    return (((((void)0), ((l)->value.n))) < ((((void)0), ((r)->value.n))));
  else if ((((l)->tt) == 4))
    return l_strcmp((((void)0), (&(l)->value.gc->ts)),
                    (((void)0), (&(r)->value.gc->ts))) < 0;
  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
    return res;
  return luaG_ordererror(L, l, r);
}
static inline int lessequal(lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (((l)->tt) != ((r)->tt))
    return luaG_ordererror(L, l, r);
  else if ((((l)->tt) == 3))
    return (((((void)0), ((l)->value.n))) <= ((((void)0), ((r)->value.n))));
  else if ((((l)->tt) == 4))
    return l_strcmp((((void)0), (&(l)->value.gc->ts)),
                    (((void)0), (&(r)->value.gc->ts))) <= 0;
  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)
    return res;
  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)
    return !res;
  return luaG_ordererror(L, l, r);
}
static inline int luaV_equalval(lua_State *L, const TValue *t1,
                                const TValue *t2) {
  const TValue *tm;
  ((void)0);
  switch (((t1)->tt)) {
  case 0:
    return 1;
  case 3:
    return (((((void)0), ((t1)->value.n))) == ((((void)0), ((t2)->value.n))));
  case 1:
    return (((void)0), ((t1)->value.b)) == (((void)0), ((t2)->value.b));
  case 2:
    return (((void)0), ((t1)->value.p)) == (((void)0), ((t2)->value.p));
  case 7: {
    if ((&(((void)0), (&(t1)->value.gc->u))->uv) ==
        (&(((void)0), (&(t2)->value.gc->u))->uv))
      return 1;
    tm = get_compTM(L, (&(((void)0), (&(t1)->value.gc->u))->uv)->metatable,
                    (&(((void)0), (&(t2)->value.gc->u))->uv)->metatable, TM_EQ);
    break;
  }
  case 5: {
    if ((((void)0), (&(t1)->value.gc->h)) == (((void)0), (&(t2)->value.gc->h)))
      return 1;
    tm = get_compTM(L, (((void)0), (&(t1)->value.gc->h))->metatable,
                    (((void)0), (&(t2)->value.gc->h))->metatable, TM_EQ);
    break;
  }
  default:
    return (((void)0), ((t1)->value.gc)) == (((void)0), ((t2)->value.gc));
  }
  if (tm == NULL)
    return 0;
  callTMres(L, L->top, tm, t1, t2);
  return !((((L->top)->tt) == 0) ||
           ((((L->top)->tt) == 1) && (((void)0), ((L->top)->value.b)) == 0));
}
static inline void luaV_concat(lua_State *L, int total, int last) {
  do {
    StkId top = L->base + last + 1;
    int n = 2;
    if (!((((top - 2)->tt) == 4) || (((top - 2)->tt) == 3)) ||
        !((((top - 1)->tt) == 4) || (luaV_tostring(L, top - 1)))) {
      if (!call_binTM(L, top - 2, top - 1, top - 2, TM_CONCAT))
        luaG_concaterror(L, top - 2, top - 1);
    } else if ((&(((void)0), (&(top - 1)->value.gc->ts))->tsv)->len == 0)
      (void)((((top - 2)->tt) == 4) || (luaV_tostring(L, top - 2)));
    else {
      size_t tl = (&(((void)0), (&(top - 1)->value.gc->ts))->tsv)->len;
      char *buffer;
      int i;
      for (n = 1; n < total && ((((top - n - 1)->tt) == 4) ||
                                (luaV_tostring(L, top - n - 1)));
           n++) {
        size_t l = (&(((void)0), (&(top - n - 1)->value.gc->ts))->tsv)->len;
        if (l >= ((size_t)(~(size_t)0) - 2) - tl)
          luaG_runerror(L, "string length overflow");
        tl += l;
      }
      buffer = luaZ_openspace(L, &(L->l_G)->buff, tl);
      tl = 0;
      for (i = n; i > 0; i--) {
        size_t l = (&(((void)0), (&(top - i)->value.gc->ts))->tsv)->len;
        memcpy(buffer + tl,
               ((const char *)(((((void)0), (&(top - i)->value.gc->ts))) + 1)),
               l);
        tl += l;
      }
      {
        TValue *i_o = (top - n);
        i_o->value.gc = ((GCObject *)((luaS_newlstr(L, buffer, tl))));
        i_o->tt = 4;
        ((void)0);
      };
    }
    total -= n - 1;
    last -= n - 1;
  } while (total > 1);
}
static inline void Arith(lua_State *L, StkId ra, const TValue *rb,
                         const TValue *rc, TMS op) {
  TValue tempb, tempc;
  const TValue *b, *c;
  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
      (c = luaV_tonumber(rc, &tempc)) != NULL) {
    lua_Number nb = (((void)0), ((b)->value.n)),
               nc = (((void)0), ((c)->value.n));
    switch (op) {
    case TM_ADD: {
      TValue *i_o = (ra);
      i_o->value.n = (((nb) + (nc)));
      i_o->tt = 3;
    }; break;
    case TM_SUB: {
      TValue *i_o = (ra);
      i_o->value.n = (((nb) - (nc)));
      i_o->tt = 3;
    }; break;
    case TM_MUL: {
      TValue *i_o = (ra);
      i_o->value.n = (((nb) * (nc)));
      i_o->tt = 3;
    }; break;
    case TM_DIV: {
      TValue *i_o = (ra);
      i_o->value.n = (((nb) / (nc)));
      i_o->tt = 3;
    }; break;
    case TM_MOD: {
      TValue *i_o = (ra);
      i_o->value.n = (((nb) - ({
                                *((volatile int *)0) = 0;
                                (double)*((volatile double *)0);
                              }) * (nc)));
      i_o->tt = 3;
    }; break;
    case TM_POW: {
      TValue *i_o = (ra);
      i_o->value.n = ((({
        *((volatile int *)0) = 0;
        (double)*((volatile double *)0);
      })));
      i_o->tt = 3;
    }; break;
    case TM_UNM: {
      TValue *i_o = (ra);
      i_o->value.n = ((-(nb)));
      i_o->tt = 3;
    }; break;
    default:
      ((void)0);
      break;
    }
  } else if (!call_binTM(L, rb, rc, ra, op))
    luaG_aritherror(L, rb, rc);
}
static inline void luaV_execute(lua_State *L, int nexeccalls) {
  LClosure *cl;
  StkId base;
  TValue *k;
  const Instruction *pc;
reentry:
  ((void)0);
  pc = L->savedpc;
  cl = &(((void)0), (&(L->ci->func)->value.gc->cl))->l;
  base = L->base;
  k = cl->p->k;
  for (;;) {
    const Instruction i = *pc++;
    StkId ra;
    if ((L->hookmask & ((1 << 2) | (1 << 3))) &&
        (--L->hookcount == 0 || L->hookmask & (1 << 2))) {
      traceexec(L, pc);
      if (L->status == 1) {
        L->savedpc = pc - 1;
        return;
      }
      base = L->base;
    }
    ra = (base +
          (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));
    ((void)0);
    ((void)0);
    ((void)0);
    switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))))) {
    case OP_MOVE: {
      {
        const TValue *o2 = ((
            ((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0)))))));
        TValue *o1 = (ra);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      continue;
    }
    case OP_LOADK: {
      {
        const TValue *o2 =
            ((((void)0),
              (k + (((int)(((i) >> ((0 + 6) + 8)) &
                           ((~((~(Instruction)0) << (9 + 9))) << 0)))))));
        TValue *o1 = (ra);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      continue;
    }
    case OP_LOADBOOL: {
      {
        TValue *i_o = (ra);
        i_o->value.b = ((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                ((~((~(Instruction)0) << 9)) << 0)))));
        i_o->tt = 1;
      };
      if ((((int)(((i) >> ((0 + 6) + 8)) &
                  ((~((~(Instruction)0) << 9)) << 0)))))
        pc++;
      continue;
    }
    case OP_LOADNIL: {
      TValue *rb =
          (((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))));
      do {
        ((rb--)->tt = 0);
      } while (rb >= ra);
      continue;
    }
    case OP_GETUPVAL: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      {
        const TValue *o2 = (cl->upvals[b]->v);
        TValue *o1 = (ra);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      continue;
    }
    case OP_GETGLOBAL: {
      TValue g;
      TValue *rb = (((void)0),
                    (k + (((int)(((i) >> ((0 + 6) + 8)) &
                                 ((~((~(Instruction)0) << (9 + 9))) << 0))))));
      {
        TValue *i_o = (&g);
        i_o->value.gc = ((GCObject *)((cl->env)));
        i_o->tt = 5;
        ((void)0);
      };
      ((void)0);
      {
        L->savedpc = pc;
        { luaV_gettable(L, &g, rb, ra); };
        base = L->base;
      };
      continue;
    }
    case OP_GETTABLE: {
      {
        L->savedpc = pc;
        {
          luaV_gettable(
              L,
              (((void)0),
               (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                               ((~((~(Instruction)0) << 9)) << 0)))))),
              (((void)0),
               ((((((int)(((i) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << 9)) << 0))))) &
                 (1 << (9 - 1)))
                    ? k + ((int)((
                               ((int)(((i) >> ((0 + 6) + 8)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))) &
                           ~(1 << (9 - 1)))
                    : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                     ((~((~(Instruction)0) << 9)) << 0)))))),
              ra);
        };
        base = L->base;
      };
      continue;
    }
    case OP_SETGLOBAL: {
      TValue g;
      {
        TValue *i_o = (&g);
        i_o->value.gc = ((GCObject *)((cl->env)));
        i_o->tt = 5;
        ((void)0);
      };
      ((void)0);
      {
        L->savedpc = pc;
        {
          luaV_settable(
              L, &g,
              (((void)0),
               (k + (((int)(((i) >> ((0 + 6) + 8)) &
                            ((~((~(Instruction)0) << (9 + 9))) << 0)))))),
              ra);
        };
        base = L->base;
      };
      continue;
    }
    case OP_SETUPVAL: {
      UpVal *uv = cl->upvals[(((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                     ((~((~(Instruction)0) << 9)) << 0))))];
      {
        const TValue *o2 = (ra);
        TValue *o1 = (uv->v);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      {
        if (((((ra)->tt) >= 4) &&
             ((((((void)0), ((ra)->value.gc)))->gch.marked) &
              ((((1 << (0)) | (1 << (1))))))) &&
            ((((((GCObject *)((uv)))))->gch.marked) & ((1 << (2)))))
          luaC_barrierf(L, (((GCObject *)((uv)))),
                        (((void)0), ((ra)->value.gc)));
      };
      continue;
    }
    case OP_SETTABLE: {
      {
        L->savedpc = pc;
        {
          luaV_settable(
              L, ra,
              (((void)0),
               ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                          ((~((~(Instruction)0) << 9)) << 0))))) &
                 (1 << (9 - 1)))
                    ? k + ((int)((
                               ((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))) &
                           ~(1 << (9 - 1)))
                    : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                     ((~((~(Instruction)0) << 9)) << 0)))))),
              (((void)0),
               ((((((int)(((i) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << 9)) << 0))))) &
                 (1 << (9 - 1)))
                    ? k + ((int)((
                               ((int)(((i) >> ((0 + 6) + 8)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))) &
                           ~(1 << (9 - 1)))
                    : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                     ((~((~(Instruction)0) << 9)) << 0)))))));
        };
        base = L->base;
      };
      continue;
    }
    case OP_NEWTABLE: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      int c = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      {
        TValue *i_o = (ra);
        i_o->value.gc =
            ((GCObject *)((luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)))));
        i_o->tt = 5;
        ((void)0);
      };
      {
        L->savedpc = pc;
        {
          {
            ((void)0);
            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
              luaC_step(L);
          };
        };
        base = L->base;
      };
      continue;
    }
    case OP_SELF: {
      StkId rb =
          (((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))));
      {
        const TValue *o2 = (rb);
        TValue *o1 = (ra + 1);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      {
        L->savedpc = pc;
        {
          luaV_gettable(
              L, rb,
              (((void)0),
               ((((((int)(((i) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << 9)) << 0))))) &
                 (1 << (9 - 1)))
                    ? k + ((int)((
                               ((int)(((i) >> ((0 + 6) + 8)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))) &
                           ~(1 << (9 - 1)))
                    : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                     ((~((~(Instruction)0) << 9)) << 0)))))),
              ra);
        };
        base = L->base;
      };
      continue;
    }
    case OP_ADD: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = (((nb) + (nc)));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_ADD); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_SUB: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = (((nb) - (nc)));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_SUB); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_MUL: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = (((nb) * (nc)));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_MUL); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_DIV: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = (((nb) / (nc)));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_DIV); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_MOD: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = (((nb) - ({
                                      *((volatile int *)0) = 0;
                                      (double)*((volatile double *)0);
                                    }) * (nc)));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_MOD); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_POW: {
      {
        TValue *rb =
            (((void)0),
             ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        TValue *rc =
            (((void)0),
             ((((((int)(((i) >> ((0 + 6) + 8)) &
                        ((~((~(Instruction)0) << 9)) << 0))))) &
               (1 << (9 - 1)))
                  ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                       ((~((~(Instruction)0) << 9)) << 0))))) &
                         ~(1 << (9 - 1)))
                  : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                   ((~((~(Instruction)0) << 9)) << 0))))));
        if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {
          lua_Number nb = (((void)0), ((rb)->value.n)),
                     nc = (((void)0), ((rc)->value.n));
          {
            TValue *i_o = (ra);
            i_o->value.n = ((({
              *((volatile int *)0) = 0;
              (double)*((volatile double *)0);
            })));
            i_o->tt = 3;
          };
        } else {
          L->savedpc = pc;
          { Arith(L, ra, rb, rc, TM_POW); };
          base = L->base;
        };
      };
      continue;
    }
    case OP_UNM: {
      TValue *rb =
          (((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))));
      if ((((rb)->tt) == 3)) {
        lua_Number nb = (((void)0), ((rb)->value.n));
        {
          TValue *i_o = (ra);
          i_o->value.n = ((-(nb)));
          i_o->tt = 3;
        };
      } else {
        {
          L->savedpc = pc;
          { Arith(L, ra, rb, rb, TM_UNM); };
          base = L->base;
        };
      }
      continue;
    }
    case OP_NOT: {
      int res = (((((((void)0),
                     (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                     ((~((~(Instruction)0) << 9)) << 0)))))))
                       ->tt) == 0) ||
                 (((((((void)0),
                      (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0)))))))
                        ->tt) == 1) &&
                  (((void)0),
                   (((((void)0),
                      (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0)))))))
                        ->value.b)) == 0));
      {
        TValue *i_o = (ra);
        i_o->value.b = (res);
        i_o->tt = 1;
      };
      continue;
    }
    case OP_LEN: {
      const TValue *rb =
          (((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))));
      switch (((rb)->tt)) {
      case 5: {
        {
          TValue *i_o = (ra);
          i_o->value.n =
              (((lua_Number)((luaH_getn((((void)0), (&(rb)->value.gc->h)))))));
          i_o->tt = 3;
        };
        break;
      }
      case 4: {
        {
          TValue *i_o = (ra);
          i_o->value.n = ((
              (lua_Number)(((&(((void)0), (&(rb)->value.gc->ts))->tsv)->len))));
          i_o->tt = 3;
        };
        break;
      }
      default: {
        {
          L->savedpc = pc;
          {
            if (!call_binTM(L, rb, (&luaO_nilobject_), ra, TM_LEN))
              luaG_typeerror(L, rb, "get length of");
            ;
          };
          base = L->base;
        }
      }
      }
      continue;
    }
    case OP_CONCAT: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      int c = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      {
        L->savedpc = pc;
        {
          luaV_concat(L, c - b + 1, c);
          {
            ((void)0);
            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
              luaC_step(L);
          };
        };
        base = L->base;
      };
      {
        const TValue *o2 = (base + b);
        TValue *o1 = ((base + (((int)(((i) >> (0 + 6)) &
                                      ((~((~(Instruction)0) << 8)) << 0))))));
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      continue;
    }
    case OP_JMP: {
      {
        (pc) += (((((int)(((i) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                  (INT_MAX - 2)));
        {
          ((void)0);
          ((void)0);
        };
      };
      continue;
    }
    case OP_EQ: {
      TValue *rb =
          (((void)0),
           ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))))) &
             (1 << (9 - 1)))
                ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                     ((~((~(Instruction)0) << 9)) << 0))))) &
                       ~(1 << (9 - 1)))
                : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                 ((~((~(Instruction)0) << 9)) << 0))))));
      TValue *rc =
          (((void)0),
           ((((((int)(((i) >> ((0 + 6) + 8)) &
                      ((~((~(Instruction)0) << 9)) << 0))))) &
             (1 << (9 - 1)))
                ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) &
                                     ((~((~(Instruction)0) << 9)) << 0))))) &
                       ~(1 << (9 - 1)))
                : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                 ((~((~(Instruction)0) << 9)) << 0))))));
      {
        L->savedpc = pc;
        {
          if ((((rb)->tt) == ((rc)->tt) && luaV_equalval(L, rb, rc)) ==
              (((int)(((i) >> (0 + 6)) &
                      ((~((~(Instruction)0) << 8)) << 0))))) {
            (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                              ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                      (INT_MAX - 2)));
            {
              ((void)0);
              ((void)0);
            };
          };
          ;
        };
        base = L->base;
      }
      pc++;
      continue;
    }
    case OP_LT: {
      {
        L->savedpc = pc;
        {
          if (luaV_lessthan(
                  L,
                  (((void)0),
                   ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                              ((~((~(Instruction)0) << 9)) << 0))))) &
                     (1 << (9 - 1)))
                        ? k + ((int)((((
                                   int)(((i) >> (((0 + 6) + 8) + 9)) &
                                        ((~((~(Instruction)0) << 9)) << 0))))) &
                               ~(1 << (9 - 1)))
                        : base +
                              (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0)))))),
                  (((void)0),
                   ((((((int)(((i) >> ((0 + 6) + 8)) &
                              ((~((~(Instruction)0) << 9)) << 0))))) &
                     (1 << (9 - 1)))
                        ? k + ((int)((((
                                   int)(((i) >> ((0 + 6) + 8)) &
                                        ((~((~(Instruction)0) << 9)) << 0))))) &
                               ~(1 << (9 - 1)))
                        : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                         ((~((~(Instruction)0) << 9))
                                          << 0))))))) ==
              (((int)(((i) >> (0 + 6)) &
                      ((~((~(Instruction)0) << 8)) << 0))))) {
            (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                              ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                      (INT_MAX - 2)));
            {
              ((void)0);
              ((void)0);
            };
          };
          ;
        };
        base = L->base;
      }
      pc++;
      continue;
    }
    case OP_LE: {
      {
        L->savedpc = pc;
        {
          if (lessequal(
                  L,
                  (((void)0),
                   ((((((int)(((i) >> (((0 + 6) + 8) + 9)) &
                              ((~((~(Instruction)0) << 9)) << 0))))) &
                     (1 << (9 - 1)))
                        ? k + ((int)((((
                                   int)(((i) >> (((0 + 6) + 8) + 9)) &
                                        ((~((~(Instruction)0) << 9)) << 0))))) &
                               ~(1 << (9 - 1)))
                        : base +
                              (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0)))))),
                  (((void)0),
                   ((((((int)(((i) >> ((0 + 6) + 8)) &
                              ((~((~(Instruction)0) << 9)) << 0))))) &
                     (1 << (9 - 1)))
                        ? k + ((int)((((
                                   int)(((i) >> ((0 + 6) + 8)) &
                                        ((~((~(Instruction)0) << 9)) << 0))))) &
                               ~(1 << (9 - 1)))
                        : base + (((int)(((i) >> ((0 + 6) + 8)) &
                                         ((~((~(Instruction)0) << 9))
                                          << 0))))))) ==
              (((int)(((i) >> (0 + 6)) &
                      ((~((~(Instruction)0) << 8)) << 0))))) {
            (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                              ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                      (INT_MAX - 2)));
            {
              ((void)0);
              ((void)0);
            };
          };
          ;
        };
        base = L->base;
      }
      pc++;
      continue;
    }
    case OP_TEST: {
      if (((((ra)->tt) == 0) ||
           ((((ra)->tt) == 1) && (((void)0), ((ra)->value.b)) == 0)) !=
          (((int)(((i) >> ((0 + 6) + 8)) &
                  ((~((~(Instruction)0) << 9)) << 0))))) {
        (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                  (INT_MAX - 2)));
        {
          ((void)0);
          ((void)0);
        };
      };
      pc++;
      continue;
    }
    case OP_TESTSET: {
      TValue *rb =
          (((void)0), (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                                      ((~((~(Instruction)0) << 9)) << 0))))));
      if (((((rb)->tt) == 0) ||
           ((((rb)->tt) == 1) && (((void)0), ((rb)->value.b)) == 0)) !=
          (((int)(((i) >> ((0 + 6) + 8)) &
                  ((~((~(Instruction)0) << 9)) << 0))))) {
        {
          const TValue *o2 = (rb);
          TValue *o1 = (ra);
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        {
          (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                            ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                    (INT_MAX - 2)));
          {
            ((void)0);
            ((void)0);
          };
        };
      }
      pc++;
      continue;
    }
    case OP_CALL: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      int nresults = (((int)(((i) >> ((0 + 6) + 8)) &
                             ((~((~(Instruction)0) << 9)) << 0)))) -
                     1;
      if (b != 0)
        L->top = ra + b;
      L->savedpc = pc;
      switch (luaD_precall(L, ra, nresults)) {
      case 0: {
        nexeccalls++;
        goto reentry;
      }
      case 1: {
        if (nresults >= 0)
          L->top = L->ci->top;
        base = L->base;
        continue;
      }
      default: {
        return;
      }
      }
    }
    case OP_TAILCALL: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      if (b != 0)
        L->top = ra + b;
      L->savedpc = pc;
      ((void)0);
      switch (luaD_precall(L, ra, (-1))) {
      case 0: {
        CallInfo *ci = L->ci - 1;
        int aux;
        StkId func = ci->func;
        StkId pfunc = (ci + 1)->func;
        if (L->openupval)
          luaF_close(L, ci->base);
        L->base = ci->base = ci->func + ((ci + 1)->base - pfunc);
        for (aux = 0; pfunc + aux < L->top; aux++) {
          const TValue *o2 = (pfunc + aux);
          TValue *o1 = (func + aux);
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        ci->top = L->top = func + aux;
        ((void)0);
        ci->savedpc = L->savedpc;
        ci->tailcalls++;
        L->ci--;
        goto reentry;
      }
      case 1: {
        base = L->base;
        continue;
      }
      default: {
        return;
      }
      }
    }
    case OP_RETURN: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      if (b != 0)
        L->top = ra + b - 1;
      if (L->openupval)
        luaF_close(L, base);
      L->savedpc = pc;
      b = luaD_poscall(L, ra);
      if (--nexeccalls == 0)
        return;
      else {
        if (b)
          L->top = L->ci->top;
        ((void)0);
        ((void)0);
        goto reentry;
      }
    }
    case OP_FORLOOP: {
      lua_Number step = (((void)0), ((ra + 2)->value.n));
      lua_Number idx = (((((void)0), ((ra)->value.n))) + (step));
      lua_Number limit = (((void)0), ((ra + 1)->value.n));
      if (((0) < (step)) ? ((idx) <= (limit)) : ((limit) <= (idx))) {
        {
          (pc) += (((((int)(((i) >> ((0 + 6) + 8)) &
                            ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                    (INT_MAX - 2)));
          {
            ((void)0);
            ((void)0);
          };
        };
        {
          TValue *i_o = (ra);
          i_o->value.n = (idx);
          i_o->tt = 3;
        };
        {
          TValue *i_o = (ra + 3);
          i_o->value.n = (idx);
          i_o->tt = 3;
        };
      }
      continue;
    }
    case OP_FORPREP: {
      const TValue *init = ra;
      const TValue *plimit = ra + 1;
      const TValue *pstep = ra + 2;
      L->savedpc = pc;
      if (!(((init)->tt) == 3 || (((init) = luaV_tonumber(init, ra)) != NULL)))
        luaG_runerror(L, "'"
                         "for"
                         "'"
                         " initial value must be a number");
      else if (!(((plimit)->tt) == 3 ||
                 (((plimit) = luaV_tonumber(plimit, ra + 1)) != NULL)))
        luaG_runerror(L, "'"
                         "for"
                         "'"
                         " limit must be a number");
      else if (!(((pstep)->tt) == 3 ||
                 (((pstep) = luaV_tonumber(pstep, ra + 2)) != NULL)))
        luaG_runerror(L, "'"
                         "for"
                         "'"
                         " step must be a number");
      {
        TValue *i_o = (ra);
        i_o->value.n = ((((((void)0), ((ra)->value.n))) -
                         ((((void)0), ((pstep)->value.n)))));
        i_o->tt = 3;
      };
      {
        (pc) += (((((int)(((i) >> ((0 + 6) + 8)) &
                          ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                  (INT_MAX - 2)));
        {
          ((void)0);
          ((void)0);
        };
      };
      continue;
    }
    case OP_TFORLOOP: {
      StkId cb = ra + 3;
      {
        const TValue *o2 = (ra + 2);
        TValue *o1 = (cb + 2);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      {
        const TValue *o2 = (ra + 1);
        TValue *o1 = (cb + 1);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      {
        const TValue *o2 = (ra);
        TValue *o1 = (cb);
        o1->value = o2->value;
        o1->tt = o2->tt;
        ((void)0);
      };
      L->top = cb + 3;
      {
        L->savedpc = pc;
        {
          luaD_call(L, cb,
                    (((int)(((i) >> ((0 + 6) + 8)) &
                            ((~((~(Instruction)0) << 9)) << 0)))));
        };
        base = L->base;
      };
      L->top = L->ci->top;
      cb = (base +
            (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) +
           3;
      if (!(((cb)->tt) == 0)) {
        {
          const TValue *o2 = (cb);
          TValue *o1 = (cb - 1);
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        {
          (pc) += (((((int)(((*pc) >> ((0 + 6) + 8)) &
                            ((~((~(Instruction)0) << (9 + 9))) << 0)))) -
                    (INT_MAX - 2)));
          {
            ((void)0);
            ((void)0);
          };
        };
      }
      pc++;
      continue;
    }
    case OP_SETLIST: {
      int n = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0))));
      int c = ((
          (int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));
      int last;
      Table *h;
      if (n == 0) {
        n = ((int)((L->top - ra))) - 1;
        L->top = L->ci->top;
      }
      if (c == 0)
        c = ((int)((*pc++)));
      {
        if (!((((ra)->tt) == 5)))
          break;
      };
      h = (((void)0), (&(ra)->value.gc->h));
      last = ((c - 1) * 50) + n;
      if (last > h->sizearray)
        luaH_resizearray(L, h, last);
      for (; n > 0; n--) {
        TValue *val = ra + n;
        {
          const TValue *o2 = (val);
          TValue *o1 = (luaH_setnum(L, h, last--));
          o1->value = o2->value;
          o1->tt = o2->tt;
          ((void)0);
        };
        {
          if (((((val)->tt) >= 4) &&
               ((((((void)0), ((val)->value.gc)))->gch.marked) &
                ((((1 << (0)) | (1 << (1))))))) &&
              ((((((GCObject *)((h)))))->gch.marked) & ((1 << (2)))))
            luaC_barrierback(L, h);
        };
      }
      continue;
    }
    case OP_CLOSE: {
      luaF_close(L, ra);
      continue;
    }
    case OP_CLOSURE: {
      Proto *p;
      Closure *ncl;
      int nup, j;
      p = cl->p->p[(((int)(((i) >> ((0 + 6) + 8)) &
                           ((~((~(Instruction)0) << (9 + 9))) << 0))))];
      nup = p->nups;
      ncl = luaF_newLclosure(L, nup, cl->env);
      ncl->l.p = p;
      for (j = 0; j < nup; j++, pc++) {
        if ((((OpCode)(((*pc) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) ==
            OP_GETUPVAL)
          ncl->l.upvals[j] =
              cl->upvals[(((int)(((*pc) >> (((0 + 6) + 8) + 9)) &
                                 ((~((~(Instruction)0) << 9)) << 0))))];
        else {
          ((void)0);
          ncl->l.upvals[j] = luaF_findupval(
              L, base + (((int)(((*pc) >> (((0 + 6) + 8) + 9)) &
                                ((~((~(Instruction)0) << 9)) << 0)))));
        }
      }
      {
        TValue *i_o = (ra);
        i_o->value.gc = ((GCObject *)((ncl)));
        i_o->tt = 6;
        ((void)0);
      };
      {
        L->savedpc = pc;
        {
          {
            ((void)0);
            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)
              luaC_step(L);
          };
        };
        base = L->base;
      };
      continue;
    }
    case OP_VARARG: {
      int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) &
                      ((~((~(Instruction)0) << 9)) << 0)))) -
              1;
      int j;
      CallInfo *ci = L->ci;
      int n = ((int)((ci->base - ci->func))) - cl->p->numparams - 1;
      if (b == (-1)) {
        {
          L->savedpc = pc;
          {
            if ((char *)L->stack_last - (char *)L->top <=
                (n) * (int)sizeof(TValue))
              luaD_growstack(L, n);
            else
              ((void)0);
            ;
          };
          base = L->base;
        };
        ra = (base +
              (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));
        b = n;
        L->top = ra + n;
      }
      for (j = 0; j < b; j++) {
        if (j < n) {
          {
            const TValue *o2 = (ci->base - n + j);
            TValue *o1 = (ra + j);
            o1->value = o2->value;
            o1->tt = o2->tt;
            ((void)0);
          };
        } else {
          ((ra + j)->tt = 0);
        }
      }
      continue;
    }
    }
  }
}
static inline int luaZ_fill(ZIO *z) {
  size_t size;
  lua_State *L = z->L;
  const char *buff;
  ((void)0);
  buff = z->reader(L, z->data, &size);
  ((void)0);
  if (buff == NULL || size == 0)
    return (-1);
  z->n = size - 1;
  z->p = buff;
  return ((int)(((unsigned char)((*(z->p++))))));
}
static inline int luaZ_lookahead(ZIO *z) {
  if (z->n == 0) {
    if (luaZ_fill(z) == (-1))
      return (-1);
    else {
      z->n++;
      z->p--;
    }
  }
  return ((int)(((unsigned char)((*z->p)))));
}
static inline void luaZ_init(lua_State *L, ZIO *z, lua_Reader reader,
                             void *data) {
  z->L = L;
  z->reader = reader;
  z->data = data;
  z->n = 0;
  z->p = NULL;
}
static inline size_t luaZ_read(ZIO *z, void *b, size_t n) {
  while (n) {
    size_t m;
    if (luaZ_lookahead(z) == (-1))
      return n;
    m = (n <= z->n) ? n : z->n;
    memcpy(b, z->p, m);
    z->n -= m;
    z->p += m;
    b = (char *)b + m;
    n -= m;
  }
  return 0;
}
static inline char *luaZ_openspace(lua_State *L, Mbuffer *buff, size_t n) {
  if (n > buff->buffsize) {
    if (n < 32)
      n = 32;
    ((((buff)->buffer) = ((char *)((
          (((size_t)((n) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(char)))
              ? luaM_realloc_(L, ((buff)->buffer),
                              ((buff)->buffsize) * (sizeof(char)),
                              (n) * (sizeof(char)))
              : luaM_toobig(L))))),
     (buff)->buffsize = n);
  }
  return buff->buffer;
}