-- Generated by make.rkt

--    The Language
--    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

--    This program is free software: you can redistribute it and/or modify
--    it under the terms of the GNU Affero General Public License as published
--    by the Free Software Foundation, either version 3 of the License, or
--    (at your option) any later version.

--    This program is distributed in the hope that it will be useful,
--    but WITHOUT ANY WARRANTY; without even the implied warranty of
--    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--    GNU Affero General Public License for more details.

--    You should have received a copy of the GNU Affero General Public License
--    along with this program.  If not, see <https://www.gnu.org/licenses/>.

--[[ Generated with https://github.com/TypeScriptToLua/TypeScriptToLua ]]
-- Lua Library inline imports
function __TS__ArrayPush(arr, ...)
    local items = ({...})
    for ____TS_index = 1, #items do
        local item = items[____TS_index]
        arr[#arr + 1] = item
    end
    return #arr
end

local ____exports = {}
local LANG_ERROR, LANG_ASSERT, symbols_set_neg, symbol_t, construction_t, null_t, data_t, error_t, just_t, delay_evaluate_t, delay_builtin_func_t, delay_builtin_form_t, delay_apply_t, comment_t, hole_t, new_comment, comment_p, comment_comment, comment_x, un_comment_all, symbol_p, un_symbol_unicodechar, un_symbol, new_construction, construction_p, construction_head, construction_tail, null_v, null_p, new_data, data_p, data_name, data_list, new_error, error_p, error_name, error_list, just_p, un_just, evaluate, delay_evaluate_p, delay_evaluate_env, delay_evaluate_x, builtin_form_apply, delay_builtin_form_p, delay_builtin_form_env, delay_builtin_form_f, delay_builtin_form_xs, builtin_func_apply, delay_builtin_func_p, delay_builtin_func_f, delay_builtin_func_xs, apply, delay_apply_p, delay_apply_f, delay_apply_xs, force_all_rec, new_hole_do, hole_p, lang_set_do, hole_set_do, lang_copy_do, system_symbol, function_symbol, form_symbol, mapping_symbol, the_world_stopped_v, data_name_function_builtin_systemName, data_list_function_builtin_systemName, data_p_function_builtin_systemName, error_name_function_builtin_systemName, error_list_function_builtin_systemName, error_p_function_builtin_systemName, construction_p_function_builtin_systemName, construction_head_function_builtin_systemName, construction_tail_function_builtin_systemName, symbol_p_function_builtin_systemName, null_p_function_builtin_systemName, equal_p_function_builtin_systemName, apply_function_builtin_systemName, evaluate_function_builtin_systemName, if_function_builtin_systemName, quote_form_builtin_systemName, lambda_form_builtin_systemName, function_builtin_use_systemName, form_builtin_use_systemName, form_use_systemName, comment_form_builtin_systemName, symbol_equal_p, jsArray_to_list, new_list, un_just_all, any_delay_p, any_delay_just_p, force_all, force1, force_uncomment_all, env_null_v, env_set, env_get, must_env_get, env2val, env_foreach, real_evaluate, name_p, real_builtin_func_apply_s, real_apply, real_builtin_func_apply, real_builtin_form_apply, make_quote, new_lambda, jsbool_equal_p, simple_print, symbols_set_init, symbols_set_neg_init
function LANG_ERROR()
    error("TheLanguage PANIC")
end
function LANG_ASSERT(x)
    if not x then
        return LANG_ERROR()
    end
end
function new_comment(comment, x)
    return {
        comment_t,
        comment,
        x,
    }
end
function comment_p(x)
    return x[0 + 1] == comment_t
end
function comment_comment(x)
    return x[1 + 1]
end
function comment_x(x)
    return x[2 + 1]
end
function un_comment_all(x)
    while comment_p(x) do
        x = comment_x(x)
    end
    return x
end
function symbol_p(x)
    return x[0 + 1] == symbol_t
end
function un_symbol_unicodechar(x)
    return x[1 + 1]
end
function un_symbol(x)
    return symbols_set_neg()[un_symbol_unicodechar(x)]
end
function new_construction(x, y)
    return {
        construction_t,
        x,
        y,
    }
end
function construction_p(x)
    return x[0 + 1] == construction_t
end
function construction_head(x)
    return x[1 + 1]
end
function construction_tail(x)
    return x[2 + 1]
end
function null_p(x)
    return x[0 + 1] == null_t
end
function new_data(x, y)
    return {
        data_t,
        x,
        y,
    }
end
function data_p(x)
    return x[0 + 1] == data_t
end
function data_name(x)
    return x[1 + 1]
end
function data_list(x)
    return x[2 + 1]
end
function new_error(x, y)
    return {
        error_t,
        x,
        y,
    }
end
function error_p(x)
    return x[0 + 1] == error_t
end
function error_name(x)
    return x[1 + 1]
end
function error_list(x)
    return x[2 + 1]
end
function just_p(x)
    return x[0 + 1] == just_t
end
function un_just(x)
    return x[1 + 1]
end
function evaluate(x, y)
    return {
        delay_evaluate_t,
        x,
        y,
    }
end
function delay_evaluate_p(x)
    return x[0 + 1] == delay_evaluate_t
end
function delay_evaluate_env(x)
    return x[1 + 1]
end
function delay_evaluate_x(x)
    return x[2 + 1]
end
function builtin_form_apply(x, y, z)
    return {
        delay_builtin_form_t,
        x,
        y,
        z,
    }
end
function delay_builtin_form_p(x)
    return x[0 + 1] == delay_builtin_form_t
end
function delay_builtin_form_env(x)
    return x[1 + 1]
end
function delay_builtin_form_f(x)
    return x[2 + 1]
end
function delay_builtin_form_xs(x)
    return x[3 + 1]
end
function builtin_func_apply(x, y)
    return {
        delay_builtin_func_t,
        x,
        y,
    }
end
function delay_builtin_func_p(x)
    return x[0 + 1] == delay_builtin_func_t
end
function delay_builtin_func_f(x)
    return x[1 + 1]
end
function delay_builtin_func_xs(x)
    return x[2 + 1]
end
function apply(f, xs)
    return {
        delay_apply_t,
        f,
        xs,
    }
end
function delay_apply_p(x)
    return x[0 + 1] == delay_apply_t
end
function delay_apply_f(x)
    return x[1 + 1]
end
function delay_apply_xs(x)
    return x[2 + 1]
end
function force_all_rec(raw)
    local x = force_all(raw)
    local function conslike(xx)
        xx[1 + 1] = force_all_rec(xx[1 + 1])
        xx[2 + 1] = force_all_rec(xx[2 + 1])
        return xx
    end
    if data_p(x) then
        return conslike(x)
    elseif error_p(x) then
        return conslike(x)
    elseif construction_p(x) then
        return conslike(x)
    elseif comment_p(x) then
        return conslike(x)
    end
    return x
end
function new_hole_do()
    return {hole_t}
end
function hole_p(x)
    return x[0 + 1] == hole_t
end
function lang_set_do(x, y)
    if x == y then
        return
    end
    x[0 + 1] = just_t
    x[1 + 1] = y
    x[2 + 1] = false
    x[3 + 1] = false
end
function hole_set_do(rawx, rawy)
    LANG_ASSERT(hole_p(rawx))
    local x = rawx
    local y = rawy
    x[0 + 1] = y[0 + 1]
    x[1 + 1] = y[1 + 1]
    x[2 + 1] = y[2 + 1]
    x[3 + 1] = y[3 + 1]
end
function lang_copy_do(x)
    local ret = new_hole_do()
    hole_set_do(ret, x)
    return ret
end
function symbol_equal_p(x, y)
    if x == y then
        return true
    end
    if un_symbol_unicodechar(x) == un_symbol_unicodechar(y) then
        lang_set_do(x, y)
        return true
    else
        return false
    end
end
function jsArray_to_list(xs)
    local ret = null_v
    do
        local i = #xs - 1
        while i >= 0 do
            ret = new_construction(xs[i + 1], ret)
            i = i - 1
        end
    end
    return ret
end
function new_list(...)
    local xs = ({...})
    return jsArray_to_list(xs)
end
function un_just_all(raw)
    if not just_p(raw) then
        return raw
    end
    local x = raw
    local xs = {}
    while just_p(x) do
        __TS__ArrayPush(xs, x)
        x = un_just(x)
    end
    for ____TS_index = 1, #xs do
        local v = xs[____TS_index]
        lang_set_do(v, x)
    end
    return x
end
function any_delay_p(x)
    return delay_evaluate_p(x) or delay_builtin_form_p(x) or delay_builtin_func_p(x) or delay_apply_p(x)
end
function any_delay_just_p(x)
    return just_p(x) or any_delay_p(x)
end
function force_all(raw, parents_history, ref_novalue_replace, xs)
    if parents_history == nil then
        parents_history = {}
    end
    if ref_novalue_replace == nil then
        ref_novalue_replace = {
            false,
            false,
        }
    end
    if xs == nil then
        xs = {}
    end
    local x, do_rewrite, do_rewrite_force_all
    function do_rewrite(newval)
        lang_set_do(x, newval)
        do
            local i = 0
            while i < #xs do
                lang_set_do(xs[i + 1], newval)
                i = i + 1
            end
        end
        return newval
    end
    function do_rewrite_force_all(newval)
        do_rewrite(newval)
        if any_delay_just_p(newval) then
            __TS__ArrayPush(xs, x)
            return force_all(newval, parents_history, {
                false,
                false,
            }, xs)
        end
        return newval
    end
    local history = {}
    x = raw
    local function replace_this_with_stopped()
        ref_novalue_replace[1 + 1] = true
        return do_rewrite_force_all(the_world_stopped_v)
    end
    local function make_history()
        local ret = {}
        for x_id in pairs(history) do
            ret[x_id] = true
        end
        for x_id in pairs(parents_history) do
            ret[x_id] = true
        end
        return ret
    end
    do
        local i = 0
        while any_delay_just_p(x) and i < 32 do
            __TS__ArrayPush(xs, x)
            x = force1(x)
            i = i + 1
        end
    end
    while any_delay_just_p(x) do
        local x_id = simple_print(x)
        if parents_history[x_id] == true then
            return replace_this_with_stopped()
        end
        if history[x_id] == true then
            ref_novalue_replace[0 + 1] = true
            if delay_evaluate_p(x) then
                return replace_this_with_stopped()
            elseif delay_builtin_func_p(x) then
                local f = delay_builtin_func_f(x)
                local xs = delay_builtin_func_xs(x)
                local elim_s = {
                    data_name_function_builtin_systemName,
                    data_list_function_builtin_systemName,
                    data_p_function_builtin_systemName,
                    error_name_function_builtin_systemName,
                    error_list_function_builtin_systemName,
                    error_p_function_builtin_systemName,
                    construction_p_function_builtin_systemName,
                    construction_head_function_builtin_systemName,
                    construction_tail_function_builtin_systemName,
                    symbol_p_function_builtin_systemName,
                    null_p_function_builtin_systemName,
                }
                local is_elim = false
                for ____TS_index = 1, #elim_s do
                    local elim_s_v = elim_s[____TS_index]
                    if jsbool_equal_p(elim_s_v, f) then
                        is_elim = true
                        break
                    end
                end
                if is_elim then
                    LANG_ASSERT(#xs == 1)
                    LANG_ASSERT(ref_novalue_replace[1 + 1] == false)
                    local inner = force_all(xs[0 + 1], make_history(), ref_novalue_replace)
                    if ref_novalue_replace[1 + 1] then
                        return do_rewrite_force_all(builtin_func_apply(f, {inner}))
                    else
                        return LANG_ERROR()
                    end
                end
                if jsbool_equal_p(f, equal_p_function_builtin_systemName) then
                    return replace_this_with_stopped()
                elseif jsbool_equal_p(f, apply_function_builtin_systemName) then
                    return replace_this_with_stopped()
                elseif jsbool_equal_p(f, evaluate_function_builtin_systemName) then
                    return replace_this_with_stopped()
                elseif jsbool_equal_p(f, if_function_builtin_systemName) then
                    LANG_ASSERT(#xs == 3)
                    LANG_ASSERT(ref_novalue_replace[1 + 1] == false)
                    local tf = force_all(xs[0 + 1], make_history(), ref_novalue_replace)
                    if ref_novalue_replace[1 + 1] then
                        return do_rewrite_force_all(builtin_func_apply(if_function_builtin_systemName, {
                            tf,
                            xs[1 + 1],
                            xs[2 + 1],
                        }))
                    else
                        return LANG_ERROR()
                    end
                end
                return LANG_ERROR()
            elseif delay_builtin_form_p(x) then
                return replace_this_with_stopped()
            elseif delay_apply_p(x) then
                return replace_this_with_stopped()
            end
            return LANG_ERROR()
        end
        history[x_id] = true
        __TS__ArrayPush(xs, x)
        x = force1(x)
    end
    return do_rewrite(x)
end
function force1(raw)
    local x = un_just_all(raw)
    local ret
    LANG_ASSERT(not just_p(x))
    if delay_evaluate_p(x) then
        ret = real_evaluate(delay_evaluate_env(x), delay_evaluate_x(x), raw)
    elseif delay_builtin_form_p(x) then
        ret = real_builtin_form_apply(delay_builtin_form_env(x), delay_builtin_form_f(x), delay_builtin_form_xs(x), raw)
    elseif delay_builtin_func_p(x) then
        ret = real_builtin_func_apply(delay_builtin_func_f(x), delay_builtin_func_xs(x), raw)
    elseif delay_apply_p(x) then
        ret = real_apply(delay_apply_f(x), delay_apply_xs(x), raw)
    else
        ret = x
    end
    ret = un_just_all(ret)
    lang_set_do(x, ret)
    return ret
end
function force_uncomment_all(x)
    while any_delay_just_p(x) or comment_p(x) do
        x = force_all(un_comment_all(x))
    end
    return x
end
function env_set(env, key, val)
    local ret = {}
    do
        local i = 0
        while i < #env do
            if jsbool_equal_p(env[(i + 0) + 1], key) then
                ret[(i + 0) + 1] = key
                ret[(i + 1) + 1] = val
                do
                    i = i + 2
                    while i < #env do
                        ret[(i + 0) + 1] = env[(i + 0) + 1]
                        ret[(i + 1) + 1] = env[(i + 1) + 1]
                        i = i + 2
                    end
                end
                return ret
            else
                ret[(i + 0) + 1] = env[(i + 0) + 1]
                ret[(i + 1) + 1] = env[(i + 1) + 1]
            end
            i = i + 2
        end
    end
    ret[(#env + 0) + 1] = key
    ret[(#env + 1) + 1] = val
    return ret
end
function env_get(env, key, default_v)
    do
        local i = 0
        while i < #env do
            if jsbool_equal_p(env[(i + 0) + 1], key) then
                return env[(i + 1) + 1]
            end
            i = i + 2
        end
    end
    return default_v
end
function must_env_get(env, key)
    do
        local i = 0
        while i < #env do
            if jsbool_equal_p(env[(i + 0) + 1], key) then
                return env[(i + 1) + 1]
            end
            i = i + 2
        end
    end
    return LANG_ERROR()
end
function env2val(env)
    local ret = null_v
    do
        local i = 0
        while i < #env do
            ret = new_construction(new_list(env[(i + 0) + 1], env[(i + 1) + 1]), ret)
            i = i + 2
        end
    end
    return new_data(mapping_symbol, new_list(ret))
end
function env_foreach(env, f)
    do
        local i = 0
        while i < #env do
            f(env[(i + 0) + 1], env[(i + 1) + 1])
            i = i + 2
        end
    end
end
function real_evaluate(env, raw, selfvalraw)
    local x = force1(raw)
    if any_delay_just_p(x) then
        return selfvalraw
    end
    local error_v = new_error(system_symbol, new_list(function_builtin_use_systemName, new_list(evaluate_function_builtin_systemName, new_list(env2val(env), x))))
    if construction_p(x) then
        local xs = {}
        local rest = x
        while not null_p(rest) do
            if any_delay_just_p(rest) then
                return selfvalraw
            elseif construction_p(rest) then
                __TS__ArrayPush(xs, construction_head(rest))
                rest = force1(construction_tail(rest))
            else
                return error_v
            end
        end
        if jsbool_equal_p(xs[0 + 1], form_builtin_use_systemName) then
            if #xs == 1 then
                return error_v
            end
            local f = xs[1 + 1]
            local args = {}
            do
                local i = 2
                while i < #xs do
                    __TS__ArrayPush(args, xs[i + 1])
                    i = i + 1
                end
            end
            return builtin_form_apply(env, f, args)
        elseif jsbool_equal_p(xs[0 + 1], form_use_systemName) then
            if #xs == 1 then
                return error_v
            end
            local f = force_all(evaluate(env, xs[1 + 1]))
            if not data_p(f) then
                return error_v
            end
            local f_type = force1(data_name(f))
            if any_delay_just_p(f_type) then
                return selfvalraw
            end
            if not symbol_p(f_type) then
                return error_v
            end
            if not symbol_equal_p(f_type, form_symbol) then
                return error_v
            end
            local f_list = force1(data_list(f))
            if any_delay_just_p(f_list) then
                return selfvalraw
            end
            if not construction_p(f_list) then
                return error_v
            end
            local f_x = construction_head(f_list)
            local f_list_cdr = force1(construction_tail(f_list))
            if any_delay_just_p(f_list_cdr) then
                return selfvalraw
            end
            if not null_p(f_list_cdr) then
                return error_v
            end
            local args = {env2val(env)}
            do
                local i = 2
                while i < #xs do
                    __TS__ArrayPush(args, xs[i + 1])
                    i = i + 1
                end
            end
            return apply(f_x, args)
        elseif jsbool_equal_p(xs[0 + 1], function_builtin_use_systemName) then
            if #xs == 1 then
                return error_v
            end
            local f = xs[1 + 1]
            local args = {}
            do
                local i = 2
                while i < #xs do
                    __TS__ArrayPush(args, evaluate(env, xs[i + 1]))
                    i = i + 1
                end
            end
            return builtin_func_apply(f, args)
        else
            local f = evaluate(env, xs[0 + 1])
            local args = {}
            do
                local i = 1
                while i < #xs do
                    __TS__ArrayPush(args, evaluate(env, xs[i + 1]))
                    i = i + 1
                end
            end
            return apply(f, args)
        end
    elseif null_p(x) then
        return x
    elseif name_p(x) then
        return env_get(env, x, error_v)
    elseif error_p(x) then
        return error_v
    end
    return LANG_ERROR()
end
function name_p(x)
    return symbol_p(x) or data_p(x)
end
function real_apply(f, xs, selfvalraw)
    local function make_error_v()
        return new_error(system_symbol, new_list(function_builtin_use_systemName, new_list(apply_function_builtin_systemName, new_list(f, jsArray_to_list(xs)))))
    end
    f = force1(f)
    if any_delay_just_p(f) then
        return selfvalraw
    end
    if not data_p(f) then
        return make_error_v()
    end
    local f_type = force_all(data_name(f))
    if not (symbol_p(f_type) and symbol_equal_p(f_type, function_symbol)) then
        return make_error_v()
    end
    local f_list = force_all(data_list(f))
    if not construction_p(f_list) then
        return make_error_v()
    end
    local args_pat = force_all_rec(construction_head(f_list))
    local f_list_cdr = force_all(construction_tail(f_list))
    if not (construction_p(f_list_cdr) and null_p(force_all(construction_tail(f_list_cdr)))) then
        return make_error_v()
    end
    local f_code = construction_head(f_list_cdr)
    local env = env_null_v
    local xs_i = 0
    while not null_p(args_pat) do
        if name_p(args_pat) then
            local x = null_v
            do
                local i = #xs - 1
                while i >= xs_i do
                    x = new_construction(xs[i + 1], x)
                    i = i - 1
                end
            end
            env = env_set(env, args_pat, x)
            xs_i = #xs
            args_pat = null_v
        elseif construction_p(args_pat) then
            if xs_i < #xs then
                local x = xs[xs_i + 1]
                xs_i = xs_i + 1
                env = env_set(env, construction_head(args_pat), x)
                args_pat = construction_tail(args_pat)
            else
                return make_error_v()
            end
        else
            return make_error_v()
        end
    end
    if #xs ~= xs_i then
        return make_error_v()
    end
    return evaluate(env, f_code)
end
function real_builtin_func_apply(f, xs, selfvalraw)
    local error_v = new_error(system_symbol, new_list(function_builtin_use_systemName, new_list(f, jsArray_to_list(xs))))
    for ____TS_index = 1, #real_builtin_func_apply_s do
        local xx = real_builtin_func_apply_s[____TS_index]
        if jsbool_equal_p(f, xx[0 + 1]) then
            if #xs ~= xx[1 + 1] then
                return error_v
            end
            if xx[1 + 1] == 1 then
                return xx[2 + 1](xs[0 + 1], error_v, selfvalraw)
            elseif xx[1 + 1] == 2 then
                return xx[2 + 1](xs[0 + 1], xs[1 + 1], error_v, selfvalraw)
            elseif xx[1 + 1] == 3 then
                return xx[2 + 1](xs[0 + 1], xs[1 + 1], xs[2 + 1], error_v, selfvalraw)
            end
            return LANG_ERROR()
        end
    end
    return error_v
end
function real_builtin_form_apply(env, f, xs, selfvalraw)
    local error_v = new_error(system_symbol, new_list(form_builtin_use_systemName, new_list(env2val(env), f, jsArray_to_list(xs))))
    if jsbool_equal_p(f, quote_form_builtin_systemName) then
        if #xs ~= 1 then
            return error_v
        end
        return xs[0 + 1]
    elseif jsbool_equal_p(f, lambda_form_builtin_systemName) then
        if #xs ~= 2 then
            return error_v
        end
        return new_lambda(env, xs[0 + 1], xs[1 + 1], error_v)
    elseif jsbool_equal_p(f, comment_form_builtin_systemName) then
        if #xs ~= 2 then
            return error_v
        end
        return new_comment(xs[0 + 1], evaluate(env, xs[1 + 1]))
    end
    return error_v
end
function make_quote(x)
    return new_list(form_builtin_use_systemName, quote_form_builtin_systemName, x)
end
function new_lambda(env, args_pat, body, error_v)
    if error_v == nil then
        error_v = false
    end
    local function make_error_v()
        if error_v == false then
            return new_error(system_symbol, new_list(form_builtin_use_systemName, new_list(env2val(env), lambda_form_builtin_systemName, jsArray_to_list({
                args_pat,
                body,
            }))))
        else
            return error_v
        end
    end
    args_pat = force_all_rec(args_pat)
    local args_pat_vars = {}
    local args_pat_is_dot = false
    local args_pat_iter = args_pat
    while not null_p(args_pat_iter) do
        if name_p(args_pat_iter) then
            __TS__ArrayPush(args_pat_vars, args_pat_iter)
            args_pat_is_dot = true
            args_pat_iter = null_v
        elseif construction_p(args_pat_iter) then
            __TS__ArrayPush(args_pat_vars, construction_head(args_pat_iter))
            args_pat_iter = construction_tail(args_pat_iter)
        else
            return make_error_v()
        end
    end
    local args_pat_vars_val = args_pat
    if args_pat_is_dot then
        args_pat_vars_val = jsArray_to_list(args_pat_vars)
    end
    local env_vars = {}
    env_foreach(env, function(k, v)
        do
            local i = 0
            while i < #args_pat_vars do
                if jsbool_equal_p(args_pat_vars[i + 1], k) then
                    return
                end
                i = i + 1
            end
        end
        __TS__ArrayPush(env_vars, k)
    end)
    local new_args_pat = args_pat_vars_val
    do
        local i = #env_vars - 1
        while i >= 0 do
            new_args_pat = new_construction(env_vars[i + 1], new_args_pat)
            i = i - 1
        end
    end
    local new_args = args_pat_vars_val
    do
        local i = #env_vars - 1
        while i >= 0 do
            new_args = new_construction(make_quote(must_env_get(env, env_vars[i + 1])), new_args)
            i = i - 1
        end
    end
    return new_data(function_symbol, new_list(args_pat, new_construction(make_quote(new_data(function_symbol, new_list(new_args_pat, body))), new_args)))
end
function jsbool_equal_p(x, y)
    if x == y then
        return true
    end
    x = force_all(x)
    y = force_all(y)
    if x == y then
        return true
    end
    local function end_2(xx, yy, f1, f2)
        if jsbool_equal_p(f1(xx), f1(yy)) and jsbool_equal_p(f2(xx), f2(yy)) then
            lang_set_do(xx, yy)
            return true
        else
            return false
        end
    end
    if null_p(x) then
        if not null_p(y) then
            return false
        end
        lang_set_do(x, null_v)
        lang_set_do(y, null_v)
        return true
    elseif symbol_p(x) then
        if not symbol_p(y) then
            return false
        end
        return symbol_equal_p(x, y)
    elseif construction_p(x) then
        if not construction_p(y) then
            return false
        end
        return end_2(x, y, construction_head, construction_tail)
    elseif error_p(x) then
        if not error_p(y) then
            return false
        end
        return end_2(x, y, error_name, error_list)
    elseif data_p(x) then
        if not data_p(y) then
            return false
        end
        return end_2(x, y, data_name, data_list)
    end
    return LANG_ERROR()
end
function simple_print(x)
    x = un_just_all(x)
    local temp = ""
    local prefix = ""
    if null_p(x) then
        return "()"
    elseif construction_p(x) then
        temp = "("
        prefix = ""
        while construction_p(x) do
            temp = tostring(temp) .. tostring(prefix) .. tostring(simple_print(construction_head(x)))
            prefix = " "
            x = un_just_all(construction_tail(x))
        end
        if null_p(x) then
            temp = tostring(temp) .. ")"
        else
            temp = tostring(temp) .. " . " .. tostring(simple_print(x)) .. ")"
        end
        return temp
    elseif data_p(x) then
        return "#" .. tostring(simple_print(new_construction(data_name(x), data_list(x))))
    elseif error_p(x) then
        return "!" .. tostring(simple_print(new_construction(error_name(x), error_list(x))))
    elseif symbol_p(x) then
        return un_symbol(x)
    elseif comment_p(x) then
        return ";(" .. tostring(simple_print(comment_comment(x))) .. " " .. tostring(simple_print(comment_x(x))) .. ")"
    elseif delay_evaluate_p(x) then
        return "$(" .. tostring(simple_print(env2val(delay_evaluate_env(x)))) .. " " .. tostring(simple_print(delay_evaluate_x(x))) .. ")"
    elseif delay_builtin_func_p(x) then
        return "%(" .. tostring(simple_print(delay_builtin_func_f(x))) .. " " .. tostring(simple_print(jsArray_to_list(delay_builtin_func_xs(x)))) .. ")"
    elseif delay_builtin_form_p(x) then
        return "@(" .. tostring(simple_print(env2val(delay_builtin_form_env(x)))) .. " " .. tostring(simple_print(delay_builtin_form_f(x))) .. " " .. tostring(simple_print(jsArray_to_list(delay_builtin_form_xs(x)))) .. ")"
    elseif delay_apply_p(x) then
        return "^(" .. tostring(simple_print(delay_apply_f(x))) .. " " .. tostring(simple_print(jsArray_to_list(delay_apply_xs(x)))) .. ")"
    end
    return LANG_ERROR()
end
function symbols_set_init()
    return {
        ["0"] = "0",
        ["1"] = "1",
        ["2"] = "2",
        ["3"] = "3",
        ["4"] = "4",
        ["5"] = "5",
        ["6"] = "6",
        ["7"] = "7",
        ["8"] = "8",
        ["9"] = "9",
        A = "A",
        B = "B",
        C = "C",
        D = "D",
        E = "E",
        F = "F",
        G = "G",
        H = "H",
        I = "I",
        J = "J",
        K = "K",
        L = "L",
        M = "M",
        N = "N",
        O = "O",
        P = "P",
        Q = "Q",
        R = "R",
        S = "S",
        T = "T",
        U = "U",
        V = "V",
        W = "W",
        X = "X",
        Y = "Y",
        Z = "Z",
        a = "a",
        b = "b",
        c = "c",
        d = "d",
        e = "e",
        f = "f",
        g = "g",
        h = "h",
        i = "i",
        j = "j",
        k = "k",
        l = "l",
        m = "m",
        n = "n",
        o = "o",
        p = "p",
        q = "q",
        r = "r",
        s = "s",
        t = "t",
        u = "u",
        v = "v",
        w = "w",
        x = "x",
        y = "y",
        z = "z",
        ["一類何物"] = "㝉",
        ["之物"] = "𫙦",
        ["其子"] = "𦮪",
        ["出入改滅"] = "𢒟",
        ["列序"] = "𠜺",
        ["化滅"] = "𠏁",
        ["參形"] = "𠫰",
        ["吾自"] = "𦣹",
        ["太始初核"] = "𣝗",
        ["如若"] = "𦱡",
        ["宇宙亡矣"] = "𨹹",
        ["尾末"] = "𡲵",
        ["序丁"] = "𠆤",
        ["序丙"] = "𠇮",
        ["序乙"] = "㐈",
        ["序甲"] = "𠇚",
        ["式形"] = "佱",
        ["引用"] = "㧈",
        ["應用"] = "𤰆",
        ["效應"] = "効",
        ["映表"] = "𤅔",
        ["是非"] = "欤",
        ["構物"] = "𡒫",
        ["為符名連"] = "‐",
        ["爻陰"] = "侌",
        ["爻陽"] = "𣆄",
        ["特定其物"] = "亓",
        ["省略一物"] = "畧",
        ["符名"] = "謼",
        ["等同"] = "弌",
        ["解算"] = "筭",
        ["註疏"] = "疎",
        ["詞素"] = "𧥝",
        ["謬誤"] = "䥘",
        ["連頸"] = "丩",
        ["間空"] = "𣣓",
        ["首始"] = "𩠐",
    }
end
function symbols_set_neg_init()
    return {
        ["0"] = "0",
        ["1"] = "1",
        ["2"] = "2",
        ["3"] = "3",
        ["4"] = "4",
        ["5"] = "5",
        ["6"] = "6",
        ["7"] = "7",
        ["8"] = "8",
        ["9"] = "9",
        A = "A",
        B = "B",
        C = "C",
        D = "D",
        E = "E",
        F = "F",
        G = "G",
        H = "H",
        I = "I",
        J = "J",
        K = "K",
        L = "L",
        M = "M",
        N = "N",
        O = "O",
        P = "P",
        Q = "Q",
        R = "R",
        S = "S",
        T = "T",
        U = "U",
        V = "V",
        W = "W",
        X = "X",
        Y = "Y",
        Z = "Z",
        a = "a",
        b = "b",
        c = "c",
        d = "d",
        e = "e",
        f = "f",
        g = "g",
        h = "h",
        i = "i",
        j = "j",
        k = "k",
        l = "l",
        m = "m",
        n = "n",
        o = "o",
        p = "p",
        q = "q",
        r = "r",
        s = "s",
        t = "t",
        u = "u",
        v = "v",
        w = "w",
        x = "x",
        y = "y",
        z = "z",
        ["㝉"] = "一類何物",
        ["𫙦"] = "之物",
        ["𦮪"] = "其子",
        ["𢒟"] = "出入改滅",
        ["𠜺"] = "列序",
        ["𠏁"] = "化滅",
        ["𠫰"] = "參形",
        ["𦣹"] = "吾自",
        ["𣝗"] = "太始初核",
        ["𦱡"] = "如若",
        ["𨹹"] = "宇宙亡矣",
        ["𡲵"] = "尾末",
        ["𠆤"] = "序丁",
        ["𠇮"] = "序丙",
        ["㐈"] = "序乙",
        ["𠇚"] = "序甲",
        ["佱"] = "式形",
        ["㧈"] = "引用",
        ["𤰆"] = "應用",
        ["効"] = "效應",
        ["𤅔"] = "映表",
        ["欤"] = "是非",
        ["𡒫"] = "構物",
        ["‐"] = "為符名連",
        ["侌"] = "爻陰",
        ["𣆄"] = "爻陽",
        ["亓"] = "特定其物",
        ["畧"] = "省略一物",
        ["謼"] = "符名",
        ["弌"] = "等同",
        ["筭"] = "解算",
        ["疎"] = "註疏",
        ["𧥝"] = "詞素",
        ["䥘"] = "謬誤",
        ["丩"] = "連頸",
        ["𣣓"] = "間空",
        ["𩠐"] = "首始",
    }
end
local symbols_set
symbols_set = function()
    local r = symbols_set_init()
    symbols_set = function() return r end
    return r
end
symbols_set_neg = function()
    local r = symbols_set_neg_init()
    symbols_set_neg = function() return r end
    return r
end
symbol_t = 0
construction_t = 1
null_t = 2
data_t = 3
error_t = 4
just_t = 5
delay_evaluate_t = 6
delay_builtin_func_t = 7
delay_builtin_form_t = 8
delay_apply_t = 9
comment_t = 11
hole_t = 10
____exports.new_comment = new_comment
____exports.comment_p = comment_p
____exports.comment_comment = comment_comment
____exports.comment_x = comment_x
____exports.un_comment_all = un_comment_all
local function can_new_symbol_unicodechar_p(x)
    return symbols_set_neg()[x] ~= nil
end
local function new_symbol_unicodechar(x)
    return {
        symbol_t,
        x,
    }
end
local function can_new_symbol_p(x)
    return symbols_set()[x] ~= nil
end
local function new_symbol(x)
    return new_symbol_unicodechar(symbols_set()[x])
end
____exports.can_new_symbol_p = can_new_symbol_p
____exports.New_Symbol = New_Symbol
____exports.new_symbol = new_symbol
____exports.symbol_p = symbol_p
____exports.un_symbol = un_symbol
____exports.New_Construction = New_Construction
____exports.new_construction = new_construction
____exports.construction_p = construction_p
____exports.construction_head = construction_head
____exports.construction_tail = construction_tail
null_v = {null_t}
____exports.Null_V = Null_V
____exports.null_v = null_v
____exports.null_p = null_p
____exports.New_Data = New_Data
____exports.new_data = new_data
____exports.data_p = data_p
____exports.data_name = data_name
____exports.data_list = data_list
____exports.New_Error = New_Error
____exports.new_error = new_error
____exports.error_p = error_p
____exports.error_name = error_name
____exports.error_list = error_list
____exports.just_p = just_p
____exports.evaluate = evaluate
____exports.apply = apply
local function force_uncomment_all_rec(raw)
    local x = force_uncomment_all(raw)
    local function conslike(xx)
        xx[1 + 1] = force_all_rec(xx[1 + 1])
        xx[2 + 1] = force_all_rec(xx[2 + 1])
        if comment_p(xx[1 + 1]) or comment_p(xx[2 + 1]) then
            local ret = lang_copy_do(xx)
            local a = xx[1 + 1]
            local d = xx[2 + 1]
            local a1 = force_uncomment_all_rec(a)
            local d1 = force_uncomment_all_rec(d)
            ret[1 + 1] = a1
            ret[2 + 1] = d1
            return ret
        else
            return xx
        end
    end
    if data_p(x) then
        return conslike(x)
    elseif error_p(x) then
        return conslike(x)
    elseif construction_p(x) then
        return conslike(x)
    end
    return x
end
____exports.force_all_rec = force_all_rec
____exports.force_uncomment_all_rec = force_uncomment_all_rec
system_symbol = new_symbol("太始初核")
local name_symbol = new_symbol("符名")
function_symbol = new_symbol("化滅")
form_symbol = new_symbol("式形")
local equal_symbol = new_symbol("等同")
local evaluate_sym = new_symbol("解算")
local theThing_symbol = new_symbol("特定其物")
local something_symbol = new_symbol("省略一物")
mapping_symbol = new_symbol("映表")
local if_symbol = new_symbol("如若")
local typeAnnotation_symbol = new_symbol("一類何物")
local isOrNot_symbol = new_symbol("是非")
local sub_symbol = new_symbol("其子")
local true_symbol = new_symbol("爻陽")
local false_symbol = new_symbol("爻陰")
local quote_symbol = new_symbol("引用")
local apply_symbol = new_symbol("應用")
local null_symbol = new_symbol("間空")
local construction_symbol = new_symbol("連頸")
local data_symbol = new_symbol("構物")
local error_symbol = new_symbol("謬誤")
local symbol_symbol = new_symbol("詞素")
local list_symbol = new_symbol("列序")
local head_symbol = new_symbol("首始")
local tail_symbol = new_symbol("尾末")
local thing_symbol = new_symbol("之物")
local theWorldStopped_symbol = new_symbol("宇宙亡矣")
local effect_symbol = new_symbol("效應")
local comment_symbol = new_symbol("註疏")
the_world_stopped_v = new_error(system_symbol, new_list(theWorldStopped_symbol, something_symbol))
local function systemName_make(x)
    return new_data(name_symbol, new_construction(system_symbol, new_construction(x, null_v)))
end
local function make_builtin_f_new_sym_f(x_sym)
    return systemName_make(new_list(typeAnnotation_symbol, new_list(function_symbol, something_symbol, x_sym), theThing_symbol))
end
local function make_builtin_f_get_sym_f(t_sym, x_sym)
    return systemName_make(new_list(typeAnnotation_symbol, new_list(function_symbol, new_list(t_sym), something_symbol), x_sym))
end
local function make_builtin_f_p_sym_f(t_sym)
    return systemName_make(new_list(typeAnnotation_symbol, function_symbol, new_list(isOrNot_symbol, new_list(typeAnnotation_symbol, t_sym, something_symbol))))
end
local new_data_function_builtin_systemName = make_builtin_f_new_sym_f(data_symbol)
data_name_function_builtin_systemName = make_builtin_f_get_sym_f(data_symbol, name_symbol)
data_list_function_builtin_systemName = make_builtin_f_get_sym_f(data_symbol, list_symbol)
data_p_function_builtin_systemName = make_builtin_f_p_sym_f(data_symbol)
local new_error_function_builtin_systemName = make_builtin_f_new_sym_f(error_symbol)
error_name_function_builtin_systemName = make_builtin_f_get_sym_f(error_symbol, name_symbol)
error_list_function_builtin_systemName = make_builtin_f_get_sym_f(error_symbol, list_symbol)
error_p_function_builtin_systemName = make_builtin_f_p_sym_f(error_symbol)
local new_construction_function_builtin_systemName = make_builtin_f_new_sym_f(construction_symbol)
construction_p_function_builtin_systemName = make_builtin_f_p_sym_f(construction_symbol)
construction_head_function_builtin_systemName = make_builtin_f_get_sym_f(construction_symbol, head_symbol)
construction_tail_function_builtin_systemName = make_builtin_f_get_sym_f(construction_symbol, tail_symbol)
symbol_p_function_builtin_systemName = make_builtin_f_p_sym_f(symbol_symbol)
null_p_function_builtin_systemName = make_builtin_f_p_sym_f(null_symbol)
equal_p_function_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, function_symbol, new_list(isOrNot_symbol, equal_symbol)))
apply_function_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, new_list(function_symbol, new_construction(function_symbol, something_symbol), something_symbol), apply_symbol))
evaluate_function_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, function_symbol, evaluate_sym))
local list_chooseOne_function_builtin_systemName = make_builtin_f_get_sym_f(list_symbol, new_list(typeAnnotation_symbol, thing_symbol, something_symbol))
if_function_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, function_symbol, if_symbol))
quote_form_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, form_symbol, quote_symbol))
lambda_form_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, new_list(form_symbol, new_list(function_symbol, something_symbol, function_symbol)), theThing_symbol))
function_builtin_use_systemName = systemName_make(new_list(form_symbol, new_list(system_symbol, function_symbol)))
form_builtin_use_systemName = systemName_make(new_list(form_symbol, new_list(system_symbol, form_symbol)))
form_use_systemName = systemName_make(new_list(form_symbol, form_symbol))
local comment_function_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, function_symbol, comment_symbol))
comment_form_builtin_systemName = systemName_make(new_list(typeAnnotation_symbol, form_symbol, comment_symbol))
local false_v = new_data(false_symbol, new_list())
local true_v = new_data(true_symbol, new_list())
local function list_to_jsArray(xs, k_done, k_tail)
    local ret = {}
    while construction_p(xs) do
        __TS__ArrayPush(ret, construction_head(xs))
        xs = construction_tail(xs)
    end
    if null_p(xs) then
        return k_done(ret)
    end
    return k_tail(ret, xs)
end
local function maybe_list_to_jsArray(xs)
    return list_to_jsArray(xs, function(x) return x end, function(_1, _2) return false end)
end
____exports.jsArray_to_list = jsArray_to_list
____exports.maybe_list_to_jsArray = maybe_list_to_jsArray
____exports.new_list = new_list
local function un_just_comment_all(x)
    while just_p(x) or comment_p(x) do
        x = un_just_all(un_comment_all(x))
    end
    return x
end
____exports.un_just = un_just_all
____exports.un_just_comment_all = un_just_comment_all
____exports.delay_p = any_delay_p
____exports.delay_just_p = any_delay_just_p
local function any_delay2delay_evaluate(x)
    if delay_evaluate_p(x) then
        return x
    elseif delay_builtin_form_p(x) then
        error("WIP")
    elseif delay_builtin_func_p(x) then
        error("WIP")
    elseif delay_apply_p(x) then
        error("WIP")
    end
    return LANG_ERROR()
end
local function any_delay_env(x)
    return delay_evaluate_env(any_delay2delay_evaluate(x))
end
local function any_delay_x(x)
    return delay_evaluate_x(any_delay2delay_evaluate(x))
end
____exports.delay_env = any_delay_env
____exports.delay_x = any_delay_x
local function force_all_export(raw)
    return force_all(raw)
end
local function force_uncomment1(raw)
    if comment_p(raw) then
        return comment_x(raw)
    else
        return force1(raw)
    end
end
____exports.force_all = force_all_export
____exports.force1 = force1
____exports.force_uncomment1 = force_uncomment1
____exports.force_uncomment_all = force_uncomment_all
env_null_v = {}
local function val2env(x)
    x = force_all(x)
    if not data_p(x) then
        return false
    end
    local s = force_all(data_name(x))
    if not symbol_p(s) then
        return false
    end
    if not symbol_equal_p(s, mapping_symbol) then
        return false
    end
    s = force_all(data_list(x))
    if not construction_p(s) then
        return false
    end
    if not null_p(force_all(construction_tail(s))) then
        return false
    end
    local ret = {}
    local xs = force_all(construction_head(s))
    while not null_p(xs) do
        if not construction_p(xs) then
            return false
        end
        local x = force_all(construction_head(xs))
        xs = force_all(construction_tail(xs))
        if not construction_p(x) then
            return false
        end
        local k = construction_head(x)
        x = force_all(construction_tail(x))
        if not construction_p(x) then
            return false
        end
        local v = construction_head(x)
        if not null_p(force_all(construction_tail(x))) then
            return false
        end
        local not_breaked = true
        do
            local i = 0
            while i < #ret do
                if jsbool_equal_p(ret[(i + 0) + 1], k) then
                    ret[(i + 1) + 1] = v
                    not_breaked = false
                    break
                end
                i = i + 2
            end
        end
        if not_breaked then
            __TS__ArrayPush(ret, k)
            __TS__ArrayPush(ret, v)
        end
    end
    return ret
end
____exports.env_null_v = env_null_v
____exports.env_set = env_set
____exports.env_get = env_get
____exports.env2val = env2val
____exports.env_foreach = env_foreach
____exports.val2env = val2env
local function make_builtin_p_func(p_sym, p_jsfunc)
    return {
        p_sym,
        1,
        function(x, error_v)
            x = force1(x)
            if any_delay_just_p(x) then
                return builtin_func_apply(p_sym, {x})
            end
            if p_jsfunc(x) then
                return true_v
            end
            return false_v
        end,
    }
end
local function make_builtin_get_func(f_sym, p_jsfunc, f_jsfunc)
    return {
        f_sym,
        1,
        function(x, error_v)
            x = force1(x)
            if any_delay_just_p(x) then
                return builtin_func_apply(f_sym, {x})
            end
            if p_jsfunc(x) then
                return f_jsfunc(x)
            end
            return error_v
        end,
    }
end
real_builtin_func_apply_s = {
    make_builtin_p_func(data_p_function_builtin_systemName, data_p),
    {
        new_data_function_builtin_systemName,
        2,
        new_data,
    },
    make_builtin_get_func(data_name_function_builtin_systemName, data_p, data_name),
    make_builtin_get_func(data_list_function_builtin_systemName, data_p, data_list),
    make_builtin_p_func(error_p_function_builtin_systemName, error_p),
    {
        new_error_function_builtin_systemName,
        2,
        new_error,
    },
    make_builtin_get_func(error_name_function_builtin_systemName, error_p, error_name),
    make_builtin_get_func(error_list_function_builtin_systemName, error_p, error_list),
    make_builtin_p_func(null_p_function_builtin_systemName, null_p),
    {
        new_construction_function_builtin_systemName,
        2,
        new_construction,
    },
    make_builtin_p_func(construction_p_function_builtin_systemName, construction_p),
    make_builtin_get_func(construction_head_function_builtin_systemName, construction_p, construction_head),
    make_builtin_get_func(construction_tail_function_builtin_systemName, construction_p, construction_tail),
    {
        equal_p_function_builtin_systemName,
        2,
        function(x, y, error_v)
            if x == y then
                return true_v
            end
            x = force1(x)
            y = force1(y)
            if any_delay_just_p(x) or any_delay_just_p(y) then
                return builtin_func_apply(equal_p_function_builtin_systemName, {
                    x,
                    y,
                })
            end
            if x == y then
                return true_v
            end
            local function H_if(b, xx, yy)
                return builtin_func_apply(if_function_builtin_systemName, {
                    b,
                    xx,
                    yy,
                })
            end
            local function H_and(xx, yy)
                return H_if(xx, yy, false_v)
            end
            LANG_ASSERT(not any_delay_just_p(x))
            local function end_2(xx, yy, f1, f2)
                return H_and(builtin_func_apply(equal_p_function_builtin_systemName, {
                    f1(xx),
                    f1(yy),
                }), builtin_func_apply(equal_p_function_builtin_systemName, {
                    f2(xx),
                    f2(yy),
                }))
            end
            if null_p(x) then
                if not null_p(x) then
                    return false_v
                end
                return true_v
            elseif symbol_p(x) then
                if not symbol_p(y) then
                    return false_v
                end
                if symbol_equal_p(x, y) then
                    return true_v
                else
                    return false_v
                end
            elseif data_p(x) then
                if not data_p(y) then
                    return false_v
                end
                return end_2(x, y, data_name, data_list)
            elseif construction_p(x) then
                if not construction_p(y) then
                    return false_v
                end
                return end_2(x, y, construction_head, construction_tail)
            elseif error_p(x) then
                if not error_p(y) then
                    return false_v
                end
                return end_2(x, y, error_name, error_list)
            end
            return LANG_ERROR()
        end,
    },
    {
        apply_function_builtin_systemName,
        2,
        function(f, xs, error_v)
            local jslist = {}
            local iter = force_all(xs)
            while construction_p(iter) do
                __TS__ArrayPush(jslist, construction_head(iter))
                iter = force_all(construction_tail(iter))
            end
            if not null_p(iter) then
                return error_v
            end
            return apply(f, jslist)
        end,
    },
    {
        evaluate_function_builtin_systemName,
        2,
        function(env, x, error_v)
            local maybeenv = val2env(env)
            if maybeenv == false then
                return error_v
            end
            return evaluate(maybeenv, x)
        end,
    },
    make_builtin_p_func(symbol_p_function_builtin_systemName, symbol_p),
    {
        list_chooseOne_function_builtin_systemName,
        1,
        function(xs, error_v)
            xs = force1(xs)
            if any_delay_just_p(xs) then
                return builtin_func_apply(list_chooseOne_function_builtin_systemName, {xs})
            end
            if not construction_p(xs) then
                return error_v
            end
            return construction_head(xs)
        end,
    },
    {
        if_function_builtin_systemName,
        3,
        function(b, x, y, error_v)
            b = force1(b)
            if any_delay_just_p(b) then
                return builtin_func_apply(if_function_builtin_systemName, {
                    b,
                    x,
                    y,
                })
            end
            if not data_p(b) then
                return error_v
            end
            local nam = force_all(data_name(b))
            if not symbol_p(nam) then
                return error_v
            end
            if symbol_equal_p(nam, true_symbol) then
                return x
            end
            if symbol_equal_p(nam, false_symbol) then
                return y
            end
            return error_v
        end,
    },
    {
        comment_function_builtin_systemName,
        2,
        new_comment,
    },
}
____exports.equal_p = jsbool_equal_p
local function jsbool_no_force_equal_p(x, y)
    if x == y then
        return true
    end
    x = un_just_all(x)
    y = un_just_all(y)
    if x == y then
        return true
    end
    local function end_2(xx, yy, f1, f2)
        if jsbool_no_force_equal_p(f1(xx), f1(yy)) and jsbool_no_force_equal_p(f2(xx), f2(yy)) then
            lang_set_do(xx, yy)
            return true
        else
            return false
        end
    end
    if null_p(x) then
        if not null_p(y) then
            return false
        end
        lang_set_do(x, null_v)
        lang_set_do(y, null_v)
        return true
    elseif symbol_p(x) then
        if not symbol_p(y) then
            return false
        end
        return symbol_equal_p(x, y)
    elseif construction_p(x) then
        if not construction_p(y) then
            return false
        end
        return end_2(x, y, construction_head, construction_tail)
    elseif error_p(x) then
        if not error_p(y) then
            return false
        end
        return end_2(x, y, error_name, error_list)
    elseif data_p(x) then
        if not data_p(y) then
            return false
        end
        return end_2(x, y, data_name, data_list)
    elseif delay_evaluate_p(x) then
        error("WIP")
    elseif delay_builtin_func_p(x) then
        error("WIP")
    elseif delay_builtin_form_p(x) then
        error("WIP")
    elseif delay_apply_p(x) then
        error("WIP")
    end
    return LANG_ERROR()
end
local function simple_print_force_all_rec(x)
    return simple_print(force_all_rec(x))
end
____exports.simple_print = simple_print
____exports.simple_print_force_all_rec = simple_print_force_all_rec
local function complex_parse(x)
    local state_const, state, eof, get, put, parse_error, a_space_p, space, symbol, readlist, data, readerror, readeval, readfuncapply, readformbuiltin, readapply, readcomment, a_symbol_p, val, un_maybe, not_eof, assert_get, readsysname_no_pack_inner_must, may_xfx_xf, readsysname_no_pack, readsysname
    function eof()
        return #state_const == state
    end
    function get()
        LANG_ASSERT(not eof())
        local ret = string.sub(state_const, state + 1, state + 1)
        state = state + 1
        return ret
    end
    function put(chr)
        LANG_ASSERT(string.sub(state_const, (state - 1) + 1, (state - 1) + 1) == chr)
        state = state - 1
    end
    function parse_error(x)
        if x == nil then
            x = ""
        end
        error("TheLanguage parse ERROR!" .. tostring(x))
    end
    function a_space_p(chr)
        return chr == " " or chr == "\n" or chr == "\t" or chr == "\r"
    end
    function space()
        if eof() then
            return false
        end
        local x = get()
        if not a_space_p(x) then
            put(x)
            return false
        end
        while a_space_p(x) and not eof() do
            x = get()
        end
        if not a_space_p(x) then
            put(x)
        end
        return true
    end
    function symbol()
        if eof() then
            return false
        end
        local x = get()
        local ret = ""
        if not a_symbol_p(x) then
            put(x)
            return false
        end
        while a_symbol_p(x) and not eof() do
            ret = tostring(ret) .. tostring(x)
            x = get()
        end
        if a_symbol_p(x) then
            ret = tostring(ret) .. tostring(x)
        else
            put(x)
        end
        if can_new_symbol_p(ret) then
            return new_symbol(ret)
        else
            return parse_error("Not Symbol" .. tostring(ret))
        end
    end
    function readlist()
        if eof() then
            return false
        end
        local x = get()
        if x ~= "(" then
            put(x)
            return false
        end
        local ret_last = new_hole_do()
        local ret = ret_last
        local function last_add_do(val)
            local ret_last2 = new_hole_do()
            hole_set_do(ret_last, new_construction(val, ret_last2))
            ret_last = ret_last2
        end
        while true do
            space()
            if eof() then
                return parse_error()
            end
            x = get()
            if x == ")" then
                hole_set_do(ret_last, null_v)
                return ret
            end
            if x == "." then
                space()
                local e = val()
                hole_set_do(ret_last, e)
                space()
                if eof() then
                    return parse_error()
                end
                x = get()
                if x ~= ")" then
                    return parse_error()
                end
                return ret
            end
            put(x)
            local e = val()
            last_add_do(e)
        end
    end
    function data()
        if eof() then
            return false
        end
        local x = get()
        if x ~= "#" then
            put(x)
            return false
        end
        local xs = readlist()
        if xs == false then
            return parse_error()
        end
        if not construction_p(xs) then
            return parse_error()
        end
        return new_data(construction_head(xs), construction_tail(xs))
    end
    function readerror()
        if eof() then
            return false
        end
        local x = get()
        if x ~= "!" then
            put(x)
            return false
        end
        local xs = readlist()
        if xs == false then
            return parse_error()
        end
        if not construction_p(xs) then
            return parse_error()
        end
        return new_error(construction_head(xs), construction_tail(xs))
    end
    function a_symbol_p(chr)
        if a_space_p(chr) then
            return false
        end
        local ____TS_array = {
            "(",
            ")",
            "!",
            "#",
            ".",
            "$",
            "%",
            "^",
            "@",
            "~",
            "/",
            "-",
            ">",
            "_",
            ":",
            "?",
            "[",
            "]",
            "&",
            ";",
        }
        for ____TS_index = 1, #____TS_array do
            local v = ____TS_array[____TS_index]
            if v == chr then
                return false
            end
        end
        return true
    end
    function val()
        space()
        local fs = {
            readlist,
            readsysname,
            data,
            readerror,
            readeval,
            readfuncapply,
            readformbuiltin,
            readapply,
            readcomment,
        }
        for ____TS_index = 1, #fs do
            local f = fs[____TS_index]
            local x = f()
            if x ~= false then
                return x
            end
        end
        return parse_error()
    end
    function un_maybe(vl)
        if vl == false then
            return parse_error()
        end
        return vl
    end
    function not_eof()
        return not eof()
    end
    function assert_get(c)
        un_maybe(not_eof())
        un_maybe(get() == c)
    end
    function readsysname_no_pack_inner_must(strict)
        if strict == nil then
            strict = false
        end
        local function readsysname_no_pack_bracket()
            assert_get("[")
            local x = readsysname_no_pack_inner_must()
            assert_get("]")
            return x
        end
        local fs
        if strict then
            fs = {
                readlist,
                symbol,
                readsysname_no_pack_bracket,
                data,
                readerror,
                readeval,
                readfuncapply,
                readformbuiltin,
                readapply,
                readcomment,
            }
        else
            fs = {
                readlist,
                readsysname_no_pack,
                data,
                readerror,
                readeval,
                readfuncapply,
                readformbuiltin,
                readapply,
                readcomment,
            }
        end
        for ____TS_index = 1, #fs do
            local f = fs[____TS_index]
            local x = f()
            if x ~= false then
                return x
            end
        end
        return parse_error()
    end
    function may_xfx_xf(vl)
        if eof() then
            return vl
        end
        local head = get()
        if head == "." then
            local y = readsysname_no_pack_inner_must()
            return new_list(typeAnnotation_symbol, new_list(function_symbol, new_list(vl), something_symbol), y)
        elseif head == ":" then
            local y = readsysname_no_pack_inner_must()
            return new_list(typeAnnotation_symbol, y, vl)
        elseif head == "~" then
            return new_list(isOrNot_symbol, vl)
        elseif head == "@" then
            local y = readsysname_no_pack_inner_must()
            return new_list(typeAnnotation_symbol, new_list(function_symbol, new_construction(vl, something_symbol), something_symbol), y)
        elseif head == "?" then
            return new_list(typeAnnotation_symbol, function_symbol, new_list(isOrNot_symbol, vl))
        elseif head == "/" then
            local ys = {vl}
            while true do
                local y = readsysname_no_pack_inner_must(true)
                __TS__ArrayPush(ys, y)
                if eof() then
                    break
                end
                local c0 = get()
                if c0 ~= "/" then
                    put(c0)
                    break
                end
            end
            return new_list(sub_symbol, jsArray_to_list(ys))
        else
            put(head)
            return vl
        end
    end
    function readsysname_no_pack()
        if eof() then
            return false
        end
        local head = get()
        if head == "&" then
            un_maybe(not_eof())
            local c0 = get()
            if c0 == "+" then
                local x = readsysname_no_pack_inner_must()
                return new_list(form_symbol, new_list(system_symbol, x))
            else
                put(c0)
            end
            local x = readsysname_no_pack_inner_must()
            return new_list(form_symbol, x)
        elseif head == ":" then
            un_maybe(not_eof())
            local c0 = get()
            if c0 == "&" then
                assert_get(">")
                local x = readsysname_no_pack_inner_must()
                return new_list(typeAnnotation_symbol, new_list(form_symbol, new_list(function_symbol, something_symbol, x)), theThing_symbol)
            elseif c0 == ">" then
                local x = readsysname_no_pack_inner_must()
                return new_list(typeAnnotation_symbol, new_list(function_symbol, something_symbol, x), theThing_symbol)
            else
                put(c0)
            end
            local x = readsysname_no_pack_inner_must()
            return new_list(typeAnnotation_symbol, x, theThing_symbol)
        elseif head == "+" then
            local x = readsysname_no_pack_inner_must()
            return new_list(system_symbol, x)
        elseif head == "[" then
            local x = readsysname_no_pack_inner_must()
            assert_get("]")
            return may_xfx_xf(x)
        elseif head == "_" then
            assert_get(":")
            local x = readsysname_no_pack_inner_must()
            return new_list(typeAnnotation_symbol, x, something_symbol)
        else
            put(head)
            local x = symbol()
            if x == false then
                return false
            end
            return may_xfx_xf(x)
        end
    end
    function readsysname()
        local x = readsysname_no_pack()
        if x == false then
            return false
        end
        if symbol_p(x) then
            return x
        end
        return systemName_make(x)
    end
    state_const = x
    state = 0
    local function make_read_two(prefix, k)
        return function()
            if eof() then
                return false
            end
            local c = get()
            if c ~= prefix then
                put(c)
                return false
            end
            local xs = readlist()
            if xs == false then
                return parse_error()
            end
            if not construction_p(xs) then
                return parse_error()
            end
            local x = construction_tail(xs)
            if not (construction_p(x) and null_p(construction_tail(x))) then
                return parse_error()
            end
            return k(construction_head(xs), construction_head(x))
        end
    end
    local function make_read_three(prefix, k)
        return function()
            if eof() then
                return false
            end
            local c = get()
            if c ~= prefix then
                put(c)
                return false
            end
            local xs = readlist()
            if xs == false then
                return parse_error()
            end
            if not construction_p(xs) then
                return parse_error()
            end
            local x = construction_tail(xs)
            if not construction_p(x) then
                return parse_error()
            end
            local x_d = construction_tail(x)
            if not (construction_p(x_d) and null_p(construction_tail(x_d))) then
                return parse_error()
            end
            return k(construction_head(xs), construction_head(x), construction_head(x_d))
        end
    end
    readeval = make_read_two("$", function(ev, val)
        local env = val2env(ev)
        if env == false then
            return parse_error()
        end
        return evaluate(env, val)
    end)
    readfuncapply = make_read_two("%", function(f, xs)
        local jsxs = list_to_jsArray(xs, function(v) return v end, function(_1, _2) return parse_error() end)
        return builtin_func_apply(f, jsxs)
    end)
    readformbuiltin = make_read_three("@", function(e, f, xs)
        local jsxs = list_to_jsArray(xs, function(v) return v end, function(_1, _2) return parse_error() end)
        local env = val2env(e)
        if env == false then
            return parse_error()
        end
        return builtin_form_apply(env, f, jsxs)
    end)
    readapply = make_read_two("^", function(f, xs)
        local jsxs = list_to_jsArray(xs, function(v) return v end, function(_1, _2) return parse_error() end)
        return apply(f, jsxs)
    end)
    readcomment = make_read_two(";", function(comment, x) return new_comment(comment, x) end)
    return val()
end
____exports.complex_parse = complex_parse
local function complex_print(val)
    local function print_sys_name(x, is_inner_bool)
        if symbol_p(x) then
            return un_symbol(x)
        end
        local function inner_bracket(vl)
            if is_inner_bool then
                return "[" .. tostring(vl) .. "]"
            else
                return vl
            end
        end
        local maybe_xs = maybe_list_to_jsArray(x)
        if maybe_xs ~= false and #maybe_xs == 3 and jsbool_no_force_equal_p(maybe_xs[0 + 1], typeAnnotation_symbol) then
            local maybe_lst_2 = maybe_list_to_jsArray(maybe_xs[1 + 1])
            if maybe_lst_2 ~= false and #maybe_lst_2 == 3 and jsbool_no_force_equal_p(maybe_lst_2[0 + 1], function_symbol) then
                local var_2_1 = maybe_lst_2[1 + 1]
                local maybe_lst_3 = maybe_list_to_jsArray(var_2_1)
                if maybe_lst_3 ~= false and #maybe_lst_3 == 1 and jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
                    return inner_bracket(tostring(print_sys_name(maybe_lst_3[0 + 1], true)) .. "." .. tostring(print_sys_name(maybe_xs[2 + 1], true)))
                elseif construction_p(var_2_1) and jsbool_no_force_equal_p(construction_tail(var_2_1), something_symbol) and jsbool_no_force_equal_p(maybe_lst_2[2 + 1], something_symbol) then
                    return inner_bracket(tostring(print_sys_name(construction_head(var_2_1), true)) .. "@" .. tostring(print_sys_name(maybe_xs[2 + 1], true)))
                elseif jsbool_no_force_equal_p(var_2_1, something_symbol) and jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) then
                    return inner_bracket(":>" .. tostring(print_sys_name(maybe_lst_2[2 + 1], true)))
                end
            end
            local maybe_lst_44 = maybe_list_to_jsArray(maybe_xs[2 + 1])
            if jsbool_no_force_equal_p(maybe_xs[1 + 1], function_symbol) and maybe_lst_44 ~= false and #maybe_lst_44 == 2 and jsbool_no_force_equal_p(maybe_lst_44[0 + 1], isOrNot_symbol) then
                return inner_bracket(tostring(print_sys_name(maybe_lst_44[1 + 1], true)) .. "?")
            end
            if maybe_lst_2 ~= false and #maybe_lst_2 == 2 and jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) and jsbool_no_force_equal_p(maybe_lst_2[0 + 1], form_symbol) then
                local maybe_lst_88 = maybe_list_to_jsArray(maybe_lst_2[1 + 1])
                if maybe_lst_88 ~= false and #maybe_lst_88 == 3 and jsbool_no_force_equal_p(maybe_lst_88[0 + 1], function_symbol) and jsbool_no_force_equal_p(maybe_lst_88[1 + 1], something_symbol) then
                    return inner_bracket(":&>" .. tostring(print_sys_name(maybe_lst_88[2 + 1], true)))
                end
            end
            local hd = jsbool_no_force_equal_p(maybe_xs[2 + 1], something_symbol) and "_" or jsbool_no_force_equal_p(maybe_xs[2 + 1], theThing_symbol) and "" or print_sys_name(maybe_xs[2 + 1], true)
            return inner_bracket(tostring(hd) .. ":" .. tostring(print_sys_name(maybe_xs[1 + 1], true)))
        elseif maybe_xs ~= false and #maybe_xs == 2 then
            if jsbool_no_force_equal_p(maybe_xs[0 + 1], form_symbol) then
                local maybe_lst_288 = maybe_list_to_jsArray(maybe_xs[1 + 1])
                if maybe_lst_288 ~= false and #maybe_lst_288 == 2 and jsbool_no_force_equal_p(maybe_lst_288[0 + 1], system_symbol) then
                    return inner_bracket("&+" .. tostring(print_sys_name(maybe_lst_288[1 + 1], true)))
                end
                return inner_bracket("&" .. tostring(print_sys_name(maybe_xs[1 + 1], true)))
            elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], isOrNot_symbol) then
                return inner_bracket(tostring(print_sys_name(maybe_xs[1 + 1], true)) .. "~")
            elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol) then
                return inner_bracket("+" .. tostring(print_sys_name(maybe_xs[1 + 1], true)))
            elseif jsbool_no_force_equal_p(maybe_xs[0 + 1], sub_symbol) then
                local maybe_lst_8934 = maybe_list_to_jsArray(maybe_xs[1 + 1])
                if maybe_lst_8934 ~= false and #maybe_lst_8934 > 1 then
                    local tmp = print_sys_name(maybe_lst_8934[0 + 1], true)
                    do
                        local i = 1
                        while i < #maybe_lst_8934 do
                            tmp = tostring(tmp) .. "/" .. tostring(print_sys_name(maybe_lst_8934[i + 1], true))
                            i = i + 1
                        end
                    end
                    return inner_bracket(tmp)
                end
            end
        end
        if is_inner_bool then
            return simple_print(x)
        else
            return simple_print(systemName_make(x))
        end
    end
    local x = complex_parse(simple_print(val))
    local temp = ""
    local prefix = ""
    if null_p(x) then
        return "()"
    elseif construction_p(x) then
        temp = "("
        prefix = ""
        while construction_p(x) do
            temp = tostring(temp) .. tostring(prefix) .. tostring(complex_print(construction_head(x)))
            prefix = " "
            x = construction_tail(x)
        end
        if null_p(x) then
            temp = tostring(temp) .. ")"
        else
            temp = tostring(temp) .. " . " .. tostring(complex_print(x)) .. ")"
        end
        return temp
    elseif data_p(x) then
        local name = data_name(x)
        local list = data_list(x)
        local maybe_xs = maybe_list_to_jsArray(list)
        if maybe_xs ~= false and #maybe_xs == 2 and jsbool_no_force_equal_p(name, name_symbol) and jsbool_no_force_equal_p(maybe_xs[0 + 1], system_symbol) then
            return print_sys_name(maybe_xs[1 + 1], false)
        end
        return "#" .. tostring(complex_print(new_construction(name, list)))
    elseif error_p(x) then
        return "!" .. tostring(complex_print(new_construction(error_name(x), error_list(x))))
    elseif symbol_p(x) then
        return un_symbol(x)
    elseif comment_p(x) then
        return ";(" .. tostring(complex_print(comment_comment(x))) .. " " .. tostring(complex_print(comment_x(x))) .. ")"
    elseif delay_evaluate_p(x) then
        return "$(" .. tostring(complex_print(env2val(delay_evaluate_env(x)))) .. " " .. tostring(complex_print(delay_evaluate_x(x))) .. ")"
    elseif delay_builtin_func_p(x) then
        return "%(" .. tostring(complex_print(delay_builtin_func_f(x))) .. " " .. tostring(complex_print(jsArray_to_list(delay_builtin_func_xs(x)))) .. ")"
    elseif delay_builtin_form_p(x) then
        return "@(" .. tostring(complex_print(env2val(delay_builtin_form_env(x)))) .. " " .. tostring(complex_print(delay_builtin_form_f(x))) .. " " .. tostring(complex_print(jsArray_to_list(delay_builtin_form_xs(x)))) .. ")"
    elseif delay_apply_p(x) then
        return "^(" .. tostring(complex_print(delay_apply_f(x))) .. " " .. tostring(complex_print(jsArray_to_list(delay_apply_xs(x)))) .. ")"
    end
    return LANG_ERROR()
end
____exports.complex_print = complex_print
local function machinetext_parse(rawstr)
    local result = new_hole_do()
    local stack = {result}
    local state = 0
    local function parse_error()
        error("MT parse ERROR")
    end
    local function parse_assert(x)
        if not x then
            return parse_error()
        end
    end
    local function get_do()
        parse_assert(#rawstr > state)
        local result = string.sub(rawstr, state + 1, state + 1)
        state = state + 1
        return result
    end
    while #stack ~= 0 do
        local new_stack = {}
        for ____TS_index = 1, #stack do
            local hol = stack[____TS_index]
            local chr = get_do()
            local conslike
            conslike = function(c)
                local hol1 = new_hole_do()
                local hol2 = new_hole_do()
                __TS__ArrayPush(new_stack, hol1)
                __TS__ArrayPush(new_stack, hol2)
                hole_set_do(hol, c(hol1, hol2))
            end
            if chr == "^" then
                local tmp = ""
                while true do
                    local chr = get_do()
                    if chr == "^" then
                        break
                    end
                    tmp = tostring(tmp) .. tostring(chr)
                end
                if can_new_symbol_unicodechar_p(tmp) then
                    hole_set_do(hol, new_symbol_unicodechar(tmp))
                else
                    return parse_error()
                end
            elseif chr == "." then
                conslike(new_construction)
            elseif chr == "#" then
                conslike(new_data)
            elseif chr == "!" then
                conslike(new_error)
            elseif chr == "$" then
                conslike(function(x, y) return evaluate(env_null_v, new_list(function_builtin_use_systemName, evaluate_function_builtin_systemName, make_quote(x), make_quote(y))) end)
            elseif chr == "_" then
                hole_set_do(hol, null_v)
            else
                return parse_error()
            end
        end
        stack = new_stack
    end
    parse_assert(state == #rawstr)
    return result
end
local function machinetext_print(x)
    local stack = {x}
    local result = ""
    while #stack ~= 0 do
        local new_stack = {}
        for ____TS_index = 1, #stack do
            local x = stack[____TS_index]
            x = un_just_all(x)
            local conslike
            conslike = function(xx, s, g1, g2)
                result = tostring(result) .. tostring(s)
                __TS__ArrayPush(new_stack, g1(xx))
                __TS__ArrayPush(new_stack, g2(xx))
            end
            if symbol_p(x) then
                result = tostring(result) .. "^"
                result = tostring(result) .. tostring(un_symbol_unicodechar(x))
                result = tostring(result) .. "^"
            elseif construction_p(x) then
                conslike(x, ".", construction_head, construction_tail)
            elseif null_p(x) then
                result = tostring(result) .. "_"
            elseif data_p(x) then
                conslike(x, "#", data_name, data_list)
            elseif error_p(x) then
                conslike(x, "!", error_name, error_list)
            elseif any_delay_p(x) then
                local y = any_delay2delay_evaluate(x)
                conslike(y, "$", (function(vl) return env2val(delay_evaluate_env(vl)) end), delay_evaluate_x)
            else
                return LANG_ERROR()
            end
        end
        stack = new_stack
    end
    return result
end
____exports.machinetext_parse = machinetext_parse
____exports.machinetext_print = machinetext_print
local function trampoline_return(x)
    return function() return {
        false,
        x,
    } end
end
local function trampoline_delay(x)
    return function() return {
        true,
        x(),
    } end
end
local function run_trampoline(x)
    local i = x()
    while i[0 + 1] do
        i = i[1 + 1]()
    end
    return i[1 + 1]
end
____exports.trampoline_return = trampoline_return
____exports.trampoline_delay = trampoline_delay
____exports.run_trampoline = run_trampoline
local return_effect_systemName = systemName_make(new_construction(sub_symbol, new_construction(new_construction(effect_symbol, new_construction(new_construction(typeAnnotation_symbol, new_construction(thing_symbol, new_construction(something_symbol, null_v))), null_v)), null_v)))
local bind_effect_systemName = systemName_make(new_construction(sub_symbol, new_construction(new_construction(effect_symbol, new_construction(construction_symbol, null_v)), null_v)))
local function new_effect_bind(monad, func)
    return new_data(bind_effect_systemName, new_list(monad, func))
end
local function new_effect_return(x)
    return new_data(return_effect_systemName, x)
end
local function run_monad_helper(return_handler, op_handler, code, state, next)
    if next == nil then
        next = false
    end
    local function make_bind(x, f)
        error("WIP")
    end
    code = force_all(code)
    if data_p(code) then
        local name = data_name(code)
        local list = data_list(code)
        if jsbool_equal_p(name, return_effect_systemName) then
            list = force_all(list)
            if construction_p(list) then
                local list_a = construction_head(list)
                local list_d = force_all(construction_tail(list))
                if null_p(list_d) then
                    if next == false then
                        local upval_v = list_a
                        local upval_st = state
                        local r
                        r = function() return return_handler(upval_v, upval_st) end
                        return trampoline_delay(r)
                    else
                        local upval_rt
                        upval_rt = return_handler
                        local upval_op
                        upval_op = op_handler
                        local upval_v = list_a
                        local upval_st = state
                        local r
                        r = function() return run_monad_helper(upval_rt, upval_op, apply(next, upval_v), upval_st) end
                        return trampoline_delay(r)
                    end
                end
            end
        elseif jsbool_equal_p(name, bind_effect_systemName) then
            list = force_all(list)
            if construction_p(list) then
                local list_a = construction_head(list)
                local list_d = force_all(construction_tail(list))
                if construction_p(list_d) then
                    local list_d_a = construction_head(list_d)
                    local list_d_d = force_all(construction_tail(list_d))
                    if null_p(list_d_d) then
                        if next == false then
                            local upval_rt
                            upval_rt = return_handler
                            local upval_op
                            upval_op = op_handler
                            local upval_a = list_a
                            local upval_b = list_d_a
                            local upval_st = state
                            local r
                            r = function() return run_monad_helper(upval_rt, upval_op, upval_a, upval_st, upval_b) end
                            return trampoline_delay(r)
                        else
                            local upval_rt
                            upval_rt = return_handler
                            local upval_op
                            upval_op = op_handler
                            local upval_a = list_a
                            local upval_b = list_d_a
                            local upval_st = state
                            local upval_nt = next
                            local x = new_symbol("序甲")
                            local r
                            r = function() return run_monad_helper(upval_rt, upval_op, upval_a, upval_st, new_data(function_symbol, new_list(new_list(x), make_bind(new_list(make_quote(upval_b), x), make_quote(upval_nt))))) end
                            return trampoline_delay(r)
                        end
                    end
                end
            end
        end
    end
    if next == false then
        return trampoline_delay(function() return op_handler(code, state, return_handler) end)
    else
        return trampoline_delay(function() return op_handler(code, state, function(val2, state2) return trampoline_delay(function() return run_monad_helper(return_handler, op_handler, apply(next, {val2}), state2) end) end) end)
    end
end
local function run_monad_trampoline(return_handler, op_handler, code, state)
    return run_monad_helper(return_handler, op_handler, code, state)
end
local function run_monad_stackoverflow(return_handler, op_handler, code, state)
    return run_trampoline(run_monad_helper((function(v, s) return trampoline_return(return_handler(v, s)) end), (function(op, st, rs) return trampoline_return(op_handler(op, st, function(v, s) return run_trampoline(rs(v, s)) end)) end), code, state))
end
____exports.Return_Effect_SystemName = Return_Effect_SystemName
____exports.return_effect_systemName = return_effect_systemName
____exports.Bind_Effect_SystemName = Bind_Effect_SystemName
____exports.bind_effect_systemName = bind_effect_systemName
____exports.new_effect_bind = new_effect_bind
____exports.new_effect_return = new_effect_return
____exports.run_monad_trampoline = run_monad_trampoline
____exports.run_monad_stackoverflow = run_monad_stackoverflow
return ____exports