/* Generated by make.rkt */
/*
    The Language
    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
function LANG_ERROR() {
    throw "TheLanguage PANIC";
}
function LANG_ASSERT(x) {
    if (!x) {
        return LANG_ERROR();
    }
}
function symbols_set_init() { return { "0": "0", "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F", "G": "G", "H": "H", "I": "I", "J": "J", "K": "K", "L": "L", "M": "M", "N": "N", "O": "O", "P": "P", "Q": "Q", "R": "R", "S": "S", "T": "T", "U": "U", "V": "V", "W": "W", "X": "X", "Y": "Y", "Z": "Z", "a": "a", "b": "b", "c": "c", "d": "d", "e": "e", "f": "f", "g": "g", "h": "h", "i": "i", "j": "j", "k": "k", "l": "l", "m": "m", "n": "n", "o": "o", "p": "p", "q": "q", "r": "r", "s": "s", "t": "t", "u": "u", "v": "v", "w": "w", "x": "x", "y": "y", "z": "z", "一類何物": "㝉", "之物": "𫙦", "其子": "𦮪", "出入改滅": "𢒟", "列序": "𠜺", "化滅": "𠏁", "參形": "𠫰", "吾自": "𦣹", "太始初核": "𣝗", "如若": "𦱡", "宇宙亡矣": "𨹹", "尾末": "𡲵", "序丁": "𠆤", "序丙": "𠇮", "序乙": "㐈", "序甲": "𠇚", "式形": "佱", "引用": "㧈", "應用": "𤰆", "效應": "効", "映表": "𤅔", "是非": "欤", "構物": "𡒫", "為符名連": "‐", "爻陰": "侌", "爻陽": "𣆄", "特定其物": "亓", "省略一物": "畧", "符名": "謼", "等同": "弌", "解算": "筭", "註疏": "疎", "詞素": "𧥝", "謬誤": "䥘", "連頸": "丩", "間空": "𣣓", "首始": "𩠐" }; }
function symbols_set_neg_init() { return { "0": "0", "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F", "G": "G", "H": "H", "I": "I", "J": "J", "K": "K", "L": "L", "M": "M", "N": "N", "O": "O", "P": "P", "Q": "Q", "R": "R", "S": "S", "T": "T", "U": "U", "V": "V", "W": "W", "X": "X", "Y": "Y", "Z": "Z", "a": "a", "b": "b", "c": "c", "d": "d", "e": "e", "f": "f", "g": "g", "h": "h", "i": "i", "j": "j", "k": "k", "l": "l", "m": "m", "n": "n", "o": "o", "p": "p", "q": "q", "r": "r", "s": "s", "t": "t", "u": "u", "v": "v", "w": "w", "x": "x", "y": "y", "z": "z", "㝉": "一類何物", "𫙦": "之物", "𦮪": "其子", "𢒟": "出入改滅", "𠜺": "列序", "𠏁": "化滅", "𠫰": "參形", "𦣹": "吾自", "𣝗": "太始初核", "𦱡": "如若", "𨹹": "宇宙亡矣", "𡲵": "尾末", "𠆤": "序丁", "𠇮": "序丙", "㐈": "序乙", "𠇚": "序甲", "佱": "式形", "㧈": "引用", "𤰆": "應用", "効": "效應", "𤅔": "映表", "欤": "是非", "𡒫": "構物", "‐": "為符名連", "侌": "爻陰", "𣆄": "爻陽", "亓": "特定其物", "畧": "省略一物", "謼": "符名", "弌": "等同", "筭": "解算", "疎": "註疏", "𧥝": "詞素", "䥘": "謬誤", "丩": "連頸", "𣣓": "間空", "𩠐": "首始" }; }
let symbols_set = () => {
    const r = symbols_set_init();
    symbols_set = () => r;
    return r;
};
let symbols_set_neg = () => {
    const r = symbols_set_neg_init();
    symbols_set_neg = () => r;
    return r;
};
const atom_t = 0;
const construction_t = 1;
const null_t = 2;
const data_t = 3;
const error_t = 4;
const just_t = 5;
const delay_evaluate_t = 6;
const delay_builtin_func_t = 7;
const delay_builtin_form_t = 8;
const delay_apply_t = 9;
const comment_t = 11;
const hole_t = 10;
function new_comment(comment, x) {
    return [comment_t, comment, x];
}
function comment_p(x) {
    return x[0] === comment_t;
}
function comment_comment(x) {
    return x[1];
}
function comment_x(x) {
    return x[2];
}
function un_comment_all(x) {
    while (comment_p(x)) {
        x = comment_x(x);
    }
    return x;
}
export { new_comment, comment_p, comment_comment, comment_x, un_comment_all };
function can_new_atom_unicodechar_p(x) {
    return x in symbols_set_neg();
}
function new_atom_unicodechar(x) {
    return [atom_t, x];
}
function atom_p(x) {
    return x[0] === atom_t;
}
function un_atom_unicodechar(x) {
    return x[1];
}
function can_new_atom_p(x) {
    return x in symbols_set();
}
function new_atom(x) {
    return new_atom_unicodechar(symbols_set()[x]);
}
function un_atom(x) {
    return symbols_set_neg()[un_atom_unicodechar(x)];
}
function atom_equal_p(x, y) {
    if (x === y) {
        return true;
    }
    if (un_atom_unicodechar(x) === un_atom_unicodechar(y)) {
        lang_set_do(x, y);
        return true;
    }
    else {
        return false;
    }
}
export { can_new_atom_p, new_atom, atom_p, un_atom, atom_equal_p };
function new_construction(x, y) {
    return [construction_t, x, y];
}
function construction_p(x) {
    return x[0] === construction_t;
}
function construction_head(x) {
    return x[1];
}
function construction_tail(x) {
    return x[2];
}
export { new_construction, construction_p, construction_head, construction_tail };
const null_v = [null_t];
function null_p(x) {
    return x[0] === null_t;
}
export { null_v, null_p };
function new_data(x, y) {
    return [data_t, x, y];
}
function data_p(x) {
    return x[0] === data_t;
}
function data_name(x) {
    return x[1];
}
function data_list(x) {
    return x[2];
}
export { new_data, data_p, data_name, data_list };
function new_error(x, y) {
    return [error_t, x, y];
}
function error_p(x) {
    return x[0] === error_t;
}
function error_name(x) {
    return x[1];
}
function error_list(x) {
    return x[2];
}
export { new_error, error_p, error_name, error_list };
function just_p(x) {
    return x[0] === just_t;
}
export { just_p };
function un_just(x) {
    return x[1];
}
function evaluate(x, y) {
    return [delay_evaluate_t, x, y];
}
export { evaluate };
function delay_evaluate_p(x) {
    return x[0] === delay_evaluate_t;
}
function delay_evaluate_env(x) {
    return x[1];
}
function delay_evaluate_x(x) {
    return x[2];
}
function builtin_form_apply(x, y, z) {
    return [delay_builtin_form_t, x, y, z];
}
function delay_builtin_form_p(x) {
    return x[0] === delay_builtin_form_t;
}
function delay_builtin_form_env(x) {
    return x[1];
}
function delay_builtin_form_f(x) {
    return x[2];
}
function delay_builtin_form_xs(x) {
    return x[3];
}
function builtin_func_apply(x, y) {
    return [delay_builtin_func_t, x, y];
}
function delay_builtin_func_p(x) {
    return x[0] === delay_builtin_func_t;
}
function delay_builtin_func_f(x) {
    return x[1];
}
function delay_builtin_func_xs(x) {
    return x[2];
}
function apply(f, xs) {
    return [delay_apply_t, f, xs];
}
export { apply };
function delay_apply_p(x) {
    return x[0] === delay_apply_t;
}
function delay_apply_f(x) {
    return x[1];
}
function delay_apply_xs(x) {
    return x[2];
}
function force_all_rec(raw) {
    const x = force_all(raw);
    function conslike(xx) {
        xx[1] = force_all_rec(xx[1]);
        xx[2] = force_all_rec(xx[2]);
        return xx;
    }
    if (data_p(x)) {
        return conslike(x);
    }
    else if (error_p(x)) {
        return conslike(x);
    }
    else if (construction_p(x)) {
        return conslike(x);
    }
    else if (comment_p(x)) {
        return conslike(x);
    }
    return x;
}
function force_uncomment_all_rec(raw) {
    const x = force_uncomment_all(raw);
    function conslike(xx) {
        xx[1] = force_all_rec(xx[1]);
        xx[2] = force_all_rec(xx[2]);
        if (comment_p(xx[1]) || comment_p(xx[2])) {
            const ret = lang_copy_do(xx);
            const a = xx[1];
            const d = xx[2];
            const a1 = force_uncomment_all_rec(a);
            const d1 = force_uncomment_all_rec(d);
            ret[1] = a1;
            ret[2] = d1;
            return ret;
        }
        else {
            return xx;
        }
    }
    if (data_p(x)) {
        return conslike(x);
    }
    else if (error_p(x)) {
        return conslike(x);
    }
    else if (construction_p(x)) {
        return conslike(x);
    }
    return x;
}
export { force_all_rec, force_uncomment_all_rec };
function new_hole_do() {
    return [hole_t];
}
function hole_p(x) {
    return x[0] === hole_t;
}
function lang_set_do(x, y) {
    if (x === y) {
        return;
    }
    x[0] = just_t;
    x[1] = y;
    x[2] = false;
    x[3] = false;
}
function hole_set_do(rawx, rawy) {
    LANG_ASSERT(hole_p(rawx));
    LANG_ASSERT(!hole_p(rawy));
    const x = rawx;
    const y = rawy;
    x[0] = y[0];
    x[1] = y[1];
    x[2] = y[2];
    x[3] = y[3];
}
function lang_copy_do(x) {
    const ret = new_hole_do();
    hole_set_do(ret, x);
    return ret;
}
const system_atom = new_atom("太始初核");
const name_atom = new_atom("符名");
const function_atom = new_atom("化滅");
const form_atom = new_atom("式形");
const equal_atom = new_atom("等同");
const evaluate_sym = new_atom("解算");
const theThing_atom = new_atom("特定其物");
const something_atom = new_atom("省略一物");
const mapping_atom = new_atom("映表");
const if_atom = new_atom("如若");
const typeAnnotation_atom = new_atom("一類何物");
const isOrNot_atom = new_atom("是非");
const sub_atom = new_atom("其子");
const true_atom = new_atom("爻陽");
const false_atom = new_atom("爻陰");
const quote_atom = new_atom("引用");
const apply_atom = new_atom("應用");
const null_atom = new_atom("間空");
const construction_atom = new_atom("連頸");
const data_atom = new_atom("構物");
const error_atom = new_atom("謬誤");
const atom_atom = new_atom("詞素");
const list_atom = new_atom("列序");
const head_atom = new_atom("首始");
const tail_atom = new_atom("尾末");
const thing_atom = new_atom("之物");
const theWorldStopped_atom = new_atom("宇宙亡矣");
const effect_atom = new_atom("效應");
const comment_atom = new_atom("註疏");
const the_world_stopped_v = new_error(system_atom, new_list(theWorldStopped_atom, something_atom));
function systemName_make(x) {
    return new_data(name_atom, new_construction(system_atom, new_construction(x, null_v)));
}
function make_builtin_f_new_sym_f(x_sym) {
    return systemName_make(new_list(typeAnnotation_atom, new_list(function_atom, something_atom, x_sym), theThing_atom));
}
function make_builtin_f_get_sym_f(t_sym, x_sym) {
    return systemName_make(new_list(typeAnnotation_atom, new_list(function_atom, new_list(t_sym), something_atom), x_sym));
}
function make_builtin_f_p_sym_f(t_sym) {
    return systemName_make(new_list(typeAnnotation_atom, function_atom, new_list(isOrNot_atom, new_list(typeAnnotation_atom, t_sym, something_atom))));
}
const new_data_function_builtin_systemName = make_builtin_f_new_sym_f(data_atom);
const data_name_function_builtin_systemName = make_builtin_f_get_sym_f(data_atom, name_atom);
const data_list_function_builtin_systemName = make_builtin_f_get_sym_f(data_atom, list_atom);
const data_p_function_builtin_systemName = make_builtin_f_p_sym_f(data_atom);
const new_error_function_builtin_systemName = make_builtin_f_new_sym_f(error_atom);
const error_name_function_builtin_systemName = make_builtin_f_get_sym_f(error_atom, name_atom);
const error_list_function_builtin_systemName = make_builtin_f_get_sym_f(error_atom, list_atom);
const error_p_function_builtin_systemName = make_builtin_f_p_sym_f(error_atom);
const new_construction_function_builtin_systemName = make_builtin_f_new_sym_f(construction_atom);
const construction_p_function_builtin_systemName = make_builtin_f_p_sym_f(construction_atom);
const construction_head_function_builtin_systemName = make_builtin_f_get_sym_f(construction_atom, head_atom);
const construction_tail_function_builtin_systemName = make_builtin_f_get_sym_f(construction_atom, tail_atom);
const atom_p_function_builtin_systemName = make_builtin_f_p_sym_f(atom_atom);
const null_p_function_builtin_systemName = make_builtin_f_p_sym_f(null_atom);
const equal_p_function_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, function_atom, new_list(isOrNot_atom, equal_atom)));
const apply_function_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, new_list(function_atom, new_construction(function_atom, something_atom), something_atom), apply_atom));
const evaluate_function_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, function_atom, evaluate_sym));
const list_chooseOne_function_builtin_systemName = make_builtin_f_get_sym_f(list_atom, new_list(typeAnnotation_atom, thing_atom, something_atom));
const if_function_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, function_atom, if_atom));
const quote_form_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, form_atom, quote_atom));
const lambda_form_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, new_list(form_atom, new_list(function_atom, something_atom, function_atom)), theThing_atom));
const function_builtin_use_systemName = systemName_make(new_list(form_atom, new_list(system_atom, function_atom)));
const form_builtin_use_systemName = systemName_make(new_list(form_atom, new_list(system_atom, form_atom)));
const form_use_systemName = systemName_make(new_list(form_atom, form_atom));
const comment_function_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, function_atom, comment_atom));
const comment_form_builtin_systemName = systemName_make(new_list(typeAnnotation_atom, form_atom, comment_atom));
const false_v = new_data(false_atom, new_list());
const true_v = new_data(true_atom, new_list());
function jsArray_to_list(xs) {
    let ret = null_v;
    for (let i = xs.length - 1; i >= 0; i--) {
        ret = new_construction(xs[i], ret);
    }
    return ret;
}
function list_to_jsArray(xs, k_done, k_tail) {
    let ret = [];
    while (construction_p(xs)) {
        ret.push(construction_head(xs));
        xs = construction_tail(xs);
    }
    if (null_p(xs)) {
        return k_done(ret);
    }
    return k_tail(ret, xs);
}
function maybe_list_to_jsArray(xs) {
    return list_to_jsArray(xs, (x) => x, (_1, _2) => false);
}
function new_list(...xs) {
    return jsArray_to_list(xs);
}
export { jsArray_to_list, maybe_list_to_jsArray, new_list };
function un_just_all(raw) {
    if (!just_p(raw)) {
        return raw;
    }
    let x = raw;
    let xs = [];
    while (just_p(x)) {
        xs.push(x);
        x = un_just(x);
    }
    for (const v of xs) {
        lang_set_do(v, x);
    }
    return x;
}
function un_just_comment_all(x) {
    while (just_p(x) || comment_p(x)) {
        x = un_just_all(un_comment_all(x));
    }
    return x;
}
export { un_just_all, un_just_comment_all };
function delay_p(x) {
    return delay_evaluate_p(x) ||
        delay_builtin_form_p(x) ||
        delay_builtin_func_p(x) ||
        delay_apply_p(x);
}
function delay_just_p(x) {
    return just_p(x) || delay_p(x);
}
export { delay_p, delay_just_p };
function delay2delay_evaluate(x) {
    if (delay_evaluate_p(x)) {
        return x;
    }
    else if (delay_builtin_form_p(x)) {
        throw 'WIP';
    }
    else if (delay_builtin_func_p(x)) {
        throw 'WIP';
    }
    else if (delay_apply_p(x)) {
        throw 'WIP';
    }
    return LANG_ERROR();
}
function delay_env(x) {
    return delay_evaluate_env(delay2delay_evaluate(x));
}
function delay_x(x) {
    return delay_evaluate_x(delay2delay_evaluate(x));
}
export { delay_env, delay_x };
function force_all_inner(raw, parents_history = {}, ref_novalue_replace = [false, false], xs = []) {
    let history = {};
    let x = raw;
    function do_rewrite(newval) {
        lang_set_do(x, newval);
        for (let i = 0; i < xs.length; i++) {
            lang_set_do(xs[i], newval);
        }
        return newval;
    }
    function replace_this_with_stopped() {
        ref_novalue_replace[1] = true;
        return do_rewrite_force_all(the_world_stopped_v);
    }
    function do_rewrite_force_all(newval) {
        do_rewrite(newval);
        if (delay_just_p(newval)) {
            xs.push(x);
            return force_all_inner(newval, parents_history, [false, false], xs);
        }
        return newval;
    }
    function make_history() {
        let ret = {};
        for (const x_id in history) {
            ret[x_id] = true;
        }
        for (const x_id in parents_history) {
            ret[x_id] = true;
        }
        return ret;
    }
    for (let i = 0; delay_just_p(x) && i < 32; i++) {
        xs.push(x);
        x = force1(x);
    }
    while (delay_just_p(x)) {
        const x_id = simple_print(x);
        if (parents_history[x_id] === true) {
            return replace_this_with_stopped();
        }
        if (history[x_id] === true) {
            ref_novalue_replace[0] = true;
            if (delay_evaluate_p(x)) {
                return replace_this_with_stopped();
            }
            else if (delay_builtin_func_p(x)) {
                const f = delay_builtin_func_f(x);
                const xs = delay_builtin_func_xs(x);
                const elim_s = [data_name_function_builtin_systemName,
                    data_list_function_builtin_systemName,
                    data_p_function_builtin_systemName,
                    error_name_function_builtin_systemName,
                    error_list_function_builtin_systemName,
                    error_p_function_builtin_systemName,
                    construction_p_function_builtin_systemName,
                    construction_head_function_builtin_systemName,
                    construction_tail_function_builtin_systemName,
                    atom_p_function_builtin_systemName,
                    null_p_function_builtin_systemName];
                let is_elim = false;
                for (const elim_s_v of elim_s) {
                    if (jsbool_equal_p(elim_s_v, f)) {
                        is_elim = true;
                        break;
                    }
                }
                if (is_elim) {
                    LANG_ASSERT(xs.length === 1);
                    LANG_ASSERT(ref_novalue_replace[1] === false);
                    const inner = force_all_inner(xs[0], make_history(), ref_novalue_replace);
                    if (ref_novalue_replace[1]) {
                        return do_rewrite_force_all(builtin_func_apply(f, [inner]));
                    }
                    else {
                        return LANG_ERROR();
                    }
                }
                if (jsbool_equal_p(f, equal_p_function_builtin_systemName)) {
                    return replace_this_with_stopped();
                }
                else if (jsbool_equal_p(f, apply_function_builtin_systemName)) {
                    return replace_this_with_stopped();
                }
                else if (jsbool_equal_p(f, evaluate_function_builtin_systemName)) {
                    return replace_this_with_stopped();
                }
                else if (jsbool_equal_p(f, if_function_builtin_systemName)) {
                    LANG_ASSERT(xs.length === 3);
                    LANG_ASSERT(ref_novalue_replace[1] === false);
                    const tf = force_all_inner(xs[0], make_history(), ref_novalue_replace);
                    if (ref_novalue_replace[1]) {
                        return do_rewrite_force_all(builtin_func_apply(if_function_builtin_systemName, [tf, xs[1], xs[2]]));
                    }
                    else {
                        return LANG_ERROR();
                    }
                }
                return LANG_ERROR();
            }
            else if (delay_builtin_form_p(x)) {
                return replace_this_with_stopped();
            }
            else if (delay_apply_p(x)) {
                return replace_this_with_stopped();
            }
            return LANG_ERROR();
        }
        history[x_id] = true;
        xs.push(x);
        x = force1(x);
    }
    return do_rewrite(x);
}
function force1(raw) {
    const x = un_just_all(raw);
    let ret;
    LANG_ASSERT(!just_p(x));
    if (delay_evaluate_p(x)) {
        ret = real_evaluate(delay_evaluate_env(x), delay_evaluate_x(x), raw);
    }
    else if (delay_builtin_form_p(x)) {
        ret = real_builtin_form_apply(delay_builtin_form_env(x), delay_builtin_form_f(x), delay_builtin_form_xs(x), raw);
    }
    else if (delay_builtin_func_p(x)) {
        ret = real_builtin_func_apply(delay_builtin_func_f(x), delay_builtin_func_xs(x), raw);
    }
    else if (delay_apply_p(x)) {
        ret = real_apply(delay_apply_f(x), delay_apply_xs(x), raw);
    }
    else {
        ret = x;
    }
    ret = un_just_all(ret);
    lang_set_do(x, ret);
    return ret;
}
function force_all(raw) {
    return force_all_inner(raw);
}
function force_uncomment_all(x) {
    while (delay_just_p(x) || comment_p(x)) {
        x = force_all(un_comment_all(x));
    }
    return x;
}
function force_uncomment1(raw) {
    if (comment_p(raw)) {
        return comment_x(raw);
    }
    else {
        return force1(raw);
    }
}
export { force_all, force1, force_uncomment1, force_uncomment_all };
const env_null_v = [];
function env_set(env, key, val) {
    let ret = [];
    for (let i = 0; i < env.length; i = i + 2) {
        if (jsbool_equal_p(env[i + 0], key)) {
            ret[i + 0] = key;
            ret[i + 1] = val;
            for (i = i + 2; i < env.length; i = i + 2) {
                ret[i + 0] = env[i + 0];
                ret[i + 1] = env[i + 1];
            }
            return ret;
        }
        else {
            ret[i + 0] = env[i + 0];
            ret[i + 1] = env[i + 1];
        }
    }
    ret[env.length + 0] = key;
    ret[env.length + 1] = val;
    return ret;
}
function env_get(env, key, default_v) {
    for (let i = 0; i < env.length; i = i + 2) {
        if (jsbool_equal_p(env[i + 0], key)) {
            return env[i + 1];
        }
    }
    return default_v;
}
function must_env_get(env, key) {
    for (let i = 0; i < env.length; i = i + 2) {
        if (jsbool_equal_p(env[i + 0], key)) {
            return env[i + 1];
        }
    }
    return LANG_ERROR();
}
function env2val(env) {
    let ret = null_v;
    for (let i = 0; i < env.length; i = i + 2) {
        ret = new_construction(new_list(env[i + 0], env[i + 1]), ret);
    }
    return new_data(mapping_atom, new_list(ret));
}
function env_foreach(env, f) {
    for (let i = 0; i < env.length; i = i + 2) {
        f(env[i + 0], env[i + 1]);
    }
}
function val2env(x) {
    x = force_all(x);
    if (!data_p(x)) {
        return false;
    }
    let s = force_all(data_name(x));
    if (!atom_p(s)) {
        return false;
    }
    if (!atom_equal_p(s, mapping_atom)) {
        return false;
    }
    s = force_all(data_list(x));
    if (!construction_p(s)) {
        return false;
    }
    if (!null_p(force_all(construction_tail(s)))) {
        return false;
    }
    let ret = [];
    let xs = force_all(construction_head(s));
    while (!null_p(xs)) {
        if (!construction_p(xs)) {
            return false;
        }
        let x = force_all(construction_head(xs));
        xs = force_all(construction_tail(xs));
        if (!construction_p(x)) {
            return false;
        }
        const k = construction_head(x);
        x = force_all(construction_tail(x));
        if (!construction_p(x)) {
            return false;
        }
        const v = construction_head(x);
        if (!null_p(force_all(construction_tail(x)))) {
            return false;
        }
        let not_breaked = true;
        for (let i = 0; i < ret.length; i = i + 2) {
            if (jsbool_equal_p(ret[i + 0], k)) {
                ret[i + 1] = v;
                not_breaked = false;
                break;
            }
        }
        if (not_breaked) {
            ret.push(k);
            ret.push(v);
        }
    }
    return ret;
}
export { env_null_v, env_set, env_get, env2val, env_foreach, val2env, };
function force_uncomment_list_1(list, not_list_k, delay_just_k, k) {
    let ret = [];
    let comments = [];
    let i = un_just_all(list);
    let not_forced = true;
    while (true) {
        if (null_p(i)) {
            return k(comments, ret);
        }
        else if (comment_p(i)) {
            comments.push(comment_comment(i));
            i = comment_x(i);
        }
        else if (construction_p(i)) {
            ret.push(construction_head(i));
            i = construction_tail(i);
        }
        else if (delay_just_p(i)) {
            if (not_forced) {
                not_forced = false;
                i = force1(i);
            }
            else {
                return delay_just_k();
            }
        }
        else {
            return not_list_k();
        }
    }
}
function real_evaluate(env, raw, selfvalraw) {
    const x = force1(raw);
    if (delay_just_p(x)) {
        return selfvalraw;
    }
    const error_v = () => new_error(system_atom, new_list(function_builtin_use_systemName, new_list(evaluate_function_builtin_systemName, new_list(env2val(env), x))));
    if (construction_p(x)) {
        return force_uncomment_list_1(x, error_v, () => selfvalraw, (comments, xs) => {
            if (comments.length !== 0) {
                throw 'WIP';
            }
            if (jsbool_equal_p(xs[0], form_builtin_use_systemName)) {
                if (xs.length === 1) {
                    return error_v();
                }
                const f = xs[1];
                const args = [];
                for (let i = 2; i < xs.length; i++) {
                    args.push(xs[i]);
                }
                return builtin_form_apply(env, f, args);
            }
            else if (jsbool_equal_p(xs[0], form_use_systemName)) {
                if (xs.length === 1) {
                    return error_v();
                }
                const f = force_all(evaluate(env, xs[1]));
                if (!data_p(f)) {
                    return error_v();
                }
                const f_type = force1(data_name(f));
                if (delay_just_p(f_type)) {
                    return selfvalraw;
                }
                if (!atom_p(f_type)) {
                    return error_v();
                }
                if (!atom_equal_p(f_type, form_atom)) {
                    return error_v();
                }
                const f_list = force1(data_list(f));
                if (delay_just_p(f_list)) {
                    return selfvalraw;
                }
                if (!construction_p(f_list)) {
                    return error_v();
                }
                const f_x = construction_head(f_list);
                const f_list_cdr = force1(construction_tail(f_list));
                if (delay_just_p(f_list_cdr)) {
                    return selfvalraw;
                }
                if (!null_p(f_list_cdr)) {
                    return error_v();
                }
                const args = [env2val(env)];
                for (let i = 2; i < xs.length; i++) {
                    args.push(xs[i]);
                }
                return apply(f_x, args);
            }
            else if (jsbool_equal_p(xs[0], function_builtin_use_systemName)) {
                if (xs.length === 1) {
                    return error_v();
                }
                const f = xs[1];
                const args = [];
                for (let i = 2; i < xs.length; i++) {
                    args.push(evaluate(env, xs[i]));
                }
                return builtin_func_apply(f, args);
            }
            else {
                const f = evaluate(env, xs[0]);
                const args = [];
                for (let i = 1; i < xs.length; i++) {
                    args.push(evaluate(env, xs[i]));
                }
                return apply(f, args);
            }
        });
    }
    else if (null_p(x)) {
        return x;
    }
    else if (name_p(x)) {
        return env_get(env, x, error_v());
    }
    else if (error_p(x)) {
        return error_v();
    }
    return LANG_ERROR();
}
function name_p(x) {
    return atom_p(x) || data_p(x);
}
function make_builtin_p_func(p_sym, p_jsfunc) {
    return [p_sym,
        1,
        (x) => {
            x = force1(x);
            if (delay_just_p(x)) {
                return builtin_func_apply(p_sym, [x]);
            }
            if (p_jsfunc(x)) {
                return true_v;
            }
            return false_v;
        }];
}
function make_builtin_get_func(f_sym, p_jsfunc, f_jsfunc) {
    return [f_sym,
        1,
        (x, error_v) => {
            x = force1(x);
            if (delay_just_p(x)) {
                return builtin_func_apply(f_sym, [x]);
            }
            if (p_jsfunc(x)) {
                return f_jsfunc(x);
            }
            return error_v();
        }];
}
const real_builtin_func_apply_s = [
    make_builtin_p_func(data_p_function_builtin_systemName, data_p),
    [new_data_function_builtin_systemName, 2, new_data],
    make_builtin_get_func(data_name_function_builtin_systemName, data_p, data_name),
    make_builtin_get_func(data_list_function_builtin_systemName, data_p, data_list),
    make_builtin_p_func(error_p_function_builtin_systemName, error_p),
    [new_error_function_builtin_systemName, 2, new_error],
    make_builtin_get_func(error_name_function_builtin_systemName, error_p, error_name),
    make_builtin_get_func(error_list_function_builtin_systemName, error_p, error_list),
    make_builtin_p_func(null_p_function_builtin_systemName, null_p),
    [new_construction_function_builtin_systemName, 2, new_construction],
    make_builtin_p_func(construction_p_function_builtin_systemName, construction_p),
    make_builtin_get_func(construction_head_function_builtin_systemName, construction_p, construction_head),
    make_builtin_get_func(construction_tail_function_builtin_systemName, construction_p, construction_tail),
    [equal_p_function_builtin_systemName, 2, (x, y, error_v) => {
            if (x === y) {
                return true_v;
            }
            x = force1(x);
            y = force1(y);
            if (delay_just_p(x) || delay_just_p(y)) {
                return builtin_func_apply(equal_p_function_builtin_systemName, [x, y]);
            }
            if (x === y) {
                return true_v;
            }
            function H_if(b, xx, yy) {
                return builtin_func_apply(if_function_builtin_systemName, [b, xx, yy]);
            }
            function H_and(xx, yy) {
                return H_if(xx, yy, false_v);
            }
            LANG_ASSERT(!delay_just_p(x));
            function end_2(xx, yy, f1, f2) {
                return H_and(builtin_func_apply(equal_p_function_builtin_systemName, [f1(xx), f1(yy)]), builtin_func_apply(equal_p_function_builtin_systemName, [f2(xx), f2(yy)]));
            }
            if (null_p(x)) {
                if (!null_p(x)) {
                    return false_v;
                }
                return true_v;
            }
            else if (atom_p(x)) {
                if (!atom_p(y)) {
                    return false_v;
                }
                if (atom_equal_p(x, y)) {
                    return true_v;
                }
                else {
                    return false_v;
                }
            }
            else if (data_p(x)) {
                if (!data_p(y)) {
                    return false_v;
                }
                return end_2(x, y, data_name, data_list);
            }
            else if (construction_p(x)) {
                if (!construction_p(y)) {
                    return false_v;
                }
                return end_2(x, y, construction_head, construction_tail);
            }
            else if (error_p(x)) {
                if (!error_p(y)) {
                    return false_v;
                }
                return end_2(x, y, error_name, error_list);
            }
            return LANG_ERROR();
        }],
    [apply_function_builtin_systemName, 2, (f, xs, error_v) => {
            let jslist = [];
            let iter = force_all(xs);
            while (construction_p(iter)) {
                jslist.push(construction_head(iter));
                iter = force_all(construction_tail(iter));
            }
            if (!null_p(iter)) {
                return error_v();
            }
            return apply(f, jslist);
        }],
    [evaluate_function_builtin_systemName, 2, (env, x, error_v) => {
            const maybeenv = val2env(env);
            if (maybeenv === false) {
                return error_v();
            }
            return evaluate(maybeenv, x);
        }],
    make_builtin_p_func(atom_p_function_builtin_systemName, atom_p),
    [list_chooseOne_function_builtin_systemName, 1, (xs, error_v) => {
            xs = force1(xs);
            if (delay_just_p(xs)) {
                return builtin_func_apply(list_chooseOne_function_builtin_systemName, [xs]);
            }
            if (!construction_p(xs)) {
                return error_v();
            }
            return construction_head(xs);
        }],
    [if_function_builtin_systemName, 3, (b, x, y, error_v) => {
            b = force1(b);
            if (delay_just_p(b)) {
                return builtin_func_apply(if_function_builtin_systemName, [b, x, y]);
            }
            if (!data_p(b)) {
                return error_v();
            }
            const nam = force_all(data_name(b));
            if (!atom_p(nam)) {
                return error_v();
            }
            if (atom_equal_p(nam, true_atom)) {
                return x;
            }
            if (atom_equal_p(nam, false_atom)) {
                return y;
            }
            return error_v();
        }],
    [comment_function_builtin_systemName, 2, new_comment],
];
function real_apply(f, xs, selfvalraw) {
    const error_v = () => new_error(system_atom, new_list(function_builtin_use_systemName, new_list(apply_function_builtin_systemName, new_list(f, jsArray_to_list(xs)))));
    f = force1(f);
    if (delay_just_p(f)) {
        return selfvalraw;
    }
    if (!data_p(f)) {
        return error_v();
    }
    const f_type = force_all(data_name(f));
    if (!(atom_p(f_type) && atom_equal_p(f_type, function_atom))) {
        return error_v();
    }
    const f_list = force_all(data_list(f));
    if (!construction_p(f_list)) {
        return error_v();
    }
    let args_pat = force_all_rec(construction_head(f_list));
    const f_list_cdr = force_all(construction_tail(f_list));
    if (!(construction_p(f_list_cdr) && null_p(force_all(construction_tail(f_list_cdr))))) {
        return error_v();
    }
    const f_code = construction_head(f_list_cdr);
    let env = env_null_v;
    let xs_i = 0;
    while (!null_p(args_pat)) {
        if (name_p(args_pat)) {
            let x = null_v;
            for (let i = xs.length - 1; i >= xs_i; i--) {
                x = new_construction(xs[i], x);
            }
            env = env_set(env, args_pat, x);
            xs_i = xs.length;
            args_pat = null_v;
        }
        else if (construction_p(args_pat)) {
            if (xs_i < xs.length) {
                const x = xs[xs_i];
                xs_i++;
                env = env_set(env, construction_head(args_pat), x);
                args_pat = construction_tail(args_pat);
            }
            else {
                return error_v();
            }
        }
        else {
            return error_v();
        }
    }
    if (xs.length !== xs_i) {
        return error_v();
    }
    return evaluate(env, f_code);
}
function real_builtin_func_apply(f, xs, selfvalraw) {
    const error_v = () => new_error(system_atom, new_list(function_builtin_use_systemName, new_list(f, jsArray_to_list(xs))));
    for (const xx of real_builtin_func_apply_s) {
        if (jsbool_equal_p(f, xx[0])) {
            if (xs.length !== xx[1]) {
                return error_v();
            }
            if (xx[1] === 1) {
                return xx[2](xs[0], error_v, selfvalraw);
            }
            else if (xx[1] === 2) {
                return xx[2](xs[0], xs[1], error_v, selfvalraw);
            }
            else if (xx[1] === 3) {
                return xx[2](xs[0], xs[1], xs[2], error_v, selfvalraw);
            }
            return LANG_ERROR();
        }
    }
    return error_v();
}
function real_builtin_form_apply(env, f, xs, selfvalraw) {
    const error_v = () => new_error(system_atom, new_list(form_builtin_use_systemName, new_list(env2val(env), f, jsArray_to_list(xs))));
    if (jsbool_equal_p(f, quote_form_builtin_systemName)) {
        if (xs.length !== 1) {
            return error_v();
        }
        return xs[0];
    }
    else if (jsbool_equal_p(f, lambda_form_builtin_systemName)) {
        if (xs.length !== 2) {
            return error_v();
        }
        return new_lambda(env, xs[0], xs[1], error_v);
    }
    else if (jsbool_equal_p(f, comment_form_builtin_systemName)) {
        if (xs.length !== 2) {
            return error_v();
        }
        return new_comment(xs[0], evaluate(env, xs[1]));
    }
    return error_v();
}
function make_quote(x) {
    return new_list(form_builtin_use_systemName, quote_form_builtin_systemName, x);
}
function new_lambda(env, args_pat, body, error_v) {
    args_pat = force_all_rec(args_pat);
    let args_pat_vars = [];
    let args_pat_is_dot = false;
    let args_pat_iter = args_pat;
    while (!null_p(args_pat_iter)) {
        if (name_p(args_pat_iter)) {
            args_pat_vars.push(args_pat_iter);
            args_pat_is_dot = true;
            args_pat_iter = null_v;
        }
        else if (construction_p(args_pat_iter)) {
            args_pat_vars.push(construction_head(args_pat_iter));
            args_pat_iter = construction_tail(args_pat_iter);
        }
        else {
            return error_v();
        }
    }
    let args_pat_vars_val;
    if (args_pat_is_dot) {
        args_pat_vars_val = jsArray_to_list(args_pat_vars);
    }
    else {
        args_pat_vars_val = args_pat;
    }
    const env_vars = [];
    env_foreach(env, (k, v) => {
        for (let i = 0; i < args_pat_vars.length; i++) {
            if (jsbool_equal_p(args_pat_vars[i], k)) {
                return;
            }
        }
        env_vars.push(k);
    });
    let new_args_pat = args_pat_vars_val;
    for (let i = env_vars.length - 1; i >= 0; i--) {
        new_args_pat = new_construction(env_vars[i], new_args_pat);
    }
    let new_args = args_pat_vars_val;
    for (let i = env_vars.length - 1; i >= 0; i--) {
        new_args = new_construction(make_quote(must_env_get(env, env_vars[i])), new_args);
    }
    return new_data(function_atom, new_list(args_pat, new_construction(make_quote(new_data(function_atom, new_list(new_args_pat, body))), new_args)));
}
function jsbool_equal_p(x, y) {
    if (x === y) {
        return true;
    }
    x = force_all(x);
    y = force_all(y);
    if (x === y) {
        return true;
    }
    function end_2(xx, yy, f1, f2) {
        if (jsbool_equal_p(f1(xx), f1(yy)) && jsbool_equal_p(f2(xx), f2(yy))) {
            lang_set_do(xx, yy);
            return true;
        }
        else {
            return false;
        }
    }
    if (null_p(x)) {
        if (!null_p(y)) {
            return false;
        }
        lang_set_do(x, null_v);
        lang_set_do(y, null_v);
        return true;
    }
    else if (atom_p(x)) {
        if (!atom_p(y)) {
            return false;
        }
        return atom_equal_p(x, y);
    }
    else if (construction_p(x)) {
        if (!construction_p(y)) {
            return false;
        }
        return end_2(x, y, construction_head, construction_tail);
    }
    else if (error_p(x)) {
        if (!error_p(y)) {
            return false;
        }
        return end_2(x, y, error_name, error_list);
    }
    else if (data_p(x)) {
        if (!data_p(y)) {
            return false;
        }
        return end_2(x, y, data_name, data_list);
    }
    return LANG_ERROR();
}
const equal_p = jsbool_equal_p;
export { equal_p };
function jsbool_no_force_equal_p(x, y) {
    if (x === y) {
        return true;
    }
    x = un_just_all(x);
    y = un_just_all(y);
    if (x === y) {
        return true;
    }
    function end_2(xx, yy, f1, f2) {
        if (jsbool_no_force_equal_p(f1(xx), f1(yy)) && jsbool_no_force_equal_p(f2(xx), f2(yy))) {
            lang_set_do(xx, yy);
            return true;
        }
        else {
            return false;
        }
    }
    if (null_p(x)) {
        if (!null_p(y)) {
            return false;
        }
        lang_set_do(x, null_v);
        lang_set_do(y, null_v);
        return true;
    }
    else if (atom_p(x)) {
        if (!atom_p(y)) {
            return false;
        }
        return atom_equal_p(x, y);
    }
    else if (construction_p(x)) {
        if (!construction_p(y)) {
            return false;
        }
        return end_2(x, y, construction_head, construction_tail);
    }
    else if (error_p(x)) {
        if (!error_p(y)) {
            return false;
        }
        return end_2(x, y, error_name, error_list);
    }
    else if (data_p(x)) {
        if (!data_p(y)) {
            return false;
        }
        return end_2(x, y, data_name, data_list);
    }
    else if (delay_p(x)) {
        return false;
    }
    return LANG_ERROR();
}
function simple_print(x) {
    x = un_just_all(x);
    let temp = "";
    let prefix = "";
    if (null_p(x)) {
        return "()";
    }
    else if (construction_p(x)) {
        temp = "(";
        prefix = "";
        while (construction_p(x)) {
            temp += prefix + simple_print(construction_head(x));
            prefix = " ";
            x = un_just_all(construction_tail(x));
        }
        if (null_p(x)) {
            temp += ")";
        }
        else {
            temp += " . " + simple_print(x) + ")";
        }
        return temp;
    }
    else if (data_p(x)) {
        return "#" + simple_print(new_construction(data_name(x), data_list(x)));
    }
    else if (error_p(x)) {
        return "!" + simple_print(new_construction(error_name(x), error_list(x)));
    }
    else if (atom_p(x)) {
        return un_atom(x);
    }
    else if (comment_p(x)) {
        return ";(" + simple_print(comment_comment(x)) + " " + simple_print(comment_x(x)) + ")";
    }
    else if (delay_evaluate_p(x)) {
        return "$(" + simple_print(env2val(delay_evaluate_env(x))) + " " + simple_print(delay_evaluate_x(x)) + ")";
    }
    else if (delay_builtin_func_p(x)) {
        return "%(" + simple_print(delay_builtin_func_f(x)) + " " + simple_print(jsArray_to_list(delay_builtin_func_xs(x))) + ")";
    }
    else if (delay_builtin_form_p(x)) {
        return "@(" +
            simple_print(env2val(delay_builtin_form_env(x))) +
            " " + simple_print(delay_builtin_form_f(x)) +
            " " + simple_print(jsArray_to_list(delay_builtin_form_xs(x))) +
            ")";
    }
    else if (delay_apply_p(x)) {
        return "^(" + simple_print(delay_apply_f(x)) + " " + simple_print(jsArray_to_list(delay_apply_xs(x))) + ")";
    }
    return LANG_ERROR();
}
export { simple_print };
function complex_parse(x) {
    const state_const = x;
    let state = 0;
    function eof() {
        return state_const.length === state;
    }
    function get() {
        LANG_ASSERT(!eof());
        const ret = state_const[state];
        state++;
        return ret;
    }
    function put(chr) {
        LANG_ASSERT(state_const[state - 1] === chr);
        state--;
    }
    function parse_error(x = "") {
        throw "TheLanguage parse ERROR!" + x;
    }
    function a_space_p(chr) {
        return chr === " " || chr === "\n" || chr === "\t" || chr === "\r";
    }
    function space() {
        if (eof()) {
            return false;
        }
        let x = get();
        if (!a_space_p(x)) {
            put(x);
            return false;
        }
        while (a_space_p(x) && !eof()) {
            x = get();
        }
        if (!a_space_p(x)) {
            put(x);
        }
        return true;
    }
    function atom() {
        if (eof()) {
            return false;
        }
        let x = get();
        let ret = "";
        if (!a_atom_p(x)) {
            put(x);
            return false;
        }
        while (a_atom_p(x) && !eof()) {
            ret += x;
            x = get();
        }
        if (a_atom_p(x)) {
            ret += x;
        }
        else {
            put(x);
        }
        if (can_new_atom_p(ret)) {
            return new_atom(ret);
        }
        else {
            return parse_error("Not Atom" + ret);
        }
    }
    function readlist() {
        if (eof()) {
            return false;
        }
        let x = get();
        if (x !== "(") {
            put(x);
            return false;
        }
        let ret_last = new_hole_do();
        const ret = ret_last;
        function last_add_do(val) {
            const ret_last2 = new_hole_do();
            hole_set_do(ret_last, new_construction(val, ret_last2));
            ret_last = ret_last2;
        }
        while (true) {
            space();
            if (eof()) {
                return parse_error();
            }
            x = get();
            if (x === ")") {
                hole_set_do(ret_last, null_v);
                return ret;
            }
            if (x === ".") {
                space();
                const e = val();
                hole_set_do(ret_last, e);
                space();
                if (eof()) {
                    return parse_error();
                }
                x = get();
                if (x !== ")") {
                    return parse_error();
                }
                return ret;
            }
            put(x);
            const e = val();
            last_add_do(e);
        }
    }
    function data() {
        if (eof()) {
            return false;
        }
        const x = get();
        if (x !== "#") {
            put(x);
            return false;
        }
        const xs = readlist();
        if (xs === false) {
            return parse_error();
        }
        if (!construction_p(xs)) {
            return parse_error();
        }
        return new_data(construction_head(xs), construction_tail(xs));
    }
    function readerror() {
        if (eof()) {
            return false;
        }
        const x = get();
        if (x !== "!") {
            put(x);
            return false;
        }
        const xs = readlist();
        if (xs === false) {
            return parse_error();
        }
        if (!construction_p(xs)) {
            return parse_error();
        }
        return new_error(construction_head(xs), construction_tail(xs));
    }
    function make_read_two(prefix, k) {
        return () => {
            if (eof()) {
                return false;
            }
            const c = get();
            if (c !== prefix) {
                put(c);
                return false;
            }
            const xs = readlist();
            if (xs === false) {
                return parse_error();
            }
            if (!construction_p(xs)) {
                return parse_error();
            }
            const x = construction_tail(xs);
            if (!(construction_p(x) && null_p(construction_tail(x)))) {
                return parse_error();
            }
            return k(construction_head(xs), construction_head(x));
        };
    }
    function make_read_three(prefix, k) {
        return () => {
            if (eof()) {
                return false;
            }
            const c = get();
            if (c !== prefix) {
                put(c);
                return false;
            }
            const xs = readlist();
            if (xs === false) {
                return parse_error();
            }
            if (!construction_p(xs)) {
                return parse_error();
            }
            const x = construction_tail(xs);
            if (!construction_p(x)) {
                return parse_error();
            }
            const x_d = construction_tail(x);
            if (!(construction_p(x_d) && null_p(construction_tail(x_d)))) {
                return parse_error();
            }
            return k(construction_head(xs), construction_head(x), construction_head(x_d));
        };
    }
    const readeval = make_read_two("$", (ev, val) => {
        const env = val2env(ev);
        if (env === false) {
            return parse_error();
        }
        return evaluate(env, val);
    });
    const readfuncapply = make_read_two("%", (f, xs) => {
        const jsxs = list_to_jsArray(xs, (v) => v, (_1, _2) => parse_error());
        return builtin_func_apply(f, jsxs);
    });
    const readformbuiltin = make_read_three("@", (e, f, xs) => {
        const jsxs = list_to_jsArray(xs, (v) => v, (_1, _2) => parse_error());
        const env = val2env(e);
        if (env === false) {
            return parse_error();
        }
        return builtin_form_apply(env, f, jsxs);
    });
    const readapply = make_read_two("^", (f, xs) => {
        const jsxs = list_to_jsArray(xs, (v) => v, (_1, _2) => parse_error());
        return apply(f, jsxs);
    });
    const readcomment = make_read_two(";", (comment, x) => new_comment(comment, x));
    function a_atom_p(chr) {
        if (a_space_p(chr)) {
            return false;
        }
        for (const v of ["(", ")", "!", "#", ".", "$", "%", "^", "@",
            '~', '/', '-', '>', '_', ':', '?', '[', ']', '&', ';'
        ]) {
            if (v === chr) {
                return false;
            }
        }
        return true;
    }
    function val() {
        space();
        const fs = [readlist, readsysname, data, readerror, readeval, readfuncapply, readformbuiltin, readapply, readcomment];
        for (const f of fs) {
            const x = f();
            if (x !== false) {
                return x;
            }
        }
        return parse_error();
    }
    return val();
    function un_maybe(vl) {
        if (vl === false) {
            return parse_error();
        }
        return vl;
    }
    function not_eof() {
        return !eof();
    }
    function assert_get(c) {
        un_maybe(not_eof());
        un_maybe(get() === c);
    }
    function readsysname_no_pack_inner_must(strict = false) {
        function readsysname_no_pack_bracket() {
            assert_get('[');
            const x = readsysname_no_pack_inner_must();
            assert_get(']');
            return x;
        }
        let fs;
        if (strict) {
            fs = [readlist, atom, readsysname_no_pack_bracket, data,
                readerror, readeval, readfuncapply, readformbuiltin, readapply, readcomment];
        }
        else {
            fs = [readlist, readsysname_no_pack, data,
                readerror, readeval, readfuncapply, readformbuiltin, readapply, readcomment];
        }
        for (const f of fs) {
            const x = f();
            if (x !== false) {
                return x;
            }
        }
        return parse_error();
    }
    function may_xfx_xf(vl) {
        if (eof()) {
            return vl;
        }
        const head = get();
        if (head === '.') {
            const y = readsysname_no_pack_inner_must();
            return new_list(typeAnnotation_atom, new_list(function_atom, new_list(vl), something_atom), y);
        }
        else if (head === ':') {
            const y = readsysname_no_pack_inner_must();
            return new_list(typeAnnotation_atom, y, vl);
        }
        else if (head === '~') {
            return new_list(isOrNot_atom, vl);
        }
        else if (head === '@') {
            const y = readsysname_no_pack_inner_must();
            return new_list(typeAnnotation_atom, new_list(function_atom, new_construction(vl, something_atom), something_atom), y);
        }
        else if (head === '?') {
            return new_list(typeAnnotation_atom, function_atom, new_list(isOrNot_atom, vl));
        }
        else if (head === '/') {
            let ys = [vl];
            while (true) {
                const y = readsysname_no_pack_inner_must(true);
                ys.push(y);
                if (eof()) {
                    break;
                }
                const c0 = get();
                if (c0 !== '/') {
                    put(c0);
                    break;
                }
            }
            return new_list(sub_atom, jsArray_to_list(ys));
        }
        else {
            put(head);
            return vl;
        }
    }
    function readsysname_no_pack() {
        if (eof()) {
            return false;
        }
        const head = get();
        if (head === '&') {
            un_maybe(not_eof());
            const c0 = get();
            if (c0 === '+') {
                const x = readsysname_no_pack_inner_must();
                return new_list(form_atom, new_list(system_atom, x));
            }
            else {
                put(c0);
            }
            const x = readsysname_no_pack_inner_must();
            return new_list(form_atom, x);
        }
        else if (head === ':') {
            un_maybe(not_eof());
            const c0 = get();
            if (c0 === '&') {
                assert_get('>');
                const x = readsysname_no_pack_inner_must();
                return new_list(typeAnnotation_atom, new_list(form_atom, new_list(function_atom, something_atom, x)), theThing_atom);
            }
            else if (c0 === '>') {
                const x = readsysname_no_pack_inner_must();
                return new_list(typeAnnotation_atom, new_list(function_atom, something_atom, x), theThing_atom);
            }
            else {
                put(c0);
            }
            const x = readsysname_no_pack_inner_must();
            return new_list(typeAnnotation_atom, x, theThing_atom);
        }
        else if (head === '+') {
            const x = readsysname_no_pack_inner_must();
            return new_list(system_atom, x);
        }
        else if (head === '[') {
            const x = readsysname_no_pack_inner_must();
            assert_get(']');
            return may_xfx_xf(x);
        }
        else if (head === '_') {
            assert_get(':');
            const x = readsysname_no_pack_inner_must();
            return new_list(typeAnnotation_atom, x, something_atom);
        }
        else {
            put(head);
            const x = atom();
            if (x === false) {
                return false;
            }
            return may_xfx_xf(x);
        }
    }
    function readsysname() {
        const x = readsysname_no_pack();
        if (x === false) {
            return false;
        }
        if (atom_p(x)) {
            return x;
        }
        return systemName_make(x);
    }
}
export { complex_parse };
function complex_print(val) {
    function print_sys_name(x, is_inner_bool) {
        if (atom_p(x)) {
            return un_atom(x);
        }
        function inner_bracket(vl) {
            if (is_inner_bool) {
                return '[' + vl + ']';
            }
            else {
                return vl;
            }
        }
        const maybe_xs = maybe_list_to_jsArray(x);
        if (maybe_xs !== false && maybe_xs.length === 3 && jsbool_no_force_equal_p(maybe_xs[0], typeAnnotation_atom)) {
            const maybe_lst_2 = maybe_list_to_jsArray(maybe_xs[1]);
            if (maybe_lst_2 !== false && maybe_lst_2.length === 3 && jsbool_no_force_equal_p(maybe_lst_2[0], function_atom)) {
                const var_2_1 = maybe_lst_2[1];
                const maybe_lst_3 = maybe_list_to_jsArray(var_2_1);
                if (maybe_lst_3 !== false && maybe_lst_3.length === 1 && jsbool_no_force_equal_p(maybe_lst_2[2], something_atom)) {
                    return inner_bracket(print_sys_name(maybe_lst_3[0], true) + '.' + print_sys_name(maybe_xs[2], true));
                }
                else if (construction_p(var_2_1) && jsbool_no_force_equal_p(construction_tail(var_2_1), something_atom) && jsbool_no_force_equal_p(maybe_lst_2[2], something_atom)) {
                    return inner_bracket(print_sys_name(construction_head(var_2_1), true) + '@' + print_sys_name(maybe_xs[2], true));
                }
                else if (jsbool_no_force_equal_p(var_2_1, something_atom) && jsbool_no_force_equal_p(maybe_xs[2], theThing_atom)) {
                    return inner_bracket(':>' + print_sys_name(maybe_lst_2[2], true));
                }
            }
            const maybe_lst_44 = maybe_list_to_jsArray(maybe_xs[2]);
            if (jsbool_no_force_equal_p(maybe_xs[1], function_atom) && maybe_lst_44 !== false && maybe_lst_44.length === 2 && jsbool_no_force_equal_p(maybe_lst_44[0], isOrNot_atom)) {
                return inner_bracket(print_sys_name(maybe_lst_44[1], true) + '?');
            }
            if (maybe_lst_2 !== false && maybe_lst_2.length === 2 && jsbool_no_force_equal_p(maybe_xs[2], theThing_atom) && jsbool_no_force_equal_p(maybe_lst_2[0], form_atom)) {
                const maybe_lst_88 = maybe_list_to_jsArray(maybe_lst_2[1]);
                if (maybe_lst_88 !== false && maybe_lst_88.length === 3 && jsbool_no_force_equal_p(maybe_lst_88[0], function_atom) && jsbool_no_force_equal_p(maybe_lst_88[1], something_atom)) {
                    return inner_bracket(':&>' + print_sys_name(maybe_lst_88[2], true));
                }
            }
            let hd;
            if (jsbool_no_force_equal_p(maybe_xs[2], something_atom)) {
                hd = '_';
            }
            else if (jsbool_no_force_equal_p(maybe_xs[2], theThing_atom)) {
                hd = '';
            }
            else {
                hd = print_sys_name(maybe_xs[2], true);
            }
            return inner_bracket(hd + ':' + print_sys_name(maybe_xs[1], true));
        }
        else if (maybe_xs !== false && maybe_xs.length === 2) {
            if (jsbool_no_force_equal_p(maybe_xs[0], form_atom)) {
                const maybe_lst_288 = maybe_list_to_jsArray(maybe_xs[1]);
                if (maybe_lst_288 !== false && maybe_lst_288.length === 2 && jsbool_no_force_equal_p(maybe_lst_288[0], system_atom)) {
                    return inner_bracket('&+' + print_sys_name(maybe_lst_288[1], true));
                }
                return inner_bracket('&' + print_sys_name(maybe_xs[1], true));
            }
            else if (jsbool_no_force_equal_p(maybe_xs[0], isOrNot_atom)) {
                return inner_bracket(print_sys_name(maybe_xs[1], true) + '~');
            }
            else if (jsbool_no_force_equal_p(maybe_xs[0], system_atom)) {
                return inner_bracket('+' + print_sys_name(maybe_xs[1], true));
            }
            else if (jsbool_no_force_equal_p(maybe_xs[0], sub_atom)) {
                const maybe_lst_8934 = maybe_list_to_jsArray(maybe_xs[1]);
                if (maybe_lst_8934 !== false && maybe_lst_8934.length > 1) {
                    let tmp = print_sys_name(maybe_lst_8934[0], true);
                    for (let i = 1; i < maybe_lst_8934.length; i++) {
                        tmp += '/' + print_sys_name(maybe_lst_8934[i], true);
                    }
                    return inner_bracket(tmp);
                }
            }
        }
        if (is_inner_bool) {
            return simple_print(x);
        }
        else {
            return simple_print(systemName_make(x));
        }
    }
    let x = complex_parse(simple_print(val));
    let temp = "";
    let prefix = "";
    if (null_p(x)) {
        return "()";
    }
    else if (construction_p(x)) {
        temp = "(";
        prefix = "";
        while (construction_p(x)) {
            temp += prefix + complex_print(construction_head(x));
            prefix = " ";
            x = construction_tail(x);
        }
        if (null_p(x)) {
            temp += ")";
        }
        else {
            temp += " . " + complex_print(x) + ")";
        }
        return temp;
    }
    else if (data_p(x)) {
        const name = data_name(x);
        const list = data_list(x);
        const maybe_xs = maybe_list_to_jsArray(list);
        if (maybe_xs !== false && maybe_xs.length === 2 && jsbool_no_force_equal_p(name, name_atom) && jsbool_no_force_equal_p(maybe_xs[0], system_atom)) {
            return print_sys_name(maybe_xs[1], false);
        }
        return "#" + complex_print(new_construction(name, list));
    }
    else if (error_p(x)) {
        return "!" + complex_print(new_construction(error_name(x), error_list(x)));
    }
    else if (atom_p(x)) {
        return un_atom(x);
    }
    else if (comment_p(x)) {
        return ";(" + complex_print(comment_comment(x)) + " " + complex_print(comment_x(x)) + ")";
    }
    else if (delay_evaluate_p(x)) {
        return "$(" + complex_print(env2val(delay_evaluate_env(x))) + " " + complex_print(delay_evaluate_x(x)) + ")";
    }
    else if (delay_builtin_func_p(x)) {
        return "%(" + complex_print(delay_builtin_func_f(x)) + " " + complex_print(jsArray_to_list(delay_builtin_func_xs(x))) + ")";
    }
    else if (delay_builtin_form_p(x)) {
        return "@(" +
            complex_print(env2val(delay_builtin_form_env(x))) +
            " " + complex_print(delay_builtin_form_f(x)) +
            " " + complex_print(jsArray_to_list(delay_builtin_form_xs(x))) +
            ")";
    }
    else if (delay_apply_p(x)) {
        return "^(" + complex_print(delay_apply_f(x)) + " " + complex_print(jsArray_to_list(delay_apply_xs(x))) + ")";
    }
    return LANG_ERROR();
}
export { complex_print };
function machinetext_parse(rawstr) {
    let state = rawstr.length;
    function parse_error(x = "") {
        throw 'MT parse ERROR ' + x;
    }
    function parse_assert(x) {
        if (!x) {
            return parse_error();
        }
    }
    function get_do() {
        parse_assert(is_not_eof());
        state--;
        return rawstr[state];
    }
    function is_eof() {
        return state === 0;
    }
    function is_not_eof() {
        return !is_eof();
    }
    const stack = [];
    function conslike(c) {
        const y = stack.pop();
        const x = stack.pop();
        if (x === undefined || y === undefined) {
            return parse_error();
        }
        else {
            return stack.unshift(c(x, y));
        }
    }
    while (is_not_eof()) {
        const chr = get_do();
        if (chr === '^') {
            let tmp = '';
            while (true) {
                const chr = get_do();
                if (chr === '^') {
                    break;
                }
                tmp = chr + tmp;
            }
            if (can_new_atom_unicodechar_p(tmp)) {
                stack.unshift(new_atom_unicodechar(tmp));
            }
            else {
                return parse_error('can_new_atom_unicodechar_p("' + tmp + '") == false');
            }
        }
        else if (chr === '.') {
            conslike(new_construction);
        }
        else if (chr === '#') {
            conslike(new_data);
        }
        else if (chr === '!') {
            conslike(new_error);
        }
        else if (chr === '$') {
            conslike((env, val) => {
                const r_env = val2env(env);
                if (r_env === false) {
                    return parse_error();
                }
                else {
                    return evaluate(r_env, val);
                }
            });
        }
        else if (chr === '_') {
            stack.unshift(null_v);
        }
        else {
            return parse_error();
        }
    }
    parse_assert(is_eof());
    parse_assert(stack.length === 1);
    return stack[0];
}
function machinetext_print(x) {
    let stack = [x];
    let result = "";
    while (stack.length !== 0) {
        const new_stack = [];
        for (let x of stack) {
            x = un_just_all(x);
            const conslike = function (xx, s, g1, g2) {
                result += (s);
                return new_stack.push(g1(xx), g2(xx));
            };
            if (atom_p(x)) {
                result += ('^' + un_atom_unicodechar(x) + '^');
            }
            else if (construction_p(x)) {
                conslike(x, '.', construction_head, construction_tail);
            }
            else if (null_p(x)) {
                result += ('_');
            }
            else if (data_p(x)) {
                conslike(x, '#', data_name, data_list);
            }
            else if (error_p(x)) {
                conslike(x, '!', error_name, error_list);
            }
            else if (delay_p(x)) {
                const y = delay2delay_evaluate(x);
                conslike(y, '$', ((vl) => env2val(delay_evaluate_env(vl))), delay_evaluate_x);
            }
            else {
                return LANG_ERROR();
            }
        }
        stack = new_stack;
    }
    return result;
}
export { machinetext_parse, machinetext_print };
function trampoline_return(x) {
    return () => [false, x];
}
function trampoline_delay(x) {
    return () => [true, x()];
}
function run_trampoline(x) {
    let i = x();
    while (i[0]) {
        i = i[1]();
    }
    return i[1];
}
export { trampoline_return, trampoline_delay, run_trampoline };
const return_effect_systemName = systemName_make(new_construction(sub_atom, new_construction(new_construction(effect_atom, new_construction(new_construction(typeAnnotation_atom, new_construction(thing_atom, new_construction(something_atom, null_v))), null_v)), null_v)));
const bind_effect_systemName = systemName_make(new_construction(sub_atom, new_construction(new_construction(effect_atom, new_construction(construction_atom, null_v)), null_v)));
function new_effect_bind(monad, func) {
    return new_data(bind_effect_systemName, new_list(monad, func));
}
function new_effect_return(x) {
    return new_data(return_effect_systemName, x);
}
function run_monad_helper(return_handler, op_handler, code, state, next = false) {
    function make_bind(x, f) {
        throw 'WIP';
    }
    code = force_all(code);
    if (data_p(code)) {
        const name = data_name(code);
        let list = data_list(code);
        if (jsbool_equal_p(name, return_effect_systemName)) {
            list = force_all(list);
            if (construction_p(list)) {
                const list_a = construction_head(list);
                const list_d = force_all(construction_tail(list));
                if (null_p(list_d)) {
                    if (next === false) {
                        const upval_v = list_a;
                        const upval_st = state;
                        const r = () => return_handler(upval_v, upval_st);
                        return trampoline_delay(r);
                    }
                    else {
                        const upval_rt = return_handler;
                        const upval_op = op_handler;
                        const upval_v = list_a;
                        const upval_st = state;
                        const r = () => run_monad_helper(upval_rt, upval_op, apply(next, upval_v), upval_st);
                        return trampoline_delay(r);
                    }
                }
            }
        }
        else if (jsbool_equal_p(name, bind_effect_systemName)) {
            list = force_all(list);
            if (construction_p(list)) {
                const list_a = construction_head(list);
                const list_d = force_all(construction_tail(list));
                if (construction_p(list_d)) {
                    const list_d_a = construction_head(list_d);
                    const list_d_d = force_all(construction_tail(list_d));
                    if (null_p(list_d_d)) {
                        if (next === false) {
                            const upval_rt = return_handler;
                            const upval_op = op_handler;
                            const upval_a = list_a;
                            const upval_b = list_d_a;
                            const upval_st = state;
                            const r = () => run_monad_helper(upval_rt, upval_op, upval_a, upval_st, upval_b);
                            return trampoline_delay(r);
                        }
                        else {
                            const upval_rt = return_handler;
                            const upval_op = op_handler;
                            const upval_a = list_a;
                            const upval_b = list_d_a;
                            const upval_st = state;
                            const upval_nt = next;
                            const x = new_atom('序甲');
                            const r = () => run_monad_helper(upval_rt, upval_op, upval_a, upval_st, new_data(function_atom, new_list(new_list(x), make_bind(new_list(make_quote(upval_b), x), make_quote(upval_nt)))));
                            return trampoline_delay(r);
                        }
                    }
                }
            }
        }
    }
    if (next === false) {
        return trampoline_delay(() => op_handler(code, state, return_handler));
    }
    else {
        return trampoline_delay(() => op_handler(code, state, (val2, state2) => trampoline_delay(() => run_monad_helper(return_handler, op_handler, apply(next, [val2]), state2))));
    }
}
function run_monad_trampoline(return_handler, op_handler, code, state) {
    return run_monad_helper(return_handler, op_handler, code, state);
}
function run_monad_stackoverflow(return_handler, op_handler, code, state) {
    return run_trampoline(run_monad_helper(((v, s) => trampoline_return(return_handler(v, s))), ((op, st, rs) => trampoline_return(op_handler(op, st, (v, s) => run_trampoline(rs(v, s))))), code, state));
}
export { return_effect_systemName, bind_effect_systemName, new_effect_bind, new_effect_return, run_monad_trampoline, run_monad_stackoverflow, };