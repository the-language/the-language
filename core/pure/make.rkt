#lang rash
;; in-dir is in the demo file still
(require rash/demo/setup)
(require make)
(require racket)

(define (id x) x)
(define ++ string-append)
(define (apply-++ x) (apply ++ x))
(define (string->lines x) (string-split x "\n"))
(define (lines->string x) (apply-++ (map (lambda (x) (++ x"\n")) x)))

(define c-copyright "/*
    The Language
    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

*/
")
(define haskell-copyright "
--    The Language
--    Copyright (C) 2018, 2019  Zaoqi <zaomir@outlook.com>

--    This program is free software: you can redistribute it and/or modify
--    it under the terms of the GNU Affero General Public License as published
--    by the Free Software Foundation, either version 3 of the License, or
--    (at your option) any later version.

--    This program is distributed in the hope that it will be useful,
--    but WITHOUT ANY WARRANTY; without even the implied warranty of
--    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--    GNU Affero General Public License for more details.

--    You should have received a copy of the GNU Affero General Public License
--    along with this program.  If not, see <https://www.gnu.org/licenses/>.

")
(define c-generatedby "/* Generated by make.rkt */\n")
(define haskell-generatedby "-- Generated by make.rkt\n")
(define bash-generatedby "# Generated by make.rkt\n")
(define (ecmascript/exports.list-parse) (filter-not (lambda (x) (equal? x "")) (string->lines #{cat ../ecmascript/exports.list})))


(define eval-ns (make-base-namespace))
(eval '(require racket) eval-ns)
(define (eval-str-sandbox x) (eval (read (open-input-string x)) eval-ns))
(define (run-racket-code-generators->lines lines)
    (match lines
        [(list
            head-other-lines ...
            (and head-c-line (regexp #rx"^ */\\* *!!!Racket +Code +Generator!!!(.*)$" (list _ head-c)))
            (and (not (regexp #rx"\\*/")) c-lines) ...
            (and tail-c-line (regexp #rx"^(.*)\\*/ *$" (list _ tail-c)))
            (and head-g-line (regexp #rx"^ *// *!!!Generated +by +Racket!!! +!!!BEGIN!!!$"))
            (not (regexp #rx"!!!Generated +by +Racket!!! +!!!")) ...
            (and tail-g-line (regexp #rx"^ *// *!!!Generated +by +Racket!!! +!!!END!!!$"))
            tail-other-lines ...
            )
         (define code (++ "(begin\n" head-c (lines->string c-lines) tail-c "\n)"))
         (append
                (run-racket-code-generators->lines head-other-lines)
                (list head-c-line)
                c-lines
                (list tail-c-line)
                (list head-g-line)
                (list (eval-str-sandbox code))
                (list tail-g-line)
                (run-racket-code-generators->lines tail-other-lines)
                )]
        [x x])
  )


(define-syntax-rule (define-make++ self write-id (pre-src pre-id pre-dep) main-id pre ((name (depend ...) code) ...))
  (begin
    (define (write-id Makefile)
      (define mkfile
        (string-append
         (string-append
          name ":" (string-append " " depend) ...
          "\n\tracket "Makefile".domake.rkt "name"\n\n"
          ) ...
         pre-src": "(apply string-append (add-between pre-dep " "))"\n\tracket "Makefile".premake.rkt\n"))
      (display-to-file mkfile Makefile #:exists 'replace)
      (display-to-file (string-append"#lang racket\n(require \""self"\")\n("(symbol->string 'pre-id)")") (string-append Makefile".premake.rkt") #:exists 'replace)
      (display-to-file (string-append"#lang racket\n(require \""self"\")\n("(symbol->string 'main-id)" (current-command-line-arguments))") (string-append Makefile".domake.rkt") #:exists 'replace))
    (define (pre-id) pre)
    (define (main-id cmd) (make ((name (depend ...) code) ...) cmd))))

;; (do-make (current-command-line-arguments))
(provide write-Makefile pre-do-make do-make)
(define (mk-ts-files d) (sort (filter (match-lambda [(regexp #rx".*\\.ts$") #t] [_ #f]) (map path->string (directory-list (string-append d "lang.ts.d") #:build? #t))) string<?))
(define ts-files-root (mk-ts-files "typescript/"))
(define-make++ "make.rkt" write-Makefile ("typescript/lang.ts" pre-do-make ts-files-root) do-make
    (make/proc `(("typescript/lang.ts" (,@ts-files-root) ,(lambda () (in-dir "typescript" {
        (define ts-files (mk-ts-files ""))
        (for ([file ts-files]) {
            (define tmpfile (path->string (make-temporary-file "rkttmp~a.ts")))
            |> lines->string (run-racket-code-generators->lines (string->lines #{cat (id file)})) &>! (id tmpfile)
            mv (id tmpfile) (id file)
        })
        |> id "" &>! lang.ts
        (for ([file ts-files]) {
            cat (id file) &>> lang.ts
            echo &>> lang.ts
        })
    })))))
    (("all" ("ecmascript/lang.min.0.js"
             "ecmascript/lang.js"
             "ecmascript/lang.min.2.js"
             "lua/lang.lua"
             "lua/lang_min.lua"
             "ecmascript6/lang.js"
             "php/lang.php"
             "java/src"
             "rust/the-language/src/lang.rs")
            (void))
     ("ecmascript/exports.list" ("ecmascript/lang.js") { in-dir "ecmascript" {
         (define exports (string->lines #{grep (id "^exports.*=") lang.js | sed (id "s|^exports\\.\\([^ ]*\\).*$|\\1|")}))
         |> lines->string exports &>! exports.list
         |> ++ "var exports = {};\nvar module={};\nmodule.exports={};\n" (apply-++ (map (lambda (x) (++ "exports."x"='something';\n")) exports)) &>! lang.externs.js
     }})
     ("ecmascript/lang.externs.js" ("ecmascript/exports.list") (void)) ;; 代码在上面。
     ("ecmascript/node_modules" ("ecmascript/yarn.lock") { in-dir "ecmascript" { ;; 避免竞争状态
         yarn
         touch node_modules/
     }})
     ("rust/node_modules" ("rust/yarn.lock") { in-dir "rust" { ;; 避免竞争状态
         yarn
         touch node_modules/
     }})
     ("rust/the-language/src/lang.rs" ("rust/node_modules" "lua/lang.lua") { in-dir "rust" {
        npx --no-install lua2rust ../lua/lang.lua lang &>! the-language/src/lang.rs
     }})
     ("ecmascript/langraw.js" ("ecmascript/node_modules" "typescript/lang.ts"){ in-dir "ecmascript" {
         npx --no-install tsickle --typed
         (define raw (match (string->lines #{cat langraw.js})
                       [(list _ ... "goog.module('_..langraw');" "var module = module || { id: '' };" "exports.__esModule = true;" rest ...) (lines->string rest)]))
         |> id raw &>! langraw.js
     }})
     ("ecmascript/lang.min.0.js" ("ecmascript/node_modules" "ecmascript/lang.externs.js" "ecmascript/langraw.js" "ecmascript/exports.list") {
        in-dir "ecmascript" {
            (define exports (ecmascript/exports.list-parse))
            sed (id "/^exports\\./d") langraw.js &>! lang.min.0.tmp.js
            (define exp (map (lambda (x) (string-split x " ")) (string->lines #{grep (id "^exports.*=") langraw.js | sed (id "s|^exports\\.\\([^ ]*\\) = \\([^ ]*\\)$|\\1 \\2|")})))
            (define exp2 (filter (match-lambda [(list x y) (member x exports)]) exp))
            (define exp-lines (map (match-lambda [(list x y) (++ "exports."x" = "y)]) exp2))
            |> lines->string exp-lines &>> lang.min.0.tmp.js
            java -jar ./node_modules/google-closure-compiler-java/compiler.jar --assume_function_wrapper --language_out ECMASCRIPT3 --js lang.min.0.tmp.js --externs lang.externs.js -O ADVANCED --use_types_for_optimization &>! lang.min.0.js
     }})
     ("ecmascript/lang.min.2.js" ("ecmascript/node_modules" "ecmascript/lang.externs.js" "ecmascript/lang.min.0.js") { in-dir "ecmascript" {
         |> ++ "var exports={};\n(function(){\n" #{cat lang.min.0.js} "\n})();" &>! lang.min.2.js.tmp
         (define raw (string->lines #{npx --no-install prepack --inlineExpressions lang.min.2.js.tmp}))
         |> lines->string (match raw [(list "var exports;" "(function () {" body1 ... "  var _$0 = this;" body2 ... "  _$0.exports = {" body3 ... "}).call(this);") (append body1 body2 '("module.exports = {") body3)]) &>! lang.min.2.js.tmp
         java -jar ./node_modules/google-closure-compiler-java/compiler.jar --assume_function_wrapper --language_out ECMASCRIPT3 --js lang.min.2.js.tmp --externs lang.externs.js -O ADVANCED &>! lang.min.2.js
         rm lang.min.2.js.tmp
     }})
     ("ecmascript/lang.js" ("ecmascript/node_modules" "typescript/lang.ts") { in-dir "ecmascript" {
         npx --no-install tsc --removeComments --outDir lang.js.tmp
         (define raw (string->lines #{cat lang.js.tmp/langraw.js}))
         |> lines->string (match raw [(list "exports.__esModule = true;" xs ...) xs]) &>! lang.js
     }})
     ("lua/luasrcdiet" () { git clone --depth 1 https://github.com/jirutka/luasrcdiet.git lua/luasrcdiet })
     ("lua/lang_min.lua" ("lua/lang.lua" "lua/luasrcdiet") { in-dir "lua" {
         sh -c (id "LUA_PATH='./luasrcdiet/?.lua' luajit ./luasrcdiet/bin/luasrcdiet lang.lua -o lang_min.lua")
     }})
     ("lua/node_modules" ("lua/yarn.lock") { in-dir "lua" { ;; 避免竞争状态
         yarn
         touch node_modules/
     }})
     ("lua/lang.lua" ("lua/node_modules" "typescript/lang.ts") {
         in-dir "lua" {
             |> ++ "/** @noSelfInFile */\n" #{cat ../typescript/lang.ts} &>! lang.ts
             touch lang.lua
             rm lang.lua
             npx --no-install tstl -p tsconfig.json
             (define raw #{cat lang.lua})
             (define out (++
                 haskell-generatedby
                 haskell-copyright
                 raw))
             |> id out &>! lang.lua
             sed -i (id "s|^function __TS__|local function __TS__|g") lang.lua

             sed -i (id "s|^\\( *\\)\\([^=]*\\) = function(|\\1function \\2(|g") lang.lua
             (define (u x) (match x [(list (regexp #rx"^( *)local ([^,=\n ]*)$" (list l1 v1 n1)) (regexp #rx"^( *)function ([^,=\n( ]*)(.*)$" (list l2 v2 n2 t)) tail ...) (if (equal? n1 n2) (string-append v1 "local function " n1 t "\n" (u tail)) (string-append l1 "\n" l2 "\n" (u tail)))] [(cons a d) (string-append a "\n" (u d))] ['() "\n"]))
             (define t (u (string->lines #{cat lang.lua})))
             |> id t &>! lang.lua

             grep (id "____exports") lang.lua &>! lang.lua.1
             sed -i (id "/____exports/d") lang.lua
             cat lang.lua.1 &>> lang.lua
             rm lang.lua.1
     }})
     ("ecmascript6/node_modules" ("ecmascript6/yarn.lock") { in-dir "ecmascript6" { ;; 避免竞争状态
         yarn
         touch node_modules/
     }})
     ("ecmascript6/lang.js" ("ecmascript6/node_modules" "typescript/lang.ts") {
         in-dir "ecmascript6" {
             touch lang.js
             rm lang.js
             npx --no-install tsc --build tsconfig.json
             (define raw #{cat lang.js})
             |> ++ c-generatedby c-copyright raw &>! lang.js
     }})
     ("java/src" ("lua/lang.lua" "java/real-src/lang/Lang.java" "java/real-src/lang/LangValue.java") {
         ;; TODO rewrite in rash
         in-dir "java" {
             ./compile.sh
     }})
     ("php/node_modules" ("php/yarn.lock") { in-dir "php" { ;; 避免竞争状态
         yarn
         touch node_modules/
     }})
     ("php/lang.php" ("php/node_modules" "lua/lang.lua") {
         in-dir "php" {
             |> lines->string (match (string->lines #{cat ../lua/lang.lua}) [(list head ... "return ____exports") head]) &>! lang.lua
             |> id (++ "<?php\n" c-generatedby c-copyright (lines->string (match (string->lines #{npx --no-install lua2php lang.lua}) [(list "<?php" tail ...) tail]))) &>! lang.php
     }})
     ))
